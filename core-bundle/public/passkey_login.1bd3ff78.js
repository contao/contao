!function(){"use strict";function e(){return t.stubThis(void 0!==globalThis?.PublicKeyCredential&&"function"==typeof globalThis.PublicKeyCredential)}const t={stubThis:e=>e};class n extends Error{constructor({message:e,code:t,cause:n,name:r}){super(e,{cause:n}),Object.defineProperty(this,"code",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.name=r??n.name,this.code=t}}const r=new class{constructor(){Object.defineProperty(this,"controller",{enumerable:!0,configurable:!0,writable:!0,value:void 0})}createNewAbortSignal(){if(this.controller){const e=new Error("Cancelling existing WebAuthn API call for new one");e.name="AbortError",this.controller.abort(e)}const e=new AbortController;return this.controller=e,e.signal}cancelCeremony(){if(this.controller){const e=new Error("Manually cancelling existing WebAuthn API call");e.name="AbortError",this.controller.abort(e),this.controller=void 0}}};function o(e){const t=new Uint8Array(e);let n="";for(const e of t)n+=String.fromCharCode(e);return btoa(n).replace(/\+/g,"-").replace(/\//g,"_").replace(/=/g,"")}function a(e){const t=e.replace(/-/g,"+").replace(/_/g,"/"),n=(4-t.length%4)%4,r=t.padEnd(t.length+n,"="),o=atob(r),a=new ArrayBuffer(o.length),i=new Uint8Array(a);for(let e=0;e<o.length;e++)i[e]=o.charCodeAt(e);return a}const i={stubThis:e=>e};function s(e){const{id:t}=e;return{...e,id:a(t),transports:e.transports}}const l=["cross-platform","platform"];function c(e){if(e&&!(l.indexOf(e)<0))return e}async function u(t){!t.optionsJSON&&t.challenge&&(console.warn("startAuthentication() was not called correctly. It will try to continue with the provided options, but this call should be refactored to use the expected call structure instead. See https://simplewebauthn.dev/docs/packages/browser#typeerror-cannot-read-properties-of-undefined-reading-challenge for more information."),t={optionsJSON:t});const{optionsJSON:l,useBrowserAutofill:u=!1,verifyBrowserAutofillInput:d=!0}=t;if(!e())throw new Error("WebAuthn is not supported in this browser");let h;0!==l.allowCredentials?.length&&(h=l.allowCredentials?.map(s));const p={...l,challenge:a(l.challenge),allowCredentials:h},f={};if(u){if(!await function(){if(!e())return i.stubThis(new Promise(e=>e(!1)));const t=globalThis.PublicKeyCredential;return void 0===t?.isConditionalMediationAvailable?i.stubThis(new Promise(e=>e(!1))):i.stubThis(t.isConditionalMediationAvailable())}())throw Error("Browser does not support WebAuthn autofill");if(document.querySelectorAll("input[autocomplete$='webauthn']").length<1&&d)throw Error('No <input> with "webauthn" as the only or last value in its `autocomplete` attribute was detected');f.mediation="conditional",p.allowCredentials=[]}let w;f.publicKey=p,f.signal=r.createNewAbortSignal();try{w=await navigator.credentials.get(f)}catch(e){throw function({error:e,options:t}){const{publicKey:r}=t;if(!r)throw Error("options was missing required publicKey property");if("AbortError"===e.name){if(t.signal instanceof AbortSignal)return new n({message:"Authentication ceremony was sent an abort signal",code:"ERROR_CEREMONY_ABORTED",cause:e})}else{if("NotAllowedError"===e.name)return new n({message:e.message,code:"ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",cause:e});if("SecurityError"===e.name){const t=globalThis.location.hostname;if("localhost"!==(o=t)&&!/^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(o))return new n({message:`${globalThis.location.hostname} is an invalid domain`,code:"ERROR_INVALID_DOMAIN",cause:e});if(r.rpId!==t)return new n({message:`The RP ID "${r.rpId}" is invalid for this domain`,code:"ERROR_INVALID_RP_ID",cause:e})}else if("UnknownError"===e.name)return new n({message:"The authenticator was unable to process the specified options, or could not create a new assertion signature",code:"ERROR_AUTHENTICATOR_GENERAL_ERROR",cause:e})}var o;return e}({error:e,options:f})}if(!w)throw new Error("Authentication was not completed");const{id:b,rawId:g,response:m,type:y}=w;let A;return m.userHandle&&(A=o(m.userHandle)),{id:b,rawId:o(g),response:{authenticatorData:o(m.authenticatorData),clientDataJSON:o(m.clientDataJSON),signature:o(m.signature),userHandle:A},type:y,clientExtensionResults:w.getClientExtensionResults(),authenticatorAttachment:c(w.authenticatorAttachment)}}const d=new WeakMap,h=t=>{if(d.has(t))return;d.set(t,!0);const n=t.querySelector("[data-passkey-button]"),r=document.querySelector("[data-passkey-error]");if(!n||!r||!t.dataset.passkeyConfig)return;const o=JSON.parse(t.dataset.passkeyConfig);n.addEventListener("click",async()=>{if(r.innerHTML="",!e())return void(r.innerHTML=o.unsupported);const t=await fetch(o.optionsUrl,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({})}),n=document.createElement("script");n.src=o.requestTokenScript,n.async=!0,document.body.append(n);const a=await t.json();if("error"===a.status)return void(r.innerText=o.assertionFailure);let i;try{i=await u({optionsJSON:a})}catch(e){throw r.innerText=o.assertionFailure,e}const s=await fetch(o.resultUrl,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(i)});"error"!==(await s.json()).status?window.location=o.redirect||window.location.href:r.innerText=o.assertionFailure})},p="[data-passkey-login]";new MutationObserver(function(e){for(const t of e)"childList"===t.type&&t.addedNodes.forEach(function(e){e.matches&&e.matches(p)&&h(e),e.querySelectorAll&&e.querySelectorAll(p).forEach(e=>h(e))})}).observe(document,{attributes:!1,childList:!0,subtree:!0}),document.querySelectorAll(p).forEach(e=>h(e))}();