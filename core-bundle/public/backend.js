/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./core-bundle/assets/controllers sync recursive \\.js$":
/*!****************************************************!*\
  !*** ./core-bundle/assets/controllers/ sync \.js$ ***!
  \****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var map = {
	"./ace-controller.js": "./core-bundle/assets/controllers/ace-controller.js",
	"./backend-search-controller.js": "./core-bundle/assets/controllers/backend-search-controller.js",
	"./check-all-controller.js": "./core-bundle/assets/controllers/check-all-controller.js",
	"./choices-controller.js": "./core-bundle/assets/controllers/choices-controller.js",
	"./clipboard-controller.js": "./core-bundle/assets/controllers/clipboard-controller.js",
	"./color-picker-controller.js": "./core-bundle/assets/controllers/color-picker-controller.js",
	"./color-scheme-controller.js": "./core-bundle/assets/controllers/color-scheme-controller.js",
	"./deeplink-controller.js": "./core-bundle/assets/controllers/deeplink-controller.js",
	"./dialog-controller.js": "./core-bundle/assets/controllers/dialog-controller.js",
	"./image-size-controller.js": "./core-bundle/assets/controllers/image-size-controller.js",
	"./input-map-controller.js": "./core-bundle/assets/controllers/input-map-controller.js",
	"./jobs-controller.js": "./core-bundle/assets/controllers/jobs-controller.js",
	"./jump-targets-controller.js": "./core-bundle/assets/controllers/jump-targets-controller.js",
	"./limit-height-controller.js": "./core-bundle/assets/controllers/limit-height-controller.js",
	"./message-outlet-controller.js": "./core-bundle/assets/controllers/message-outlet-controller.js",
	"./metawizard-controller.js": "./core-bundle/assets/controllers/metawizard-controller.js",
	"./operations-menu-controller.js": "./core-bundle/assets/controllers/operations-menu-controller.js",
	"./passkeys-controller.js": "./core-bundle/assets/controllers/passkeys-controller.js",
	"./profile-controller.js": "./core-bundle/assets/controllers/profile-controller.js",
	"./row-wizard-controller.js": "./core-bundle/assets/controllers/row-wizard-controller.js",
	"./scroll-offset-controller.js": "./core-bundle/assets/controllers/scroll-offset-controller.js",
	"./serp-preview-controller.js": "./core-bundle/assets/controllers/serp-preview-controller.js",
	"./sortable-controller.js": "./core-bundle/assets/controllers/sortable-controller.js",
	"./tabs-controller.js": "./core-bundle/assets/controllers/tabs-controller.js",
	"./template-studio-controller.js": "./core-bundle/assets/controllers/template-studio-controller.js",
	"./tinymce-controller.js": "./core-bundle/assets/controllers/tinymce-controller.js",
	"./toggle-fieldset-controller.js": "./core-bundle/assets/controllers/toggle-fieldset-controller.js",
	"./toggle-navigation-controller.js": "./core-bundle/assets/controllers/toggle-navigation-controller.js",
	"./toggle-nodes-controller.js": "./core-bundle/assets/controllers/toggle-nodes-controller.js",
	"./tooltips-controller.js": "./core-bundle/assets/controllers/tooltips-controller.js",
	"./webauthn-error-controller.js": "./core-bundle/assets/controllers/webauthn-error-controller.js"
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = "./core-bundle/assets/controllers sync recursive \\.js$";

/***/ }),

/***/ "./core-bundle/assets/controllers/ace-controller.js":
/*!**********************************************************!*\
  !*** ./core-bundle/assets/controllers/ace-controller.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");

/* harmony default export */ __webpack_exports__["default"] = (class extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static values = {
    type: String,
    readOnly: Boolean
  };
  connect() {
    // Create a div to apply the editor to
    this.container = document.createElement('div');
    this.container.id = `${this.element.id}_div`;
    this.container.className = this.element.className;
    this.element.parentNode.insertBefore(this.container, this.element.nextSibling);

    // Hide the textarea
    this.element.style.display = 'none';

    // Instantiate the editor
    this.editor = ace.edit(this.container);
    this.editor.getSession().setValue(this.element.value);
    this.editor.on('focus', () => {
      window.dispatchEvent(new Event('store-scroll-offset'));
    });
    this.editor.getSession().on('change', () => {
      this.element.value = this.editor.getValue();
    });

    // Disable command conflicts with AltGr (see #5792)
    this.editor.commands.bindKey('Ctrl-alt-a|Ctrl-alt-e|Ctrl-alt-h|Ctrl-alt-l|Ctrl-alt-s', null);

    // Execute the config callback
    this.element?.configCallback(this.editor);
    this.setMaxLines();
    window.addEventListener('resize', this.setMaxLines.bind(this));
  }
  disconnect() {
    this.editor?.destroy();
    this.container?.remove();
  }
  beforeCache() {
    // Remove the element container before Turbo caches the page. It will
    // be recreated when the connect() call happens on the restored page.
    this.disconnect();
  }
  colorChange(event) {
    this.editor.setTheme(`ace/theme/${event.detail.mode === 'dark' ? 'twilight' : 'clouds'}`);
  }
  setMaxLines() {
    this.editor.setOption('maxLines', Math.floor((window.innerHeight - 320) / Math.floor(12 * this.editor.container.style.lineHeight)));
  }
});

/***/ }),

/***/ "./core-bundle/assets/controllers/backend-search-controller.js":
/*!*********************************************************************!*\
  !*** ./core-bundle/assets/controllers/backend-search-controller.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ BackendSearchController; }
/* harmony export */ });
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");
/* harmony import */ var focus_trap__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! focus-trap */ "./node_modules/focus-trap/dist/focus-trap.esm.js");
/* harmony import */ var _modules_turbo_stream_connection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../modules/turbo-stream-connection */ "./core-bundle/assets/modules/turbo-stream-connection.js");



class BackendSearchController extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ['input', 'results'];
  static values = {
    url: String,
    minCharacters: Number,
    debounceDelay: Number
  };
  static classes = ['hidden', 'initial', 'loading', 'invalid', 'results', 'error'];
  connect() {
    this.debounceTimeout = null;
    this.searchResultConnection = new _modules_turbo_stream_connection__WEBPACK_IMPORTED_MODULE_2__.TurboStreamConnection();
    this.focusTrap = focus_trap__WEBPACK_IMPORTED_MODULE_1__.createFocusTrap(this.element, {
      escapeDeactivates: false,
      allowOutsideClick: true
    });
  }
  disconnect() {
    this._stopPendingSearch();
  }
  async search() {
    this._stopPendingSearch();

    // Require a minimum number of characters
    if (this.inputTarget.value.length < this.minCharactersValue) {
      return this._setState('invalid');
    }
    this._setState('loading');

    // Debounce to avoid too many requests
    await new Promise(resolve => this.debounceTimeout = setTimeout(resolve, this.debounceDelayValue));

    // Get the search results
    const result = await this.searchResultConnection.get(this.urlValue, {
      keywords: this.inputTarget.value
    });
    if (result.ok) {
      this._setState('results');
      this.focusTrap.activate();
    } else if (result.error) {
      this._setState('error');
    }
  }
  open() {
    // Ignore focus on input if tabbing through results
    if (this.focusTrap.active) {
      return;
    }
    this._setState('initial');
  }
  close(event) {
    // Only close when clicking away
    if (event instanceof PointerEvent && this.element.contains(event.target)) {
      return;
    }

    // Ignore lost focus on input when tabbing through results
    if (event.type === 'blur' && this.focusTrap.active) {
      return;
    }
    this._stopPendingSearch();
    this.resultsTarget.innerText = '';
    this.inputTarget.blur();
    this.inputTarget.value = '';
    this._setState('hidden');
  }
  _stopPendingSearch() {
    clearTimeout(this.debounceTimeout);
    this.searchResultConnection.abortPending();
    this.focusTrap.deactivate();
  }
  _setState(state) {
    for (const className of BackendSearchController.classes) {
      this.element.classList.toggle(this[`${className}Class`], className === state);
    }
  }
}

/***/ }),

/***/ "./core-bundle/assets/controllers/check-all-controller.js":
/*!****************************************************************!*\
  !*** ./core-bundle/assets/controllers/check-all-controller.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");

/* harmony default export */ __webpack_exports__["default"] = (class extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ['source', 'input'];
  update() {
    const checked = this.sourceTarget.checked;
    for (const el of this.inputTargets) {
      el.checked = checked;
    }
  }
});

/***/ }),

/***/ "./core-bundle/assets/controllers/choices-controller.js":
/*!**************************************************************!*\
  !*** ./core-bundle/assets/controllers/choices-controller.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ ChoicesController; }
/* harmony export */ });
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");

class ChoicesController extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  connect() {
    const select = this.element.querySelector('select');
    this.choices = new Choices(select, {
      shouldSort: false,
      duplicateItemsAllowed: false,
      allowHTML: false,
      removeItemButton: true,
      searchEnabled: select.options.length > 7,
      searchResultLimit: -1,
      appendGroupInSearch: true,
      classNames: {
        containerOuter: ['choices', ...Array.from(select.classList)],
        flippedState: ''
      },
      fuseOptions: {
        includeScore: true,
        threshold: 0.4
      },
      callbackOnInit: () => {
        const choices = select.closest('.choices')?.querySelector('.choices__list--dropdown > .choices__list');
        if (choices && select.dataset.placeholder) {
          choices.dataset.placeholder = select.dataset.placeholder;
        }
      },
      loadingText: Contao.lang.loading,
      noResultsText: Contao.lang.noResults,
      noChoicesText: Contao.lang.noOptions,
      removeItemLabelText: value => Contao.lang.removeItem.concat(' ').concat(value)
    });
  }
  disconnect() {
    this._removeChoices();
  }
  beforeCache() {
    // Let choices unwrap the element container before Turbo caches the
    // page. It will be recreated, when the connect() call happens on the
    // restored page.
    this._removeChoices();
  }
  _removeChoices() {
    this.choices?.destroy();
    this.choices = null;
  }
}

/***/ }),

/***/ "./core-bundle/assets/controllers/clipboard-controller.js":
/*!****************************************************************!*\
  !*** ./core-bundle/assets/controllers/clipboard-controller.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");
/* harmony import */ var _modules_message__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../modules/message */ "./core-bundle/assets/modules/message.js");


/* harmony default export */ __webpack_exports__["default"] = (class extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static values = {
    content: String,
    message: {
      type: String,
      default: 'Copied to clipboard.'
    }
  };
  async write() {
    if (!navigator.clipboard) {
      if (window.console) {
        console.error('The clipboard API is not available. Make sure you use a secure context (https).');
      }
      return;
    }
    await navigator.clipboard.writeText(this.contentValue);
    _modules_message__WEBPACK_IMPORTED_MODULE_1__.info(this.messageValue);
  }
});

/***/ }),

/***/ "./core-bundle/assets/controllers/color-picker-controller.js":
/*!*******************************************************************!*\
  !*** ./core-bundle/assets/controllers/color-picker-controller.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _stimulus_components_color_picker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @stimulus-components/color-picker */ "./node_modules/@stimulus-components/color-picker/dist/stimulus-color-picker.mjs");

/* harmony default export */ __webpack_exports__["default"] = (class extends _stimulus_components_color_picker__WEBPACK_IMPORTED_MODULE_0__["default"] {
  connect() {
    let hexValueLoaded = false;
    if (this.inputTarget.value && /^[0-9a-f]{3,6}$/i.test(this.inputTarget.value)) {
      this.inputTarget.value = `#${this.inputTarget.value}`;
      hexValueLoaded = true;
    }
    super.connect();
    if (hexValueLoaded) {
      this.inputTarget.value = this.inputTarget.value.substring(1);
    }
  }

  // Override the onSave function to strip the leading `#`
  onSave(color) {
    this.inputTarget.value = null;
    if (color) {
      let value = color.toHEXA().toString();
      if ('#' === value.charAt(0)) {
        value = value.substring(1);
      }
      this.inputTarget.value = value.toLowerCase();
    }
    this.picker.hide();
  }
});

/***/ }),

/***/ "./core-bundle/assets/controllers/color-scheme-controller.js":
/*!*******************************************************************!*\
  !*** ./core-bundle/assets/controllers/color-scheme-controller.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");

const prefersDark = () => {
  const prefersDark = localStorage.getItem('contao--prefers-dark');
  if (null === prefersDark) {
    return !!window.matchMedia('(prefers-color-scheme: dark)').matches;
  }
  return prefersDark === 'true';
};
const setColorScheme = () => {
  document.documentElement.dataset.colorScheme = prefersDark() ? 'dark' : 'light';
};
window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', setColorScheme);
setColorScheme();
/* harmony default export */ __webpack_exports__["default"] = (class extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ['label'];
  static values = {
    i18n: {
      type: Object,
      default: {
        light: 'Disable dark mode',
        dark: 'Enable dark mode'
      }
    }
  };
  initialize() {
    this.setLabel = this.setLabel.bind(this);
  }
  connect() {
    this.matchMedia = window.matchMedia('(prefers-color-scheme: dark)');
    this.matchMedia.addEventListener('change', this.setLabel);
    this.setLabel();
  }
  disconnect() {
    this.matchMedia.removeEventListener('change', this.setLabel);
  }
  toggle(e) {
    e.preventDefault();
    const isDark = !prefersDark();
    if (isDark === this.matchMedia.matches) {
      localStorage.removeItem('contao--prefers-dark');
    } else {
      localStorage.setItem('contao--prefers-dark', String(isDark));
    }
    setColorScheme();
    this.dispatch('change', {
      detail: {
        mode: isDark ? 'dark' : 'light'
      }
    });

    // Change the label after the dropdown is hidden
    setTimeout(this.setLabel, 300);
  }
  setLabel() {
    if (!this.hasLabelTarget) {
      return;
    }
    const label = this.i18nValue[prefersDark() ? 'light' : 'dark'];
    this.labelTarget.title = label;
    this.labelTarget.innerText = label;
  }
});

/***/ }),

/***/ "./core-bundle/assets/controllers/deeplink-controller.js":
/*!***************************************************************!*\
  !*** ./core-bundle/assets/controllers/deeplink-controller.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");
/* harmony import */ var _hotwired_turbo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @hotwired/turbo */ "./node_modules/@hotwired/turbo/dist/turbo.es2017-esm.js");


/* harmony default export */ __webpack_exports__["default"] = (class extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ['primary', 'secondary'];
  static afterLoad(identifier) {
    const setupController = () => {
      for (const el of document.querySelectorAll('.click2edit')) {
        el.classList.remove('click2edit');
        const primary = el.querySelector('a.edit');
        const secondary = el.querySelector('a.children');
        if (primary) {
          primary.setAttribute(`data-${identifier}-target`, 'primary');
        }
        if (secondary) {
          secondary.setAttribute(`data-${identifier}-target`, 'secondary');
        }
        el.dataset.controller = el.dataset.controller ? `${el.dataset.controller} ${identifier}` : `${identifier}`;
      }
    };
    document.addEventListener('DOMContentLoaded', setupController);
    document.addEventListener('ajax_change', setupController);
    document.addEventListener('turbo:render', setupController);
    document.addEventListener('turbo:frame-render', setupController);
    setupController();
    Theme.setupCtrlClick = () => {
      if (window.console) {
        console.warn('Using Theme.setupCtrlClick() is deprecated and will be removed in Contao 6. Apply the Stimulus actions instead.');
      }
      setupController();
    };
  }
  initialize() {
    this.handle = this.handle.bind(this);
  }
  connect() {
    this.element.addEventListener('click', this.handle);
  }
  handle(event) {
    // Ignore clicks on anchor elements
    if (!this.isValid(event.target)) {
      return;
    }
    const primaryKey = window.navigator.platform?.startsWith('Mac') ? 'metaKey' : 'ctrlKey';
    if (event[primaryKey] && !event.shiftKey && this.hasPrimaryTarget && this.primaryTarget.href) {
      _hotwired_turbo__WEBPACK_IMPORTED_MODULE_1__.visit(this.primaryTarget.href);
      return;
    }
    if (event[primaryKey] && event.shiftKey && this.hasSecondaryTarget && this.secondaryTarget.href) {
      _hotwired_turbo__WEBPACK_IMPORTED_MODULE_1__.visit(this.secondaryTarget.href);
      return;
    }
    if (event.pointerType === 'mouse' || !this.hasPrimaryTarget || !this.primaryTarget.href) {
      return;
    }
    clearTimeout(this.$timer);
    if (!this.element.getAttribute('data-visited')) {
      this.element.setAttribute('data-visited', '1');
      this.$timer = setTimeout(() => {
        this.element.removeAttribute('data-visited');
      }, 2000);
    } else {
      this.element.removeAttribute('data-visited');
      _hotwired_turbo__WEBPACK_IMPORTED_MODULE_1__.visit(this.primaryTarget.href);
    }
  }
  visitPrimary(event) {
    if (this.hasPrimaryTarget && this.primaryTarget.href && this.isValid(event.target)) {
      _hotwired_turbo__WEBPACK_IMPORTED_MODULE_1__.visit(this.primaryTarget.href);
    }
  }
  visitSecondary(event) {
    if (this.hasSecondaryTarget && this.secondaryTarget.href && this.isValid(event.target)) {
      _hotwired_turbo__WEBPACK_IMPORTED_MODULE_1__.visit(this.secondaryTarget.href);
    }
  }
  isValid(element) {
    return 'a' !== element.tagName && !element.closest('a, button');
  }
});

/***/ }),

/***/ "./core-bundle/assets/controllers/dialog-controller.js":
/*!*************************************************************!*\
  !*** ./core-bundle/assets/controllers/dialog-controller.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");

/* harmony default export */ __webpack_exports__["default"] = (class extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  connect() {
    if (this.element.open) {
      return;
    }
    this.element.showModal();
    this.focus();
  }
  focus() {
    // Focus the first input element if present
    this.element.querySelector('input')?.focus();

    // Select the text of the first text input element if present
    this.element.querySelector('input[type="text"]')?.select();
  }
  close() {
    this.element.remove();
  }
  suspend() {
    if (this.element.open) {
      this.element.close();
    }
  }
  resume() {
    if (!this.element.open) {
      this.element.showModal();
    }
  }
});

/***/ }),

/***/ "./core-bundle/assets/controllers/image-size-controller.js":
/*!*****************************************************************!*\
  !*** ./core-bundle/assets/controllers/image-size-controller.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");

/* harmony default export */ __webpack_exports__["default"] = (class extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ['select', 'button', 'image', 'width', 'height'];
  static values = {
    config: Object
  };
  connect() {
    this._updateWizard();
    this._updateInputs();
  }
  widthTargetDisconnected(input) {
    this._resetInput(input);
  }
  heightTargetDisconnected(input) {
    this._resetInput(input);
  }
  update() {
    this._updateWizard();
    this._updateInputs();
  }
  _updateWizard() {
    if (this.canEdit()) {
      this.buttonTarget.title = this.configValue.title;
      this.buttonTarget.disabled = false;
      for (const img of this.imageTargets) {
        img.src = this.configValue.icon;
      }
    } else {
      this.buttonTarget.title = '';
      this.buttonTarget.disabled = true;
      for (const img of this.imageTargets) {
        img.src = this.configValue.iconDisabled;
      }
    }
  }
  _updateInputs() {
    const select = this.selectTarget;
    const value = select.value;
    if (value === '' || value.indexOf('_') === 0 || value.toInt().toString() === value) {
      let dimensions = select.options[select.selectedIndex].text;
      dimensions = dimensions.split('(');
      dimensions = dimensions.length > 1 ? dimensions.getLast().split(')')[0].split('x') : ['', ''];
      this.widthTarget.readOnly = true;
      this.heightTarget.readOnly = true;
      this.widthTarget.value = '';
      this.heightTarget.value = '';
      this.widthTarget.setAttribute('placeholder', dimensions[0] * 1 || '');
      this.heightTarget.setAttribute('placeholder', dimensions[1] * 1 || '');
    } else {
      this.widthTarget.readOnly = false;
      this.heightTarget.readOnly = false;
      this.widthTarget.removeAttribute('placeholder');
      this.heightTarget.removeAttribute('placeholder');
    }
  }
  _resetInput(input) {
    input.value = '';
    input.removeAttribute('placeholder');
    input.readOnly = false;
  }
  openModal() {
    Backend.openModalIframe({
      title: this.configValue.title,
      url: `${this.configValue.href}&id=${this.selectTarget.value}`
    });
  }
  canEdit() {
    return this.configValue.ids.includes(Number(this.selectTarget.value));
  }
});

/***/ }),

/***/ "./core-bundle/assets/controllers/input-map-controller.js":
/*!****************************************************************!*\
  !*** ./core-bundle/assets/controllers/input-map-controller.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");

/* harmony default export */ __webpack_exports__["default"] = (class extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ['input', 'source'];
  static values = {
    attribute: String
  };
  update() {
    const value = [];
    for (const el of this.sourceTargets) {
      value.push(el.getAttribute(this.attributeValue));
    }
    this.inputTarget.value = value.join(',');
  }
  removeElement(event) {
    const el = this._getElement(event);
    if (!el) {
      return;
    }
    el.remove();
    this.update();
  }
  _getElement(event) {
    if (event.params.closest) {
      return event.target.closest(event.params.closest);
    }
    if (event.params.querySelector) {
      return event.target.querySelector(event.params.querySelector);
    }
    return event.target;
  }
});

/***/ }),

/***/ "./core-bundle/assets/controllers/jobs-controller.js":
/*!***********************************************************!*\
  !*** ./core-bundle/assets/controllers/jobs-controller.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");
/* harmony import */ var _modules_message__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../modules/message */ "./core-bundle/assets/modules/message.js");
/* harmony import */ var _modules_turbo_stream_connection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../modules/turbo-stream-connection */ "./core-bundle/assets/modules/turbo-stream-connection.js");



/* harmony default export */ __webpack_exports__["default"] = (class extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  _turboStreamConnection = new _modules_turbo_stream_connection__WEBPACK_IMPORTED_MODULE_2__.TurboStreamConnection();
  _runningJobs = false;
  static values = {
    pendingJobsUrl: String,
    defaultInterval: Number,
    maximumInterval: Number,
    enabled: Boolean,
    allJobsProcessedMessage: String
  };
  static targets = ['count', 'list'];
  connect() {
    this._pollInterval = this.defaultIntervalValue;
    this._timer = null;
    if (this.enabledValue) {
      this.enable();
    }
  }
  enable() {
    clearTimeout(this._timer);
    this._poll();
  }
  listTargetConnected(el) {
    // Clear timer in case the target was added manually
    clearTimeout(this._timer);
    if ('0' === el.dataset.jobs) {
      this.countTarget.innerText = '';
      if (this._runningJobs) {
        // ALl pending jobs have been processed
        this._runningJobs = false;
        _modules_message__WEBPACK_IMPORTED_MODULE_1__.info(this.allJobsProcessedMessageValue);
      }

      // Continuously increase interval if there are no results
      this._pollInterval = Math.min(this.maximumIntervalValue, this._pollInterval * 2);
    } else {
      this.countTarget.innerText = el.dataset.jobs;
      this._runningJobs = true;
      this._pollInterval = this.defaultIntervalValue;
    }
    this._waitAndPoll();
  }
  _waitAndPoll() {
    this._timer = setTimeout(() => this._poll(), this._pollInterval);
  }
  _poll() {
    this._turboStreamConnection.get(this.pendingJobsUrlValue, null, true);
  }
});

/***/ }),

/***/ "./core-bundle/assets/controllers/jump-targets-controller.js":
/*!*******************************************************************!*\
  !*** ./core-bundle/assets/controllers/jump-targets-controller.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");

/* harmony default export */ __webpack_exports__["default"] = (class extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ['navigation', 'section'];
  sectionTargetConnected() {
    this.rebuildNavigation();
  }
  sectionTargetDisconnected() {
    this.rebuildNavigation();
  }
  rebuildNavigation() {
    if (!this.hasNavigationTarget) {
      return;
    }
    const links = document.createElement('ul');
    for (const el of this.sectionTargets) {
      const action = document.createElement('button');
      action.innerText = el.getAttribute(`data-${this.identifier}-label-value`);
      action.addEventListener('click', event => {
        event.preventDefault();
        this.dispatch('scrollto', {
          target: el
        });
        el.scrollIntoView();
      });
      const li = document.createElement('li');
      li.append(action);
      links.append(li);
    }
    this.navigationTarget.replaceChildren(links);
  }
});

/***/ }),

/***/ "./core-bundle/assets/controllers/limit-height-controller.js":
/*!*******************************************************************!*\
  !*** ./core-bundle/assets/controllers/limit-height-controller.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");

/* harmony default export */ __webpack_exports__["default"] = (class extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static values = {
    max: Number,
    expand: String,
    collapse: String,
    expandAll: String,
    expandAllTitle: String,
    collapseAll: String,
    collapseAllTitle: String
  };
  static targets = ['operation', 'node'];
  initialize() {
    super.initialize();
    this.togglerMap = new WeakMap();
    this.nextId = 1;
  }
  operationTargetConnected() {
    this.updateOperation();
  }
  nodeTargetConnected(node) {
    const style = window.getComputedStyle(node, null);
    const padding = Number.parseFloat(style.paddingTop) + Number.parseFloat(style.paddingBottom);
    const height = node.clientHeight - padding;

    // Resize the element if it is higher than the maximum height
    if (this.maxValue > height) {
      return;
    }
    if (!node.id) {
      node.id = `limit-height-${this.nextId++}`;
    }
    node.style.overflow = 'hidden';
    node.style.maxHeight = `${this.maxValue}px`;
    const button = document.createElement('button');
    button.setAttribute('type', 'button');
    button.title = this.expandValue;
    button.innerHTML = '<span>...</span>';
    button.classList.add('unselectable');
    button.setAttribute('aria-expanded', 'false');
    button.setAttribute('aria-controls', node.id);
    button.addEventListener('click', event => {
      event.preventDefault();
      this.toggle(node);
      this.updateOperation(event);
    });
    const toggler = document.createElement('div');
    toggler.classList.add('limit_toggler');
    toggler.append(button);
    this.togglerMap.set(node, toggler);
    node.append(toggler);
    this.updateOperation();
  }
  nodeTargetDisconnected(node) {
    if (!this.togglerMap.has(node)) {
      return;
    }
    this.togglerMap.get(node).remove();
    this.togglerMap.delete(node);
    node.style.overflow = '';
    node.style.maxHeight = '';
  }
  toggle(node) {
    if (node.style.maxHeight === '') {
      this.collapse(node);
    } else {
      this.expand(node);
    }
  }
  expand(node) {
    if (!this.togglerMap.has(node)) {
      return;
    }
    node.style.maxHeight = '';
    const button = this.togglerMap.get(node).querySelector('button');
    button.title = this.collapseValue;
    button.setAttribute('aria-expanded', 'true');
  }
  collapse(node) {
    if (!this.togglerMap.has(node)) {
      return;
    }
    node.style.maxHeight = `${this.maxValue}px`;
    const button = this.togglerMap.get(node).querySelector('button');
    button.title = this.expandValue;
    button.setAttribute('aria-expanded', 'false');
  }
  toggleAll(event) {
    event.preventDefault();
    const isExpanded = this.hasExpanded() ^ event.altKey;
    for (const node of this.nodeTargets) {
      if (isExpanded) {
        this.collapse(node);
      } else {
        this.expand(node);
      }
    }
    this.updateOperation(event);
  }
  keypress(event) {
    this.updateOperation(event);
  }
  updateOperation(event) {
    if (!this.hasOperationTarget) {
      return;
    }
    const hasTogglers = !!this.nodeTargets.find(el => this.togglerMap.has(el));
    const expanded = this.hasExpanded();
    for (const operationTarget of this.operationTargets) {
      operationTarget.style.display = hasTogglers ? '' : 'none';
      operationTarget.setAttribute('aria-controls', this.nodeTargets.map(el => el.id).join(' '));
      operationTarget.setAttribute('aria-expanded', expanded ? 'true' : 'false');
      if (operationTarget.closest('#tl_buttons')) {
        operationTarget.parentNode.style.display = hasTogglers ? '' : 'none';
      }
      if (expanded ^ (event ? event.altKey : false)) {
        operationTarget.innerText = this.collapseAllValue;
        operationTarget.title = this.collapseAllTitleValue;
      } else {
        operationTarget.innerText = this.expandAllValue;
        operationTarget.title = this.expandAllTitleValue;
      }
    }
  }
  hasExpanded() {
    return !!this.nodeTargets.find(el => this.togglerMap.has(el) && el.style.maxHeight === '');
  }
});

/***/ }),

/***/ "./core-bundle/assets/controllers/message-outlet-controller.js":
/*!*********************************************************************!*\
  !*** ./core-bundle/assets/controllers/message-outlet-controller.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");

/* harmony default export */ __webpack_exports__["default"] = (class extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ['message', 'messagePrototype'];
  messageTargetConnected(el) {
    if (el.hasAttribute(`data-${this.identifier}-autoclose`)) {
      setTimeout(() => this._hide(el), el.getAttribute(`data-${this.identifier}-autoclose`));
    }
  }
  close(event) {
    this._hide(event.target.closest('*[data-contao--message-outlet-target]'));
  }
  renderMessage(event) {
    const {
      type,
      message
    } = event.detail;
    for (const target of this.messagePrototypeTargets) {
      if (target.dataset.type === type) {
        const html = target.getHTML().replace('{{message}}', message);
        this.element.append(document.createRange().createContextualFragment(html));
        return;
      }
    }
    if (window.console) {
      console.error(`Could not find any message prototypes for type "${type}".`);
    }
  }
  _hide(el) {
    el.hidden = true;
  }
});

/***/ }),

/***/ "./core-bundle/assets/controllers/metawizard-controller.js":
/*!*****************************************************************!*\
  !*** ./core-bundle/assets/controllers/metawizard-controller.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");

/* harmony default export */ __webpack_exports__["default"] = (class extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ['input'];
  delete() {
    for (const input of this.inputTargets) {
      input.value = '';
    }
  }
});

/***/ }),

/***/ "./core-bundle/assets/controllers/operations-menu-controller.js":
/*!**********************************************************************!*\
  !*** ./core-bundle/assets/controllers/operations-menu-controller.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ OperationsMenuController; }
/* harmony export */ });
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");
/* harmony import */ var accessible_menu__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! accessible-menu */ "./node_modules/accessible-menu/dist/accessible-menu.es.js");


let menus = [];
class OperationsMenuController extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ['menu', 'submenu', 'controller', 'title'];
  connect() {
    if (!this.hasControllerTarget || !this.hasMenuTarget) {
      return;
    }
    this.$menu = new accessible_menu__WEBPACK_IMPORTED_MODULE_1__["default"].DisclosureMenu({
      menuElement: this.menuTarget,
      menuLinkSelector: 'a,button,img'
    });
    menus.push(this.$menu);
    this.controllerTarget?.addEventListener('accessibleMenuExpand', () => {
      for (const menu of menus) {
        if (menu !== this.$menu && menu.elements.submenuToggles[0].isOpen) {
          menu.elements.submenuToggles[0].close();
        }
      }
      this.setPosition();
    });
  }
  disconnect() {
    // Cleanup menu instance, otherwise we would leak memory
    for (const [key, value] of Object.entries(window.AccessibleMenu?.menus ?? {})) {
      if (value === this.$menu) {
        delete window.AccessibleMenu.menus[key];
      }
    }
    menus = menus.filter(menu => menu !== this.$menu);
  }
  titleTargetConnected(el) {
    el.removeAttribute(`data-${this.identifier}-target`);
    const link = el.querySelector('a[title]');
    if (link && '' !== link.getAttribute('title')) {
      link.append(link.getAttribute('title'));
      return;
    }
    const img = el.querySelector('img[alt]');
    if (img && '' !== img.getAttribute('alt')) {
      img.parentNode.append(img.getAttribute('alt'));
    }
  }
  open(event) {
    if (!this.hasControllerTarget || !this.hasMenuTarget || this.isInteractive(event.target)) {
      return;
    }
    if (this.$menu.elements.submenuToggles[0].isOpen) {
      this.$menu.elements.submenuToggles[0].close();
      return;
    }
    event.preventDefault();

    // Prevent accessible-menu from handling pointerup and closing the menu again (see #8065, #8567)
    this.element.addEventListener('pointerup', e => e.stopPropagation(), {
      once: true
    });
    this.$menu.elements.submenuToggles[0].open();
    this.setPosition(event);
  }
  setPosition(event) {
    const offset = 2; // border-width that is excluded from getBoundingClientRect

    const submenuRect = this.submenuTarget.getBoundingClientRect();
    const parentRect = this.menuTarget.querySelector('.operations-menu-container').getBoundingClientRect();
    const rect = this.controllerTarget.getBoundingClientRect();
    let clientX;
    let clientY;
    if (event === undefined) {
      clientX = rect.right;
      clientY = rect.bottom;
    } else {
      clientX = event.clientX;
      clientY = event.clientY;
    }
    const {
      innerWidth,
      innerHeight
    } = window;
    const rowRect = this.element.getBoundingClientRect();
    const overflowRight = innerWidth < clientX + submenuRect.width + parentRect.width;
    const overflowBottom = innerHeight < clientY + submenuRect.height;
    const x = innerWidth - clientX - (innerWidth - parentRect.left);
    let y = clientY - rowRect.top - (parentRect.top - rowRect.top);

    // If not a context menu and bottom overflow, position at the top of the "more" handle.
    if (event === undefined && overflowBottom) {
      y = y - clientY + rect.top - offset;
    }
    this.submenuTarget.style.left = overflowRight ? `-${x + submenuRect.width - offset}px` : `-${x}px`;
    this.submenuTarget.style.top = overflowBottom ? `${y - submenuRect.height + offset}px` : `${y}px`;
    this.submenuTarget.style.right = 'auto';
  }
  isInteractive(el) {
    return el instanceof HTMLAnchorElement || el instanceof HTMLButtonElement || el instanceof HTMLInputElement || el?.closest('a, button, input');
  }
}

/***/ }),

/***/ "./core-bundle/assets/controllers/passkeys-controller.js":
/*!***************************************************************!*\
  !*** ./core-bundle/assets/controllers/passkeys-controller.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");

/* harmony default export */ __webpack_exports__["default"] = (class extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ['form', 'nameInput'];
  nameInputTargetConnected(el) {
    el.focus();
    el.select();
  }
  cancelEdit(e) {
    this.nameInputTarget.value = this.nameInputTarget.getAttribute('value');
    this.formTarget.requestSubmit();
  }
});

/***/ }),

/***/ "./core-bundle/assets/controllers/profile-controller.js":
/*!**************************************************************!*\
  !*** ./core-bundle/assets/controllers/profile-controller.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");

/* harmony default export */ __webpack_exports__["default"] = (class extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ['button', 'menu'];
  static values = {
    name: {
      type: String,
      default: 'tmenu__profile'
    }
  };
  buttonTargetConnected(button) {
    button.setAttribute('aria-controls', this.nameValue);
    button.setAttribute('aria-expanded', 'false');
  }
  menuTargetConnected(menu) {
    menu.setAttribute('id', this.nameValue);
  }
  toggle(event) {
    this.menuTarget.classList.toggle('active');
    if (this.menuTarget.classList.contains('active')) {
      this.buttonTarget.setAttribute('aria-expanded', 'true');
    } else {
      this.buttonTarget.setAttribute('aria-expanded', 'false');
    }
  }
  close() {
    this.menuTarget.classList.remove('active');
    this.buttonTarget.setAttribute('aria-expanded', 'false');
  }
  documentClick(event) {
    if (this.buttonTarget.contains(event.target)) {
      return;
    }
    this.close();
  }
});

/***/ }),

/***/ "./core-bundle/assets/controllers/row-wizard-controller.js":
/*!*****************************************************************!*\
  !*** ./core-bundle/assets/controllers/row-wizard-controller.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");

/* harmony default export */ __webpack_exports__["default"] = (class extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ['body', 'row'];
  rowTargetConnected() {
    this.updateSorting();
  }
  rowTargetDisconnected() {
    this.updateSorting();
  }
  copy(event) {
    const row = this._getRow(event);
    const previous = row.previousElementSibling;

    // Cause Choices and similar controllers to be disconnected
    row.remove();

    // Wait until Stimulus controllers are disconnected
    queueMicrotask(() => {
      const newRow = row.cloneNode(true);

      // Re-insert the previous and new row
      if (previous) {
        previous.after(row, newRow);
      } else {
        this.bodyTarget.prepend(row, newRow);
      }
      this._focus(newRow);
    });
  }
  delete(event) {
    const row = this._getRow(event);
    if (this.bodyTarget.children.length > 1) {
      this._focus(row.nextElementSibling) || this._focus(row.previousElementSibling) || this._focus(this.bodyTarget);
      row.remove();
    } else {
      this._resetInputs(row);
      this._focus(row);
    }
  }

  /**
   * This method is specific to the row wizard being a "module wizard".
   */
  updateModuleWizardLink(event) {
    const row = this._getRow(event);
    const link = row.querySelector('.module_link');
    const images = row.querySelectorAll('img.module_image');
    const select = event.target;
    const isContentElement = select.value.startsWith('content-');
    const id = isContentElement ? select.value.replace('content-', '') : select.value;
    const href = new URL(link.href);
    href.searchParams.set('table', isContentElement ? 'tl_content' : 'tl_module');
    href.searchParams.set('id', id);
    link.href = href.toString();
    if (id > 0) {
      link.classList.remove('hidden');
      for (const image of images) {
        image.classList.add('hidden');
      }
    } else {
      link.classList.add('hidden');
      for (const image of images) {
        image.classList.remove('hidden');
      }
    }
  }
  updateSorting() {
    Array.from(this.bodyTarget.children).forEach((tr, i) => {
      for (const el of tr.querySelectorAll('label, input, select')) {
        if (el.name) {
          el.name = el.name.replace(/\[[0-9]+]/g, `[${i}]`);
        }
        if (el.id) {
          el.id = el.id.replace(/_[0-9]+(_|$)/g, `_${i}$1`);
        }
        if (el.getAttribute('for')) {
          el.setAttribute('for', el.getAttribute('for').replace(/_[0-9]+(_|$)/g, `_${i}$1`));
        }
      }
    });
  }
  _getRow(event) {
    return event.target.closest('*[data-contao--row-wizard-target="row"]');
  }
  _resetInputs(row) {
    for (const input of row.querySelectorAll('input')) {
      input.value = '';
    }
    for (const select of row.querySelectorAll('select')) {
      select.value = select.children[0].value;
    }
  }
  _focus(el) {
    if (!el) {
      return false;
    }
    el.querySelector('input, select:not(.choices__input), .tl_select.choices')?.focus();
    return true;
  }
});

/***/ }),

/***/ "./core-bundle/assets/controllers/scroll-offset-controller.js":
/*!********************************************************************!*\
  !*** ./core-bundle/assets/controllers/scroll-offset-controller.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");

/* harmony default export */ __webpack_exports__["default"] = (class extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  #autoFocus = false;
  static targets = ['scrollTo', 'autoFocus', 'widgetError'];
  static values = {
    sessionKey: {
      type: String,
      default: 'contao_backend_offset'
    },
    behavior: {
      type: String,
      default: 'instant'
    },
    block: {
      type: String,
      default: 'center'
    }
  };

  // Backwards compatibility: automatically register the Stimulus controller if the legacy methods are used
  static afterLoad(identifier, application) {
    const loadFallback = () => {
      return new Promise((resolve, reject) => {
        const controller = application.getControllerForElementAndIdentifier(document.documentElement, identifier);
        if (controller) {
          resolve(controller);
          return;
        }
        const {
          controllerAttribute
        } = application.schema;
        document.documentElement.setAttribute(controllerAttribute, `${document.documentElement.getAttribute(controllerAttribute) || ''} ${identifier}`);
        setTimeout(() => {
          const controller = application.getControllerForElementAndIdentifier(document.documentElement, identifier);
          controller && resolve(controller) || reject(controller);
        }, 100);
      });
    };
    if (window.Backend && !window.Backend.initScrollOffset) {
      window.Backend.initScrollOffset = () => {
        if (window.console) {
          console.warn('Backend.initScrollOffset() is deprecated. Please use the Stimulus controller instead.');
        }
        loadFallback();
      };
    }
    if (window.Backend && !window.Backend.getScrollOffset) {
      window.Backend.getScrollOffset = () => {
        if (window.console) {
          console.warn('Backend.getScrollOffset() is deprecated. Please use the Stimulus controller instead.');
        }
        loadFallback().then(controller => controller.discard());
      };
    }
  }
  initialize() {
    this.store = this.store.bind(this);
  }
  connect() {
    this.restore();
  }
  async restore() {
    if (!this.offset) return;

    // Execute scroll restore after Turbo scrolled to top
    await new Promise(requestAnimationFrame);
    window.scrollTo({
      top: this.offset,
      behavior: this.behaviorValue,
      block: this.blockValue
    });
    this.offset = null;
  }
  scrollToTargetConnected() {
    this.scrollToTarget.scrollIntoView({
      behavior: this.behaviorValue,
      block: this.blockValue
    });
  }
  autoFocusTargetConnected() {
    if (this.offset || this.#autoFocus) return;
    const input = this.autoFocusTarget;
    if (input.disabled || input.readonly || !input.offsetWidth || !input.offsetHeight || input.closest('.chzn-search') || input.autocomplete && input.autocomplete !== 'off') {
      return;
    }
    this.#autoFocus = true;
    input.focus();
  }
  autoFocusTargetDisconnected() {
    this.#autoFocus = false;
  }
  widgetErrorTargetConnected() {
    this.widgetErrorTarget.scrollIntoView({
      behavior: 'smooth',
      block: 'start'
    });
  }
  store() {
    this.offset = this.element.scrollTop;
  }
  discard() {
    this.offset = null;
  }
  scrollToWidgetError() {
    if (this.hasWidgetErrorTarget) {
      this.widgetErrorTargetConnected();
    }
  }
  get offset() {
    const value = window.sessionStorage.getItem(this.sessionKeyValue);
    return value ? Number.parseInt(value) : null;
  }
  set offset(value) {
    if (value === null || value === undefined) {
      window.sessionStorage.removeItem(this.sessionKeyValue);
    } else {
      window.sessionStorage.setItem(this.sessionKeyValue, String(value));
    }
  }
});

/***/ }),

/***/ "./core-bundle/assets/controllers/serp-preview-controller.js":
/*!*******************************************************************!*\
  !*** ./core-bundle/assets/controllers/serp-preview-controller.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");

/* harmony default export */ __webpack_exports__["default"] = (class extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static values = {
    id: String,
    trail: String,
    titleTag: String,
    fields: Object
  };
  static targets = ['url', 'title', 'description'];
  sourceElements = new Map();
  connect() {
    // Install event listeners on the source fields
    for (const [sourceType, ids] of Object.entries(this.fieldsValue)) {
      const elements = [];
      for (const id of ids) {
        const el = document.getElementById(id);
        if (!el) {
          continue;
        }
        elements.push(el);
        el.addEventListener('input', this._update.bind(this, sourceType));
      }
      this.sourceElements.set(sourceType, elements);

      // Initially gather content
      this._update(sourceType);
    }
  }
  disconnect() {
    for (const elements of this.sourceElements.values()) {
      for (const el of elements) {
        el.removeEventListener('input', this._update);
      }
    }
    this.sourceElements.clear();
  }
  _update(sourceType) {
    const value = this._getValue(sourceType);
    if (sourceType === 'title') {
      this.titleTarget.textContent = this._shorten(this._html2string(this.titleTagValue.replace(/%s/, value)).replace(/%%/g, '%'), 64);
    } else if (sourceType === 'alias') {
      this.urlTarget.textContent = value === 'index' ? this.trailValue : `${this.trailValue}  ${(value || this.idValue).replace(/\//g, '  ')}`;
    } else if (sourceType === 'description') {
      this.descriptionTarget.textContent = this._shorten(value, 160);
    }
  }
  _getValue(sourceType) {
    for (const el of this.sourceElements.get(sourceType)) {
      if (!el) {
        continue;
      }
      const value = el.classList.contains('tl_textarea') && el.classList.contains('noresize') ? this._html2string(el.value) : el.value;
      if (value) {
        return value;
      }
    }
    return '';
  }
  _shorten(str, max) {
    if (str.length <= max) {
      return str;
    }
    return `${str.substr(0, str.lastIndexOf(' ', max))} `;
  }
  _html2string(html) {
    return new DOMParser().parseFromString(html, 'text/html').body.textContent.replace(/\[-]/g, '\xAD').replace(/\[nbsp]/g, '\xA0');
  }
});

/***/ }),

/***/ "./core-bundle/assets/controllers/sortable-controller.js":
/*!***************************************************************!*\
  !*** ./core-bundle/assets/controllers/sortable-controller.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");
/* harmony import */ var sortablejs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! sortablejs */ "./node_modules/sortablejs/modular/sortable.esm.js");


/* harmony default export */ __webpack_exports__["default"] = (class extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static values = {
    parentMode: {
      type: Boolean,
      default: false
    },
    requestToken: String,
    handle: String,
    draggable: String
  };
  connect() {
    const options = {
      animation: 100,
      onSort: event => {
        this._onSorted(event.item);
      }
    };
    if (this.hasHandleValue) {
      options.handle = this.handleValue;
    }
    if (this.hasDraggableValue) {
      options.draggable = this.draggableValue;
    }
    this.sortable = new sortablejs__WEBPACK_IMPORTED_MODULE_1__["default"](this.element, options);

    // Backwards compatibility for parent mode, will unhide the operation if no other drag handle is found
    for (const el of [...this.element.children]) {
      const handles = el.querySelectorAll('.drag-handle');

      // There will always be at least 2 handles: one for the operations list and one for the operations menu (which is hidden)
      if (handles.length === 2) {
        handles[0].style.display = '';
      }
      for (const handle of handles) {
        if (handle.style.display === 'none' && handle.parentNode.localName === 'li') {
          handle.parentNode.style = 'display: none !important';
        }
      }
    }
  }
  disconnect() {
    this.sortable?.destroy();
    this.sortable = undefined;
  }
  move(event) {
    const item = this._getItem(event.target);
    if (event.code === 'ArrowUp' || event.keyCode === 38) {
      event.preventDefault();
      if (item.previousElementSibling) {
        item.previousElementSibling.before(item);
      } else {
        this.element.append(item);
      }
      this._onSorted(item);
      event.target.focus();
    } else if (event.code === 'ArrowDown' || event.keyCode === 40) {
      event.preventDefault();
      if (item.nextElementSibling) {
        item.nextElementSibling.after(item);
      } else {
        this.element.prepend(item);
      }
      this._onSorted(item);
      event.target.focus();
    }
  }
  _updateWrapperLevel() {
    const divs = this.element.querySelectorAll('li > div:first-child');
    if (!divs) {
      return;
    }
    let wrapLevel = 0;
    for (let i = 0; i < divs.length; i++) {
      if (divs[i].classList.contains('wrapper_stop') && wrapLevel > 0) {
        wrapLevel--;
      }
      divs[i].className = divs[i].className.replace(/(^|\s)indent[^\s]*/g, '');
      if (wrapLevel > 0) {
        divs[i].classList.add('indent');
        divs[i].classList.add(`indent_${wrapLevel}`);
      }
      if (divs[i].classList.contains('wrapper_start')) {
        wrapLevel++;
      }
      divs[i].classList.remove('indent_first');
      divs[i].classList.remove('indent_last');
      if (divs[i - 1] && divs[i - 1].classList.contains('wrapper_start')) {
        divs[i].classList.add('indent_first');
      }
      if (divs[i + 1] && divs[i + 1].classList.contains('wrapper_stop')) {
        divs[i].classList.add('indent_last');
      }
    }
  }
  _updateParentSorting(el) {
    const url = new URL(window.location.href);
    url.searchParams.set('rt', this.requestTokenValue);
    url.searchParams.set('act', 'cut');
    url.searchParams.set('id', el.dataset.id);
    if (el.previousElementSibling) {
      url.searchParams.set('pid', el.previousElementSibling.dataset.id);
      url.searchParams.set('mode', 1);
    } else {
      url.searchParams.set('pid', this.element.dataset.id);
      url.searchParams.set('mode', 2);
    }
    fetch(url, {
      redirect: 'manual'
    });
  }
  _getItem(el) {
    if (!el.parentNode || el.parentNode === this.element) {
      return el;
    }
    return this._getItem(el.parentNode);
  }
  _onSorted(item) {
    this.dispatch('update', {
      target: item
    });
    if (this.parentModeValue) {
      this._updateWrapperLevel(item);
      this._updateParentSorting(item);
    }
  }
});

/***/ }),

/***/ "./core-bundle/assets/controllers/tabs-controller.js":
/*!***********************************************************!*\
  !*** ./core-bundle/assets/controllers/tabs-controller.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ TabsController; }
/* harmony export */ });
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");
/* harmony import */ var _modules_icon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../modules/icon */ "./core-bundle/assets/modules/icon.js");


class TabsController extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static values = {
    closeLabel: String
  };
  static targets = ['navigation', 'panel'];
  activeTab = null;
  panelTargetConnected(panel) {
    // When the DOM is already set up, just set the panel ID and
    // install the event listeners, otherwise create the elements first.
    const isRestore = 'tabpanel' === panel.getAttribute('role');
    const tabId = isRestore ? panel.dataset.tabId : (Math.random() + 1).toString(36).substring(7);
    const containerId = this.element.id;
    const panelReference = panel.id || `tab-panel_${containerId}_${tabId}`;
    const controlReference = `tab-control_${containerId}_${tabId}`;

    // Create navigation elements
    const selectButton = isRestore ? this.navigationTarget.querySelector(`button.select[aria-controls="${panelReference}"]`) : (() => {
      const button = document.createElement('button');
      button.id = controlReference;
      button.className = 'select';
      button.innerText = panel.dataset.label;
      button.setAttribute('type', 'button');
      button.setAttribute('role', 'tab');
      button.setAttribute('aria-controls', panelReference);
      return button;
    })();
    selectButton.addEventListener('click', () => {
      this.selectTab(panel);
    });
    const closeButton = isRestore ? this.navigationTarget.querySelector(`button.close[aria-controls="${panelReference}"]`) : (() => {
      const button = document.createElement('button');
      button.className = 'close';
      button.append(_modules_icon__WEBPACK_IMPORTED_MODULE_1__.getTemplate('close', {
        'aria-hidden': true,
        width: 12,
        height: 12
      }).content);
      button.setAttribute('type', 'button');
      button.setAttribute('aria-controls', panelReference);
      button.setAttribute('aria-label', this.closeLabelValue);
      return button;
    })();
    closeButton.addEventListener('click', () => {
      // Remove the panel and let the disconnect handler do the rest
      panel.remove();
    });
    if (!isRestore) {
      // Enhance panel container
      panel.dataset.tabId = tabId;
      panel.id = panelReference;
      panel.setAttribute('role', 'tabpanel');
      panel.setAttribute('aria-labelledby', controlReference);

      // Add navigation element
      const li = document.createElement('li');
      li.setAttribute('role', 'presentation');
      li.append(selectButton);
      li.append(closeButton);
      this.navigationTarget.append(li);
    }

    // Activate tab
    this.selectTab(panel);
  }
  panelTargetDisconnected(panel) {
    // Remove controls
    document.getElementById(panel.getAttribute('aria-labelledby'))?.parentElement?.remove();

    // Select the first tab/no tab if the current tab was active before closing.
    if (panel === this.activeTab) {
      if (this.hasPanelTarget) {
        this.selectTab(this.panelTarget);
      } else {
        this.activeTab = null;
      }
    }
  }
  selectTab(panel) {
    for (const el of this.panelTargets) {
      const isTarget = el === panel;
      el.toggleAttribute('aria-selected', isTarget);
      el.toggleAttribute('data-active', isTarget);
      el.style.display = isTarget ? 'revert' : 'none';

      // Re-enable/disable the button access keys
      if (isTarget) {
        for (const button of el.querySelectorAll('button[data-disabled-accesskey]')) {
          button.setAttribute('accesskey', button.getAttribute('data-disabled-accesskey'));
          button.removeAttribute('data-disabled-accesskey');
        }
      } else {
        for (const button of el.querySelectorAll('button[accesskey]')) {
          button.setAttribute('data-disabled-accesskey', button.getAttribute('accesskey'));
          button.removeAttribute('accesskey');
        }
      }
      const selectButton = document.getElementById(el.getAttribute('aria-labelledby'));
      selectButton?.toggleAttribute('aria-selected', isTarget);
      selectButton?.parentElement.toggleAttribute('data-active', isTarget);
    }
    this.activeTab = panel;
  }
  getActiveTab() {
    return this.activeTab;
  }
  getTabs() {
    return this.panelTargets.reduce((result, panel) => {
      result[panel.id] = panel;
      return result;
    }, {});
  }
}

/***/ }),

/***/ "./core-bundle/assets/controllers/template-studio-controller.js":
/*!**********************************************************************!*\
  !*** ./core-bundle/assets/controllers/template-studio-controller.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");
/* harmony import */ var _modules_turbo_stream_connection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../modules/turbo-stream-connection */ "./core-bundle/assets/modules/turbo-stream-connection.js");
/* harmony import */ var _modules_twig_editor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../modules/twig-editor */ "./core-bundle/assets/modules/twig-editor.js");



/* harmony default export */ __webpack_exports__["default"] = (class extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  editors = new Map();
  turboStreamConnection = new _modules_turbo_stream_connection__WEBPACK_IMPORTED_MODULE_1__.TurboStreamConnection();
  static values = {
    followUrl: String,
    blockInfoUrl: String
  };
  static targets = ['themeSelector', 'tabs', 'editor', 'editorAnnotations'];
  connect() {
    // Subscribe to events dispatched by the editors
    this.element.addEventListener('twig-editor:lens:follow', event => {
      this.turboStreamConnection.get(this.followUrlValue, {
        name: event.detail.name
      }, true);
    });
    this.element.addEventListener('twig-editor:lens:block-info', event => {
      this.turboStreamConnection.get(this.blockInfoUrlValue, event.detail, true);
    });
    this.element.addEventListener('turbo:submit-start', event => {
      // Add the currently open editor tabs to the request when selecting a theme
      if (this.hasThemeSelectorTarget && event.target === this.themeSelectorTarget) {
        this._addOpenEditorTabsToRequest(event);
      }

      // Include the active editor's content when the save operation was triggered
      if (event.detail.formSubmission.submitter?.dataset?.operation === 'save') {
        this._addEditorContentToRequest(event);
        this._getActiveMutableEditor()?.focus();
      }
    });
  }
  beforeCache() {
    // Destroy editor instances before Turbo caches the page. They will be
    // recreated when the editorTargetConnected() calls happens on the
    // restored page.
    for (const [key, editor] of this.editors) {
      editor.destroy();
      delete this.editors[key];
    }
  }
  close(event) {
    document.getElementById(event.target.getAttribute('aria-controls')).innerText = '';
  }
  editorTargetConnected(el) {
    this.editors.set(el, new _modules_twig_editor__WEBPACK_IMPORTED_MODULE_2__.TwigEditor(el.querySelector('textarea')));
  }
  editorTargetDisconnected(el) {
    this.editors.get(el).destroy();
    this.editors.delete(el);
  }
  editorAnnotationsTargetConnected(el) {
    this.editors.get(el.closest('*[data-contao--template-studio-target="editor"]'))?.setAnnotationsData(JSON.parse(el.innerText));
  }
  colorChange(event) {
    for (const editor of this.editors) {
      editor.setColorScheme(event.detail.mode);
    }
  }
  _addOpenEditorTabsToRequest(event) {
    const searchParams = event.detail.formSubmission.location.searchParams;
    const tabs = this.application.getControllerForElementAndIdentifier(this.tabsTarget, 'contao--tabs').getTabs();
    for (const tabId of Object.keys(tabs)) {
      // Extract identifier from tabId "template-studio--tab_<identifier>"
      searchParams.append('open_tab[]', tabId.substring(21));
    }
  }
  _addEditorContentToRequest(event) {
    event.detail.formSubmission.fetchRequest.body.append('code', this._getActiveMutableEditor()?.getContent() ?? '');
  }
  _getActiveMutableEditor() {
    const editorElementsOnActiveTab = this.application.getControllerForElementAndIdentifier(this.tabsTarget, 'contao--tabs').getActiveTab()?.querySelectorAll('*[data-contao--template-studio-target="editor"]');
    for (const el of editorElementsOnActiveTab ?? []) {
      const editor = this.editors.get(el);
      if (editor?.isEditable()) {
        return editor;
      }
    }
    return null;
  }
});

/***/ }),

/***/ "./core-bundle/assets/controllers/tinymce-controller.js":
/*!**************************************************************!*\
  !*** ./core-bundle/assets/controllers/tinymce-controller.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");

/* harmony default export */ __webpack_exports__["default"] = (class extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  connect() {
    // Work around a bug in Safari where the transition to a new context
    // causes disconnect() to be called before connect(). If the element ID
    // is identical - which is the case when saving a record - this messes
    // up the initialization of the editor. To prevent this, we delay the
    // execution until the call stack has been cleared and all microtasks,
    // i.e. disconnect() calls, have been executed.
    queueMicrotask(() => this._connect());
  }
  _connect() {
    if (!this.element.tinymceConfig) {
      if (window.console) {
        console.error('No TinyMCE config was attached to the DOM element, expected an expando property called "tinymceConfig".', this.element);
      }
      return;
    }
    const config = this.element.tinymceConfig;
    config.target = this.element;
    tinymce?.init(config).then(editors => {
      const editor = editors[0] ?? null;
      this.editorId = editor?.id;

      // Allow others to listen on the input event of the underlying textarea
      editor?.on('keyup', () => {
        const before = this.element.innerText;
        const after = editor.getContent();
        if (before !== after) {
          this.element.innerText = editor.getContent();
          this.element.dispatchEvent(new Event('input'));
        }
      });

      // Fire a custom event when the editor finished initializing.
      this.dispatch('editor-loaded', {
        detail: {
          content: editor
        }
      });
    });
  }
  disconnect() {
    tinymce?.get(this.editorId)?.remove();
  }
  beforeCache() {
    // Destroy TinyMCE before Turbo caches the page. It will be recreated
    // when the connect() call happens on the restored page.
    this.disconnect();

    // Remove the controller attribute. They will be re-added in the init
    // script of the be_tinyMCE.html5 template.
    this.element.removeAttribute('data-controller');
  }
  leave(event) {
    const editor = tinymce?.get(this.editorId);
    if (!editor || !Object.hasOwn(editor.plugins, 'autosave') || editor.isNotDirty) {
      return;
    }

    // Trigger a beforeunload event like when navigating away to capture the TinyMCE autosave message
    const delegate = document.createEvent('BeforeUnloadEvent');
    delegate.initEvent('beforeunload', false, true);
    if (!window.dispatchEvent(delegate) && !confirm(delegate.returnValue)) {
      event.preventDefault();
    }
  }
});

/***/ }),

/***/ "./core-bundle/assets/controllers/toggle-fieldset-controller.js":
/*!**********************************************************************!*\
  !*** ./core-bundle/assets/controllers/toggle-fieldset-controller.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");

/* harmony default export */ __webpack_exports__["default"] = (class extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static values = {
    id: String,
    table: String
  };
  static classes = ['collapsed'];
  static afterLoad(identifier, application) {
    const addController = (el, id, table) => {
      const fs = el.parentNode;
      fs.dataset.controller = `${fs.dataset.controller || ''} ${identifier}`;
      fs.setAttribute(`data-${identifier}-id-value`, id);
      fs.setAttribute(`data-${identifier}-table-value`, table);
      fs.setAttribute(`data-${identifier}-collapsed-class`, 'collapsed');
      el.setAttribute('tabindex', 0);
      el.setAttribute('data-action', `click->${identifier}#toggle keydown.enter->${identifier}#toggle keydown.space->${identifier}#prevent:prevent keyup.space->${identifier}#toggle:prevent`);
    };
    const migrateLegacy = () => {
      for (const el of document.querySelectorAll('legend[data-toggle-fieldset]')) {
        if (window.console) {
          console.warn(`Using the "data-toggle-fieldset" attribute on fieldset legends is deprecated and will be removed in Contao 6. Apply the "${identifier}" Stimulus controller instead.`);
        }
        const {
          id,
          table
        } = JSON.parse(el.getAttribute('data-toggle-fieldset'));
        addController(el, id, table);
      }
      AjaxRequest.toggleFieldset = (el, id, table) => {
        const fs = el.parentNode;

        // Already clicked, Stimulus controller was added dynamically
        if (application.getControllerForElementAndIdentifier(fs, identifier)) {
          return;
        }
        if (window.console) {
          console.warn('Using AjaxRequest.toggleFieldset() is deprecated and will be removed in Contao 6. Apply the Stimulus actions instead.');
        }
        addController(el, id, table);

        // Optimistically wait until Stimulus has registered the new controller
        setTimeout(() => {
          application.getControllerForElementAndIdentifier(fs, identifier).toggle();
        }, 100);
      };
    };

    // Called as soon as registered, so DOM may not have been loaded yet
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', migrateLegacy);
    } else {
      migrateLegacy();
    }
  }
  connect() {
    if (this.element.querySelectorAll('label.error, label.mandatory').length) {
      this.element.classList.remove(this.collapsedClass);
    } else if (this.element.classList.contains('hide')) {
      if (window.console) {
        console.warn(`Using class "hide" on a fieldset is deprecated and will be removed in Contao 6. Use class "${this.collapsedClass}" instead.`);
      }
      this.element.classList.add(this.collapsedClass);
    }
    if (this.element.classList.contains(this.collapsedClass)) {
      this.setAriaExpanded(false);
    } else {
      this.setAriaExpanded(true);
    }
  }
  toggle() {
    if (this.element.classList.contains(this.collapsedClass)) {
      this.open();
      this.setAriaExpanded(true);
    } else {
      this.close();
      this.setAriaExpanded(false);
    }
  }
  open() {
    if (!this.element.classList.contains(this.collapsedClass)) {
      return;
    }
    this.element.classList.remove(this.collapsedClass);
    this.storeState(1);
  }
  close() {
    if (this.element.classList.contains(this.collapsedClass)) {
      return;
    }
    const form = this.element.closest('form');
    const input = this.element.querySelectorAll('[required]');
    let collapse = true;
    for (let i = 0; i < input.length; i++) {
      if (!input[i].value) {
        collapse = false;
        break;
      }
    }
    if (!collapse) {
      if (typeof form.checkValidity === 'function') {
        form.querySelector('button[type="submit"]').click();
      }
    } else {
      this.element.classList.add(this.collapsedClass);
      this.storeState(0);
    }
  }
  storeState(state) {
    if (!this.hasIdValue || !this.hasTableValue) {
      return;
    }
    fetch(window.location.href, {
      method: 'POST',
      headers: {
        'X-Requested-With': 'XMLHttpRequest'
      },
      body: new URLSearchParams({
        action: 'toggleFieldset',
        id: this.idValue,
        table: this.tableValue,
        state: state
      })
    });
  }
  setAriaExpanded(state) {
    const button = this.element.querySelector('button');
    if (button) {
      button.ariaExpanded = state;
    }
  }
});

/***/ }),

/***/ "./core-bundle/assets/controllers/toggle-navigation-controller.js":
/*!************************************************************************!*\
  !*** ./core-bundle/assets/controllers/toggle-navigation-controller.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");

/* harmony default export */ __webpack_exports__["default"] = (class extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static classes = ['collapsed'];
  static values = {
    url: String,
    requestToken: String,
    expandTitle: String,
    collapseTitle: String
  };
  toggle({
    currentTarget,
    params: {
      category
    }
  }) {
    const el = currentTarget.parentNode;
    const collapsed = el.classList.toggle(this.collapsedClass);
    currentTarget.setAttribute('aria-expanded', collapsed ? 'false' : 'true');
    currentTarget.setAttribute('title', collapsed ? this.expandTitleValue : this.collapseTitleValue);
    this.sendRequest(category, collapsed);
  }
  sendRequest(category, collapsed) {
    fetch(this.urlValue, {
      method: 'POST',
      headers: {
        'X-Requested-With': 'XMLHttpRequest'
      },
      body: new URLSearchParams({
        action: 'toggleNavigation',
        id: category,
        state: collapsed ? 0 : 1,
        REQUEST_TOKEN: this.requestTokenValue
      })
    });
  }
});

/***/ }),

/***/ "./core-bundle/assets/controllers/toggle-nodes-controller.js":
/*!*******************************************************************!*\
  !*** ./core-bundle/assets/controllers/toggle-nodes-controller.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");

/* harmony default export */ __webpack_exports__["default"] = (class extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static values = {
    mode: {
      type: Number,
      default: 5
    },
    toggleAction: String,
    loadAction: String,
    requestToken: String,
    refererId: String,
    expand: String,
    collapse: String,
    expandAll: String,
    expandAllTitle: String,
    collapseAll: String,
    collapseAllTitle: String
  };
  static targets = ['operation', 'node', 'toggle', 'child', 'rootChild'];
  operationTargetConnected() {
    this.updateOperation();
  }
  childTargetConnected() {
    this.updateOperation();
  }
  toggle(event) {
    const el = event.currentTarget;
    this.toggleToggler(el, event.params.id, event.params.level, event.params.folder);
  }
  toggleToggler(el, id, level, folder) {
    const item = document.id(id);
    if (item && item.style.display === 'none') {
      this.showChild(item);
      this.expandToggler(el);
      this.updateState(el, id, 1);
    } else if (item) {
      this.hideChild(item);
      this.collapseToggler(el);
      this.updateState(el, id, 0);
    } else {
      this.fetchChild(el, id, level, folder);
    }
    this.updateOperation();
  }
  expandToggler(el) {
    el.classList.add('foldable--open');
    if (el.hasAttribute('title')) {
      el.title = this.collapseValue;
    }
    for (const image of el.querySelectorAll('img')) {
      image.alt = this.collapseValue;
    }
  }
  collapseToggler(el) {
    el.classList.remove('foldable--open');
    if (el.hasAttribute('title')) {
      el.title = this.expandValue;
    }
    for (const image of el.querySelectorAll('img')) {
      image.alt = this.expandValue;
    }
  }
  loadToggler(el, enabled) {
    el.classList[enabled ? 'add' : 'remove']('foldable--loading');
  }
  showChild(item) {
    item.style.display = '';
  }
  hideChild(item) {
    item.style.display = 'none';
  }
  async fetchChild(el, id, level, folder) {
    this.loadToggler(el, true);
    const url = new URL(location.href);
    const search = url.searchParams;
    search.set('ref', this.refererIdValue);
    url.search = search.toString();
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
        'X-Requested-With': 'XMLHttpRequest'
      },
      body: new URLSearchParams({
        action: this.loadActionValue,
        id: id,
        level: level,
        folder: folder,
        state: 1,
        REQUEST_TOKEN: this.requestTokenValue
      })
    });
    if (response.ok) {
      const txt = await response.text();
      const li = document.createElement('li');
      li.id = id;
      li.classList.add('parent');
      li.style.display = 'inline';
      li.setAttribute(`data-${this.identifier}-target`, level === 0 ? 'child rootChild' : 'child');
      const ul = document.createElement('ul');
      ul.classList.add(`level_${level}`);
      ul.innerHTML = txt;
      li.append(ul);
      if (this.modeValue === 5) {
        el.closest('li').after(li);
      } else {
        let isFolder = false;
        let parent = el.closest('li');
        let next;
        while (typeOf(parent) === 'element' && parent.tagName === 'LI' && (next = parent.nextElementSibling)) {
          parent = next;
          if (parent.classList.contains('tl_folder')) {
            isFolder = true;
            break;
          }
        }
        if (isFolder) {
          parent.before(li);
        } else {
          parent.after(li);
        }
      }
      window.dispatchEvent(new CustomEvent('structure'));
      this.expandToggler(el);

      // HOOK (see #6752)
      window.fireEvent('ajax_change');
    }
    this.loadToggler(el, false);
  }
  async toggleAll(event) {
    const href = event.currentTarget.href;
    if (this.hasExpandedRoot() ^ (event ? event.altKey : false)) {
      this.updateAllState(href, 0);
      for (const el of this.toggleTargets) {
        this.collapseToggler(el);
      }
      for (const item of this.childTargets) {
        item.style.display = 'none';
      }
    } else {
      for (const el of this.childTargets) {
        el.remove();
      }
      for (const el of this.toggleTargets) {
        this.loadToggler(el, true);
      }
      await this.updateAllState(href, 1);
      const promises = [];
      for (const el of this.toggleTargets) {
        promises.push(this.fetchChild(el, el.getAttribute(`data-${this.identifier}-id-param`), 0, el.getAttribute(`data-${this.identifier}-folder-param`)));
      }
      await Promise.all(promises);
    }
    this.updateOperation();
  }
  keypress(event) {
    this.updateOperation(event);
  }
  async updateState(el, id, state) {
    await fetch(location.href, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/x-www-form-urlencoded',
        'X-Requested-With': 'XMLHttpRequest'
      },
      body: new URLSearchParams({
        action: this.toggleActionValue,
        id: id,
        state: state,
        REQUEST_TOKEN: this.requestTokenValue
      })
    });
  }
  async updateAllState(href, state) {
    await fetch(`${href}&state=${state}`);
  }
  updateOperation(event) {
    if (!this.hasOperationTarget) {
      return;
    }
    for (const operationTarget of this.operationTargets) {
      if (this.hasExpandedRoot() ^ (event ? event.altKey : false)) {
        operationTarget.innerText = this.collapseAllValue;
        operationTarget.title = this.collapseAllTitleValue;
      } else {
        operationTarget.innerText = this.expandAllValue;
        operationTarget.title = this.expandAllTitleValue;
      }
    }
  }
  hasExpandedRoot() {
    return !!this.rootChildTargets.find(el => el.style.display !== 'none');
  }
});

/***/ }),

/***/ "./core-bundle/assets/controllers/tooltips-controller.js":
/*!***************************************************************!*\
  !*** ./core-bundle/assets/controllers/tooltips-controller.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ TooltipsController; }
/* harmony export */ });
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");

class TooltipsController extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static defaultOptionsMap = {
    'a img[alt]': {
      x: -9,
      y: 30
    },
    '.sgallery img[alt]': {
      x: 0,
      y: 75
    },
    'p.tl_tip': {
      x: 0,
      y: 23,
      useContent: true
    },
    '#home[title]': {
      x: 6,
      y: 42
    },
    '#tmenu a[title]': {
      x: 0,
      y: 42
    },
    'a[title][class^="group-"]': {
      x: -6,
      y: 27
    },
    'a[title].navigation': {
      x: 25,
      y: 32
    },
    'img[title].gimage': {
      x: -9,
      y: 60
    },
    'img[title]:not(.gimage)': {
      x: -9,
      y: 30
    },
    'a[title].picker-wizard': {
      x: -4,
      y: 30
    },
    'button img[alt]': {
      x: -9,
      y: 30
    },
    '.tl_panel button[title]': {
      x: 0,
      y: 36
    },
    'button[title].unselectable': {
      x: -4,
      y: 20
    },
    'button[title]:not(.unselectable)': {
      x: -9,
      y: 30
    },
    'a[title]:not(.picker-wizard)': {
      x: -9,
      y: 30
    },
    'input[title]': {
      x: -9,
      y: 30
    },
    'time[title]': {
      x: -9,
      y: 26
    },
    'span[title]': {
      x: -9,
      y: 26
    }
  };
  activeTargets = new Set();
  removeClickTargetHandlerDelegates = new Map();

  /**
   * There is one controller handling multiple tooltip targets. The tooltip
   * DOM element is shared across targets.
   */
  connect() {
    this.tooltip = document.body.querySelector('body > div[role="tooltip"]') ?? this._createTipContainer();
  }
  disconnect() {
    this.tooltip.remove();
  }
  tooltipTargetConnected(el) {
    el.addEventListener('mouseenter', e => this._showTooltip(e.target, 1000));
    el.addEventListener('touchend', e => this._showTooltip(e.target));
    el.addEventListener('mouseleave', e => this._hideTooltip(e.target));

    // In case the tooltip target is inside a link or button, also close it
    // when a click happened
    const clickTarget = el.closest('button, a');
    if (clickTarget) {
      const handler = () => this._hideTooltip(el);
      clickTarget.addEventListener('click', handler);
      this.removeClickTargetHandlerDelegates.set(el, () => el.removeEventListener('click', handler));
    }
  }
  tooltipTargetDisconnected(el) {
    if (this.activeTargets.has(el)) {
      this._hideTooltip(el);
    }
    if (this.removeClickTargetHandlerDelegates.has(el)) {
      this.removeClickTargetHandlerDelegates.get(el)();
      this.removeClickTargetHandlerDelegates.delete(el);
    }
  }
  _createTipContainer() {
    const tooltip = document.createElement('div');
    tooltip.setAttribute('role', 'tooltip');
    tooltip.classList.add('tip');
    tooltip.style.position = 'absolute';
    tooltip.style.display = 'none';
    document.body.appendChild(tooltip);
    return tooltip;
  }
  touchStart = e => {
    [...this.activeTargets].filter(el => !el.contains(e.target)).forEach(this._hideTooltip.bind(this));
  };
  _showTooltip(el, delay = 0) {
    const options = this._getOptionsForElement(el);
    let text;
    if (options.useContent) {
      text = el.innerHTML;
    } else if (el instanceof HTMLImageElement) {
      text = el.getAttribute('alt');
      text = text?.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/"/g, '&quot;').replace(/'/g, '&apos;');
    } else {
      text = el.getAttribute('title');
      el.setAttribute('data-original-title', text);
      el.removeAttribute('title');
      text = text?.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/"/g, '&quot;').replace(/'/g, '&apos;');
    }
    if (!text) {
      return;
    }
    clearTimeout(this.timer);
    this.tooltip.style.willChange = 'display,contents';
    this.timer = setTimeout(() => {
      this.activeTargets.add(el);
      const position = el.getBoundingClientRect();
      const rtl = getComputedStyle(el).direction === 'rtl';
      const clientWidth = document.documentElement.clientWidth;
      if (rtl && position.x < 200 || !rtl && position.x < clientWidth - 200) {
        this.tooltip.style.left = `${window.scrollX + position.left + options.x}px`;
        this.tooltip.style.right = 'auto';
        this.tooltip.classList.remove('tip--rtl');
      } else {
        this.tooltip.style.left = 'auto';
        this.tooltip.style.right = `${clientWidth - window.scrollX - position.right + options.x}px`;
        this.tooltip.classList.add('tip--rtl');
      }
      this.tooltip.innerHTML = `<div>${text}</div>`;
      this.tooltip.style.top = `${window.scrollY + position.top + options.y}px`;
      this.tooltip.style.display = 'block';
      this.tooltip.style.willChange = 'auto';
    }, delay);
  }
  _hideTooltip(el, delay = 0) {
    if (el.hasAttribute('data-original-title')) {
      if (!el.hasAttribute('title')) {
        el.setAttribute('title', el.getAttribute('data-original-title'));
      }
      el.removeAttribute('data-original-title');
    }
    clearTimeout(this.timer);
    this.tooltip.style.willChange = 'auto';
    if (this.tooltip.style.display === 'block') {
      this.activeTargets.delete(el);
      this.tooltip.style.willChange = 'display';
      this.timer = setTimeout(() => {
        this.tooltip.style.display = 'none';
        this.tooltip.style.willChange = 'auto';
      }, delay);
    }
  }
  _getOptionsForElement(el) {
    for (const [criteria, defaultOptions] of Object.entries(TooltipsController.defaultOptionsMap)) {
      if (el.match(criteria)) {
        return defaultOptions;
      }
    }
    return {
      x: -9,
      y: 30
    };
  }

  /**
   * Migrate legacy targets to proper controller targets.
   */
  static afterLoad(identifier, application) {
    const targetSelectors = Object.keys(TooltipsController.defaultOptionsMap);
    const migrateTarget = el => {
      for (const target of targetSelectors) {
        if (!el.hasAttribute(`data-${identifier}-target`) && el.match(target)) {
          el.setAttribute(`data-${identifier}-target`, 'tooltip');
        }
        for (const sel of el.querySelectorAll(target)) {
          if (!sel.hasAttribute(`data-${identifier}-target`)) {
            sel.setAttribute(`data-${identifier}-target`, 'tooltip');
          }
        }
      }
    };
    new MutationObserver(mutationsList => {
      for (const mutation of mutationsList) {
        if (mutation.type !== 'childList') {
          continue;
        }
        for (const node of mutation.addedNodes) {
          if (!(node instanceof HTMLElement)) {
            continue;
          }
          migrateTarget(node);
        }
      }
    }).observe(document, {
      childList: true,
      subtree: true
    });

    // Initially migrate all targets that are already in the DOM
    for (const el of document.querySelectorAll(targetSelectors.join(','))) {
      migrateTarget(el);
    }
  }
}

/***/ }),

/***/ "./core-bundle/assets/controllers/webauthn-error-controller.js":
/*!*********************************************************************!*\
  !*** ./core-bundle/assets/controllers/webauthn-error-controller.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");

/* harmony default export */ __webpack_exports__["default"] = (class extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  static targets = ['message'];
  static values = {
    unsupportedMessage: String,
    assertionFailureMessage: String,
    attestationFailureMessage: String,
    optionsFailureMessage: String,
    csrfUrl: String
  };
  handleUnsupported() {
    this.messageTarget.innerHTML = this.renderMessage(this.unsupportedMessageValue);
  }
  handleAssertionFailure(e) {
    this.messageTarget.innerHTML = this.renderMessage(this.assertionFailureMessageValue);
  }
  handleAttestationFailure() {
    this.messageTarget.innerHTML = this.renderMessage(this.attestationFailureMessageValue);
  }
  handleOptionsFailure() {
    this.messageTarget.innerHTML = this.renderMessage(this.optionsFailureMessageValue);
  }
  loadCsrf() {
    if (this.csrfScript || !this.csrfUrlValue) {
      return;
    }

    // Make sure we always have the correct request token and cookie
    this.csrfScript = document.createElement('script');
    this.csrfScript.src = this.csrfUrlValue;
    this.csrfScript.async = true;
    document.body.append(this.csrfScript);
  }
  renderMessage(message, type) {
    return `<p class="tl_${type ?? 'error'}">${message}</p>`;
  }
});

/***/ }),

/***/ "./core-bundle/assets/modules/icon.js":
/*!********************************************!*\
  !*** ./core-bundle/assets/modules/icon.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getSource: function() { return /* binding */ getSource; },
/* harmony export */   getTemplate: function() { return /* binding */ getTemplate; }
/* harmony export */ });
/* harmony import */ var _contao_themes_flexible_icons_manifest_json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../contao/themes/flexible/icons/manifest.json */ "./core-bundle/contao/themes/flexible/icons/manifest.json");


/**
 * Create an icon template for the given name. You can call "getHtml()"
 * on the result to get the HTML of the included icon(s). The result will
 * include either one image element (light/dark mode share an icon) or
 * two with a color-scheme CSS class, if there are different variants for
 * light/dark mode.
 *
 * @param name The name of the icon (e.g. "edit" or "delete").
 * @param attributes An object of attributes (e.g. {title: 'foo'}).
 * @returns {HTMLTemplateElement}
 */
function getTemplate(name, attributes = {}) {
  // Make sure the alt attribute gets set
  if (!Object.prototype.hasOwnProperty.call(attributes, 'alt')) {
    attributes.alt = '';
  }
  const source = getSource(name);
  if (!source) {
    throw Error(`The icon "${name}" does not exist.`);
  }
  const sourceDark = getSource(name, true);
  const template = document.createElement('template');
  if (sourceDark) {
    template.content.append(_getImage(source, attributes, 'light'));
    template.content.append(_getImage(sourceDark, attributes, 'dark'));
  } else {
    template.content.append(_getImage(source, attributes));
  }
  return template;
}
function _getImage(source, attributes, colorScheme = null) {
  const img = document.createElement('img');
  img.src = source;
  for (const [key, value] of Object.entries(attributes)) {
    img.setAttribute(key, value);
  }
  if (colorScheme) {
    img.classList.add(`color-scheme--${colorScheme}`);
  }
  return img;
}
function getSource(name, darkScheme = false) {
  const fileName = `${name}${darkScheme ? '--dark' : ''}.svg`;
  return Object.prototype.hasOwnProperty.call(_contao_themes_flexible_icons_manifest_json__WEBPACK_IMPORTED_MODULE_0__, fileName) ? _contao_themes_flexible_icons_manifest_json__WEBPACK_IMPORTED_MODULE_0__[fileName] : null;
}

/***/ }),

/***/ "./core-bundle/assets/modules/message.js":
/*!***********************************************!*\
  !*** ./core-bundle/assets/modules/message.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   error: function() { return /* binding */ error; },
/* harmony export */   info: function() { return /* binding */ info; }
/* harmony export */ });
/**
 * Display an info message.
 *
 * @param message Text or HTML that will be put into the message body.
 */
function info(message) {
  _addMessage(message, 'info');
}

/**
 * Display an error message.
 *
 * @param message Text or HTML that will be put into the message body.
 */
function error(message) {
  _addMessage(message, 'error');
}
function _addMessage(message, type) {
  const event = new CustomEvent('contao--message', {
    detail: {
      type,
      message
    }
  });
  document.dispatchEvent(event);
}

/***/ }),

/***/ "./core-bundle/assets/modules/turbo-stream-connection.js":
/*!***************************************************************!*\
  !*** ./core-bundle/assets/modules/turbo-stream-connection.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TurboStreamConnection: function() { return /* binding */ TurboStreamConnection; },
/* harmony export */   TurboStreamResult: function() { return /* binding */ TurboStreamResult; }
/* harmony export */ });
class TurboStreamConnection {
  _abortController = new AbortController();
  _abortSignal = {
    reason: 'The request was substituted.'
  };

  /**
   * Requests a stream response using GET and lets Turbo handle it.
   *
   * @param url The URL of the Symfony controller answering the stream request.
   * @param query_params An object of query parameters. If the value is an array, a key "foo" will be named "foo[]" and appear multiple times.
   * @param abortPending If set to true, previous requests that are still pending will be aborted.
   *
   * @returns {Promise<TurboStreamResult>}
   */
  async get(url, query_params = null, abortPending = false) {
    if (abortPending) {
      this.abortPending();
    }
    const params = {
      method: 'get',
      headers: {
        Accept: 'text/vnd.turbo-stream.html'
      },
      signal: this._abortController.signal
    };
    let response;
    try {
      response = await fetch(this.constructor.buildURL(url, query_params), params);
    } catch (e) {
      if (e !== this._abortSignal) {
        if (window.console) {
          console.error(`There was an error fetching the Turbo stream response from "${url}"`);
        }
        return new TurboStreamResult('error', response);
      }
      return new TurboStreamResult('aborted');
    }
    if (response.redirected) {
      document.location = response.url;
      return new TurboStreamResult('error', response);
    }
    if (!response.headers.get('content-type').startsWith('text/vnd.turbo-stream.html') || response.status >= 300) {
      if (window.console) {
        console.error(`The Turbo stream response from "${url}" has an unprocessable format.`);
      }
      return new TurboStreamResult('error', response);
    }
    const html = await response.text();
    Turbo.renderStreamMessage(html);
    return new TurboStreamResult('ok', response);
  }
  abortPending() {
    this._abortController?.abort(this._abortSignal);
    this._abortController = new AbortController();
  }
  static buildURL(url, query_params) {
    if (query_params === null) {
      return url;
    }
    const pairs = [];
    for (const [key, value] of Object.entries(query_params)) {
      if (!Array.isArray(value)) {
        pairs.push([key, value]);
        continue;
      }
      for (const value1 of value) {
        pairs.push([`${key}[]`, value1]);
      }
    }
    return `${url}?${new URLSearchParams(pairs).toString()}`;
  }
}
class TurboStreamResult {
  constructor(resultState, response = null) {
    this.resultState = resultState;
    this.response = response;
  }
  get ok() {
    return this.resultState === 'ok';
  }
  get aborted() {
    return this.resultState === 'aborted';
  }
  get error() {
    return this.resultState === 'error';
  }
}

/***/ }),

/***/ "./core-bundle/assets/modules/twig-editor.js":
/*!***************************************************!*\
  !*** ./core-bundle/assets/modules/twig-editor.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TwigEditor: function() { return /* binding */ TwigEditor; }
/* harmony export */ });
class TwigEditor {
  constructor(element) {
    this.containerBackup = element.cloneNode();
    this.name = element.dataset.name;
    this.resourceUrl = element.dataset.resourceUrl;
    this.editor = ace.edit(element, {
      mode: 'ace/mode/twig',
      maxLines: 100,
      wrap: true,
      useSoftTabs: false,
      autoScrollEditorIntoView: true,
      readOnly: element.hasAttribute('readonly'),
      enableLiveAutocompletion: true,
      enableKeyboardAccessibility: true
    });
    this.setColorScheme(document.documentElement.dataset.colorScheme);
    this.editor.container.style.lineHeight = '1.45';
    const whitespace = ace.require('ace/ext/whitespace');
    whitespace.detectIndentation(this.editor.getSession());

    // Register commands
    this.editor.commands.addCommand({
      name: 'lens:block-info',
      readOnly: true,
      exec: (editor, args) => {
        editor.container.dispatchEvent(new CustomEvent('twig-editor:lens:block-info', {
          bubbles: true,
          detail: {
            name: this.name,
            block: args[0]
          }
        }));
      }
    });
    this.editor.commands.addCommand({
      name: 'lens:follow',
      readOnly: true,
      exec: (editor, args) => {
        editor.container.dispatchEvent(new CustomEvent('twig-editor:lens:follow', {
          bubbles: true,
          detail: {
            name: args[0]
          }
        }));
      }
    });

    // Setup code lenses
    this.editor.getSession().once('tokenizerUpdate', () => {
      this.registerCodeLensProvider();
    });
  }
  registerCodeLensProvider() {
    const codeLens = ace.require('ace/ext/code_lens');
    codeLens.registerCodeLensProvider(this.editor, {
      provideCodeLenses: (session, callback) => {
        if (session.destroyed) {
          return;
        }
        const payload = [];
        for (const reference of this.analyzeReferences()) {
          payload.push({
            start: {
              row: reference.row,
              column: reference.column
            },
            command: {
              id: 'lens:follow',
              title: reference.name,
              arguments: [reference.name]
            }
          });
        }
        for (const block of this.analyzeBlocks()) {
          payload.push({
            start: {
              row: block.row,
              column: block.column
            },
            command: {
              id: 'lens:block-info',
              title: `Block "${block.name}"`,
              arguments: [block.name]
            }
          });
        }
        callback(null, payload);
      }
    });
  }
  analyzeReferences() {
    const references = [];
    for (let row = 0; row < this.editor.getSession().getLength(); row++) {
      const tokens = this.editor.getSession().getTokens(row);
      for (let i = 0; i < tokens.length; i++) {
        if (tokens[i].type === 'meta.tag.twig' && /^{%-?$/.test(tokens[i].value) && tokens[i + 2]?.type === 'keyword.control.twig' && ['extends', 'use'].includes(tokens[i + 2].value) && tokens[i + 4]?.type === 'string') {
          const name = tokens[i + 4].value.replace(/["']/g, '');
          if (/^@Contao(_.+)?\//.test(name)) {
            references.push({
              name,
              row,
              column: tokens[i].start
            });
          }
        }
      }
    }
    return references;
  }
  analyzeBlocks() {
    const blocks = [];
    for (let row = 0; row < this.editor.getSession().getLength(); row++) {
      const tokens = this.editor.getSession().getTokens(row);
      for (let i = 0; i < tokens.length; i++) {
        if (tokens[i].type === 'meta.tag.twig' && /^{%-?$/.test(tokens[i].value) && tokens[i + 2]?.type === 'keyword.control.twig' && tokens[i + 2].value === 'block' && tokens[i + 4]?.type === 'identifier') {
          blocks.push({
            name: tokens[i + 4].value,
            row,
            column: tokens[i].start
          });
        }
      }
    }
    return blocks;
  }
  setAnnotationsData(data) {
    this.editor.completers = [{
      getCompletions: (editor, session, pos, prefix, callback) => {
        callback(null, data.autocomplete);
      }
    }];
    if ('error' in data) {
      this.editor.getSession().setAnnotations([{
        row: data.error.line - 1,
        type: data.error.type || 'error',
        text: ` ${data.error.message}`
      }]);
    }
  }
  setColorScheme(mode) {
    this.editor.setTheme(mode === 'dark' ? 'ace/theme/twilight' : 'ace/theme/clouds');
  }
  isEditable() {
    return !this.editor.getReadOnly();
  }
  getContent() {
    return this.editor.getValue();
  }
  focus() {
    this.editor.focus();
  }
  destroy() {
    // Destroying the ACE instance does not fully reset the HTML, so we
    // manually restore the container by using the cloned backup with
    // updated content.
    this.containerBackup.textContent = this.getContent();
    this.editor.container.replaceWith(this.containerBackup);
    this.editor.destroy();
  }
}

/***/ }),

/***/ "./core-bundle/assets/scripts/core.js":
/*!********************************************!*\
  !*** ./core-bundle/assets/scripts/core.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _modules_icon__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../modules/icon */ "./core-bundle/assets/modules/icon.js");


/**
 * Provide methods to handle Ajax requests.
 *
 * @author Leo Feyer <https://github.com/leofeyer>
 */
window.AjaxRequest = {
  /**
   * Toggle the navigation menu
   *
   * @param {object} el  The DOM element
   * @param {string} id  The ID of the menu item
   * @param {string} url The Ajax URL
   *
   * @returns {boolean}
   */
  toggleNavigation: function (el, id, url) {
    if (window.console) {
      console.warn('AjaxRequest.toggleNavigation() is deprecated. Please use the stimulus controller instead.');
    }
    var item = $(id),
      parent = $(el).getParent('li');
    if (item) {
      if (parent.hasClass('collapsed')) {
        parent.removeClass('collapsed');
        $(el).setAttribute('aria-expanded', 'true');
        $(el).setAttribute('title', Contao.lang.collapse);
        new Request.Contao({
          url: url
        }).post({
          'action': 'toggleNavigation',
          'id': id,
          'state': 1,
          'REQUEST_TOKEN': Contao.request_token
        });
      } else {
        parent.addClass('collapsed');
        $(el).setAttribute('aria-expanded', 'false');
        $(el).setAttribute('title', Contao.lang.expand);
        new Request.Contao({
          url: url
        }).post({
          'action': 'toggleNavigation',
          'id': id,
          'state': 0,
          'REQUEST_TOKEN': Contao.request_token
        });
      }
      return false;
    }
    return false;
  },
  /**
   * Toggle the page tree
   *
   * @param {object} el    The DOM element
   * @param {string} id    The ID of the target element
   * @param {int}    level The indentation level
   * @param {int}    mode  The insert mode
   *
   * @returns {boolean}
   */
  toggleStructure: function (el, id, level, mode) {
    if (window.console) {
      console.warn('AjaxRequest.toggleStructure() is deprecated. Please use the stimulus controller instead.');
    }
    var item = $(id);
    if (item) {
      if (item.getStyle('display') == 'none') {
        item.setStyle('display', null);
        $(el).addClass('foldable--open');
        $(el).setAttribute('title', Contao.lang.collapse);
        new Request.Contao({
          field: el
        }).post({
          'action': 'toggleStructure',
          'id': id,
          'state': 1,
          'REQUEST_TOKEN': Contao.request_token
        });
      } else {
        item.setStyle('display', 'none');
        $(el).removeClass('foldable--open');
        $(el).setAttribute('title', Contao.lang.expand);
        new Request.Contao({
          field: el
        }).post({
          'action': 'toggleStructure',
          'id': id,
          'state': 0,
          'REQUEST_TOKEN': Contao.request_token
        });
      }
      return false;
    }
    new Request.Contao({
      field: el,
      evalScripts: true,
      onRequest: function () {
        AjaxRequest.displayBox(Contao.lang.loading + ' ');
      },
      onSuccess: function (txt) {
        var li = new Element('li', {
          'id': id,
          'class': 'parent',
          'styles': {
            'display': 'inline'
          }
        });
        new Element('ul', {
          'class': 'level_' + level,
          'html': txt
        }).inject(li, 'bottom');
        if (mode == 5) {
          li.inject($(el).getParent('li'), 'after');
        } else {
          var folder = false,
            parent = $(el).getParent('li'),
            next;
          while (typeOf(parent) == 'element' && (next = parent.getNext('li'))) {
            parent = next;
            if (parent.hasClass('tl_folder')) {
              folder = true;
              break;
            }
          }
          if (folder) {
            li.inject(parent, 'before');
          } else {
            li.inject(parent, 'after');
          }
        }

        // Update the referer ID
        li.getElements('a').each(function (el) {
          el.href = el.href.replace(/&ref=[a-f0-9]+/, '&ref=' + Contao.referer_id);
        });
        $(el).addClass('foldable--open');
        $(el).setAttribute('title', Contao.lang.collapse);
        window.fireEvent('structure');
        AjaxRequest.hideBox();

        // HOOK
        window.fireEvent('ajax_change');
      }
    }).post({
      'action': 'loadStructure',
      'id': id,
      'level': level,
      'state': 1,
      'REQUEST_TOKEN': Contao.request_token
    });
    return false;
  },
  /**
   * Toggle the file tree
   *
   * @param {object} el     The DOM element
   * @param {string} id     The ID of the target element
   * @param {string} folder The folder's path
   * @param {int}    level  The indentation level
   *
   * @returns {boolean}
   */
  toggleFileManager: function (el, id, folder, level) {
    if (window.console) {
      console.warn('AjaxRequest.toggleFileManager() is deprecated. Please use the stimulus controller instead.');
    }
    var item = $(id);
    if (item) {
      if (item.getStyle('display') == 'none') {
        item.setStyle('display', null);
        $(el).addClass('foldable--open');
        $(el).setAttribute('title', Contao.lang.collapse);
        new Request.Contao({
          field: el
        }).post({
          'action': 'toggleFileManager',
          'id': id,
          'state': 1,
          'REQUEST_TOKEN': Contao.request_token
        });
      } else {
        item.setStyle('display', 'none');
        $(el).removeClass('foldable--open');
        $(el).setAttribute('title', Contao.lang.expand);
        new Request.Contao({
          field: el
        }).post({
          'action': 'toggleFileManager',
          'id': id,
          'state': 0,
          'REQUEST_TOKEN': Contao.request_token
        });
      }
      return false;
    }
    new Request.Contao({
      field: el,
      evalScripts: true,
      onRequest: function () {
        AjaxRequest.displayBox(Contao.lang.loading + ' ');
      },
      onSuccess: function (txt) {
        var li = new Element('li', {
          'id': id,
          'class': 'parent',
          'styles': {
            'display': 'inline'
          }
        });
        new Element('ul', {
          'class': 'level_' + level,
          'html': txt
        }).inject(li, 'bottom');
        li.inject($(el).getParent('li'), 'after');

        // Update the referer ID
        li.getElements('a').each(function (el) {
          el.href = el.href.replace(/&ref=[a-f0-9]+/, '&ref=' + Contao.referer_id);
        });
        $(el).addClass('foldable--open');
        $(el).setAttribute('title', Contao.lang.collapse);
        AjaxRequest.hideBox();

        // HOOK
        window.fireEvent('ajax_change');
      }
    }).post({
      'action': 'loadFileManager',
      'id': id,
      'level': level,
      'folder': folder,
      'state': 1,
      'REQUEST_TOKEN': Contao.request_token
    });
    return false;
  },
  /**
   * Toggle sub-palettes in edit mode
   *
   * @param {object} el    The DOM element
   * @param {string} id    The ID of the target element
   * @param {string} field The field name
   */
  toggleSubpalette: function (el, id, field) {
    var item = $(id);
    if (item) {
      if (!el.value) {
        el.value = 1;
        el.checked = 'checked';
        item.setStyle('display', null);
        item.getElements('[data-required]').each(function (el) {
          el.set('required', '').set('data-required', null);
        });
        new Request.Contao({
          field: el,
          onSuccess: updateVersionNumber
        }).post({
          'action': 'toggleSubpalette',
          'id': id,
          'field': field,
          'state': 1,
          'REQUEST_TOKEN': Contao.request_token
        });
      } else {
        el.value = '';
        el.checked = '';
        item.setStyle('display', 'none');
        item.getElements('[required]').each(function (el) {
          el.set('required', null).set('data-required', '');
        });
        new Request.Contao({
          field: el,
          onSuccess: updateVersionNumber
        }).post({
          'action': 'toggleSubpalette',
          'id': id,
          'field': field,
          'state': 0,
          'REQUEST_TOKEN': Contao.request_token
        });
      }
      return;
    }
    new Request.Contao({
      field: el,
      evalScripts: false,
      onRequest: function () {
        AjaxRequest.displayBox(Contao.lang.loading + ' ');
      },
      onSuccess: function (txt, json) {
        var div = new Element('div', {
          'id': id,
          'class': 'subpal widget-group',
          'html': txt
        }).inject($(el).getParent('div').getParent('div'), 'after');

        // Execute scripts after the DOM has been updated
        if (json.javascript) {
          // Use Asset.javascript() instead of document.write() to load a
          // JavaScript file and re-execute the code after it has been loaded
          document.write = function (str) {
            var src = '';
            str.replace(/<script src="([^"]+)"/i, function (all, match) {
              src = match;
            });
            src && Asset.javascript(src, {
              onLoad: function () {
                Browser.exec(json.javascript);
              }
            });
          };
          Browser.exec(json.javascript);
        }
        el.value = 1;
        el.checked = 'checked';

        // Update the referer ID
        div.getElements('a').each(function (el) {
          el.href = el.href.replace(/&ref=[a-f0-9]+/, '&ref=' + Contao.referer_id);
        });
        updateVersionNumber(txt);
        AjaxRequest.hideBox();
        window.fireEvent('ajax_change');
      }
    }).post({
      'action': 'toggleSubpalette',
      'id': id,
      'field': field,
      'load': 1,
      'state': 1,
      'REQUEST_TOKEN': Contao.request_token
    });
    function updateVersionNumber(html) {
      var fields = el.form.elements.VERSION_NUMBER || [];
      if (!fields.forEach) {
        fields = [fields];
      }
      fields.forEach(function (field) {
        field.value = /<input\s+[^>]*?name="VERSION_NUMBER"\s+[^>]*?value="([^"]*)"/i.exec(html)[1];
      });
    }
  },
  /**
   * Toggle the state of a checkbox field
   *
   * @param {object}  el       The DOM element
   * @param {boolean} rowIcon  Whether the row icon should be toggled as well
   * @param {boolean} iconOnly If only the icon should be toggled (without sending a request)
   *
   * @returns {boolean}
   */
  toggleField: function (el, rowIcon, iconOnly = false) {
    var img = null,
      images = $(el).getElements('img'),
      published = images[0].get('data-state') == 1,
      div,
      next,
      pa,
      label;
    if (rowIcon && !iconOnly) {
      // Find the icon depending on the view (tree view, list view, parent view)
      if (div = el.closest('.tl_right')) {
        img = div.getPrevious('div').getElements('img');
      } else if ((div = el.closest('.tl_content_right')) && (next = div.getNext('div'))) {
        if (next.hasClass('cte_type')) {
          img = next;
        }
        if (img === null) {
          // newsletter recipients
          img = next.getFirst('div.list_icon');
        }
      } else if (el.closest('.tl_listing_container') && el.getParent('tr')) {
        img = el.getParent('td').getPrevious('td').getFirst('div.list_icon');
        if (img === null) {
          // comments
          img = el.getParent('td').getPrevious('td').getElement('div.cte_type');
        }
        if (img === null) {
          // showColumns
          img = el.getParent('tr').getFirst('td').getElement('div.list_icon_new');
        }
      }

      // Change the row icon
      if (img !== null) {
        // Tree view
        if (!(img instanceof HTMLElement) && img.forEach) {
          img.forEach(img => {
            if (img instanceof HTMLImageElement) {
              if (!img.getParent('ul.tl_listing').hasClass('tl_tree_xtnd')) {
                pa = img.getParent('a');
                if (pa && pa.href.indexOf('contao/preview') == -1) {
                  if (next = pa.getNext('a')) {
                    img = next.getElement('img');
                  } else {
                    img = new Element('img'); // no icons used (see #2286)
                  }
                }
              }
              const newSrc = !published ? img.get('data-icon') : img.get('data-icon-disabled');
              img.src = img.src.includes('/') && !newSrc.includes('/') ? img.src.slice(0, img.src.lastIndexOf('/') + 1) + newSrc : newSrc;
            }
          });
        }
        // Parent view
        else if (img.hasClass('cte_type')) {
          if (!published) {
            img.addClass('published');
            img.removeClass('unpublished');
          } else {
            img.addClass('unpublished');
            img.removeClass('published');
          }
        }
        // List view
        else {
          img.setStyle('background-image', 'url(' + (!published ? img.get('data-icon') : img.get('data-icon-disabled')) + ')');
        }
      }
    }

    // Send request
    images.forEach(function (image) {
      const newSrc = !published ? image.get('data-icon') : image.get('data-icon-disabled');
      image.src = image.src.includes('/') && !newSrc.includes('/') ? image.src.slice(0, image.src.lastIndexOf('/') + 1) + newSrc : newSrc;
      image.alt = label = !published ? image.get('data-alt') : image.get('data-alt-disabled');
      image.set('data-state', !published ? 1 : 0);
    });
    if (!published && $(el).get('data-title')) {
      el.title = label = $(el).get('data-title');
    } else if (published && $(el).get('data-title-disabled')) {
      el.title = label = $(el).get('data-title-disabled');
    }
    if (!published && $(el).get('data-label')) {
      label = $(el).get('data-label');
    } else if (published && $(el).get('data-label-disabled')) {
      label = $(el).get('data-label-disabled');
    }
    if (label) {
      el.childNodes.forEach(child => {
        if (child instanceof Text && child.nodeValue.trim()) {
          child.replaceWith(new Text(label));
        }
      });
    }
    if (!iconOnly) {
      document.body.querySelectorAll(`a[href="${el.getAttribute('href')}"]`).forEach(clone => {
        if (el !== clone) {
          AjaxRequest.toggleField(clone, rowIcon, true);
        }
      });
      new Request.Contao({
        'url': el.href,
        'followRedirects': false
      }).get();
    }

    // Return false to stop the click event on link
    return false;
  },
  /**
   * Toggle a group of a multi-checkbox field
   *
   * @param {object} el The DOM element
   * @param {string} id The ID of the target element
   *
   * @returns {boolean}
   */
  toggleCheckboxGroup: function (el, id) {
    var item = $(id);
    if (item) {
      if (item.getStyle('display') == 'none') {
        item.setStyle('display', null);
        $(el).addClass('foldable--open');
        new Request.Contao().post({
          'action': 'toggleCheckboxGroup',
          'id': id,
          'state': 1,
          'REQUEST_TOKEN': Contao.request_token
        });
      } else {
        item.setStyle('display', 'none');
        $(el).removeClass('foldable--open');
        new Request.Contao().post({
          'action': 'toggleCheckboxGroup',
          'id': id,
          'state': 0,
          'REQUEST_TOKEN': Contao.request_token
        });
      }
      return true;
    }
    return false;
  },
  /**
   * Display the "loading data" message
   *
   * @param {string} message The message text
   */
  displayBox: function (message) {
    var box = $('tl_ajaxBox'),
      overlay = $('tl_ajaxOverlay'),
      scroll = window.getScroll();
    if (overlay === null) {
      overlay = new Element('div', {
        'id': 'tl_ajaxOverlay'
      }).inject($(document.body), 'bottom');
    }
    overlay.set({
      'styles': {
        'display': 'block',
        'top': scroll.y + 'px'
      }
    });
    if (box === null) {
      box = new Element('div', {
        'id': 'tl_ajaxBox'
      }).inject($(document.body), 'bottom');
    }
    box.set({
      'html': message,
      'styles': {
        'display': 'block',
        'top': scroll.y + 100 + 'px'
      }
    });
  },
  /**
   * Hide the "loading data" message
   */
  hideBox: function () {
    var box = $('tl_ajaxBox'),
      overlay = $('tl_ajaxOverlay');
    if (overlay) {
      overlay.setStyle('display', 'none');
    }
    if (box) {
      box.setStyle('display', 'none');
    }
  }
};

/**
 * Provide methods to handle back end tasks.
 *
 * @author Leo Feyer <https://github.com/leofeyer>
 */
window.Backend = {
  /**
   * The current ID
   * @member {(string|null)}
   */
  currentId: null,
  /**
   * The popup window
   * @member {object}
   */
  popupWindow: null,
  /**
   * The theme path
   * @member {string}
   */
  themePath: Contao.script_url + 'system/themes/' + Contao.theme + '/',
  /**
   * Open a modal window
   *
   * @param {int}    width   The width in pixels
   * @param {string} title   The window's title
   * @param {string} content The window's content
   */
  openModalWindow: function (width, title, content) {
    new SimpleModal({
      'width': width,
      'hideFooter': true,
      'draggable': false,
      'overlayOpacity': .7,
      'overlayClick': false,
      'onShow': function () {
        document.body.setStyle('overflow', 'hidden');
      },
      'onHide': function () {
        document.body.setStyle('overflow', 'auto');
      }
    }).show({
      'title': title,
      'contents': content
    });
  },
  /**
   * Open an image in a modal window
   *
   * @param {object} options An optional options object
   */
  openModalImage: function (options) {
    var opt = options || {},
      maxWidth = (window.getSize().x - 20).toInt();
    if (!opt.width || opt.width > maxWidth) opt.width = Math.min(maxWidth, 900);
    var M = new SimpleModal({
      'width': opt.width,
      'hideFooter': true,
      'draggable': false,
      'overlayOpacity': .7,
      'onShow': function () {
        document.body.setStyle('overflow', 'hidden');
      },
      'onHide': function () {
        document.body.setStyle('overflow', 'auto');
      }
    });
    M.show({
      'title': opt.title?.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/"/g, '&quot;').replace(/'/g, '&apos;'),
      'contents': '<img src="' + opt.url + '" alt="">'
    });
  },
  /**
   * Open an iframe in a modal window
   *
   * @param {object} options An optional options object
   */
  openModalIframe: function (options) {
    var opt = options || {},
      maxWidth = (window.getSize().x - 20).toInt(),
      maxHeight = (window.getSize().y - 137).toInt();
    if (!opt.width || opt.width > maxWidth) opt.width = Math.min(maxWidth, 900);
    if (!opt.height || opt.height > maxHeight) opt.height = maxHeight;
    var M = new SimpleModal({
      'width': opt.width,
      'hideFooter': true,
      'draggable': false,
      'overlayOpacity': .7,
      'overlayClick': false,
      'onShow': function () {
        document.body.setStyle('overflow', 'hidden');
      },
      'onHide': function () {
        document.body.setStyle('overflow', 'auto');
      }
    });
    M.show({
      'title': opt.title?.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/"/g, '&quot;').replace(/'/g, '&apos;'),
      'contents': '<iframe src="' + opt.url + '" width="100%" height="' + opt.height + '" frameborder="0"></iframe>',
      'model': 'modal'
    });
  },
  /**
   * Open a selector page in a modal window
   *
   * @param {object} options An optional options object
   */
  openModalSelector: function (options) {
    var opt = options || {},
      maxWidth = (window.getSize().x - 20).toInt(),
      maxHeight = (window.getSize().y - 192).toInt();
    if (!opt.id) opt.id = 'tl_select';
    if (!opt.width || opt.width > maxWidth) opt.width = Math.min(maxWidth, 900);
    if (!opt.height || opt.height > maxHeight) opt.height = maxHeight;
    var M = new SimpleModal({
      'width': opt.width,
      'draggable': false,
      'overlayOpacity': .7,
      'overlayClick': false,
      'onShow': function () {
        document.body.setStyle('overflow', 'hidden');
        document.dispatchEvent(new CustomEvent('contao--simple-modal:show'));
      },
      'onHide': function () {
        document.body.setStyle('overflow', 'auto');
        document.dispatchEvent(new CustomEvent('contao--simple-modal:hide'));
      }
    });
    M.addButton(Contao.lang.cancel, 'btn', function () {
      if (this.buttons[0].hasClass('btn-disabled')) {
        return;
      }
      this.hide();
    });
    M.addButton(Contao.lang.apply, 'btn primary', function () {
      if (this.buttons[1].hasClass('btn-disabled')) {
        return;
      }
      var frm = window.frames['simple-modal-iframe'],
        val = [],
        ul,
        inp,
        i,
        pickerValue,
        sIndex;
      if (frm === undefined) {
        alert('Could not find the SimpleModal frame');
        return;
      }
      ul = frm.document.getElementById(opt.id);
      // Load the previous values (#1816)
      if (pickerValue = ul.get('data-picker-value')) {
        val = JSON.parse(pickerValue);
      }
      inp = ul.getElementsByTagName('input');
      for (i = 0; i < inp.length; i++) {
        if (inp[i].id.match(/^(check_all_|reset_)/)) {
          continue;
        }
        // Add currently selected value, otherwise remove (#1816)
        sIndex = val.indexOf(inp[i].get('value'));
        if (inp[i].checked) {
          if (sIndex == -1) {
            val.push(inp[i].get('value'));
          }
        } else if (sIndex != -1) {
          val.splice(sIndex, 1);
        }
      }
      opt.callback(ul.get('data-table'), val);
      this.hide();
    });
    M.show({
      'title': opt.title?.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/"/g, '&quot;').replace(/'/g, '&apos;'),
      'contents': '<iframe src="' + opt.url + '" name="simple-modal-iframe" width="100%" height="' + opt.height + '" frameborder="0"></iframe>',
      'model': 'modal'
    });
  },
  /**
   * Open a TinyMCE file browser in a modal window
   *
   * @param {string} field_name The field name
   * @param {string} url        The URL
   * @param {string} type       The picker type
   * @param {object} win        The window object
   * @param {string} source     The source record
   */
  openModalBrowser: function (field_name, url, type, win, source) {
    Backend.openModalSelector({
      'id': 'tl_listing',
      'title': win.document.getElement('div.mce-title').get('text'),
      'url': Contao.routes.backend_picker + '?context=' + (type == 'file' ? 'link' : 'file') + '&amp;extras[fieldType]=radio&amp;extras[filesOnly]=true&amp;extras[source]=' + source + '&amp;value=' + url + '&amp;popup=1',
      'callback': function (table, value) {
        win.document.getElementById(field_name).value = value.join(',');
      }
    });
  },
  /**
   * Automatically submit a form
   *
   * @param {object} el The DOM element
   */
  autoSubmit: function (el) {
    window.dispatchEvent(new Event('store-scroll-offset'));
    var hidden = new Element('input', {
      'type': 'hidden',
      'name': 'SUBMIT_TYPE',
      'value': 'auto'
    });
    var form = $(el) || el;
    hidden.inject(form, 'bottom');
    form.noValidate = true;
    form.requestSubmit();
  },
  /**
   * Scroll the window to a certain vertical position
   *
   * @param {int} offset The offset to scroll to
   */
  vScrollTo: function (offset) {
    if (window.console) {
      console.warn('Backend.vScrollTo() is deprecated. Please use the Stimulus controller instead.');
    }
    window.addEvent('load', function () {
      window.scrollTo(null, parseInt(offset));
    });
  },
  /**
   * Toggle checkboxes
   *
   * @param {object} el   The DOM element
   * @param {string} [id] The ID of the target element
   */
  toggleCheckboxes: function (el, id) {
    var items = $$('input'),
      status = $(el).checked ? 'checked' : '';
    for (var i = 0; i < items.length; i++) {
      if (items[i].type.toLowerCase() != 'checkbox') {
        continue;
      }
      if (id !== undefined && id != items[i].id.substr(0, id.length)) {
        continue;
      }
      items[i].checked = status;
    }
  },
  /**
   * Toggle a checkbox group
   *
   * @param {object} el The DOM element
   * @param {string} id The ID of the target element
   */
  toggleCheckboxGroup: function (el, id) {
    var cls = $(el).className,
      status = $(el).checked ? 'checked' : '';
    if (cls == 'tl_checkbox') {
      var cbx = $(id) ? $$('#' + id + ' .tl_checkbox') : $(el).getParent('fieldset').getElements('.tl_checkbox');
      cbx.each(function (checkbox) {
        checkbox.checked = status;
      });
    } else if (cls == 'tl_tree_checkbox') {
      $$('#' + id + ' .parent .tl_tree_checkbox').each(function (checkbox) {
        checkbox.checked = status;
      });
    }
    window.dispatchEvent(new Event('store-scroll-offset'));
  },
  /**
   * Toggle checkbox elements
   *
   * @param {string} el  The DOM element
   * @param {string} cls The CSS class name
   */
  toggleCheckboxElements: function (el, cls) {
    var status = $(el).checked ? 'checked' : '';
    $$('.' + cls).each(function (checkbox) {
      if (checkbox.hasClass('tl_checkbox')) {
        checkbox.checked = status;
      }
    });
    window.dispatchEvent(new Event('store-scroll-offset'));
  },
  /**
   * Make parent view items sortable
   *
   * @param {object} ul The DOM element
   *
   * @author Joe Ray Gregory
   * @author Martin Auswger
   */
  makeParentViewSortable: function (ul) {
    console.warn('Backend.makeParentViewSortable() is deprecated. Please use the stimulus controllers instead.');
    var ds = new Scroller(document.getElement('body'), {
      onChange: function (x, y) {
        this.element.scrollTo(this.element.getScroll().x, y);
      }
    });
    var list = new Sortables(ul, {
      constrain: true,
      opacity: 0.6,
      onStart: function () {
        ds.start();
      },
      onComplete: function () {
        ds.stop();
      },
      onSort: function (el) {
        var ul = el.getParent('ul'),
          wrapLevel = 0,
          divs,
          i;
        if (!ul) return;
        divs = ul.getChildren('li > div:first-child');
        if (!divs) return;
        for (i = 0; i < divs.length; i++) {
          if (divs[i].hasClass('wrapper_stop') && wrapLevel > 0) {
            wrapLevel--;
          }
          divs[i].className = divs[i].className.replace(/(^|\s)indent[^\s]*/g, '');
          if (wrapLevel > 0) {
            divs[i].addClass('indent').addClass('indent_' + wrapLevel);
          }
          if (divs[i].hasClass('wrapper_start')) {
            wrapLevel++;
          }
          divs[i].removeClass('indent_first');
          divs[i].removeClass('indent_last');
          if (divs[i - 1] && divs[i - 1].hasClass('wrapper_start')) {
            divs[i].addClass('indent_first');
          }
          if (divs[i + 1] && divs[i + 1].hasClass('wrapper_stop')) {
            divs[i].addClass('indent_last');
          }
        }
      },
      handle: '.drag-handle'
    });
    list.active = false;
    list.addEvent('start', function () {
      list.active = true;
    });
    list.addEvent('complete', function (el) {
      if (!list.active) return;
      var id,
        pid,
        url = new URL(window.location.href);
      url.searchParams.set('rt', Contao.request_token);
      url.searchParams.set('act', 'cut');
      if (el.getPrevious('li')) {
        id = el.get('id').replace(/li_/, '');
        pid = el.getPrevious('li').get('id').replace(/li_/, '');
        url.searchParams.set('id', id);
        url.searchParams.set('pid', pid);
        url.searchParams.set('mode', 1);
        new Request.Contao({
          'url': url.toString(),
          'followRedirects': false
        }).get();
      } else if (el.getParent('ul')) {
        id = el.get('id').replace(/li_/, '');
        pid = el.getParent('ul').get('id').replace(/ul_/, '');
        url.searchParams.set('id', id);
        url.searchParams.set('pid', pid);
        url.searchParams.set('mode', 2);
        new Request.Contao({
          'url': url.toString(),
          'followRedirects': false
        }).get();
      }
    });
  },
  /**
   * Make multiSRC items sortable
   *
   * @param {string} id  The ID of the target element
   * @param {string} oid The order field
   * @param {string} val The value field
   */
  makeMultiSrcSortable: function (id, oid, val) {
    console.warn('Backend.makeMultiSrcSortable() is deprecated. Please use the stimulus controllers instead.');
    var list = new Sortables($(id), {
      constrain: true,
      opacity: 0.6
    }).addEvent('complete', function () {
      var els = [],
        lis = $(id).getChildren('[data-id]'),
        i;
      for (i = 0; i < lis.length; i++) {
        els.push(lis[i].get('data-id'));
      }
      if (oid === val) {
        $(val).value.split(',').forEach(function (j) {
          if (els.indexOf(j) === -1) {
            els.push(j);
          }
        });
      }
      $(oid).value = els.join(',');
    });
    $(id).getElements('.gimage').each(function (el) {
      if (el.hasClass('removable')) {
        new Element('button', {
          type: 'button',
          html: _modules_icon__WEBPACK_IMPORTED_MODULE_0__.getTemplate('delete', {
            'aria-hidden': true
          }).getHTML(),
          'class': 'tl_red'
        }).addEvent('click', function () {
          var li = el.getParent('li'),
            did = li.get('data-id');
          $(val).value = $(val).value.split(',').filter(function (j) {
            return j != did;
          }).join(',');
          $(oid).value = $(oid).value.split(',').filter(function (j) {
            return j != did;
          }).join(',');
          li.dispose();
        }).inject(el, 'after');
      } else {
        new Element('button', {
          type: 'button',
          html: _modules_icon__WEBPACK_IMPORTED_MODULE_0__.getTemplate('delete', {
            'aria-hidden': true
          }).getHTML(),
          disabled: true
        }).inject(el, 'after');
      }
    });
    list.fireEvent("complete"); // Initial sorting
  },
  /**
   * Enable drag and drop for the file tree
   *
   * @param {object} ul      The DOM element
   * @param {object} options An optional options object
   */
  enableFileTreeDragAndDrop: function (ul, options) {
    var ds = new Scroller(document.getElement('body'), {
      onChange: function (x, y) {
        this.element.scrollTo(this.element.getScroll().x, y);
      }
    });
    ul.addEvent('mousedown', function (event) {
      var dragHandle = event.target.hasClass('drag-handle') ? event.target : event.target.getParent('.drag-handle');
      var dragElement = event.target.getParent('.tl_file,.tl_folder');
      if (!dragHandle || !dragElement || event.rightClick) {
        return;
      }
      ds.start();
      ul.addClass('tl_listing_dragging');
      var cloneBase = dragElement.getElements('.tl_left')[0] || dragElement,
        clone = cloneBase.clone(true).inject(ul).addClass('tl_left_dragging'),
        currentHover,
        currentHoverTime,
        expandLink;
      clone.setPosition({
        x: event.page.x - cloneBase.getOffsetParent().getPosition().x - clone.getSize().x,
        y: cloneBase.getPosition(cloneBase.getOffsetParent()).y
      }).setStyle('display', 'none');
      var move = new Drag.Move(clone, {
        droppables: $$([ul]).append(ul.getElements('.tl_folder,li.parent,.tl_folder_top')),
        unDraggableTags: [],
        modifiers: {
          x: 'left',
          y: 'top'
        },
        onStart: function () {
          clone.setStyle('display', '');
        },
        onEnter: function (element, droppable) {
          droppable = fixDroppable(droppable);
          droppable.addClass('tl_folder_dropping');
          if (droppable.hasClass('tl_folder') && currentHover !== droppable) {
            currentHover = droppable;
            currentHoverTime = new Date().getTime();
            expandLink = droppable.getElement('a.foldable');
            if (expandLink && !expandLink.hasClass('foldable--open')) {
              // Expand the folder after one second hover time
              setTimeout(function () {
                if (currentHover === droppable && currentHoverTime + 900 < new Date().getTime()) {
                  var event = document.createEvent('HTMLEvents');
                  event.initEvent('click', true, true);
                  expandLink.dispatchEvent(event);
                  currentHover = undefined;
                  currentHoverTime = undefined;
                  window.addEvent('ajax_change', function onAjax() {
                    if (move && move.droppables && ul && ul.getElements) {
                      move.droppables = $$([ul]).append(ul.getElements('.tl_folder,li.parent'));
                    }
                    window.removeEvent('ajax_change', onAjax);
                  });
                }
              }, 1000);
            }
          }
        },
        onCancel: function () {
          currentHover = undefined;
          currentHoverTime = undefined;
          ds.stop();
          clone.destroy();
          window.removeEvent('keyup', onKeyup);
          ul.getElements('.tl_folder_dropping').removeClass('tl_folder_dropping');
          ul.removeClass('tl_listing_dragging');
        },
        onDrop: function (element, droppable) {
          currentHover = undefined;
          currentHoverTime = undefined;
          ds.stop();
          clone.destroy();
          window.removeEvent('keyup', onKeyup);
          ul.getElements('.tl_folder_dropping').removeClass('tl_folder_dropping');
          ul.removeClass('tl_listing_dragging');
          droppable = fixDroppable(droppable);
          if (!droppable) {
            return;
          }
          var id = dragElement.get('data-id'),
            pid = droppable.get('data-id') || decodeURIComponent(options.url.split(/[?&]pid=/)[1].split('&')[0]);

          // Ignore invalid move operations
          if (id && pid && ((pid + '/').indexOf(id + '/') === 0 || pid + '/' === id.replace(/[^/]+$/, ''))) {
            return;
          }
          window.dispatchEvent(new Event('store-scroll-offset'));
          document.location.href = options.url + '&id=' + encodeURIComponent(id) + '&pid=' + encodeURIComponent(pid);
        },
        onLeave: function (element, droppable) {
          droppable = fixDroppable(droppable);
          droppable.removeClass('tl_folder_dropping');
          currentHover = undefined;
          currentHoverTime = undefined;
        }
      });
      move.start(event);
      window.addEvent('keyup', onKeyup);
      function onKeyup(event) {
        if (event.key === 'esc' && move && move.stop) {
          move.droppables = $$([]);
          move.stop();
        }
      }
    });
    function fixDroppable(droppable) {
      if (droppable && droppable.hasClass('parent') && droppable.getPrevious('.tl_folder')) {
        return droppable.getPrevious('.tl_folder');
      }
      return droppable;
    }
  },
  /**
   * List wizard
   *
   * @param {string} id The ID of the target element
   */
  listWizard: function (id) {
    console.warn('Backend.listWizard() is deprecated. Please use the stimulus controller instead.');
    var ul = $(id),
      makeSortable = function (ul) {
        new Sortables(ul, {
          constrain: true,
          opacity: 0.6,
          handle: '.drag-handle'
        });
      },
      addEventsTo = function (li) {
        var command, clone, input, previous, next;
        li.getElements('button').each(function (bt) {
          if (bt.hasEvent('click')) return;
          command = bt.getProperty('data-command');
          switch (command) {
            case 'copy':
              bt.addEvent('click', function () {
                window.dispatchEvent(new Event('store-scroll-offset'));
                clone = li.clone(true).inject(li, 'before');
                if (input = li.getFirst('input')) {
                  clone.getFirst('input').value = input.value;
                }
                addEventsTo(clone);
                input.select();
              });
              break;
            case 'delete':
              bt.addEvent('click', function () {
                window.dispatchEvent(new Event('store-scroll-offset'));
                if (ul.getChildren().length > 1) {
                  li.destroy();
                }
              });
              break;
            case null:
              bt.addEvent('keydown', function (e) {
                if (e.event.keyCode == 38) {
                  e.preventDefault();
                  if (previous = li.getPrevious('li')) {
                    li.inject(previous, 'before');
                  } else {
                    li.inject(ul, 'bottom');
                  }
                  bt.focus();
                } else if (e.event.keyCode == 40) {
                  e.preventDefault();
                  if (next = li.getNext('li')) {
                    li.inject(next, 'after');
                  } else {
                    li.inject(ul.getFirst('li'), 'before');
                  }
                  bt.focus();
                }
              });
              break;
          }
        });
      };
    makeSortable(ul);
    ul.getChildren().each(function (li) {
      addEventsTo(li);
    });
  },
  /**
   * Table wizard
   *
   * @param {string} id The ID of the target element
   */
  tableWizard: function (id) {
    var table = $(id),
      thead = table.getElement('thead'),
      tbody = table.getElement('tbody'),
      makeSortable = function (tbody) {
        var rows = tbody.getChildren(),
          textarea,
          children,
          i,
          j;
        for (i = 0; i < rows.length; i++) {
          children = rows[i].getChildren();
          for (j = 0; j < children.length; j++) {
            if (textarea = children[j].getFirst('textarea')) {
              textarea.name = textarea.name.replace(/\[[0-9]+][[0-9]+]/g, '[' + i + '][' + j + ']');
            }
          }
        }
        new Sortables(tbody, {
          constrain: true,
          opacity: 0.6,
          handle: '.drag-handle',
          onComplete: function () {
            makeSortable(tbody);
          }
        });
      },
      addEventsTo = function (tr) {
        var head = thead.getFirst('tr'),
          command,
          textarea,
          current,
          next,
          ntr,
          children,
          index,
          i;
        tr.getElements('button').each(function (bt) {
          if (bt.hasEvent('click')) return;
          command = bt.getProperty('data-command');
          switch (command) {
            case 'rcopy':
              bt.addEvent('click', function () {
                window.dispatchEvent(new Event('store-scroll-offset'));
                ntr = new Element('tr');
                children = tr.getChildren();
                for (i = 0; i < children.length; i++) {
                  next = children[i].clone(true).inject(ntr, 'bottom');
                  if (textarea = children[i].getFirst('textarea')) {
                    next.getFirst('textarea').value = textarea.value;
                  }
                }
                ntr.inject(tr, 'after');
                addEventsTo(ntr);
                makeSortable(tbody);
                ntr.getFirst('td').getFirst('textarea').select();
              });
              break;
            case 'rdelete':
              bt.addEvent('click', function () {
                window.dispatchEvent(new Event('store-scroll-offset'));
                if (tbody.getChildren().length > 1) {
                  tr.destroy();
                }
                makeSortable(tbody);
              });
              break;
            case 'ccopy':
              bt.addEvent('click', function () {
                window.dispatchEvent(new Event('store-scroll-offset'));
                index = getIndex(bt);
                children = tbody.getChildren();
                for (i = 0; i < children.length; i++) {
                  current = children[i].getChildren()[index];
                  next = current.clone(true).inject(current, 'after');
                  if (textarea = current.getFirst('textarea')) {
                    next.getFirst('textarea').value = textarea.value;
                  }
                  addEventsTo(next);
                }
                var headFirst = head.getFirst('td');
                next = headFirst.clone(true).inject(head.getLast('td'), 'before');
                addEventsTo(next);
                makeSortable(tbody);
                children[0].getChildren()[index + 1].getFirst('textarea').select();
              });
              break;
            case 'cmovel':
              bt.addEvent('click', function () {
                window.dispatchEvent(new Event('store-scroll-offset'));
                index = getIndex(bt);
                children = tbody.getChildren();
                if (index > 0) {
                  for (i = 0; i < children.length; i++) {
                    current = children[i].getChildren()[index];
                    current.inject(current.getPrevious(), 'before');
                  }
                } else {
                  for (i = 0; i < children.length; i++) {
                    current = children[i].getChildren()[index];
                    current.inject(children[i].getLast(), 'before');
                  }
                }
                makeSortable(tbody);
              });
              break;
            case 'cmover':
              bt.addEvent('click', function () {
                window.dispatchEvent(new Event('store-scroll-offset'));
                index = getIndex(bt);
                children = tbody.getChildren();
                if (index < tr.getChildren().length - 2) {
                  for (i = 0; i < children.length; i++) {
                    current = children[i].getChildren()[index];
                    current.inject(current.getNext(), 'after');
                  }
                } else {
                  for (i = 0; i < children.length; i++) {
                    current = children[i].getChildren()[index];
                    current.inject(children[i].getFirst(), 'before');
                  }
                }
                makeSortable(tbody);
              });
              break;
            case 'cdelete':
              bt.addEvent('click', function () {
                window.dispatchEvent(new Event('store-scroll-offset'));
                index = getIndex(bt);
                children = tbody.getChildren();
                if (tr.getChildren().length > 2) {
                  for (i = 0; i < children.length; i++) {
                    children[i].getChildren()[index].destroy();
                  }
                  head.getFirst('td').destroy();
                }
                makeSortable(tbody);
              });
              break;
            case null:
              bt.addEvent('keydown', function (e) {
                if (e.event.keyCode == 38) {
                  e.preventDefault();
                  if (ntr = tr.getPrevious('tr')) {
                    tr.inject(ntr, 'before');
                  } else {
                    tr.inject(tbody, 'bottom');
                  }
                  bt.focus();
                  makeSortable(tbody);
                } else if (e.event.keyCode == 40) {
                  e.preventDefault();
                  if (ntr = tr.getNext('tr')) {
                    tr.inject(ntr, 'after');
                  } else {
                    tr.inject(tbody, 'top');
                  }
                  bt.focus();
                  makeSortable(tbody);
                }
              });
              break;
          }
        });
      },
      getIndex = function (bt) {
        var td = $(bt).getParent('td'),
          tr = td.getParent('tr'),
          cols = tr.getChildren(),
          index = 0,
          i;
        for (i = 0; i < cols.length; i++) {
          if (cols[i] == td) {
            break;
          }
          index++;
        }
        return index;
      };
    makeSortable(tbody);
    thead.getChildren().each(function (tr) {
      addEventsTo(tr);
    });
    tbody.getChildren().each(function (tr) {
      addEventsTo(tr);
    });
    Backend.tableWizardResize();
  },
  /**
   * Resize the table wizard fields on focus
   *
   * @param {float} [factor] The resize factor
   */
  tableWizardResize: function (factor) {
    var size = window.localStorage.getItem('contao_table_wizard_cell_size');
    if (factor !== undefined) {
      size = '';
      $$('.tl_tablewizard textarea').each(function (el) {
        el.setStyle('width', (el.getStyle('width').toInt() * factor).round().limit(142, 284));
        el.setStyle('height', (el.getStyle('height').toInt() * factor).round().limit(66, 132));
        if (size == '') {
          size = el.getStyle('width') + '|' + el.getStyle('height');
        }
      });
      window.localStorage.setItem('contao_table_wizard_cell_size', size);
    } else if (size !== null) {
      var chunks = size.split('|');
      $$('.tl_tablewizard textarea').each(function (el) {
        el.setStyle('width', chunks[0]);
        el.setStyle('height', chunks[1]);
      });
    }
  },
  /**
   * Set the width of the table wizard
   */
  tableWizardSetWidth: function () {
    var wrap = $('tl_tablewizard');
    if (!wrap) return;
    wrap.setStyle('width', Math.round(wrap.getParent('.tl_formbody_edit').getComputedSize().width * 0.96));
  },
  /**
   * Options wizard
   *
   * @param {string} id The ID of the target element
   */
  optionsWizard: function (id) {
    console.warn('Backend.optionsWizard() is deprecated. Please use the stimulus controller instead.');
    var table = $(id),
      tbody = table.getElement('tbody'),
      makeSortable = function (tbody) {
        var rows = tbody.getChildren(),
          children,
          i,
          j,
          input;
        for (i = 0; i < rows.length; i++) {
          children = rows[i].getChildren();
          for (j = 0; j < children.length; j++) {
            if (input = children[j].getFirst('input')) {
              input.name = input.name.replace(/\[[0-9]+]/g, '[' + i + ']');
              if (input.type == 'checkbox') {
                input.id = input.name.replace(/\[[0-9]+]/g, '').replace(/\[/g, '_').replace(/]/g, '') + '_' + i;
                input.getNext('label').set('for', input.id);
              }
            }
          }
        }
        new Sortables(tbody, {
          constrain: true,
          opacity: 0.6,
          handle: '.drag-handle',
          onComplete: function () {
            makeSortable(tbody);
          }
        });
      },
      addEventsTo = function (tr) {
        var command, input, next, ntr, children, i;
        tr.getElements('button').each(function (bt) {
          if (bt.hasEvent('click')) return;
          command = bt.getProperty('data-command');
          switch (command) {
            case 'copy':
              bt.addEvent('click', function () {
                window.dispatchEvent(new Event('store-scroll-offset'));
                ntr = new Element('tr');
                children = tr.getChildren();
                for (i = 0; i < children.length; i++) {
                  next = children[i].clone(true).inject(ntr, 'bottom');
                  if (input = children[i].getFirst('input')) {
                    next.getFirst('input').value = input.value;
                    if (input.type == 'checkbox') {
                      next.getFirst('input').checked = input.checked ? 'checked' : '';
                    }
                  }
                }
                ntr.inject(tr, 'after');
                addEventsTo(ntr);
                makeSortable(tbody);
                ntr.getFirst('td').getFirst('input').select();
              });
              break;
            case 'delete':
              bt.addEvent('click', function () {
                window.dispatchEvent(new Event('store-scroll-offset'));
                if (tbody.getChildren().length > 1) {
                  tr.destroy();
                }
                makeSortable(tbody);
              });
              break;
            case null:
              bt.addEvent('keydown', function (e) {
                if (e.event.keyCode == 38) {
                  e.preventDefault();
                  if (ntr = tr.getPrevious('tr')) {
                    tr.inject(ntr, 'before');
                  } else {
                    tr.inject(tbody, 'bottom');
                  }
                  bt.focus();
                  makeSortable(tbody);
                } else if (e.event.keyCode == 40) {
                  e.preventDefault();
                  if (ntr = tr.getNext('tr')) {
                    tr.inject(ntr, 'after');
                  } else {
                    tr.inject(tbody, 'top');
                  }
                  bt.focus();
                  makeSortable(tbody);
                }
              });
              break;
          }
        });
      };
    makeSortable(tbody);
    tbody.getChildren().each(function (tr) {
      addEventsTo(tr);
    });
  },
  /**
   * Key/value wizard
   *
   * @param {string} id The ID of the target element
   */
  keyValueWizard: function (id) {
    console.warn('Backend.keyValueWizard() is deprecated. Please use the stimulus controller instead.');
    var table = $(id),
      tbody = table.getElement('tbody'),
      makeSortable = function (tbody) {
        var rows = tbody.getChildren(),
          children,
          i,
          j,
          input;
        for (i = 0; i < rows.length; i++) {
          children = rows[i].getChildren();
          for (j = 0; j < children.length; j++) {
            if (input = children[j].getFirst('input')) {
              input.name = input.name.replace(/\[[0-9]+]/g, '[' + i + ']');
            }
          }
        }
        new Sortables(tbody, {
          constrain: true,
          opacity: 0.6,
          handle: '.drag-handle',
          onComplete: function () {
            makeSortable(tbody);
          }
        });
      },
      addEventsTo = function (tr) {
        var command, input, next, ntr, children, i;
        tr.getElements('button').each(function (bt) {
          if (bt.hasEvent('click')) return;
          command = bt.getProperty('data-command');
          switch (command) {
            case 'copy':
              bt.addEvent('click', function () {
                window.dispatchEvent(new Event('store-scroll-offset'));
                ntr = new Element('tr');
                children = tr.getChildren();
                for (i = 0; i < children.length; i++) {
                  next = children[i].clone(true).inject(ntr, 'bottom');
                  if (input = children[i].getFirst('input')) {
                    next.getFirst().value = input.value;
                  }
                }
                ntr.inject(tr, 'after');
                addEventsTo(ntr);
                makeSortable(tbody);
                ntr.getFirst('td').getFirst('input').select();
              });
              break;
            case 'delete':
              bt.addEvent('click', function () {
                window.dispatchEvent(new Event('store-scroll-offset'));
                if (tbody.getChildren().length > 1) {
                  tr.destroy();
                }
                makeSortable(tbody);
              });
              break;
            case null:
              bt.addEvent('keydown', function (e) {
                if (e.event.keyCode == 38) {
                  e.preventDefault();
                  if (ntr = tr.getPrevious('tr')) {
                    tr.inject(ntr, 'before');
                  } else {
                    tr.inject(tbody, 'bottom');
                  }
                  bt.focus();
                  makeSortable(tbody);
                } else if (e.event.keyCode == 40) {
                  e.preventDefault();
                  if (ntr = tr.getNext('tr')) {
                    tr.inject(ntr, 'after');
                  } else {
                    tr.inject(tbody, 'top');
                  }
                  bt.focus();
                  makeSortable(tbody);
                }
              });
              break;
          }
        });
      };
    makeSortable(tbody);
    tbody.getChildren().each(function (tr) {
      addEventsTo(tr);
    });
  },
  /**
   * Checkbox wizard
   *
   * @param {string} id The ID of the target element
   */
  checkboxWizard: function (id) {
    console.warn('Backend.checkboxWizard() is deprecated. Please use the Stimulus controller instead.');
    var container = $(id).getElement('.sortable'),
      makeSortable = function (container) {
        new Sortables(container, {
          constrain: true,
          opacity: 0.6,
          handle: '.drag-handle'
        });
      },
      addEventsTo = function (span) {
        var nspan;
        span.getElements('button').each(function (bt) {
          if (bt.hasEvent('click')) return;
          bt.addEvent('keydown', function (e) {
            if (e.event.keyCode == 38) {
              e.preventDefault();
              if (nspan = span.getPrevious('span')) {
                span.inject(nspan, 'before');
              } else {
                span.inject(container, 'bottom');
              }
              bt.focus();
            } else if (e.event.keyCode == 40) {
              e.preventDefault();
              if (nspan = span.getNext('span')) {
                span.inject(nspan, 'after');
              } else {
                span.inject(container, 'top');
              }
              bt.focus();
            }
          });
        });
      };
    makeSortable(container);
    container.getChildren().each(function (span) {
      addEventsTo(span);
    });
  },
  /**
   * Update the fields of the imageSize widget upon change
   */
  enableImageSizeWidgets: function () {
    $$('.tl_image_size').each(function (el) {
      var select = el.getElement('select'),
        widthInput = el.getChildren('input')[0],
        heightInput = el.getChildren('input')[1],
        update = function () {
          if (select.get('value') === '' || select.get('value').indexOf('_') === 0 || select.get('value').toInt().toString() === select.get('value')) {
            widthInput.readOnly = true;
            heightInput.readOnly = true;
            var dimensions = $(select.getSelected()[0]).get('text');
            dimensions = dimensions.split('(').length > 1 ? dimensions.split('(').getLast().split(')')[0].split('x') : ['', ''];
            widthInput.set('value', '').set('placeholder', dimensions[0] * 1 || '');
            heightInput.set('value', '').set('placeholder', dimensions[1] * 1 || '');
          } else {
            widthInput.set('placeholder', '');
            heightInput.set('placeholder', '');
            widthInput.readOnly = false;
            heightInput.readOnly = false;
          }
        };
      update();
      select.addEvent('change', update);
      select.addEvent('keyup', update);
    });
  },
  /**
   * Allow toggling checkboxes or radio buttons by clicking a row
   *
   * @author Kamil Kuzminski
   */
  enableToggleSelect: function () {
    var container = $('tl_listing'),
      shiftToggle = function (el) {
        thisIndex = checkboxes.indexOf(el);
        startIndex = checkboxes.indexOf(start);
        from = Math.min(thisIndex, startIndex);
        to = Math.max(thisIndex, startIndex);
        status = !!checkboxes[startIndex].checked;
        for (from; from <= to; from++) {
          checkboxes[from].checked = status;
        }
      },
      clickEvent = function (e) {
        if (e.target instanceof HTMLAnchorElement || e.target instanceof HTMLButtonElement || e.target instanceof HTMLInputElement || e.target?.closest('a, button, input, .operations')) {
          return;
        }
        var input = this.getElement('input[type="checkbox"],input[type="radio"]'),
          limitToggler = $(e.target).getParent('.limit_toggler');
        if (!input || input.get('disabled') || limitToggler !== null) {
          return;
        }

        // Radio buttons
        if (input.type == 'radio') {
          if (!input.checked) {
            input.checked = 'checked';
          }
          return;
        }

        // Checkboxes
        if (e.shift && start) {
          shiftToggle(input);
        } else {
          input.checked = input.checked ? '' : 'checked';
          if (input.get('onclick') == 'Backend.toggleCheckboxes(this)') {
            Backend.toggleCheckboxes(input); // see #6399
          }
        }
        start = input;
      },
      checkboxes = [],
      start,
      thisIndex,
      startIndex,
      status,
      from,
      to;
    if (container) {
      checkboxes = container.getElements('input[type="checkbox"]');
    }

    // Row click
    $$('.toggle_select').each(function (el) {
      var boundEvent = el.retrieve('boundEvent');
      if (boundEvent) {
        el.removeEvent('click', boundEvent);
      }

      // Do not propagate the form field click events
      el.getElements('label,input[type="checkbox"],input[type="radio"]').each(function (i) {
        i.addEvent('click', function (e) {
          e.stopPropagation();
        });
      });
      boundEvent = clickEvent.bind(el);
      el.addEvent('click', boundEvent);
      el.store('boundEvent', boundEvent);
    });

    // Checkbox click
    checkboxes.each(function (el) {
      el.addEvent('click', function (e) {
        if (e.shift && start) {
          shiftToggle(this);
        }
        start = this;
      });
    });
  },
  /**
   * Allow to mark the important part of an image
   *
   * @param {object} el The DOM element
   */
  editPreviewWizard: function (el) {
    el = $(el);
    var imageElement = el.getElement('img'),
      inputElements = {},
      isDrawing = false,
      partElement,
      startPos,
      getScale = function () {
        return {
          x: imageElement.getComputedSize().width,
          y: imageElement.getComputedSize().height
        };
      },
      updateImage = function () {
        var scale = getScale(),
          imageSize = imageElement.getComputedSize();
        partElement.setStyles({
          top: imageSize.computedTop + (inputElements.y.get('value') * scale.y).round() + 'px',
          left: imageSize.computedLeft + (inputElements.x.get('value') * scale.x).round() + 'px',
          width: (inputElements.width.get('value') * scale.x).round() + 'px',
          height: (inputElements.height.get('value') * scale.y).round() + 'px'
        });
        if (!inputElements.width.get('value').toFloat() || !inputElements.height.get('value').toFloat()) {
          partElement.setStyle('display', 'none');
        } else {
          partElement.setStyle('display', null);
        }
      },
      updateValues = function () {
        var scale = getScale(),
          styles = partElement.getStyles('top', 'left', 'width', 'height'),
          imageSize = imageElement.getComputedSize(),
          values = {
            x: Math.max(0, Math.min(1, (styles.left.toFloat() - imageSize.computedLeft) / scale.x)),
            y: Math.max(0, Math.min(1, (styles.top.toFloat() - imageSize.computedTop) / scale.y))
          };
        values.width = Math.min(1 - values.x, styles.width.toFloat() / scale.x);
        values.height = Math.min(1 - values.y, styles.height.toFloat() / scale.y);
        if (!values.width || !values.height) {
          values.x = values.y = values.width = values.height = '';
          partElement.setStyle('display', 'none');
        } else {
          partElement.setStyle('display', null);
        }
        Object.each(values, function (value, key) {
          inputElements[key].set('value', value === '' ? '' : Number(value).toFixed(15));
        });
      },
      start = function (event) {
        event.preventDefault();
        if (isDrawing) {
          return;
        }
        isDrawing = true;
        startPos = {
          x: event.page.x - el.getPosition().x - imageElement.getComputedSize().computedLeft,
          y: event.page.y - el.getPosition().y - imageElement.getComputedSize().computedTop
        };
        move(event);
      },
      move = function (event) {
        if (!isDrawing) {
          return;
        }
        event.preventDefault();
        var imageSize = imageElement.getComputedSize();
        var rect = {
          x: [Math.max(0, Math.min(imageSize.width, startPos.x)), Math.max(0, Math.min(imageSize.width, event.page.x - el.getPosition().x - imageSize.computedLeft))],
          y: [Math.max(0, Math.min(imageSize.height, startPos.y)), Math.max(0, Math.min(imageSize.height, event.page.y - el.getPosition().y - imageSize.computedTop))]
        };
        partElement.setStyles({
          top: Math.min(rect.y[0], rect.y[1]) + imageSize.computedTop + 'px',
          left: Math.min(rect.x[0], rect.x[1]) + imageSize.computedLeft + 'px',
          width: Math.abs(rect.x[0] - rect.x[1]) + 'px',
          height: Math.abs(rect.y[0] - rect.y[1]) + 'px'
        });
        updateValues();
      },
      stop = function (event) {
        move(event);
        isDrawing = false;
      },
      init = function () {
        el.getParent('.tl_tbox,.tl_box').getElements('input[name^="importantPart"]').each(function (input) {
          ['x', 'y', 'width', 'height'].each(function (key) {
            if (input.get('name').substr(13, key.length) === key.capitalize()) {
              inputElements[key] = input = $(input);
            }
          });
        });
        if (Object.getLength(inputElements) !== 4) {
          return;
        }
        Object.each(inputElements, function (input) {
          input.getParent().setStyle('display', 'none');
        });
        el.addClass('tl_edit_preview_enabled');
        partElement = new Element('div', {
          'class': 'tl_edit_preview_important_part'
        }).inject(el);
        updateImage();
        imageElement.addEvent('load', updateImage);
        el.addEvents({
          mousedown: start,
          touchstart: start
        });
        $(document.documentElement).addEvents({
          mousemove: move,
          touchmove: move,
          mouseup: stop,
          touchend: stop,
          touchcancel: stop,
          resize: updateImage
        });
      };
    window.addEvent('domready', init);
  },
  /**
   * Enable drag and drop file upload for the file tree
   *
   * @param {object} wrap    The DOM element
   * @param {object} options An optional options object
   */
  enableFileTreeUpload: function (wrap, options) {
    wrap = $(wrap);
    var fallbackUrl = options.url,
      dzElement = new Element('div', {
        'class': 'dropzone dropzone-filetree',
        html: '<span class="dropzone-previews"></span>'
      }).inject(wrap, 'top'),
      currentHover,
      currentHoverTime,
      expandLink;
    options.previewsContainer = dzElement.getElement('.dropzone-previews');
    options.clickable = false;
    var dz = new Dropzone(wrap, options);
    dz.on('queuecomplete', function () {
      window.location.reload();
    });
    dz.on('dragover', function (event) {
      if (!event.dataTransfer || !event.dataTransfer.types || event.dataTransfer.types.indexOf('Files') === -1) {
        return;
      }
      wrap.getElements('.tl_folder_dropping').removeClass('tl_folder_dropping');
      var target = event.target && $(event.target);
      if (target) {
        var folder = target.match('.tl_folder') ? target : target.getParent('.tl_folder');
        if (!folder) {
          folder = target.getParent('.parent');
          folder = folder && folder.getPrevious('.tl_folder');
        }
        if (folder) {
          var link = folder.getElement('img[src$="/icons/new.svg"]');
          link = link && link.getParent('a');
        }
      }
      if (link && link.href) {
        dz.options.url = '' + link.href;
        folder.addClass('tl_folder_dropping');
        if (currentHover !== folder) {
          currentHover = folder;
          currentHoverTime = new Date().getTime();
          expandLink = folder.getElement('a.foldable');
          if (expandLink && !expandLink.hasClass('foldable--open')) {
            // Expand the folder after one second hover time
            setTimeout(function () {
              if (currentHover === folder && currentHoverTime + 900 < new Date().getTime()) {
                var event = document.createEvent('HTMLEvents');
                event.initEvent('click', true, true);
                expandLink.dispatchEvent(event);
                currentHover = undefined;
                currentHoverTime = undefined;
              }
            }, 1000);
          }
        }
      } else {
        dz.options.url = fallbackUrl;
        currentHover = undefined;
        currentHoverTime = undefined;
      }
    });
    dz.on('drop', function (event) {
      if (!event.dataTransfer || !event.dataTransfer.types || event.dataTransfer.types.indexOf('Files') === -1) {
        return;
      }
      dzElement.addClass('dropzone-filetree-enabled');
      window.dispatchEvent(new Event('store-scroll-offset'));
    });
    dz.on('dragleave', function () {
      wrap.getElements('.tl_folder_dropping').removeClass('tl_folder_dropping');
      currentHover = undefined;
      currentHoverTime = undefined;
    });
  },
  /**
   * Crawl the website
   */
  crawl: function () {
    var timeout = 2000,
      crawl = $('tl_crawl'),
      progressBar = crawl.getElement('div.progress-bar'),
      progressCount = crawl.getElement('p.progress-count'),
      results = crawl.getElement('div.results'),
      debugLog = crawl.getElement('p.debug-log');
    function updateData(response) {
      var total = response.total,
        done = total - response.pending,
        percentage = total > 0 ? parseInt(done / total * 100, 10) : 100,
        result;

      // Initialize the status bar at 10%
      if (done < 1 && percentage < 1) {
        done = 1;
        percentage = 10;
        total = 10;
      }
      progressBar.setStyle('width', percentage + '%');
      progressBar.set('html', percentage + '%');
      progressBar.setAttribute('aria-valuenow', percentage);
      progressCount.set('html', done + ' / ' + total);
      if (response.hasDebugLog) {
        debugLog.setStyle('display', 'block');
      }
      if (response.hasDebugLog) {
        debugLog.setStyle('display', 'block');
      }
      if (!response.finished) {
        return;
      }
      progressBar.removeClass('running').addClass('finished');
      results.removeClass('running').addClass('finished');
      for (result in response.results) {
        if (response.results.hasOwnProperty(result)) {
          var summary = results.getElement('.result[data-subscriber="' + result + '"] p.summary'),
            warning = results.getElement('.result[data-subscriber="' + result + '"] p.warning'),
            log = results.getElement('.result[data-subscriber="' + result + '"] p.subscriber-log'),
            subscriberResults = response.results[result],
            subscriberSummary = subscriberResults.summary;
          if (subscriberResults.warning) {
            warning.set('html', subscriberResults.warning);
          }
          if (subscriberResults.hasLog) {
            log.setStyle('display', 'block');
          }
          summary.addClass(subscriberResults.wasSuccessful ? 'success' : 'failure');
          summary.set('html', subscriberSummary);
        }
      }
    }
    function execRequest(onlyStatusUpdate = false) {
      new Request({
        url: window.location.href,
        headers: {
          'Only-Status-Update': onlyStatusUpdate
        },
        onSuccess: function (responseText) {
          var response = JSON.decode(responseText);
          updateData(response);
          if (!response.finished) {
            setTimeout(execRequest, timeout);
          }
        }
      }).send();
    }
    execRequest(true);
  }
};
window.Theme = {
  /**
   * Check for WebKit
   * @member {boolean}
  	 */
  isWebkit: Browser.chrome || Browser.safari || navigator.userAgent.match(/(?:webkit|khtml)/i),
  /**
   * Stop the propagation of click events of certain elements
   */
  stopClickPropagation: function () {
    // Do not propagate the click events of the icons
    $$('.picker_selector').each(function (ul) {
      ul.getElements('a').each(function (el) {
        el.addEvent('click', function (e) {
          e.stopPropagation();
        });
      });
    });

    // Do not propagate the click events of the checkboxes
    $$('.picker_selector,.click2edit').each(function (ul) {
      ul.getElements('input[type="checkbox"]').each(function (el) {
        el.addEvent('click', function (e) {
          e.stopPropagation();
        });
      });
    });
  },
  /**
   * Set up the textarea resizing
   */
  setupTextareaResizing: function () {
    $$('.tl_textarea').each(function (el) {
      if (Browser.ie6 || Browser.ie7 || Browser.ie8) return;
      if (el.hasClass('noresize') || el.retrieve('autogrow')) return;

      // Set up the dummy element
      var dummy = new Element('div', {
        html: 'X',
        styles: {
          'position': 'absolute',
          'top': 0,
          'left': '-999em',
          'overflow-x': 'hidden'
        }
      }).setStyles(el.getStyles('font-size', 'font-family', 'width', 'line-height')).inject(document.body);

      // Also consider the box-sizing
      if (el.getStyle('-moz-box-sizing') == 'border-box' || el.getStyle('-webkit-box-sizing') == 'border-box' || el.getStyle('box-sizing') == 'border-box') {
        dummy.setStyles({
          'padding': el.getStyle('padding'),
          'border': el.getStyle('border-left')
        });
      }

      // Single line height
      var line = Math.max(dummy.clientHeight, 30);

      // Respond to the "input" event
      el.addEvent('input', function () {
        dummy.set('html', this.get('value').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\n|\r\n/g, '<br>X'));
        var height = Math.max(line, dummy.getSize().y);
        if (this.clientHeight != height) this.tween('height', height);
      }).set('tween', {
        'duration': 100
      }).setStyle('height', line + 'px');

      // Fire the event
      el.fireEvent('input');
      el.store('autogrow', true);
    });
  },
  /**
   * Set up the menu toggle
   */
  setupMenuToggle: function () {
    var burger = $('burger');
    if (!burger) return;
    burger.addEvent('click', function () {
      document.body.toggleClass('show-navigation');
      burger.setAttribute('aria-expanded', document.body.hasClass('show-navigation') ? 'true' : 'false');
    }).addEvent('keydown', function (e) {
      if (e.event.keyCode == 27) {
        document.body.removeClass('show-navigation');
      }
    });
    if (window.matchMedia) {
      var matchMedia = window.matchMedia('(max-width:991px)');
      var setAriaControls = function () {
        if (matchMedia.matches) {
          burger.setAttribute('aria-controls', 'left');
          burger.setAttribute('aria-expanded', document.body.hasClass('show-navigation') ? 'true' : 'false');
        } else {
          burger.removeAttribute('aria-controls');
          burger.removeAttribute('aria-expanded');
        }
      };
      matchMedia.addEventListener('change', setAriaControls);
      setAriaControls();
    }
  },
  /**
   * Set up the profile toggle
   */
  setupProfileToggle: function () {
    if (window.console) {
      console.warn('Theme.setupProfileToggle() is deprecated. Please use the stimulus controller instead.');
    }
    var tmenu = $('tmenu');
    if (!tmenu) return;
    var li = tmenu.getElement('.submenu'),
      button = li.getFirst('span').getFirst('button'),
      menu = li.getFirst('ul');
    if (!li || !button || !menu) return;
    button.setAttribute('aria-controls', 'tmenu__profile');
    button.setAttribute('aria-expanded', 'false');
    menu.id = 'tmenu__profile';
    button.addEvent('click', function (e) {
      if (li.hasClass('active')) {
        li.removeClass('active');
        button.setAttribute('aria-expanded', 'false');
      } else {
        li.addClass('active');
        button.setAttribute('aria-expanded', 'true');
      }
      e.stopPropagation();
    });
    $(document.body).addEvent('click', function () {
      if (li.hasClass('active')) {
        li.removeClass('active');
      }
    });
  },
  /**
   * Set up the split button toggle
   */
  setupSplitButtonToggle: function () {
    var toggle = $('sbtog');
    if (!toggle) return;
    var ul = toggle.getParent('.split-button').getElement('ul'),
      tab,
      timer;
    toggle.addEvent('click', function (e) {
      tab = false;
      ul.toggleClass('invisible');
      toggle.toggleClass('active');
      e.stopPropagation();
    });
    $(document.body).addEvent('click', function () {
      tab = false;
      ul.addClass('invisible');
      toggle.removeClass('active');
    });
    $(document.body).addEvent('keydown', function (e) {
      tab = e.event.keyCode == 9;
    });
    [toggle].append(ul.getElements('button')).each(function (el) {
      el.addEvent('focus', function () {
        if (!tab) return;
        ul.removeClass('invisible');
        toggle.addClass('active');
        clearTimeout(timer);
      });
      el.addEvent('blur', function () {
        if (!tab) return;
        timer = setTimeout(function () {
          ul.addClass('invisible');
          toggle.removeClass('active');
        }, 100);
      });
    });
    toggle.set('tabindex', '-1');
  }
};

// Initialize the back end script
window.addEvent('domready', function () {
  $(document.body).addClass('js');

  // Mark touch devices (see #5563)
  if (Browser.Features.Touch) {
    $(document.body).addClass('touch');
  }
  Backend.tableWizardSetWidth();
  Backend.enableToggleSelect();
  Theme.stopClickPropagation();
  Theme.setupTextareaResizing();
  Theme.setupMenuToggle();
  Theme.setupSplitButtonToggle();
});

// Resize the table wizard
window.addEvent('resize', function () {
  Backend.tableWizardSetWidth();
});

// Re-apply certain changes upon ajax_change
window.addEvent('ajax_change', function () {
  Backend.enableToggleSelect();
  Theme.stopClickPropagation();
  Theme.setupTextareaResizing();
});

/***/ }),

/***/ "./core-bundle/assets/scripts/limit-height.js":
/*!****************************************************!*\
  !*** ./core-bundle/assets/scripts/limit-height.js ***!
  \****************************************************/
/***/ (function() {

window.addEventListener('DOMContentLoaded', function () {
  document.querySelectorAll('div.limit_height').forEach(function (div) {
    if (window.console) {
      console.warn('Using "limit_height" class on child_record_callback is deprecated. Set a list.sorting.limitHeight in your DCA instead.');
    }
    const parent = div.parentNode.closest('.tl_content');

    // Return if the element is a wrapper
    if (parent && (parent.classList.contains('wrapper_start') || parent.classList.contains('wrapper_stop'))) return;
    const hgt = Number(div.className.replace(/[^0-9]*/, ''));

    // Return if there is no height value
    if (!hgt) return;
    const style = window.getComputedStyle(div, null);
    const padding = parseFloat(style.paddingTop) + parseFloat(style.paddingBottom);
    const height = div.clientHeight - padding;

    // Do not add the toggle if the preview height is below the max-height
    if (height <= hgt) return;

    // Resize the element if it is higher than the maximum height
    div.style.height = hgt + 'px';
    const button = document.createElement('button');
    button.setAttribute('type', 'button');
    button.title = Contao.lang.expand;
    button.innerHTML = '<span>...</span>';
    button.classList.add('unselectable');
    button.addEventListener('click', function () {
      if (div.style.height == 'auto') {
        div.style.height = hgt + 'px';
        button.title = Contao.lang.expand;
      } else {
        div.style.height = 'auto';
        button.title = Contao.lang.collapse;
      }
    });
    const toggler = document.createElement('div');
    toggler.classList.add('limit_toggler');
    toggler.append(button);
    div.append(toggler);
  });
});

/***/ }),

/***/ "./core-bundle/assets/scripts/mootao.js":
/*!**********************************************!*\
  !*** ./core-bundle/assets/scripts/mootao.js ***!
  \**********************************************/
/***/ (function() {

/*
---

name: Request.Contao

description: Extends the MooTools Request.JSON class with Contao-specific routines.

license: LGPLv3

authors:
 - Leo Feyer

requires: [Request, JSON]

provides: Request.Contao

...
*/

Request.Contao = new Class({
  Extends: Request.JSON,
  options: {
    followRedirects: true
  },
  initialize: function (options) {
    if (!options) {
      options = {};
    }
    if (!options.url && options.field && options.field.form && options.field.form.action) {
      options.url = options.field.form.action;
    }
    if (!options.url) {
      options.url = window.location.href;
    }
    this.parent(options);
  },
  success: function (text) {
    var url = this.getHeader('X-Ajax-Location'),
      json;
    if (url && this.options.followRedirects) {
      location.replace(url);
      return;
    }

    // Support both plain text and JSON responses
    try {
      json = this.response.json = JSON.decode(text, this.options.secure);
    } catch (e) {
      json = {
        'content': text
      };
    }

    // Empty response
    if (json === null) {
      json = {
        'content': ''
      };
    } else if (typeof json != 'object') {
      json = {
        'content': text
      };
    }

    // Isolate scripts and execute them
    if (json.content != '') {
      json.content = json.content.stripScripts(function (script) {
        json.javascript = script.replace(/<!--|\/\/-->|<!\[CDATA\[\/\/>|<!]]>/g, '');
      });
      if (json.javascript && this.options.evalScripts) {
        Browser.exec(json.javascript);
      }
    }
    this.onSuccess(json.content, json);
  },
  failure: function () {
    var url = this.getHeader('X-Ajax-Location');
    if (url && 401 === this.status) {
      location.replace(url);
      return;
    }
    if (url && this.options.followRedirects && this.status >= 300 && this.status < 400) {
      location.replace(url);
      return;
    }
    this.onFailure();
  }
});

/*
---

name: Drag

description: Extends the base Drag class with touch support.

license: LGPLv3

authors:
 - Andreas Schempp

requires: [Drag]

provides: Drag

...
*/

Class.refactor(Drag, {
  attach: function () {
    this.handles.addEvent('touchstart', this.bound.start);
    return this.previous.apply(this, arguments);
  },
  detach: function () {
    this.handles.removeEvent('touchstart', this.bound.start);
    return this.previous.apply(this, arguments);
  },
  start: function () {
    document.addEvents({
      touchmove: this.bound.check,
      touchend: this.bound.cancel
    });
    this.previous.apply(this, arguments);
  },
  check: function (event) {
    if (this.options.preventDefault) event.preventDefault();
    var distance = Math.round(Math.sqrt(Math.pow(event.page.x - this.mouse.start.x, 2) + Math.pow(event.page.y - this.mouse.start.y, 2)));
    if (distance > this.options.snap) {
      this.cancel();
      this.document.addEvents({
        mousemove: this.bound.drag,
        mouseup: this.bound.stop
      });
      document.addEvents({
        touchmove: this.bound.drag,
        touchend: this.bound.stop
      });
      this.fireEvent('start', [this.element, event]).fireEvent('snap', this.element);
    }
  },
  cancel: function () {
    document.removeEvents({
      touchmove: this.bound.check,
      touchend: this.bound.cancel
    });
    return this.previous.apply(this, arguments);
  },
  stop: function () {
    document.removeEvents({
      touchmove: this.bound.drag,
      touchend: this.bound.stop
    });
    return this.previous.apply(this, arguments);
  }
});

/*
---

name: Sortables

description: Extends the base Sortables class with touch support.

license: LGPLv3

authors:
 - Andreas Schempp

requires: [Sortables]

provides: Sortables

...
*/

Class.refactor(Sortables, {
  initialize: function (lists, options) {
    options.dragOptions = Object.merge(options.dragOptions || {}, {
      preventDefault: options.dragOptions && options.dragOptions.preventDefault || Browser.Features.Touch
    });
    if (options.dragOptions.unDraggableTags === undefined) {
      options.dragOptions.unDraggableTags = this.options.unDraggableTags.filter(function (tag) {
        return tag != 'button';
      });
    }
    return this.previous.apply(this, arguments);
  },
  addItems: function () {
    Array.flatten(arguments).each(function (element) {
      this.elements.push(element);
      var start = element.retrieve('sortables:start', function (event) {
        this.start.call(this, event, element);
      }.bind(this));
      (this.options.handle ? element.getElement(this.options.handle) || element : element).addEvents({
        mousedown: start,
        touchstart: start
      });
    }, this);
    return this;
  },
  removeItems: function () {
    return $$(Array.flatten(arguments).map(function (element) {
      this.elements.erase(element);
      var start = element.retrieve('sortables:start');
      (this.options.handle ? element.getElement(this.options.handle) || element : element).removeEvents({
        mousedown: start,
        touchend: start
      });
      return element;
    }, this));
  },
  getClone: function (event, element) {
    if (!this.options.clone) return new Element(element.tagName).inject(document.body);
    if (typeOf(this.options.clone) == 'function') return this.options.clone.call(this, event, element, this.list);
    var clone = this.previous.apply(this, arguments);
    clone.addEvent('touchstart', function (event) {
      element.fireEvent('touchstart', event);
    });
    return clone;
  }
});

/*
---

script: Request.Queue.js

name: Request.Queue

description: Extends the base Request.Queue class and attempts to fix some issues.

license: MIT-style license

authors:
 - Leo Feyer

requires:
	- Core/Element
	- Core/Request
	- Class.Binds

provides: [Request.Queue]

...
*/

Class.refactor(Request.Queue, {
  // Do not fire the "end" event here
  onComplete: function () {
    this.fireEvent('complete', arguments);
  },
  // Call resume() instead of runNext()
  onCancel: function () {
    if (this.options.autoAdvance && !this.error) this.resume();
    this.fireEvent('cancel', arguments);
  },
  // Call resume() instead of runNext() and fire the "end" event
  onSuccess: function () {
    if (this.options.autoAdvance && !this.error) this.resume();
    this.fireEvent('success', arguments);
    if (!this.queue.length && !this.isRunning()) this.fireEvent('end');
  },
  // Call resume() instead of runNext() and fire the "end" event
  onFailure: function () {
    this.error = true;
    if (!this.options.stopOnFailure && this.options.autoAdvance) this.resume();
    this.fireEvent('failure', arguments);
    if (!this.queue.length && !this.isRunning()) this.fireEvent('end');
  },
  // Call resume() instead of runNext()
  onException: function () {
    this.error = true;
    if (!this.options.stopOnFailure && this.options.autoAdvance) this.resume();
    this.fireEvent('exception', arguments);
  }
});

/***/ }),

/***/ "./core-bundle/assets/styles/backend.pcss":
/*!************************************************!*\
  !*** ./core-bundle/assets/styles/backend.pcss ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./core-bundle/contao/themes/flexible/icons/manifest.json":
/*!****************************************************************!*\
  !*** ./core-bundle/contao/themes/flexible/icons/manifest.json ***!
  \****************************************************************/
/***/ (function(module) {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"arrow_left--dark.svg":"/system/themes/flexible/icons/arrow_left--dark.svg","arrow_left.svg":"/system/themes/flexible/icons/arrow_left.svg","arrow_right--dark.svg":"/system/themes/flexible/icons/arrow_right--dark.svg","arrow_right.svg":"/system/themes/flexible/icons/arrow_right.svg","stop.svg":"/system/themes/flexible/icons/stop.svg","hints--dark.svg":"/system/themes/flexible/icons/hints--dark.svg","hints.svg":"/system/themes/flexible/icons/hints.svg","theme_export_--dark.svg":"/system/themes/flexible/icons/theme_export_--dark.svg","theme_export_.svg":"/system/themes/flexible/icons/theme_export_.svg","mgroup_.svg":"/system/themes/flexible/icons/mgroup_.svg","group_.svg":"/system/themes/flexible/icons/group_.svg","sizes_--dark.svg":"/system/themes/flexible/icons/sizes_--dark.svg","sizes_.svg":"/system/themes/flexible/icons/sizes_.svg","copychilds--dark.svg":"/system/themes/flexible/icons/copychilds--dark.svg","copychilds--disabled--dark.svg":"/system/themes/flexible/icons/copychilds--disabled--dark.svg","copychilds_--dark.svg":"/system/themes/flexible/icons/copychilds_--dark.svg","copychilds.svg":"/system/themes/flexible/icons/copychilds.svg","copychilds--disabled.svg":"/system/themes/flexible/icons/copychilds--disabled.svg","copychilds_.svg":"/system/themes/flexible/icons/copychilds_.svg","settings.svg":"/system/themes/flexible/icons/settings.svg","filemanager.svg":"/system/themes/flexible/icons/filemanager.svg","pickfile.svg":"/system/themes/flexible/icons/pickfile.svg","featured_--dark.svg":"/system/themes/flexible/icons/featured_--dark.svg","featured_.svg":"/system/themes/flexible/icons/featured_.svg","header_.svg":"/system/themes/flexible/icons/header_.svg","header.svg":"/system/themes/flexible/icons/header.svg","unpublished.svg":"/system/themes/flexible/icons/unpublished.svg","modules_--dark.svg":"/system/themes/flexible/icons/modules_--dark.svg","modules_.svg":"/system/themes/flexible/icons/modules_.svg","editor_--dark.svg":"/system/themes/flexible/icons/editor_--dark.svg","editor_.svg":"/system/themes/flexible/icons/editor_.svg","share_--dark.svg":"/system/themes/flexible/icons/share_--dark.svg","share_.svg":"/system/themes/flexible/icons/share_.svg","cut_--dark.svg":"/system/themes/flexible/icons/cut_--dark.svg","cut_.svg":"/system/themes/flexible/icons/cut_.svg","article_--dark.svg":"/system/themes/flexible/icons/article_--dark.svg","article_.svg":"/system/themes/flexible/icons/article_.svg","logo--dark.svg":"/system/themes/flexible/icons/logo--dark.svg","logo.svg":"/system/themes/flexible/icons/logo.svg","su_--dark.svg":"/system/themes/flexible/icons/su_--dark.svg","su_.svg":"/system/themes/flexible/icons/su_.svg","contao.svg":"/system/themes/flexible/icons/contao.svg","admin_two_factor_.svg":"/system/themes/flexible/icons/admin_two_factor_.svg","member_two_factor_.svg":"/system/themes/flexible/icons/member_two_factor_.svg","user_two_factor_.svg":"/system/themes/flexible/icons/user_two_factor_.svg","pasteafter_--dark.svg":"/system/themes/flexible/icons/pasteafter_--dark.svg","pasteafter_.svg":"/system/themes/flexible/icons/pasteafter_.svg","pasteinto_--dark.svg":"/system/themes/flexible/icons/pasteinto_--dark.svg","pasteinto_.svg":"/system/themes/flexible/icons/pasteinto_.svg","wrench.svg":"/system/themes/flexible/icons/wrench.svg","edit_--dark.svg":"/system/themes/flexible/icons/edit_--dark.svg","edit_.svg":"/system/themes/flexible/icons/edit_.svg","layout_--dark.svg":"/system/themes/flexible/icons/layout_--dark.svg","layout_.svg":"/system/themes/flexible/icons/layout_.svg","diff_--dark.svg":"/system/themes/flexible/icons/diff_--dark.svg","diff_.svg":"/system/themes/flexible/icons/diff_.svg","copy_--dark.svg":"/system/themes/flexible/icons/copy_--dark.svg","copy_.svg":"/system/themes/flexible/icons/copy_.svg","right--dark.svg":"/system/themes/flexible/icons/right--dark.svg","pickcolor--dark.svg":"/system/themes/flexible/icons/pickcolor--dark.svg","pickcolor.svg":"/system/themes/flexible/icons/pickcolor.svg","right.svg":"/system/themes/flexible/icons/right.svg","left--dark.svg":"/system/themes/flexible/icons/left--dark.svg","left.svg":"/system/themes/flexible/icons/left.svg","passkey--dark.svg":"/system/themes/flexible/icons/passkey--dark.svg","passkey.svg":"/system/themes/flexible/icons/passkey.svg","admin_.svg":"/system/themes/flexible/icons/admin_.svg","diffTemplate_--dark.svg":"/system/themes/flexible/icons/diffTemplate_--dark.svg","member_.svg":"/system/themes/flexible/icons/member_.svg","user_.svg":"/system/themes/flexible/icons/user_.svg","diffTemplate_.svg":"/system/themes/flexible/icons/diffTemplate_.svg","above--dark.svg":"/system/themes/flexible/icons/above--dark.svg","above.svg":"/system/themes/flexible/icons/above.svg","visible_--dark.svg":"/system/themes/flexible/icons/visible_--dark.svg","visible_.svg":"/system/themes/flexible/icons/visible_.svg","below--dark.svg":"/system/themes/flexible/icons/below--dark.svg","below.svg":"/system/themes/flexible/icons/below.svg","alias.svg":"/system/themes/flexible/icons/alias.svg","delete_--dark.svg":"/system/themes/flexible/icons/delete_--dark.svg","delete_.svg":"/system/themes/flexible/icons/delete_.svg","placeholder--dark.svg":"/system/themes/flexible/icons/placeholder--dark.svg","feed_2--dark.svg":"/system/themes/flexible/icons/feed_2--dark.svg","feed_2.svg":"/system/themes/flexible/icons/feed_2.svg","feed_3--dark.svg":"/system/themes/flexible/icons/feed_3--dark.svg","feed_3.svg":"/system/themes/flexible/icons/feed_3.svg","placeholder.svg":"/system/themes/flexible/icons/placeholder.svg","logout_6--dark.svg":"/system/themes/flexible/icons/logout_6--dark.svg","logout_6.svg":"/system/themes/flexible/icons/logout_6.svg","logout_7--dark.svg":"/system/themes/flexible/icons/logout_7--dark.svg","logout_7.svg":"/system/themes/flexible/icons/logout_7.svg","forward_6--dark.svg":"/system/themes/flexible/icons/forward_6--dark.svg","forward_6.svg":"/system/themes/flexible/icons/forward_6.svg","forward_7--dark.svg":"/system/themes/flexible/icons/forward_7--dark.svg","forward_7.svg":"/system/themes/flexible/icons/forward_7.svg","redirect_6--dark.svg":"/system/themes/flexible/icons/redirect_6--dark.svg","redirect_6.svg":"/system/themes/flexible/icons/redirect_6.svg","redirect_7--dark.svg":"/system/themes/flexible/icons/redirect_7--dark.svg","redirect_7.svg":"/system/themes/flexible/icons/redirect_7.svg","loading--dark.svg":"/system/themes/flexible/icons/loading--dark.svg","loading.svg":"/system/themes/flexible/icons/loading.svg","regular_6--dark.svg":"/system/themes/flexible/icons/regular_6--dark.svg","regular_6.svg":"/system/themes/flexible/icons/regular_6.svg","regular_7--dark.svg":"/system/themes/flexible/icons/regular_7--dark.svg","regular_7.svg":"/system/themes/flexible/icons/regular_7.svg","folderCP.svg":"/system/themes/flexible/icons/folderCP.svg","json--dark.svg":"/system/themes/flexible/icons/json--dark.svg","json.svg":"/system/themes/flexible/icons/json.svg","sizes.svg":"/system/themes/flexible/icons/sizes.svg","parent--disabled--dark.svg":"/system/themes/flexible/icons/parent--disabled--dark.svg","parent--disabled.svg":"/system/themes/flexible/icons/parent--disabled.svg","admin_two_factor--disabled--dark.svg":"/system/themes/flexible/icons/admin_two_factor--disabled--dark.svg","admin_two_factor--disabled.svg":"/system/themes/flexible/icons/admin_two_factor--disabled.svg","member_two_factor--disabled--dark.svg":"/system/themes/flexible/icons/member_two_factor--disabled--dark.svg","member_two_factor--disabled.svg":"/system/themes/flexible/icons/member_two_factor--disabled.svg","user_two_factor--disabled--dark.svg":"/system/themes/flexible/icons/user_two_factor--disabled--dark.svg","user_two_factor--disabled.svg":"/system/themes/flexible/icons/user_two_factor--disabled.svg","forward_4--dark.svg":"/system/themes/flexible/icons/forward_4--dark.svg","forward_4.svg":"/system/themes/flexible/icons/forward_4.svg","forward_5--dark.svg":"/system/themes/flexible/icons/forward_5--dark.svg","forward_5.svg":"/system/themes/flexible/icons/forward_5.svg","parent--dark.svg":"/system/themes/flexible/icons/parent--dark.svg","parent.svg":"/system/themes/flexible/icons/parent.svg","redirect_4--dark.svg":"/system/themes/flexible/icons/redirect_4--dark.svg","redirect_4.svg":"/system/themes/flexible/icons/redirect_4.svg","redirect_5--dark.svg":"/system/themes/flexible/icons/redirect_5--dark.svg","redirect_5.svg":"/system/themes/flexible/icons/redirect_5.svg","articles_3--dark.svg":"/system/themes/flexible/icons/articles_3--dark.svg","articles_3.svg":"/system/themes/flexible/icons/articles_3.svg","modules--disabled--dark.svg":"/system/themes/flexible/icons/modules--disabled--dark.svg","modules--disabled.svg":"/system/themes/flexible/icons/modules--disabled.svg","modules.svg":"/system/themes/flexible/icons/modules.svg","articles_2.svg":"/system/themes/flexible/icons/articles_2.svg","content.svg":"/system/themes/flexible/icons/content.svg","logout_4--dark.svg":"/system/themes/flexible/icons/logout_4--dark.svg","logout_4.svg":"/system/themes/flexible/icons/logout_4.svg","logout_5--dark.svg":"/system/themes/flexible/icons/logout_5--dark.svg","logout_5.svg":"/system/themes/flexible/icons/logout_5.svg","image--dark.svg":"/system/themes/flexible/icons/image--dark.svg","image.svg":"/system/themes/flexible/icons/image.svg","invisible--dark.svg":"/system/themes/flexible/icons/invisible--dark.svg","invisible.svg":"/system/themes/flexible/icons/invisible.svg","group--disabled--dark.svg":"/system/themes/flexible/icons/group--disabled--dark.svg","group--disabled.svg":"/system/themes/flexible/icons/group--disabled.svg","mgroup--disabled--dark.svg":"/system/themes/flexible/icons/mgroup--disabled--dark.svg","mgroup--disabled.svg":"/system/themes/flexible/icons/mgroup--disabled.svg","admin_two_factor.svg":"/system/themes/flexible/icons/admin_two_factor.svg","member_two_factor.svg":"/system/themes/flexible/icons/member_two_factor.svg","user_two_factor.svg":"/system/themes/flexible/icons/user_two_factor.svg","diffTemplate--disabled--dark.svg":"/system/themes/flexible/icons/diffTemplate--disabled--dark.svg","diffTemplate--disabled.svg":"/system/themes/flexible/icons/diffTemplate--disabled.svg","diffTemplate.svg":"/system/themes/flexible/icons/diffTemplate.svg","drag--dark.svg":"/system/themes/flexible/icons/drag--dark.svg","drag.svg":"/system/themes/flexible/icons/drag.svg","important.svg":"/system/themes/flexible/icons/important.svg","articles_2--dark.svg":"/system/themes/flexible/icons/articles_2--dark.svg","down.svg":"/system/themes/flexible/icons/down.svg","save.svg":"/system/themes/flexible/icons/save.svg","sizes--disabled--dark.svg":"/system/themes/flexible/icons/sizes--disabled--dark.svg","sizes--disabled.svg":"/system/themes/flexible/icons/sizes--disabled.svg","regular_4--dark.svg":"/system/themes/flexible/icons/regular_4--dark.svg","regular_4.svg":"/system/themes/flexible/icons/regular_4.svg","regular_5--dark.svg":"/system/themes/flexible/icons/regular_5--dark.svg","regular_5.svg":"/system/themes/flexible/icons/regular_5.svg","manager.svg":"/system/themes/flexible/icons/manager.svg","binary--dark.svg":"/system/themes/flexible/icons/binary--dark.svg","binary.svg":"/system/themes/flexible/icons/binary.svg","pasteinto--disabled--dark.svg":"/system/themes/flexible/icons/pasteinto--disabled--dark.svg","pasteinto--disabled.svg":"/system/themes/flexible/icons/pasteinto--disabled.svg","pasteinto.svg":"/system/themes/flexible/icons/pasteinto.svg","pasteafter--disabled--dark.svg":"/system/themes/flexible/icons/pasteafter--disabled--dark.svg","pasteafter--disabled.svg":"/system/themes/flexible/icons/pasteafter--disabled.svg","pasteafter.svg":"/system/themes/flexible/icons/pasteafter.svg","archive--dark.svg":"/system/themes/flexible/icons/archive--dark.svg","archive.svg":"/system/themes/flexible/icons/archive.svg","debug.svg":"/system/themes/flexible/icons/debug.svg","filemounts.svg":"/system/themes/flexible/icons/filemounts.svg","audio--dark.svg":"/system/themes/flexible/icons/audio--dark.svg","audio.svg":"/system/themes/flexible/icons/audio.svg","chart--dark.svg":"/system/themes/flexible/icons/chart--dark.svg","chart.svg":"/system/themes/flexible/icons/chart.svg","color_scheme--dark.svg":"/system/themes/flexible/icons/color_scheme--dark.svg","logout_2--dark.svg":"/system/themes/flexible/icons/logout_2--dark.svg","logout_2.svg":"/system/themes/flexible/icons/logout_2.svg","logout_3--dark.svg":"/system/themes/flexible/icons/logout_3--dark.svg","logout_3.svg":"/system/themes/flexible/icons/logout_3.svg","store.svg":"/system/themes/flexible/icons/store.svg","sync.svg":"/system/themes/flexible/icons/sync.svg","clipboard.svg":"/system/themes/flexible/icons/clipboard.svg","forward_2--dark.svg":"/system/themes/flexible/icons/forward_2--dark.svg","forward_2.svg":"/system/themes/flexible/icons/forward_2.svg","forward_3--dark.svg":"/system/themes/flexible/icons/forward_3--dark.svg","forward_3.svg":"/system/themes/flexible/icons/forward_3.svg","redirect_2--dark.svg":"/system/themes/flexible/icons/redirect_2--dark.svg","redirect_2.svg":"/system/themes/flexible/icons/redirect_2.svg","redirect_3--dark.svg":"/system/themes/flexible/icons/redirect_3--dark.svg","redirect_3.svg":"/system/themes/flexible/icons/redirect_3.svg","share--disabled--dark.svg":"/system/themes/flexible/icons/share--disabled--dark.svg","share--disabled.svg":"/system/themes/flexible/icons/share--disabled.svg","share.svg":"/system/themes/flexible/icons/share.svg","copychildren--disabled--dark.svg":"/system/themes/flexible/icons/copychildren--disabled--dark.svg","copychildren--disabled.svg":"/system/themes/flexible/icons/copychildren--disabled.svg","copychildren.svg":"/system/themes/flexible/icons/copychildren.svg","group.svg":"/system/themes/flexible/icons/group.svg","mgroup.svg":"/system/themes/flexible/icons/mgroup.svg","newfolder.svg":"/system/themes/flexible/icons/newfolder.svg","children--disabled--dark.svg":"/system/themes/flexible/icons/children--disabled--dark.svg","children--disabled.svg":"/system/themes/flexible/icons/children--disabled.svg","children.svg":"/system/themes/flexible/icons/children.svg","regular_2--dark.svg":"/system/themes/flexible/icons/regular_2--dark.svg","regular_2.svg":"/system/themes/flexible/icons/regular_2.svg","regular_3--dark.svg":"/system/themes/flexible/icons/regular_3--dark.svg","regular_3.svg":"/system/themes/flexible/icons/regular_3.svg","children_--dark.svg":"/system/themes/flexible/icons/children_--dark.svg","children_.svg":"/system/themes/flexible/icons/children_.svg","parent_--dark.svg":"/system/themes/flexible/icons/parent_--dark.svg","parent_.svg":"/system/themes/flexible/icons/parent_.svg","pickpage--dark.svg":"/system/themes/flexible/icons/pickpage--dark.svg","pickpage.svg":"/system/themes/flexible/icons/pickpage.svg","code--dark.svg":"/system/themes/flexible/icons/code--dark.svg","code.svg":"/system/themes/flexible/icons/code.svg","cut--disabled--dark.svg":"/system/themes/flexible/icons/cut--disabled--dark.svg","cut--disabled.svg":"/system/themes/flexible/icons/cut--disabled.svg","cut.svg":"/system/themes/flexible/icons/cut.svg","admin--disabled--dark.svg":"/system/themes/flexible/icons/admin--disabled--dark.svg","admin--disabled.svg":"/system/themes/flexible/icons/admin--disabled.svg","editor--dark.svg":"/system/themes/flexible/icons/editor--dark.svg","editor.svg":"/system/themes/flexible/icons/editor.svg","member--disabled--dark.svg":"/system/themes/flexible/icons/member--disabled--dark.svg","member--disabled.svg":"/system/themes/flexible/icons/member--disabled.svg","user--disabled--dark.svg":"/system/themes/flexible/icons/user--disabled--dark.svg","user--disabled.svg":"/system/themes/flexible/icons/user--disabled.svg","su--dark.svg":"/system/themes/flexible/icons/su--dark.svg","su.svg":"/system/themes/flexible/icons/su.svg","copy--disabled--dark.svg":"/system/themes/flexible/icons/copy--disabled--dark.svg","copy--disabled.svg":"/system/themes/flexible/icons/copy--disabled.svg","copy.svg":"/system/themes/flexible/icons/copy.svg","font--dark.svg":"/system/themes/flexible/icons/font--dark.svg","font.svg":"/system/themes/flexible/icons/font.svg","spreadsheet--dark.svg":"/system/themes/flexible/icons/spreadsheet--dark.svg","spreadsheet.svg":"/system/themes/flexible/icons/spreadsheet.svg","folderC.svg":"/system/themes/flexible/icons/folderC.svg","unfeatured--dark.svg":"/system/themes/flexible/icons/unfeatured--dark.svg","unfeatured.svg":"/system/themes/flexible/icons/unfeatured.svg","document--dark.svg":"/system/themes/flexible/icons/document--dark.svg","document.svg":"/system/themes/flexible/icons/document.svg","root--dark.svg":"/system/themes/flexible/icons/root--dark.svg","root.svg":"/system/themes/flexible/icons/root.svg","root_1--dark.svg":"/system/themes/flexible/icons/root_1--dark.svg","root_1.svg":"/system/themes/flexible/icons/root_1.svg","terminal--dark.svg":"/system/themes/flexible/icons/terminal--dark.svg","terminal.svg":"/system/themes/flexible/icons/terminal.svg","editor--disabled--dark.svg":"/system/themes/flexible/icons/editor--disabled--dark.svg","editor--disabled.svg":"/system/themes/flexible/icons/editor--disabled.svg","pagemounts.svg":"/system/themes/flexible/icons/pagemounts.svg","su--disabled--dark.svg":"/system/themes/flexible/icons/su--disabled--dark.svg","su--disabled.svg":"/system/themes/flexible/icons/su--disabled.svg","video--dark.svg":"/system/themes/flexible/icons/video--dark.svg","video.svg":"/system/themes/flexible/icons/video.svg","cssimport.svg":"/system/themes/flexible/icons/cssimport.svg","tablewizard.svg":"/system/themes/flexible/icons/tablewizard.svg","theme_export--disabled--dark.svg":"/system/themes/flexible/icons/theme_export--disabled--dark.svg","theme_export--disabled.svg":"/system/themes/flexible/icons/theme_export--disabled.svg","theme_export.svg":"/system/themes/flexible/icons/theme_export.svg","theme_import.svg":"/system/themes/flexible/icons/theme_import.svg","protected.svg":"/system/themes/flexible/icons/protected.svg","delete--disabled--dark.svg":"/system/themes/flexible/icons/delete--disabled--dark.svg","delete--disabled.svg":"/system/themes/flexible/icons/delete--disabled.svg","delete.svg":"/system/themes/flexible/icons/delete.svg","favorites.svg":"/system/themes/flexible/icons/favorites.svg","favorites_group.svg":"/system/themes/flexible/icons/favorites_group.svg","featured--disabled--dark.svg":"/system/themes/flexible/icons/featured--disabled--dark.svg","featured--disabled.svg":"/system/themes/flexible/icons/featured--disabled.svg","featured.svg":"/system/themes/flexible/icons/featured.svg","favorite--dark.svg":"/system/themes/flexible/icons/favorite--dark.svg","favorite.svg":"/system/themes/flexible/icons/favorite.svg","favorite_active--dark.svg":"/system/themes/flexible/icons/favorite_active--dark.svg","favorite_active.svg":"/system/themes/flexible/icons/favorite_active.svg","favorites_small--dark.svg":"/system/themes/flexible/icons/favorites_small--dark.svg","favorites_small.svg":"/system/themes/flexible/icons/favorites_small.svg","filter-reset.svg":"/system/themes/flexible/icons/filter-reset.svg","forward--dark.svg":"/system/themes/flexible/icons/forward--dark.svg","forward.svg":"/system/themes/flexible/icons/forward.svg","forward_1--dark.svg":"/system/themes/flexible/icons/forward_1--dark.svg","forward_1.svg":"/system/themes/flexible/icons/forward_1.svg","redirect--dark.svg":"/system/themes/flexible/icons/redirect--dark.svg","redirect.svg":"/system/themes/flexible/icons/redirect.svg","redirect_1--dark.svg":"/system/themes/flexible/icons/redirect_1--dark.svg","redirect_1.svg":"/system/themes/flexible/icons/redirect_1.svg","filter-apply.svg":"/system/themes/flexible/icons/filter-apply.svg","lock-locked.svg":"/system/themes/flexible/icons/lock-locked.svg","undo--disabled--dark.svg":"/system/themes/flexible/icons/undo--disabled--dark.svg","undo--disabled.svg":"/system/themes/flexible/icons/undo--disabled.svg","undo.svg":"/system/themes/flexible/icons/undo.svg","more--dark.svg":"/system/themes/flexible/icons/more--dark.svg","more.svg":"/system/themes/flexible/icons/more.svg","help.svg":"/system/themes/flexible/icons/help.svg","articles_1--dark.svg":"/system/themes/flexible/icons/articles_1--dark.svg","articles_1.svg":"/system/themes/flexible/icons/articles_1.svg","visible--dark.svg":"/system/themes/flexible/icons/visible--dark.svg","visible--disabled--dark.svg":"/system/themes/flexible/icons/visible--disabled--dark.svg","visible--disabled.svg":"/system/themes/flexible/icons/visible--disabled.svg","visible.svg":"/system/themes/flexible/icons/visible.svg","manual--dark.svg":"/system/themes/flexible/icons/manual--dark.svg","manual.svg":"/system/themes/flexible/icons/manual.svg","article--disabled--dark.svg":"/system/themes/flexible/icons/article--disabled--dark.svg","article--disabled.svg":"/system/themes/flexible/icons/article--disabled.svg","articles--dark.svg":"/system/themes/flexible/icons/articles--dark.svg","articles.svg":"/system/themes/flexible/icons/articles.svg","admin.svg":"/system/themes/flexible/icons/admin.svg","article--dark.svg":"/system/themes/flexible/icons/article--dark.svg","article.svg":"/system/themes/flexible/icons/article.svg","logout--dark.svg":"/system/themes/flexible/icons/logout--dark.svg","logout.svg":"/system/themes/flexible/icons/logout.svg","logout_1--dark.svg":"/system/themes/flexible/icons/logout_1--dark.svg","logout_1.svg":"/system/themes/flexible/icons/logout_1.svg","member.svg":"/system/themes/flexible/icons/member.svg","person.svg":"/system/themes/flexible/icons/person.svg","root_2.svg":"/system/themes/flexible/icons/root_2.svg","user.svg":"/system/themes/flexible/icons/user.svg","error_401--dark.svg":"/system/themes/flexible/icons/error_401--dark.svg","error_401.svg":"/system/themes/flexible/icons/error_401.svg","error_401_1--dark.svg":"/system/themes/flexible/icons/error_401_1--dark.svg","error_401_1.svg":"/system/themes/flexible/icons/error_401_1.svg","error_403--dark.svg":"/system/themes/flexible/icons/error_403--dark.svg","error_403.svg":"/system/themes/flexible/icons/error_403.svg","error_403_1--dark.svg":"/system/themes/flexible/icons/error_403_1--dark.svg","error_403_1.svg":"/system/themes/flexible/icons/error_403_1.svg","error_404--dark.svg":"/system/themes/flexible/icons/error_404--dark.svg","error_404.svg":"/system/themes/flexible/icons/error_404.svg","error_404_1--dark.svg":"/system/themes/flexible/icons/error_404_1--dark.svg","error_404_1.svg":"/system/themes/flexible/icons/error_404_1.svg","error_503--dark.svg":"/system/themes/flexible/icons/error_503--dark.svg","error_503.svg":"/system/themes/flexible/icons/error_503.svg","error_503_1--dark.svg":"/system/themes/flexible/icons/error_503_1--dark.svg","error_503_1.svg":"/system/themes/flexible/icons/error_503_1.svg","feed--dark.svg":"/system/themes/flexible/icons/feed--dark.svg","feed.svg":"/system/themes/flexible/icons/feed.svg","feed_1--dark.svg":"/system/themes/flexible/icons/feed_1--dark.svg","feed_1.svg":"/system/themes/flexible/icons/feed_1.svg","preview.svg":"/system/themes/flexible/icons/preview.svg","rss.svg":"/system/themes/flexible/icons/rss.svg","profile.svg":"/system/themes/flexible/icons/profile.svg","profile_small--dark.svg":"/system/themes/flexible/icons/profile_small--dark.svg","profile_small.svg":"/system/themes/flexible/icons/profile_small.svg","alert--dark.svg":"/system/themes/flexible/icons/alert--dark.svg","alert.svg":"/system/themes/flexible/icons/alert.svg","layout--disabled--dark.svg":"/system/themes/flexible/icons/layout--disabled--dark.svg","layout--disabled.svg":"/system/themes/flexible/icons/layout--disabled.svg","layout.svg":"/system/themes/flexible/icons/layout.svg","monitor.svg":"/system/themes/flexible/icons/monitor.svg","all.svg":"/system/themes/flexible/icons/all.svg","edit--disabled--dark.svg":"/system/themes/flexible/icons/edit--disabled--dark.svg","edit--disabled.svg":"/system/themes/flexible/icons/edit--disabled.svg","edit.svg":"/system/themes/flexible/icons/edit.svg","diff.svg":"/system/themes/flexible/icons/diff.svg","regular--dark.svg":"/system/themes/flexible/icons/regular--dark.svg","regular.svg":"/system/themes/flexible/icons/regular.svg","regular_1--dark.svg":"/system/themes/flexible/icons/regular_1--dark.svg","regular_1.svg":"/system/themes/flexible/icons/regular_1.svg","exit--dark.svg":"/system/themes/flexible/icons/exit--dark.svg","exit.svg":"/system/themes/flexible/icons/exit.svg","plain--dark.svg":"/system/themes/flexible/icons/plain--dark.svg","plain.svg":"/system/themes/flexible/icons/plain.svg","error--dark.svg":"/system/themes/flexible/icons/error--dark.svg","error.svg":"/system/themes/flexible/icons/error.svg","info.svg":"/system/themes/flexible/icons/info.svg","show.svg":"/system/themes/flexible/icons/show.svg","3cl--dark.svg":"/system/themes/flexible/icons/3cl--dark.svg","3cl.svg":"/system/themes/flexible/icons/3cl.svg","3rw--dark.svg":"/system/themes/flexible/icons/3rw--dark.svg","3rw.svg":"/system/themes/flexible/icons/3rw.svg","new.svg":"/system/themes/flexible/icons/new.svg","magnify.svg":"/system/themes/flexible/icons/magnify.svg","jobs--dark.svg":"/system/themes/flexible/icons/jobs--dark.svg","jobs.svg":"/system/themes/flexible/icons/jobs.svg","search--dark.svg":"/system/themes/flexible/icons/search--dark.svg","search.svg":"/system/themes/flexible/icons/search.svg","shield.svg":"/system/themes/flexible/icons/shield.svg","2clr--dark.svg":"/system/themes/flexible/icons/2clr--dark.svg","2clr.svg":"/system/themes/flexible/icons/2clr.svg","2rwf--dark.svg":"/system/themes/flexible/icons/2rwf--dark.svg","2rwf.svg":"/system/themes/flexible/icons/2rwf.svg","2cll--dark.svg":"/system/themes/flexible/icons/2cll--dark.svg","2cll.svg":"/system/themes/flexible/icons/2cll.svg","2rwh--dark.svg":"/system/themes/flexible/icons/2rwh--dark.svg","2rwh.svg":"/system/themes/flexible/icons/2rwh.svg","shield_small--dark.svg":"/system/themes/flexible/icons/shield_small--dark.svg","shield_small.svg":"/system/themes/flexible/icons/shield_small.svg","demagnify.svg":"/system/themes/flexible/icons/demagnify.svg","resend.svg":"/system/themes/flexible/icons/resend.svg","back.svg":"/system/themes/flexible/icons/back.svg","color_scheme.svg":"/system/themes/flexible/icons/color_scheme.svg","folMinus--dark.svg":"/system/themes/flexible/icons/folMinus--dark.svg","folPlus--dark.svg":"/system/themes/flexible/icons/folPlus--dark.svg","movel.svg":"/system/themes/flexible/icons/movel.svg","diff--disabled--dark.svg":"/system/themes/flexible/icons/diff--disabled--dark.svg","diff--disabled.svg":"/system/themes/flexible/icons/diff--disabled.svg","mover.svg":"/system/themes/flexible/icons/mover.svg","1cl--dark.svg":"/system/themes/flexible/icons/1cl--dark.svg","1cl.svg":"/system/themes/flexible/icons/1cl.svg","1rw--dark.svg":"/system/themes/flexible/icons/1rw--dark.svg","1rw.svg":"/system/themes/flexible/icons/1rw.svg","close--dark.svg":"/system/themes/flexible/icons/close--dark.svg","close.svg":"/system/themes/flexible/icons/close.svg","navexp.svg":"/system/themes/flexible/icons/navexp.svg","ok.svg":"/system/themes/flexible/icons/ok.svg","navcol.svg":"/system/themes/flexible/icons/navcol.svg","chevron-right--dark.svg":"/system/themes/flexible/icons/chevron-right--dark.svg","chevron-right.svg":"/system/themes/flexible/icons/chevron-right.svg","folMinus.svg":"/system/themes/flexible/icons/folMinus.svg","folPlus.svg":"/system/themes/flexible/icons/folPlus.svg","chevron-down.svg":"/system/themes/flexible/icons/chevron-down.svg","arrow-down.svg":"/system/themes/flexible/icons/arrow-down.svg"}');

/***/ }),

/***/ "./node_modules/@hotwired/stimulus-webpack-helpers/dist/stimulus-webpack-helpers.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@hotwired/stimulus-webpack-helpers/dist/stimulus-webpack-helpers.js ***!
  \******************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   definitionForModuleAndIdentifier: function() { return /* binding */ definitionForModuleAndIdentifier; },
/* harmony export */   definitionForModuleWithContextAndKey: function() { return /* binding */ definitionForModuleWithContextAndKey; },
/* harmony export */   definitionsFromContext: function() { return /* binding */ definitionsFromContext; },
/* harmony export */   identifierForContextKey: function() { return /* binding */ identifierForContextKey; }
/* harmony export */ });
/*
Stimulus Webpack Helpers 1.0.0
Copyright  2021 Basecamp, LLC
 */
function definitionsFromContext(context) {
    return context.keys()
        .map((key) => definitionForModuleWithContextAndKey(context, key))
        .filter((value) => value);
}
function definitionForModuleWithContextAndKey(context, key) {
    const identifier = identifierForContextKey(key);
    if (identifier) {
        return definitionForModuleAndIdentifier(context(key), identifier);
    }
}
function definitionForModuleAndIdentifier(module, identifier) {
    const controllerConstructor = module.default;
    if (typeof controllerConstructor == "function") {
        return { identifier, controllerConstructor };
    }
}
function identifierForContextKey(key) {
    const logicalName = (key.match(/^(?:\.\/)?(.+)(?:[_-]controller\..+?)$/) || [])[1];
    if (logicalName) {
        return logicalName.replace(/_/g, "-").replace(/\//g, "--");
    }
}




/***/ }),

/***/ "./node_modules/@hotwired/stimulus/dist/stimulus.js":
/*!**********************************************************!*\
  !*** ./node_modules/@hotwired/stimulus/dist/stimulus.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Application: function() { return /* binding */ Application; },
/* harmony export */   AttributeObserver: function() { return /* binding */ AttributeObserver; },
/* harmony export */   Context: function() { return /* binding */ Context; },
/* harmony export */   Controller: function() { return /* binding */ Controller; },
/* harmony export */   ElementObserver: function() { return /* binding */ ElementObserver; },
/* harmony export */   IndexedMultimap: function() { return /* binding */ IndexedMultimap; },
/* harmony export */   Multimap: function() { return /* binding */ Multimap; },
/* harmony export */   SelectorObserver: function() { return /* binding */ SelectorObserver; },
/* harmony export */   StringMapObserver: function() { return /* binding */ StringMapObserver; },
/* harmony export */   TokenListObserver: function() { return /* binding */ TokenListObserver; },
/* harmony export */   ValueListObserver: function() { return /* binding */ ValueListObserver; },
/* harmony export */   add: function() { return /* binding */ add; },
/* harmony export */   defaultSchema: function() { return /* binding */ defaultSchema; },
/* harmony export */   del: function() { return /* binding */ del; },
/* harmony export */   fetch: function() { return /* binding */ fetch; },
/* harmony export */   prune: function() { return /* binding */ prune; }
/* harmony export */ });
/*
Stimulus 3.2.1
Copyright  2023 Basecamp, LLC
 */
class EventListener {
    constructor(eventTarget, eventName, eventOptions) {
        this.eventTarget = eventTarget;
        this.eventName = eventName;
        this.eventOptions = eventOptions;
        this.unorderedBindings = new Set();
    }
    connect() {
        this.eventTarget.addEventListener(this.eventName, this, this.eventOptions);
    }
    disconnect() {
        this.eventTarget.removeEventListener(this.eventName, this, this.eventOptions);
    }
    bindingConnected(binding) {
        this.unorderedBindings.add(binding);
    }
    bindingDisconnected(binding) {
        this.unorderedBindings.delete(binding);
    }
    handleEvent(event) {
        const extendedEvent = extendEvent(event);
        for (const binding of this.bindings) {
            if (extendedEvent.immediatePropagationStopped) {
                break;
            }
            else {
                binding.handleEvent(extendedEvent);
            }
        }
    }
    hasBindings() {
        return this.unorderedBindings.size > 0;
    }
    get bindings() {
        return Array.from(this.unorderedBindings).sort((left, right) => {
            const leftIndex = left.index, rightIndex = right.index;
            return leftIndex < rightIndex ? -1 : leftIndex > rightIndex ? 1 : 0;
        });
    }
}
function extendEvent(event) {
    if ("immediatePropagationStopped" in event) {
        return event;
    }
    else {
        const { stopImmediatePropagation } = event;
        return Object.assign(event, {
            immediatePropagationStopped: false,
            stopImmediatePropagation() {
                this.immediatePropagationStopped = true;
                stopImmediatePropagation.call(this);
            },
        });
    }
}

class Dispatcher {
    constructor(application) {
        this.application = application;
        this.eventListenerMaps = new Map();
        this.started = false;
    }
    start() {
        if (!this.started) {
            this.started = true;
            this.eventListeners.forEach((eventListener) => eventListener.connect());
        }
    }
    stop() {
        if (this.started) {
            this.started = false;
            this.eventListeners.forEach((eventListener) => eventListener.disconnect());
        }
    }
    get eventListeners() {
        return Array.from(this.eventListenerMaps.values()).reduce((listeners, map) => listeners.concat(Array.from(map.values())), []);
    }
    bindingConnected(binding) {
        this.fetchEventListenerForBinding(binding).bindingConnected(binding);
    }
    bindingDisconnected(binding, clearEventListeners = false) {
        this.fetchEventListenerForBinding(binding).bindingDisconnected(binding);
        if (clearEventListeners)
            this.clearEventListenersForBinding(binding);
    }
    handleError(error, message, detail = {}) {
        this.application.handleError(error, `Error ${message}`, detail);
    }
    clearEventListenersForBinding(binding) {
        const eventListener = this.fetchEventListenerForBinding(binding);
        if (!eventListener.hasBindings()) {
            eventListener.disconnect();
            this.removeMappedEventListenerFor(binding);
        }
    }
    removeMappedEventListenerFor(binding) {
        const { eventTarget, eventName, eventOptions } = binding;
        const eventListenerMap = this.fetchEventListenerMapForEventTarget(eventTarget);
        const cacheKey = this.cacheKey(eventName, eventOptions);
        eventListenerMap.delete(cacheKey);
        if (eventListenerMap.size == 0)
            this.eventListenerMaps.delete(eventTarget);
    }
    fetchEventListenerForBinding(binding) {
        const { eventTarget, eventName, eventOptions } = binding;
        return this.fetchEventListener(eventTarget, eventName, eventOptions);
    }
    fetchEventListener(eventTarget, eventName, eventOptions) {
        const eventListenerMap = this.fetchEventListenerMapForEventTarget(eventTarget);
        const cacheKey = this.cacheKey(eventName, eventOptions);
        let eventListener = eventListenerMap.get(cacheKey);
        if (!eventListener) {
            eventListener = this.createEventListener(eventTarget, eventName, eventOptions);
            eventListenerMap.set(cacheKey, eventListener);
        }
        return eventListener;
    }
    createEventListener(eventTarget, eventName, eventOptions) {
        const eventListener = new EventListener(eventTarget, eventName, eventOptions);
        if (this.started) {
            eventListener.connect();
        }
        return eventListener;
    }
    fetchEventListenerMapForEventTarget(eventTarget) {
        let eventListenerMap = this.eventListenerMaps.get(eventTarget);
        if (!eventListenerMap) {
            eventListenerMap = new Map();
            this.eventListenerMaps.set(eventTarget, eventListenerMap);
        }
        return eventListenerMap;
    }
    cacheKey(eventName, eventOptions) {
        const parts = [eventName];
        Object.keys(eventOptions)
            .sort()
            .forEach((key) => {
            parts.push(`${eventOptions[key] ? "" : "!"}${key}`);
        });
        return parts.join(":");
    }
}

const defaultActionDescriptorFilters = {
    stop({ event, value }) {
        if (value)
            event.stopPropagation();
        return true;
    },
    prevent({ event, value }) {
        if (value)
            event.preventDefault();
        return true;
    },
    self({ event, value, element }) {
        if (value) {
            return element === event.target;
        }
        else {
            return true;
        }
    },
};
const descriptorPattern = /^(?:(?:([^.]+?)\+)?(.+?)(?:\.(.+?))?(?:@(window|document))?->)?(.+?)(?:#([^:]+?))(?::(.+))?$/;
function parseActionDescriptorString(descriptorString) {
    const source = descriptorString.trim();
    const matches = source.match(descriptorPattern) || [];
    let eventName = matches[2];
    let keyFilter = matches[3];
    if (keyFilter && !["keydown", "keyup", "keypress"].includes(eventName)) {
        eventName += `.${keyFilter}`;
        keyFilter = "";
    }
    return {
        eventTarget: parseEventTarget(matches[4]),
        eventName,
        eventOptions: matches[7] ? parseEventOptions(matches[7]) : {},
        identifier: matches[5],
        methodName: matches[6],
        keyFilter: matches[1] || keyFilter,
    };
}
function parseEventTarget(eventTargetName) {
    if (eventTargetName == "window") {
        return window;
    }
    else if (eventTargetName == "document") {
        return document;
    }
}
function parseEventOptions(eventOptions) {
    return eventOptions
        .split(":")
        .reduce((options, token) => Object.assign(options, { [token.replace(/^!/, "")]: !/^!/.test(token) }), {});
}
function stringifyEventTarget(eventTarget) {
    if (eventTarget == window) {
        return "window";
    }
    else if (eventTarget == document) {
        return "document";
    }
}

function camelize(value) {
    return value.replace(/(?:[_-])([a-z0-9])/g, (_, char) => char.toUpperCase());
}
function namespaceCamelize(value) {
    return camelize(value.replace(/--/g, "-").replace(/__/g, "_"));
}
function capitalize(value) {
    return value.charAt(0).toUpperCase() + value.slice(1);
}
function dasherize(value) {
    return value.replace(/([A-Z])/g, (_, char) => `-${char.toLowerCase()}`);
}
function tokenize(value) {
    return value.match(/[^\s]+/g) || [];
}

function isSomething(object) {
    return object !== null && object !== undefined;
}
function hasProperty(object, property) {
    return Object.prototype.hasOwnProperty.call(object, property);
}

const allModifiers = ["meta", "ctrl", "alt", "shift"];
class Action {
    constructor(element, index, descriptor, schema) {
        this.element = element;
        this.index = index;
        this.eventTarget = descriptor.eventTarget || element;
        this.eventName = descriptor.eventName || getDefaultEventNameForElement(element) || error("missing event name");
        this.eventOptions = descriptor.eventOptions || {};
        this.identifier = descriptor.identifier || error("missing identifier");
        this.methodName = descriptor.methodName || error("missing method name");
        this.keyFilter = descriptor.keyFilter || "";
        this.schema = schema;
    }
    static forToken(token, schema) {
        return new this(token.element, token.index, parseActionDescriptorString(token.content), schema);
    }
    toString() {
        const eventFilter = this.keyFilter ? `.${this.keyFilter}` : "";
        const eventTarget = this.eventTargetName ? `@${this.eventTargetName}` : "";
        return `${this.eventName}${eventFilter}${eventTarget}->${this.identifier}#${this.methodName}`;
    }
    shouldIgnoreKeyboardEvent(event) {
        if (!this.keyFilter) {
            return false;
        }
        const filters = this.keyFilter.split("+");
        if (this.keyFilterDissatisfied(event, filters)) {
            return true;
        }
        const standardFilter = filters.filter((key) => !allModifiers.includes(key))[0];
        if (!standardFilter) {
            return false;
        }
        if (!hasProperty(this.keyMappings, standardFilter)) {
            error(`contains unknown key filter: ${this.keyFilter}`);
        }
        return this.keyMappings[standardFilter].toLowerCase() !== event.key.toLowerCase();
    }
    shouldIgnoreMouseEvent(event) {
        if (!this.keyFilter) {
            return false;
        }
        const filters = [this.keyFilter];
        if (this.keyFilterDissatisfied(event, filters)) {
            return true;
        }
        return false;
    }
    get params() {
        const params = {};
        const pattern = new RegExp(`^data-${this.identifier}-(.+)-param$`, "i");
        for (const { name, value } of Array.from(this.element.attributes)) {
            const match = name.match(pattern);
            const key = match && match[1];
            if (key) {
                params[camelize(key)] = typecast(value);
            }
        }
        return params;
    }
    get eventTargetName() {
        return stringifyEventTarget(this.eventTarget);
    }
    get keyMappings() {
        return this.schema.keyMappings;
    }
    keyFilterDissatisfied(event, filters) {
        const [meta, ctrl, alt, shift] = allModifiers.map((modifier) => filters.includes(modifier));
        return event.metaKey !== meta || event.ctrlKey !== ctrl || event.altKey !== alt || event.shiftKey !== shift;
    }
}
const defaultEventNames = {
    a: () => "click",
    button: () => "click",
    form: () => "submit",
    details: () => "toggle",
    input: (e) => (e.getAttribute("type") == "submit" ? "click" : "input"),
    select: () => "change",
    textarea: () => "input",
};
function getDefaultEventNameForElement(element) {
    const tagName = element.tagName.toLowerCase();
    if (tagName in defaultEventNames) {
        return defaultEventNames[tagName](element);
    }
}
function error(message) {
    throw new Error(message);
}
function typecast(value) {
    try {
        return JSON.parse(value);
    }
    catch (o_O) {
        return value;
    }
}

class Binding {
    constructor(context, action) {
        this.context = context;
        this.action = action;
    }
    get index() {
        return this.action.index;
    }
    get eventTarget() {
        return this.action.eventTarget;
    }
    get eventOptions() {
        return this.action.eventOptions;
    }
    get identifier() {
        return this.context.identifier;
    }
    handleEvent(event) {
        const actionEvent = this.prepareActionEvent(event);
        if (this.willBeInvokedByEvent(event) && this.applyEventModifiers(actionEvent)) {
            this.invokeWithEvent(actionEvent);
        }
    }
    get eventName() {
        return this.action.eventName;
    }
    get method() {
        const method = this.controller[this.methodName];
        if (typeof method == "function") {
            return method;
        }
        throw new Error(`Action "${this.action}" references undefined method "${this.methodName}"`);
    }
    applyEventModifiers(event) {
        const { element } = this.action;
        const { actionDescriptorFilters } = this.context.application;
        const { controller } = this.context;
        let passes = true;
        for (const [name, value] of Object.entries(this.eventOptions)) {
            if (name in actionDescriptorFilters) {
                const filter = actionDescriptorFilters[name];
                passes = passes && filter({ name, value, event, element, controller });
            }
            else {
                continue;
            }
        }
        return passes;
    }
    prepareActionEvent(event) {
        return Object.assign(event, { params: this.action.params });
    }
    invokeWithEvent(event) {
        const { target, currentTarget } = event;
        try {
            this.method.call(this.controller, event);
            this.context.logDebugActivity(this.methodName, { event, target, currentTarget, action: this.methodName });
        }
        catch (error) {
            const { identifier, controller, element, index } = this;
            const detail = { identifier, controller, element, index, event };
            this.context.handleError(error, `invoking action "${this.action}"`, detail);
        }
    }
    willBeInvokedByEvent(event) {
        const eventTarget = event.target;
        if (event instanceof KeyboardEvent && this.action.shouldIgnoreKeyboardEvent(event)) {
            return false;
        }
        if (event instanceof MouseEvent && this.action.shouldIgnoreMouseEvent(event)) {
            return false;
        }
        if (this.element === eventTarget) {
            return true;
        }
        else if (eventTarget instanceof Element && this.element.contains(eventTarget)) {
            return this.scope.containsElement(eventTarget);
        }
        else {
            return this.scope.containsElement(this.action.element);
        }
    }
    get controller() {
        return this.context.controller;
    }
    get methodName() {
        return this.action.methodName;
    }
    get element() {
        return this.scope.element;
    }
    get scope() {
        return this.context.scope;
    }
}

class ElementObserver {
    constructor(element, delegate) {
        this.mutationObserverInit = { attributes: true, childList: true, subtree: true };
        this.element = element;
        this.started = false;
        this.delegate = delegate;
        this.elements = new Set();
        this.mutationObserver = new MutationObserver((mutations) => this.processMutations(mutations));
    }
    start() {
        if (!this.started) {
            this.started = true;
            this.mutationObserver.observe(this.element, this.mutationObserverInit);
            this.refresh();
        }
    }
    pause(callback) {
        if (this.started) {
            this.mutationObserver.disconnect();
            this.started = false;
        }
        callback();
        if (!this.started) {
            this.mutationObserver.observe(this.element, this.mutationObserverInit);
            this.started = true;
        }
    }
    stop() {
        if (this.started) {
            this.mutationObserver.takeRecords();
            this.mutationObserver.disconnect();
            this.started = false;
        }
    }
    refresh() {
        if (this.started) {
            const matches = new Set(this.matchElementsInTree());
            for (const element of Array.from(this.elements)) {
                if (!matches.has(element)) {
                    this.removeElement(element);
                }
            }
            for (const element of Array.from(matches)) {
                this.addElement(element);
            }
        }
    }
    processMutations(mutations) {
        if (this.started) {
            for (const mutation of mutations) {
                this.processMutation(mutation);
            }
        }
    }
    processMutation(mutation) {
        if (mutation.type == "attributes") {
            this.processAttributeChange(mutation.target, mutation.attributeName);
        }
        else if (mutation.type == "childList") {
            this.processRemovedNodes(mutation.removedNodes);
            this.processAddedNodes(mutation.addedNodes);
        }
    }
    processAttributeChange(element, attributeName) {
        if (this.elements.has(element)) {
            if (this.delegate.elementAttributeChanged && this.matchElement(element)) {
                this.delegate.elementAttributeChanged(element, attributeName);
            }
            else {
                this.removeElement(element);
            }
        }
        else if (this.matchElement(element)) {
            this.addElement(element);
        }
    }
    processRemovedNodes(nodes) {
        for (const node of Array.from(nodes)) {
            const element = this.elementFromNode(node);
            if (element) {
                this.processTree(element, this.removeElement);
            }
        }
    }
    processAddedNodes(nodes) {
        for (const node of Array.from(nodes)) {
            const element = this.elementFromNode(node);
            if (element && this.elementIsActive(element)) {
                this.processTree(element, this.addElement);
            }
        }
    }
    matchElement(element) {
        return this.delegate.matchElement(element);
    }
    matchElementsInTree(tree = this.element) {
        return this.delegate.matchElementsInTree(tree);
    }
    processTree(tree, processor) {
        for (const element of this.matchElementsInTree(tree)) {
            processor.call(this, element);
        }
    }
    elementFromNode(node) {
        if (node.nodeType == Node.ELEMENT_NODE) {
            return node;
        }
    }
    elementIsActive(element) {
        if (element.isConnected != this.element.isConnected) {
            return false;
        }
        else {
            return this.element.contains(element);
        }
    }
    addElement(element) {
        if (!this.elements.has(element)) {
            if (this.elementIsActive(element)) {
                this.elements.add(element);
                if (this.delegate.elementMatched) {
                    this.delegate.elementMatched(element);
                }
            }
        }
    }
    removeElement(element) {
        if (this.elements.has(element)) {
            this.elements.delete(element);
            if (this.delegate.elementUnmatched) {
                this.delegate.elementUnmatched(element);
            }
        }
    }
}

class AttributeObserver {
    constructor(element, attributeName, delegate) {
        this.attributeName = attributeName;
        this.delegate = delegate;
        this.elementObserver = new ElementObserver(element, this);
    }
    get element() {
        return this.elementObserver.element;
    }
    get selector() {
        return `[${this.attributeName}]`;
    }
    start() {
        this.elementObserver.start();
    }
    pause(callback) {
        this.elementObserver.pause(callback);
    }
    stop() {
        this.elementObserver.stop();
    }
    refresh() {
        this.elementObserver.refresh();
    }
    get started() {
        return this.elementObserver.started;
    }
    matchElement(element) {
        return element.hasAttribute(this.attributeName);
    }
    matchElementsInTree(tree) {
        const match = this.matchElement(tree) ? [tree] : [];
        const matches = Array.from(tree.querySelectorAll(this.selector));
        return match.concat(matches);
    }
    elementMatched(element) {
        if (this.delegate.elementMatchedAttribute) {
            this.delegate.elementMatchedAttribute(element, this.attributeName);
        }
    }
    elementUnmatched(element) {
        if (this.delegate.elementUnmatchedAttribute) {
            this.delegate.elementUnmatchedAttribute(element, this.attributeName);
        }
    }
    elementAttributeChanged(element, attributeName) {
        if (this.delegate.elementAttributeValueChanged && this.attributeName == attributeName) {
            this.delegate.elementAttributeValueChanged(element, attributeName);
        }
    }
}

function add(map, key, value) {
    fetch(map, key).add(value);
}
function del(map, key, value) {
    fetch(map, key).delete(value);
    prune(map, key);
}
function fetch(map, key) {
    let values = map.get(key);
    if (!values) {
        values = new Set();
        map.set(key, values);
    }
    return values;
}
function prune(map, key) {
    const values = map.get(key);
    if (values != null && values.size == 0) {
        map.delete(key);
    }
}

class Multimap {
    constructor() {
        this.valuesByKey = new Map();
    }
    get keys() {
        return Array.from(this.valuesByKey.keys());
    }
    get values() {
        const sets = Array.from(this.valuesByKey.values());
        return sets.reduce((values, set) => values.concat(Array.from(set)), []);
    }
    get size() {
        const sets = Array.from(this.valuesByKey.values());
        return sets.reduce((size, set) => size + set.size, 0);
    }
    add(key, value) {
        add(this.valuesByKey, key, value);
    }
    delete(key, value) {
        del(this.valuesByKey, key, value);
    }
    has(key, value) {
        const values = this.valuesByKey.get(key);
        return values != null && values.has(value);
    }
    hasKey(key) {
        return this.valuesByKey.has(key);
    }
    hasValue(value) {
        const sets = Array.from(this.valuesByKey.values());
        return sets.some((set) => set.has(value));
    }
    getValuesForKey(key) {
        const values = this.valuesByKey.get(key);
        return values ? Array.from(values) : [];
    }
    getKeysForValue(value) {
        return Array.from(this.valuesByKey)
            .filter(([_key, values]) => values.has(value))
            .map(([key, _values]) => key);
    }
}

class IndexedMultimap extends Multimap {
    constructor() {
        super();
        this.keysByValue = new Map();
    }
    get values() {
        return Array.from(this.keysByValue.keys());
    }
    add(key, value) {
        super.add(key, value);
        add(this.keysByValue, value, key);
    }
    delete(key, value) {
        super.delete(key, value);
        del(this.keysByValue, value, key);
    }
    hasValue(value) {
        return this.keysByValue.has(value);
    }
    getKeysForValue(value) {
        const set = this.keysByValue.get(value);
        return set ? Array.from(set) : [];
    }
}

class SelectorObserver {
    constructor(element, selector, delegate, details) {
        this._selector = selector;
        this.details = details;
        this.elementObserver = new ElementObserver(element, this);
        this.delegate = delegate;
        this.matchesByElement = new Multimap();
    }
    get started() {
        return this.elementObserver.started;
    }
    get selector() {
        return this._selector;
    }
    set selector(selector) {
        this._selector = selector;
        this.refresh();
    }
    start() {
        this.elementObserver.start();
    }
    pause(callback) {
        this.elementObserver.pause(callback);
    }
    stop() {
        this.elementObserver.stop();
    }
    refresh() {
        this.elementObserver.refresh();
    }
    get element() {
        return this.elementObserver.element;
    }
    matchElement(element) {
        const { selector } = this;
        if (selector) {
            const matches = element.matches(selector);
            if (this.delegate.selectorMatchElement) {
                return matches && this.delegate.selectorMatchElement(element, this.details);
            }
            return matches;
        }
        else {
            return false;
        }
    }
    matchElementsInTree(tree) {
        const { selector } = this;
        if (selector) {
            const match = this.matchElement(tree) ? [tree] : [];
            const matches = Array.from(tree.querySelectorAll(selector)).filter((match) => this.matchElement(match));
            return match.concat(matches);
        }
        else {
            return [];
        }
    }
    elementMatched(element) {
        const { selector } = this;
        if (selector) {
            this.selectorMatched(element, selector);
        }
    }
    elementUnmatched(element) {
        const selectors = this.matchesByElement.getKeysForValue(element);
        for (const selector of selectors) {
            this.selectorUnmatched(element, selector);
        }
    }
    elementAttributeChanged(element, _attributeName) {
        const { selector } = this;
        if (selector) {
            const matches = this.matchElement(element);
            const matchedBefore = this.matchesByElement.has(selector, element);
            if (matches && !matchedBefore) {
                this.selectorMatched(element, selector);
            }
            else if (!matches && matchedBefore) {
                this.selectorUnmatched(element, selector);
            }
        }
    }
    selectorMatched(element, selector) {
        this.delegate.selectorMatched(element, selector, this.details);
        this.matchesByElement.add(selector, element);
    }
    selectorUnmatched(element, selector) {
        this.delegate.selectorUnmatched(element, selector, this.details);
        this.matchesByElement.delete(selector, element);
    }
}

class StringMapObserver {
    constructor(element, delegate) {
        this.element = element;
        this.delegate = delegate;
        this.started = false;
        this.stringMap = new Map();
        this.mutationObserver = new MutationObserver((mutations) => this.processMutations(mutations));
    }
    start() {
        if (!this.started) {
            this.started = true;
            this.mutationObserver.observe(this.element, { attributes: true, attributeOldValue: true });
            this.refresh();
        }
    }
    stop() {
        if (this.started) {
            this.mutationObserver.takeRecords();
            this.mutationObserver.disconnect();
            this.started = false;
        }
    }
    refresh() {
        if (this.started) {
            for (const attributeName of this.knownAttributeNames) {
                this.refreshAttribute(attributeName, null);
            }
        }
    }
    processMutations(mutations) {
        if (this.started) {
            for (const mutation of mutations) {
                this.processMutation(mutation);
            }
        }
    }
    processMutation(mutation) {
        const attributeName = mutation.attributeName;
        if (attributeName) {
            this.refreshAttribute(attributeName, mutation.oldValue);
        }
    }
    refreshAttribute(attributeName, oldValue) {
        const key = this.delegate.getStringMapKeyForAttribute(attributeName);
        if (key != null) {
            if (!this.stringMap.has(attributeName)) {
                this.stringMapKeyAdded(key, attributeName);
            }
            const value = this.element.getAttribute(attributeName);
            if (this.stringMap.get(attributeName) != value) {
                this.stringMapValueChanged(value, key, oldValue);
            }
            if (value == null) {
                const oldValue = this.stringMap.get(attributeName);
                this.stringMap.delete(attributeName);
                if (oldValue)
                    this.stringMapKeyRemoved(key, attributeName, oldValue);
            }
            else {
                this.stringMap.set(attributeName, value);
            }
        }
    }
    stringMapKeyAdded(key, attributeName) {
        if (this.delegate.stringMapKeyAdded) {
            this.delegate.stringMapKeyAdded(key, attributeName);
        }
    }
    stringMapValueChanged(value, key, oldValue) {
        if (this.delegate.stringMapValueChanged) {
            this.delegate.stringMapValueChanged(value, key, oldValue);
        }
    }
    stringMapKeyRemoved(key, attributeName, oldValue) {
        if (this.delegate.stringMapKeyRemoved) {
            this.delegate.stringMapKeyRemoved(key, attributeName, oldValue);
        }
    }
    get knownAttributeNames() {
        return Array.from(new Set(this.currentAttributeNames.concat(this.recordedAttributeNames)));
    }
    get currentAttributeNames() {
        return Array.from(this.element.attributes).map((attribute) => attribute.name);
    }
    get recordedAttributeNames() {
        return Array.from(this.stringMap.keys());
    }
}

class TokenListObserver {
    constructor(element, attributeName, delegate) {
        this.attributeObserver = new AttributeObserver(element, attributeName, this);
        this.delegate = delegate;
        this.tokensByElement = new Multimap();
    }
    get started() {
        return this.attributeObserver.started;
    }
    start() {
        this.attributeObserver.start();
    }
    pause(callback) {
        this.attributeObserver.pause(callback);
    }
    stop() {
        this.attributeObserver.stop();
    }
    refresh() {
        this.attributeObserver.refresh();
    }
    get element() {
        return this.attributeObserver.element;
    }
    get attributeName() {
        return this.attributeObserver.attributeName;
    }
    elementMatchedAttribute(element) {
        this.tokensMatched(this.readTokensForElement(element));
    }
    elementAttributeValueChanged(element) {
        const [unmatchedTokens, matchedTokens] = this.refreshTokensForElement(element);
        this.tokensUnmatched(unmatchedTokens);
        this.tokensMatched(matchedTokens);
    }
    elementUnmatchedAttribute(element) {
        this.tokensUnmatched(this.tokensByElement.getValuesForKey(element));
    }
    tokensMatched(tokens) {
        tokens.forEach((token) => this.tokenMatched(token));
    }
    tokensUnmatched(tokens) {
        tokens.forEach((token) => this.tokenUnmatched(token));
    }
    tokenMatched(token) {
        this.delegate.tokenMatched(token);
        this.tokensByElement.add(token.element, token);
    }
    tokenUnmatched(token) {
        this.delegate.tokenUnmatched(token);
        this.tokensByElement.delete(token.element, token);
    }
    refreshTokensForElement(element) {
        const previousTokens = this.tokensByElement.getValuesForKey(element);
        const currentTokens = this.readTokensForElement(element);
        const firstDifferingIndex = zip(previousTokens, currentTokens).findIndex(([previousToken, currentToken]) => !tokensAreEqual(previousToken, currentToken));
        if (firstDifferingIndex == -1) {
            return [[], []];
        }
        else {
            return [previousTokens.slice(firstDifferingIndex), currentTokens.slice(firstDifferingIndex)];
        }
    }
    readTokensForElement(element) {
        const attributeName = this.attributeName;
        const tokenString = element.getAttribute(attributeName) || "";
        return parseTokenString(tokenString, element, attributeName);
    }
}
function parseTokenString(tokenString, element, attributeName) {
    return tokenString
        .trim()
        .split(/\s+/)
        .filter((content) => content.length)
        .map((content, index) => ({ element, attributeName, content, index }));
}
function zip(left, right) {
    const length = Math.max(left.length, right.length);
    return Array.from({ length }, (_, index) => [left[index], right[index]]);
}
function tokensAreEqual(left, right) {
    return left && right && left.index == right.index && left.content == right.content;
}

class ValueListObserver {
    constructor(element, attributeName, delegate) {
        this.tokenListObserver = new TokenListObserver(element, attributeName, this);
        this.delegate = delegate;
        this.parseResultsByToken = new WeakMap();
        this.valuesByTokenByElement = new WeakMap();
    }
    get started() {
        return this.tokenListObserver.started;
    }
    start() {
        this.tokenListObserver.start();
    }
    stop() {
        this.tokenListObserver.stop();
    }
    refresh() {
        this.tokenListObserver.refresh();
    }
    get element() {
        return this.tokenListObserver.element;
    }
    get attributeName() {
        return this.tokenListObserver.attributeName;
    }
    tokenMatched(token) {
        const { element } = token;
        const { value } = this.fetchParseResultForToken(token);
        if (value) {
            this.fetchValuesByTokenForElement(element).set(token, value);
            this.delegate.elementMatchedValue(element, value);
        }
    }
    tokenUnmatched(token) {
        const { element } = token;
        const { value } = this.fetchParseResultForToken(token);
        if (value) {
            this.fetchValuesByTokenForElement(element).delete(token);
            this.delegate.elementUnmatchedValue(element, value);
        }
    }
    fetchParseResultForToken(token) {
        let parseResult = this.parseResultsByToken.get(token);
        if (!parseResult) {
            parseResult = this.parseToken(token);
            this.parseResultsByToken.set(token, parseResult);
        }
        return parseResult;
    }
    fetchValuesByTokenForElement(element) {
        let valuesByToken = this.valuesByTokenByElement.get(element);
        if (!valuesByToken) {
            valuesByToken = new Map();
            this.valuesByTokenByElement.set(element, valuesByToken);
        }
        return valuesByToken;
    }
    parseToken(token) {
        try {
            const value = this.delegate.parseValueForToken(token);
            return { value };
        }
        catch (error) {
            return { error };
        }
    }
}

class BindingObserver {
    constructor(context, delegate) {
        this.context = context;
        this.delegate = delegate;
        this.bindingsByAction = new Map();
    }
    start() {
        if (!this.valueListObserver) {
            this.valueListObserver = new ValueListObserver(this.element, this.actionAttribute, this);
            this.valueListObserver.start();
        }
    }
    stop() {
        if (this.valueListObserver) {
            this.valueListObserver.stop();
            delete this.valueListObserver;
            this.disconnectAllActions();
        }
    }
    get element() {
        return this.context.element;
    }
    get identifier() {
        return this.context.identifier;
    }
    get actionAttribute() {
        return this.schema.actionAttribute;
    }
    get schema() {
        return this.context.schema;
    }
    get bindings() {
        return Array.from(this.bindingsByAction.values());
    }
    connectAction(action) {
        const binding = new Binding(this.context, action);
        this.bindingsByAction.set(action, binding);
        this.delegate.bindingConnected(binding);
    }
    disconnectAction(action) {
        const binding = this.bindingsByAction.get(action);
        if (binding) {
            this.bindingsByAction.delete(action);
            this.delegate.bindingDisconnected(binding);
        }
    }
    disconnectAllActions() {
        this.bindings.forEach((binding) => this.delegate.bindingDisconnected(binding, true));
        this.bindingsByAction.clear();
    }
    parseValueForToken(token) {
        const action = Action.forToken(token, this.schema);
        if (action.identifier == this.identifier) {
            return action;
        }
    }
    elementMatchedValue(element, action) {
        this.connectAction(action);
    }
    elementUnmatchedValue(element, action) {
        this.disconnectAction(action);
    }
}

class ValueObserver {
    constructor(context, receiver) {
        this.context = context;
        this.receiver = receiver;
        this.stringMapObserver = new StringMapObserver(this.element, this);
        this.valueDescriptorMap = this.controller.valueDescriptorMap;
    }
    start() {
        this.stringMapObserver.start();
        this.invokeChangedCallbacksForDefaultValues();
    }
    stop() {
        this.stringMapObserver.stop();
    }
    get element() {
        return this.context.element;
    }
    get controller() {
        return this.context.controller;
    }
    getStringMapKeyForAttribute(attributeName) {
        if (attributeName in this.valueDescriptorMap) {
            return this.valueDescriptorMap[attributeName].name;
        }
    }
    stringMapKeyAdded(key, attributeName) {
        const descriptor = this.valueDescriptorMap[attributeName];
        if (!this.hasValue(key)) {
            this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), descriptor.writer(descriptor.defaultValue));
        }
    }
    stringMapValueChanged(value, name, oldValue) {
        const descriptor = this.valueDescriptorNameMap[name];
        if (value === null)
            return;
        if (oldValue === null) {
            oldValue = descriptor.writer(descriptor.defaultValue);
        }
        this.invokeChangedCallback(name, value, oldValue);
    }
    stringMapKeyRemoved(key, attributeName, oldValue) {
        const descriptor = this.valueDescriptorNameMap[key];
        if (this.hasValue(key)) {
            this.invokeChangedCallback(key, descriptor.writer(this.receiver[key]), oldValue);
        }
        else {
            this.invokeChangedCallback(key, descriptor.writer(descriptor.defaultValue), oldValue);
        }
    }
    invokeChangedCallbacksForDefaultValues() {
        for (const { key, name, defaultValue, writer } of this.valueDescriptors) {
            if (defaultValue != undefined && !this.controller.data.has(key)) {
                this.invokeChangedCallback(name, writer(defaultValue), undefined);
            }
        }
    }
    invokeChangedCallback(name, rawValue, rawOldValue) {
        const changedMethodName = `${name}Changed`;
        const changedMethod = this.receiver[changedMethodName];
        if (typeof changedMethod == "function") {
            const descriptor = this.valueDescriptorNameMap[name];
            try {
                const value = descriptor.reader(rawValue);
                let oldValue = rawOldValue;
                if (rawOldValue) {
                    oldValue = descriptor.reader(rawOldValue);
                }
                changedMethod.call(this.receiver, value, oldValue);
            }
            catch (error) {
                if (error instanceof TypeError) {
                    error.message = `Stimulus Value "${this.context.identifier}.${descriptor.name}" - ${error.message}`;
                }
                throw error;
            }
        }
    }
    get valueDescriptors() {
        const { valueDescriptorMap } = this;
        return Object.keys(valueDescriptorMap).map((key) => valueDescriptorMap[key]);
    }
    get valueDescriptorNameMap() {
        const descriptors = {};
        Object.keys(this.valueDescriptorMap).forEach((key) => {
            const descriptor = this.valueDescriptorMap[key];
            descriptors[descriptor.name] = descriptor;
        });
        return descriptors;
    }
    hasValue(attributeName) {
        const descriptor = this.valueDescriptorNameMap[attributeName];
        const hasMethodName = `has${capitalize(descriptor.name)}`;
        return this.receiver[hasMethodName];
    }
}

class TargetObserver {
    constructor(context, delegate) {
        this.context = context;
        this.delegate = delegate;
        this.targetsByName = new Multimap();
    }
    start() {
        if (!this.tokenListObserver) {
            this.tokenListObserver = new TokenListObserver(this.element, this.attributeName, this);
            this.tokenListObserver.start();
        }
    }
    stop() {
        if (this.tokenListObserver) {
            this.disconnectAllTargets();
            this.tokenListObserver.stop();
            delete this.tokenListObserver;
        }
    }
    tokenMatched({ element, content: name }) {
        if (this.scope.containsElement(element)) {
            this.connectTarget(element, name);
        }
    }
    tokenUnmatched({ element, content: name }) {
        this.disconnectTarget(element, name);
    }
    connectTarget(element, name) {
        var _a;
        if (!this.targetsByName.has(name, element)) {
            this.targetsByName.add(name, element);
            (_a = this.tokenListObserver) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.targetConnected(element, name));
        }
    }
    disconnectTarget(element, name) {
        var _a;
        if (this.targetsByName.has(name, element)) {
            this.targetsByName.delete(name, element);
            (_a = this.tokenListObserver) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.targetDisconnected(element, name));
        }
    }
    disconnectAllTargets() {
        for (const name of this.targetsByName.keys) {
            for (const element of this.targetsByName.getValuesForKey(name)) {
                this.disconnectTarget(element, name);
            }
        }
    }
    get attributeName() {
        return `data-${this.context.identifier}-target`;
    }
    get element() {
        return this.context.element;
    }
    get scope() {
        return this.context.scope;
    }
}

function readInheritableStaticArrayValues(constructor, propertyName) {
    const ancestors = getAncestorsForConstructor(constructor);
    return Array.from(ancestors.reduce((values, constructor) => {
        getOwnStaticArrayValues(constructor, propertyName).forEach((name) => values.add(name));
        return values;
    }, new Set()));
}
function readInheritableStaticObjectPairs(constructor, propertyName) {
    const ancestors = getAncestorsForConstructor(constructor);
    return ancestors.reduce((pairs, constructor) => {
        pairs.push(...getOwnStaticObjectPairs(constructor, propertyName));
        return pairs;
    }, []);
}
function getAncestorsForConstructor(constructor) {
    const ancestors = [];
    while (constructor) {
        ancestors.push(constructor);
        constructor = Object.getPrototypeOf(constructor);
    }
    return ancestors.reverse();
}
function getOwnStaticArrayValues(constructor, propertyName) {
    const definition = constructor[propertyName];
    return Array.isArray(definition) ? definition : [];
}
function getOwnStaticObjectPairs(constructor, propertyName) {
    const definition = constructor[propertyName];
    return definition ? Object.keys(definition).map((key) => [key, definition[key]]) : [];
}

class OutletObserver {
    constructor(context, delegate) {
        this.started = false;
        this.context = context;
        this.delegate = delegate;
        this.outletsByName = new Multimap();
        this.outletElementsByName = new Multimap();
        this.selectorObserverMap = new Map();
        this.attributeObserverMap = new Map();
    }
    start() {
        if (!this.started) {
            this.outletDefinitions.forEach((outletName) => {
                this.setupSelectorObserverForOutlet(outletName);
                this.setupAttributeObserverForOutlet(outletName);
            });
            this.started = true;
            this.dependentContexts.forEach((context) => context.refresh());
        }
    }
    refresh() {
        this.selectorObserverMap.forEach((observer) => observer.refresh());
        this.attributeObserverMap.forEach((observer) => observer.refresh());
    }
    stop() {
        if (this.started) {
            this.started = false;
            this.disconnectAllOutlets();
            this.stopSelectorObservers();
            this.stopAttributeObservers();
        }
    }
    stopSelectorObservers() {
        if (this.selectorObserverMap.size > 0) {
            this.selectorObserverMap.forEach((observer) => observer.stop());
            this.selectorObserverMap.clear();
        }
    }
    stopAttributeObservers() {
        if (this.attributeObserverMap.size > 0) {
            this.attributeObserverMap.forEach((observer) => observer.stop());
            this.attributeObserverMap.clear();
        }
    }
    selectorMatched(element, _selector, { outletName }) {
        const outlet = this.getOutlet(element, outletName);
        if (outlet) {
            this.connectOutlet(outlet, element, outletName);
        }
    }
    selectorUnmatched(element, _selector, { outletName }) {
        const outlet = this.getOutletFromMap(element, outletName);
        if (outlet) {
            this.disconnectOutlet(outlet, element, outletName);
        }
    }
    selectorMatchElement(element, { outletName }) {
        const selector = this.selector(outletName);
        const hasOutlet = this.hasOutlet(element, outletName);
        const hasOutletController = element.matches(`[${this.schema.controllerAttribute}~=${outletName}]`);
        if (selector) {
            return hasOutlet && hasOutletController && element.matches(selector);
        }
        else {
            return false;
        }
    }
    elementMatchedAttribute(_element, attributeName) {
        const outletName = this.getOutletNameFromOutletAttributeName(attributeName);
        if (outletName) {
            this.updateSelectorObserverForOutlet(outletName);
        }
    }
    elementAttributeValueChanged(_element, attributeName) {
        const outletName = this.getOutletNameFromOutletAttributeName(attributeName);
        if (outletName) {
            this.updateSelectorObserverForOutlet(outletName);
        }
    }
    elementUnmatchedAttribute(_element, attributeName) {
        const outletName = this.getOutletNameFromOutletAttributeName(attributeName);
        if (outletName) {
            this.updateSelectorObserverForOutlet(outletName);
        }
    }
    connectOutlet(outlet, element, outletName) {
        var _a;
        if (!this.outletElementsByName.has(outletName, element)) {
            this.outletsByName.add(outletName, outlet);
            this.outletElementsByName.add(outletName, element);
            (_a = this.selectorObserverMap.get(outletName)) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.outletConnected(outlet, element, outletName));
        }
    }
    disconnectOutlet(outlet, element, outletName) {
        var _a;
        if (this.outletElementsByName.has(outletName, element)) {
            this.outletsByName.delete(outletName, outlet);
            this.outletElementsByName.delete(outletName, element);
            (_a = this.selectorObserverMap
                .get(outletName)) === null || _a === void 0 ? void 0 : _a.pause(() => this.delegate.outletDisconnected(outlet, element, outletName));
        }
    }
    disconnectAllOutlets() {
        for (const outletName of this.outletElementsByName.keys) {
            for (const element of this.outletElementsByName.getValuesForKey(outletName)) {
                for (const outlet of this.outletsByName.getValuesForKey(outletName)) {
                    this.disconnectOutlet(outlet, element, outletName);
                }
            }
        }
    }
    updateSelectorObserverForOutlet(outletName) {
        const observer = this.selectorObserverMap.get(outletName);
        if (observer) {
            observer.selector = this.selector(outletName);
        }
    }
    setupSelectorObserverForOutlet(outletName) {
        const selector = this.selector(outletName);
        const selectorObserver = new SelectorObserver(document.body, selector, this, { outletName });
        this.selectorObserverMap.set(outletName, selectorObserver);
        selectorObserver.start();
    }
    setupAttributeObserverForOutlet(outletName) {
        const attributeName = this.attributeNameForOutletName(outletName);
        const attributeObserver = new AttributeObserver(this.scope.element, attributeName, this);
        this.attributeObserverMap.set(outletName, attributeObserver);
        attributeObserver.start();
    }
    selector(outletName) {
        return this.scope.outlets.getSelectorForOutletName(outletName);
    }
    attributeNameForOutletName(outletName) {
        return this.scope.schema.outletAttributeForScope(this.identifier, outletName);
    }
    getOutletNameFromOutletAttributeName(attributeName) {
        return this.outletDefinitions.find((outletName) => this.attributeNameForOutletName(outletName) === attributeName);
    }
    get outletDependencies() {
        const dependencies = new Multimap();
        this.router.modules.forEach((module) => {
            const constructor = module.definition.controllerConstructor;
            const outlets = readInheritableStaticArrayValues(constructor, "outlets");
            outlets.forEach((outlet) => dependencies.add(outlet, module.identifier));
        });
        return dependencies;
    }
    get outletDefinitions() {
        return this.outletDependencies.getKeysForValue(this.identifier);
    }
    get dependentControllerIdentifiers() {
        return this.outletDependencies.getValuesForKey(this.identifier);
    }
    get dependentContexts() {
        const identifiers = this.dependentControllerIdentifiers;
        return this.router.contexts.filter((context) => identifiers.includes(context.identifier));
    }
    hasOutlet(element, outletName) {
        return !!this.getOutlet(element, outletName) || !!this.getOutletFromMap(element, outletName);
    }
    getOutlet(element, outletName) {
        return this.application.getControllerForElementAndIdentifier(element, outletName);
    }
    getOutletFromMap(element, outletName) {
        return this.outletsByName.getValuesForKey(outletName).find((outlet) => outlet.element === element);
    }
    get scope() {
        return this.context.scope;
    }
    get schema() {
        return this.context.schema;
    }
    get identifier() {
        return this.context.identifier;
    }
    get application() {
        return this.context.application;
    }
    get router() {
        return this.application.router;
    }
}

class Context {
    constructor(module, scope) {
        this.logDebugActivity = (functionName, detail = {}) => {
            const { identifier, controller, element } = this;
            detail = Object.assign({ identifier, controller, element }, detail);
            this.application.logDebugActivity(this.identifier, functionName, detail);
        };
        this.module = module;
        this.scope = scope;
        this.controller = new module.controllerConstructor(this);
        this.bindingObserver = new BindingObserver(this, this.dispatcher);
        this.valueObserver = new ValueObserver(this, this.controller);
        this.targetObserver = new TargetObserver(this, this);
        this.outletObserver = new OutletObserver(this, this);
        try {
            this.controller.initialize();
            this.logDebugActivity("initialize");
        }
        catch (error) {
            this.handleError(error, "initializing controller");
        }
    }
    connect() {
        this.bindingObserver.start();
        this.valueObserver.start();
        this.targetObserver.start();
        this.outletObserver.start();
        try {
            this.controller.connect();
            this.logDebugActivity("connect");
        }
        catch (error) {
            this.handleError(error, "connecting controller");
        }
    }
    refresh() {
        this.outletObserver.refresh();
    }
    disconnect() {
        try {
            this.controller.disconnect();
            this.logDebugActivity("disconnect");
        }
        catch (error) {
            this.handleError(error, "disconnecting controller");
        }
        this.outletObserver.stop();
        this.targetObserver.stop();
        this.valueObserver.stop();
        this.bindingObserver.stop();
    }
    get application() {
        return this.module.application;
    }
    get identifier() {
        return this.module.identifier;
    }
    get schema() {
        return this.application.schema;
    }
    get dispatcher() {
        return this.application.dispatcher;
    }
    get element() {
        return this.scope.element;
    }
    get parentElement() {
        return this.element.parentElement;
    }
    handleError(error, message, detail = {}) {
        const { identifier, controller, element } = this;
        detail = Object.assign({ identifier, controller, element }, detail);
        this.application.handleError(error, `Error ${message}`, detail);
    }
    targetConnected(element, name) {
        this.invokeControllerMethod(`${name}TargetConnected`, element);
    }
    targetDisconnected(element, name) {
        this.invokeControllerMethod(`${name}TargetDisconnected`, element);
    }
    outletConnected(outlet, element, name) {
        this.invokeControllerMethod(`${namespaceCamelize(name)}OutletConnected`, outlet, element);
    }
    outletDisconnected(outlet, element, name) {
        this.invokeControllerMethod(`${namespaceCamelize(name)}OutletDisconnected`, outlet, element);
    }
    invokeControllerMethod(methodName, ...args) {
        const controller = this.controller;
        if (typeof controller[methodName] == "function") {
            controller[methodName](...args);
        }
    }
}

function bless(constructor) {
    return shadow(constructor, getBlessedProperties(constructor));
}
function shadow(constructor, properties) {
    const shadowConstructor = extend(constructor);
    const shadowProperties = getShadowProperties(constructor.prototype, properties);
    Object.defineProperties(shadowConstructor.prototype, shadowProperties);
    return shadowConstructor;
}
function getBlessedProperties(constructor) {
    const blessings = readInheritableStaticArrayValues(constructor, "blessings");
    return blessings.reduce((blessedProperties, blessing) => {
        const properties = blessing(constructor);
        for (const key in properties) {
            const descriptor = blessedProperties[key] || {};
            blessedProperties[key] = Object.assign(descriptor, properties[key]);
        }
        return blessedProperties;
    }, {});
}
function getShadowProperties(prototype, properties) {
    return getOwnKeys(properties).reduce((shadowProperties, key) => {
        const descriptor = getShadowedDescriptor(prototype, properties, key);
        if (descriptor) {
            Object.assign(shadowProperties, { [key]: descriptor });
        }
        return shadowProperties;
    }, {});
}
function getShadowedDescriptor(prototype, properties, key) {
    const shadowingDescriptor = Object.getOwnPropertyDescriptor(prototype, key);
    const shadowedByValue = shadowingDescriptor && "value" in shadowingDescriptor;
    if (!shadowedByValue) {
        const descriptor = Object.getOwnPropertyDescriptor(properties, key).value;
        if (shadowingDescriptor) {
            descriptor.get = shadowingDescriptor.get || descriptor.get;
            descriptor.set = shadowingDescriptor.set || descriptor.set;
        }
        return descriptor;
    }
}
const getOwnKeys = (() => {
    if (typeof Object.getOwnPropertySymbols == "function") {
        return (object) => [...Object.getOwnPropertyNames(object), ...Object.getOwnPropertySymbols(object)];
    }
    else {
        return Object.getOwnPropertyNames;
    }
})();
const extend = (() => {
    function extendWithReflect(constructor) {
        function extended() {
            return Reflect.construct(constructor, arguments, new.target);
        }
        extended.prototype = Object.create(constructor.prototype, {
            constructor: { value: extended },
        });
        Reflect.setPrototypeOf(extended, constructor);
        return extended;
    }
    function testReflectExtension() {
        const a = function () {
            this.a.call(this);
        };
        const b = extendWithReflect(a);
        b.prototype.a = function () { };
        return new b();
    }
    try {
        testReflectExtension();
        return extendWithReflect;
    }
    catch (error) {
        return (constructor) => class extended extends constructor {
        };
    }
})();

function blessDefinition(definition) {
    return {
        identifier: definition.identifier,
        controllerConstructor: bless(definition.controllerConstructor),
    };
}

class Module {
    constructor(application, definition) {
        this.application = application;
        this.definition = blessDefinition(definition);
        this.contextsByScope = new WeakMap();
        this.connectedContexts = new Set();
    }
    get identifier() {
        return this.definition.identifier;
    }
    get controllerConstructor() {
        return this.definition.controllerConstructor;
    }
    get contexts() {
        return Array.from(this.connectedContexts);
    }
    connectContextForScope(scope) {
        const context = this.fetchContextForScope(scope);
        this.connectedContexts.add(context);
        context.connect();
    }
    disconnectContextForScope(scope) {
        const context = this.contextsByScope.get(scope);
        if (context) {
            this.connectedContexts.delete(context);
            context.disconnect();
        }
    }
    fetchContextForScope(scope) {
        let context = this.contextsByScope.get(scope);
        if (!context) {
            context = new Context(this, scope);
            this.contextsByScope.set(scope, context);
        }
        return context;
    }
}

class ClassMap {
    constructor(scope) {
        this.scope = scope;
    }
    has(name) {
        return this.data.has(this.getDataKey(name));
    }
    get(name) {
        return this.getAll(name)[0];
    }
    getAll(name) {
        const tokenString = this.data.get(this.getDataKey(name)) || "";
        return tokenize(tokenString);
    }
    getAttributeName(name) {
        return this.data.getAttributeNameForKey(this.getDataKey(name));
    }
    getDataKey(name) {
        return `${name}-class`;
    }
    get data() {
        return this.scope.data;
    }
}

class DataMap {
    constructor(scope) {
        this.scope = scope;
    }
    get element() {
        return this.scope.element;
    }
    get identifier() {
        return this.scope.identifier;
    }
    get(key) {
        const name = this.getAttributeNameForKey(key);
        return this.element.getAttribute(name);
    }
    set(key, value) {
        const name = this.getAttributeNameForKey(key);
        this.element.setAttribute(name, value);
        return this.get(key);
    }
    has(key) {
        const name = this.getAttributeNameForKey(key);
        return this.element.hasAttribute(name);
    }
    delete(key) {
        if (this.has(key)) {
            const name = this.getAttributeNameForKey(key);
            this.element.removeAttribute(name);
            return true;
        }
        else {
            return false;
        }
    }
    getAttributeNameForKey(key) {
        return `data-${this.identifier}-${dasherize(key)}`;
    }
}

class Guide {
    constructor(logger) {
        this.warnedKeysByObject = new WeakMap();
        this.logger = logger;
    }
    warn(object, key, message) {
        let warnedKeys = this.warnedKeysByObject.get(object);
        if (!warnedKeys) {
            warnedKeys = new Set();
            this.warnedKeysByObject.set(object, warnedKeys);
        }
        if (!warnedKeys.has(key)) {
            warnedKeys.add(key);
            this.logger.warn(message, object);
        }
    }
}

function attributeValueContainsToken(attributeName, token) {
    return `[${attributeName}~="${token}"]`;
}

class TargetSet {
    constructor(scope) {
        this.scope = scope;
    }
    get element() {
        return this.scope.element;
    }
    get identifier() {
        return this.scope.identifier;
    }
    get schema() {
        return this.scope.schema;
    }
    has(targetName) {
        return this.find(targetName) != null;
    }
    find(...targetNames) {
        return targetNames.reduce((target, targetName) => target || this.findTarget(targetName) || this.findLegacyTarget(targetName), undefined);
    }
    findAll(...targetNames) {
        return targetNames.reduce((targets, targetName) => [
            ...targets,
            ...this.findAllTargets(targetName),
            ...this.findAllLegacyTargets(targetName),
        ], []);
    }
    findTarget(targetName) {
        const selector = this.getSelectorForTargetName(targetName);
        return this.scope.findElement(selector);
    }
    findAllTargets(targetName) {
        const selector = this.getSelectorForTargetName(targetName);
        return this.scope.findAllElements(selector);
    }
    getSelectorForTargetName(targetName) {
        const attributeName = this.schema.targetAttributeForScope(this.identifier);
        return attributeValueContainsToken(attributeName, targetName);
    }
    findLegacyTarget(targetName) {
        const selector = this.getLegacySelectorForTargetName(targetName);
        return this.deprecate(this.scope.findElement(selector), targetName);
    }
    findAllLegacyTargets(targetName) {
        const selector = this.getLegacySelectorForTargetName(targetName);
        return this.scope.findAllElements(selector).map((element) => this.deprecate(element, targetName));
    }
    getLegacySelectorForTargetName(targetName) {
        const targetDescriptor = `${this.identifier}.${targetName}`;
        return attributeValueContainsToken(this.schema.targetAttribute, targetDescriptor);
    }
    deprecate(element, targetName) {
        if (element) {
            const { identifier } = this;
            const attributeName = this.schema.targetAttribute;
            const revisedAttributeName = this.schema.targetAttributeForScope(identifier);
            this.guide.warn(element, `target:${targetName}`, `Please replace ${attributeName}="${identifier}.${targetName}" with ${revisedAttributeName}="${targetName}". ` +
                `The ${attributeName} attribute is deprecated and will be removed in a future version of Stimulus.`);
        }
        return element;
    }
    get guide() {
        return this.scope.guide;
    }
}

class OutletSet {
    constructor(scope, controllerElement) {
        this.scope = scope;
        this.controllerElement = controllerElement;
    }
    get element() {
        return this.scope.element;
    }
    get identifier() {
        return this.scope.identifier;
    }
    get schema() {
        return this.scope.schema;
    }
    has(outletName) {
        return this.find(outletName) != null;
    }
    find(...outletNames) {
        return outletNames.reduce((outlet, outletName) => outlet || this.findOutlet(outletName), undefined);
    }
    findAll(...outletNames) {
        return outletNames.reduce((outlets, outletName) => [...outlets, ...this.findAllOutlets(outletName)], []);
    }
    getSelectorForOutletName(outletName) {
        const attributeName = this.schema.outletAttributeForScope(this.identifier, outletName);
        return this.controllerElement.getAttribute(attributeName);
    }
    findOutlet(outletName) {
        const selector = this.getSelectorForOutletName(outletName);
        if (selector)
            return this.findElement(selector, outletName);
    }
    findAllOutlets(outletName) {
        const selector = this.getSelectorForOutletName(outletName);
        return selector ? this.findAllElements(selector, outletName) : [];
    }
    findElement(selector, outletName) {
        const elements = this.scope.queryElements(selector);
        return elements.filter((element) => this.matchesElement(element, selector, outletName))[0];
    }
    findAllElements(selector, outletName) {
        const elements = this.scope.queryElements(selector);
        return elements.filter((element) => this.matchesElement(element, selector, outletName));
    }
    matchesElement(element, selector, outletName) {
        const controllerAttribute = element.getAttribute(this.scope.schema.controllerAttribute) || "";
        return element.matches(selector) && controllerAttribute.split(" ").includes(outletName);
    }
}

class Scope {
    constructor(schema, element, identifier, logger) {
        this.targets = new TargetSet(this);
        this.classes = new ClassMap(this);
        this.data = new DataMap(this);
        this.containsElement = (element) => {
            return element.closest(this.controllerSelector) === this.element;
        };
        this.schema = schema;
        this.element = element;
        this.identifier = identifier;
        this.guide = new Guide(logger);
        this.outlets = new OutletSet(this.documentScope, element);
    }
    findElement(selector) {
        return this.element.matches(selector) ? this.element : this.queryElements(selector).find(this.containsElement);
    }
    findAllElements(selector) {
        return [
            ...(this.element.matches(selector) ? [this.element] : []),
            ...this.queryElements(selector).filter(this.containsElement),
        ];
    }
    queryElements(selector) {
        return Array.from(this.element.querySelectorAll(selector));
    }
    get controllerSelector() {
        return attributeValueContainsToken(this.schema.controllerAttribute, this.identifier);
    }
    get isDocumentScope() {
        return this.element === document.documentElement;
    }
    get documentScope() {
        return this.isDocumentScope
            ? this
            : new Scope(this.schema, document.documentElement, this.identifier, this.guide.logger);
    }
}

class ScopeObserver {
    constructor(element, schema, delegate) {
        this.element = element;
        this.schema = schema;
        this.delegate = delegate;
        this.valueListObserver = new ValueListObserver(this.element, this.controllerAttribute, this);
        this.scopesByIdentifierByElement = new WeakMap();
        this.scopeReferenceCounts = new WeakMap();
    }
    start() {
        this.valueListObserver.start();
    }
    stop() {
        this.valueListObserver.stop();
    }
    get controllerAttribute() {
        return this.schema.controllerAttribute;
    }
    parseValueForToken(token) {
        const { element, content: identifier } = token;
        return this.parseValueForElementAndIdentifier(element, identifier);
    }
    parseValueForElementAndIdentifier(element, identifier) {
        const scopesByIdentifier = this.fetchScopesByIdentifierForElement(element);
        let scope = scopesByIdentifier.get(identifier);
        if (!scope) {
            scope = this.delegate.createScopeForElementAndIdentifier(element, identifier);
            scopesByIdentifier.set(identifier, scope);
        }
        return scope;
    }
    elementMatchedValue(element, value) {
        const referenceCount = (this.scopeReferenceCounts.get(value) || 0) + 1;
        this.scopeReferenceCounts.set(value, referenceCount);
        if (referenceCount == 1) {
            this.delegate.scopeConnected(value);
        }
    }
    elementUnmatchedValue(element, value) {
        const referenceCount = this.scopeReferenceCounts.get(value);
        if (referenceCount) {
            this.scopeReferenceCounts.set(value, referenceCount - 1);
            if (referenceCount == 1) {
                this.delegate.scopeDisconnected(value);
            }
        }
    }
    fetchScopesByIdentifierForElement(element) {
        let scopesByIdentifier = this.scopesByIdentifierByElement.get(element);
        if (!scopesByIdentifier) {
            scopesByIdentifier = new Map();
            this.scopesByIdentifierByElement.set(element, scopesByIdentifier);
        }
        return scopesByIdentifier;
    }
}

class Router {
    constructor(application) {
        this.application = application;
        this.scopeObserver = new ScopeObserver(this.element, this.schema, this);
        this.scopesByIdentifier = new Multimap();
        this.modulesByIdentifier = new Map();
    }
    get element() {
        return this.application.element;
    }
    get schema() {
        return this.application.schema;
    }
    get logger() {
        return this.application.logger;
    }
    get controllerAttribute() {
        return this.schema.controllerAttribute;
    }
    get modules() {
        return Array.from(this.modulesByIdentifier.values());
    }
    get contexts() {
        return this.modules.reduce((contexts, module) => contexts.concat(module.contexts), []);
    }
    start() {
        this.scopeObserver.start();
    }
    stop() {
        this.scopeObserver.stop();
    }
    loadDefinition(definition) {
        this.unloadIdentifier(definition.identifier);
        const module = new Module(this.application, definition);
        this.connectModule(module);
        const afterLoad = definition.controllerConstructor.afterLoad;
        if (afterLoad) {
            afterLoad.call(definition.controllerConstructor, definition.identifier, this.application);
        }
    }
    unloadIdentifier(identifier) {
        const module = this.modulesByIdentifier.get(identifier);
        if (module) {
            this.disconnectModule(module);
        }
    }
    getContextForElementAndIdentifier(element, identifier) {
        const module = this.modulesByIdentifier.get(identifier);
        if (module) {
            return module.contexts.find((context) => context.element == element);
        }
    }
    proposeToConnectScopeForElementAndIdentifier(element, identifier) {
        const scope = this.scopeObserver.parseValueForElementAndIdentifier(element, identifier);
        if (scope) {
            this.scopeObserver.elementMatchedValue(scope.element, scope);
        }
        else {
            console.error(`Couldn't find or create scope for identifier: "${identifier}" and element:`, element);
        }
    }
    handleError(error, message, detail) {
        this.application.handleError(error, message, detail);
    }
    createScopeForElementAndIdentifier(element, identifier) {
        return new Scope(this.schema, element, identifier, this.logger);
    }
    scopeConnected(scope) {
        this.scopesByIdentifier.add(scope.identifier, scope);
        const module = this.modulesByIdentifier.get(scope.identifier);
        if (module) {
            module.connectContextForScope(scope);
        }
    }
    scopeDisconnected(scope) {
        this.scopesByIdentifier.delete(scope.identifier, scope);
        const module = this.modulesByIdentifier.get(scope.identifier);
        if (module) {
            module.disconnectContextForScope(scope);
        }
    }
    connectModule(module) {
        this.modulesByIdentifier.set(module.identifier, module);
        const scopes = this.scopesByIdentifier.getValuesForKey(module.identifier);
        scopes.forEach((scope) => module.connectContextForScope(scope));
    }
    disconnectModule(module) {
        this.modulesByIdentifier.delete(module.identifier);
        const scopes = this.scopesByIdentifier.getValuesForKey(module.identifier);
        scopes.forEach((scope) => module.disconnectContextForScope(scope));
    }
}

const defaultSchema = {
    controllerAttribute: "data-controller",
    actionAttribute: "data-action",
    targetAttribute: "data-target",
    targetAttributeForScope: (identifier) => `data-${identifier}-target`,
    outletAttributeForScope: (identifier, outlet) => `data-${identifier}-${outlet}-outlet`,
    keyMappings: Object.assign(Object.assign({ enter: "Enter", tab: "Tab", esc: "Escape", space: " ", up: "ArrowUp", down: "ArrowDown", left: "ArrowLeft", right: "ArrowRight", home: "Home", end: "End", page_up: "PageUp", page_down: "PageDown" }, objectFromEntries("abcdefghijklmnopqrstuvwxyz".split("").map((c) => [c, c]))), objectFromEntries("0123456789".split("").map((n) => [n, n]))),
};
function objectFromEntries(array) {
    return array.reduce((memo, [k, v]) => (Object.assign(Object.assign({}, memo), { [k]: v })), {});
}

class Application {
    constructor(element = document.documentElement, schema = defaultSchema) {
        this.logger = console;
        this.debug = false;
        this.logDebugActivity = (identifier, functionName, detail = {}) => {
            if (this.debug) {
                this.logFormattedMessage(identifier, functionName, detail);
            }
        };
        this.element = element;
        this.schema = schema;
        this.dispatcher = new Dispatcher(this);
        this.router = new Router(this);
        this.actionDescriptorFilters = Object.assign({}, defaultActionDescriptorFilters);
    }
    static start(element, schema) {
        const application = new this(element, schema);
        application.start();
        return application;
    }
    async start() {
        await domReady();
        this.logDebugActivity("application", "starting");
        this.dispatcher.start();
        this.router.start();
        this.logDebugActivity("application", "start");
    }
    stop() {
        this.logDebugActivity("application", "stopping");
        this.dispatcher.stop();
        this.router.stop();
        this.logDebugActivity("application", "stop");
    }
    register(identifier, controllerConstructor) {
        this.load({ identifier, controllerConstructor });
    }
    registerActionOption(name, filter) {
        this.actionDescriptorFilters[name] = filter;
    }
    load(head, ...rest) {
        const definitions = Array.isArray(head) ? head : [head, ...rest];
        definitions.forEach((definition) => {
            if (definition.controllerConstructor.shouldLoad) {
                this.router.loadDefinition(definition);
            }
        });
    }
    unload(head, ...rest) {
        const identifiers = Array.isArray(head) ? head : [head, ...rest];
        identifiers.forEach((identifier) => this.router.unloadIdentifier(identifier));
    }
    get controllers() {
        return this.router.contexts.map((context) => context.controller);
    }
    getControllerForElementAndIdentifier(element, identifier) {
        const context = this.router.getContextForElementAndIdentifier(element, identifier);
        return context ? context.controller : null;
    }
    handleError(error, message, detail) {
        var _a;
        this.logger.error(`%s\n\n%o\n\n%o`, message, error, detail);
        (_a = window.onerror) === null || _a === void 0 ? void 0 : _a.call(window, message, "", 0, 0, error);
    }
    logFormattedMessage(identifier, functionName, detail = {}) {
        detail = Object.assign({ application: this }, detail);
        this.logger.groupCollapsed(`${identifier} #${functionName}`);
        this.logger.log("details:", Object.assign({}, detail));
        this.logger.groupEnd();
    }
}
function domReady() {
    return new Promise((resolve) => {
        if (document.readyState == "loading") {
            document.addEventListener("DOMContentLoaded", () => resolve());
        }
        else {
            resolve();
        }
    });
}

function ClassPropertiesBlessing(constructor) {
    const classes = readInheritableStaticArrayValues(constructor, "classes");
    return classes.reduce((properties, classDefinition) => {
        return Object.assign(properties, propertiesForClassDefinition(classDefinition));
    }, {});
}
function propertiesForClassDefinition(key) {
    return {
        [`${key}Class`]: {
            get() {
                const { classes } = this;
                if (classes.has(key)) {
                    return classes.get(key);
                }
                else {
                    const attribute = classes.getAttributeName(key);
                    throw new Error(`Missing attribute "${attribute}"`);
                }
            },
        },
        [`${key}Classes`]: {
            get() {
                return this.classes.getAll(key);
            },
        },
        [`has${capitalize(key)}Class`]: {
            get() {
                return this.classes.has(key);
            },
        },
    };
}

function OutletPropertiesBlessing(constructor) {
    const outlets = readInheritableStaticArrayValues(constructor, "outlets");
    return outlets.reduce((properties, outletDefinition) => {
        return Object.assign(properties, propertiesForOutletDefinition(outletDefinition));
    }, {});
}
function getOutletController(controller, element, identifier) {
    return controller.application.getControllerForElementAndIdentifier(element, identifier);
}
function getControllerAndEnsureConnectedScope(controller, element, outletName) {
    let outletController = getOutletController(controller, element, outletName);
    if (outletController)
        return outletController;
    controller.application.router.proposeToConnectScopeForElementAndIdentifier(element, outletName);
    outletController = getOutletController(controller, element, outletName);
    if (outletController)
        return outletController;
}
function propertiesForOutletDefinition(name) {
    const camelizedName = namespaceCamelize(name);
    return {
        [`${camelizedName}Outlet`]: {
            get() {
                const outletElement = this.outlets.find(name);
                const selector = this.outlets.getSelectorForOutletName(name);
                if (outletElement) {
                    const outletController = getControllerAndEnsureConnectedScope(this, outletElement, name);
                    if (outletController)
                        return outletController;
                    throw new Error(`The provided outlet element is missing an outlet controller "${name}" instance for host controller "${this.identifier}"`);
                }
                throw new Error(`Missing outlet element "${name}" for host controller "${this.identifier}". Stimulus couldn't find a matching outlet element using selector "${selector}".`);
            },
        },
        [`${camelizedName}Outlets`]: {
            get() {
                const outlets = this.outlets.findAll(name);
                if (outlets.length > 0) {
                    return outlets
                        .map((outletElement) => {
                        const outletController = getControllerAndEnsureConnectedScope(this, outletElement, name);
                        if (outletController)
                            return outletController;
                        console.warn(`The provided outlet element is missing an outlet controller "${name}" instance for host controller "${this.identifier}"`, outletElement);
                    })
                        .filter((controller) => controller);
                }
                return [];
            },
        },
        [`${camelizedName}OutletElement`]: {
            get() {
                const outletElement = this.outlets.find(name);
                const selector = this.outlets.getSelectorForOutletName(name);
                if (outletElement) {
                    return outletElement;
                }
                else {
                    throw new Error(`Missing outlet element "${name}" for host controller "${this.identifier}". Stimulus couldn't find a matching outlet element using selector "${selector}".`);
                }
            },
        },
        [`${camelizedName}OutletElements`]: {
            get() {
                return this.outlets.findAll(name);
            },
        },
        [`has${capitalize(camelizedName)}Outlet`]: {
            get() {
                return this.outlets.has(name);
            },
        },
    };
}

function TargetPropertiesBlessing(constructor) {
    const targets = readInheritableStaticArrayValues(constructor, "targets");
    return targets.reduce((properties, targetDefinition) => {
        return Object.assign(properties, propertiesForTargetDefinition(targetDefinition));
    }, {});
}
function propertiesForTargetDefinition(name) {
    return {
        [`${name}Target`]: {
            get() {
                const target = this.targets.find(name);
                if (target) {
                    return target;
                }
                else {
                    throw new Error(`Missing target element "${name}" for "${this.identifier}" controller`);
                }
            },
        },
        [`${name}Targets`]: {
            get() {
                return this.targets.findAll(name);
            },
        },
        [`has${capitalize(name)}Target`]: {
            get() {
                return this.targets.has(name);
            },
        },
    };
}

function ValuePropertiesBlessing(constructor) {
    const valueDefinitionPairs = readInheritableStaticObjectPairs(constructor, "values");
    const propertyDescriptorMap = {
        valueDescriptorMap: {
            get() {
                return valueDefinitionPairs.reduce((result, valueDefinitionPair) => {
                    const valueDescriptor = parseValueDefinitionPair(valueDefinitionPair, this.identifier);
                    const attributeName = this.data.getAttributeNameForKey(valueDescriptor.key);
                    return Object.assign(result, { [attributeName]: valueDescriptor });
                }, {});
            },
        },
    };
    return valueDefinitionPairs.reduce((properties, valueDefinitionPair) => {
        return Object.assign(properties, propertiesForValueDefinitionPair(valueDefinitionPair));
    }, propertyDescriptorMap);
}
function propertiesForValueDefinitionPair(valueDefinitionPair, controller) {
    const definition = parseValueDefinitionPair(valueDefinitionPair, controller);
    const { key, name, reader: read, writer: write } = definition;
    return {
        [name]: {
            get() {
                const value = this.data.get(key);
                if (value !== null) {
                    return read(value);
                }
                else {
                    return definition.defaultValue;
                }
            },
            set(value) {
                if (value === undefined) {
                    this.data.delete(key);
                }
                else {
                    this.data.set(key, write(value));
                }
            },
        },
        [`has${capitalize(name)}`]: {
            get() {
                return this.data.has(key) || definition.hasCustomDefaultValue;
            },
        },
    };
}
function parseValueDefinitionPair([token, typeDefinition], controller) {
    return valueDescriptorForTokenAndTypeDefinition({
        controller,
        token,
        typeDefinition,
    });
}
function parseValueTypeConstant(constant) {
    switch (constant) {
        case Array:
            return "array";
        case Boolean:
            return "boolean";
        case Number:
            return "number";
        case Object:
            return "object";
        case String:
            return "string";
    }
}
function parseValueTypeDefault(defaultValue) {
    switch (typeof defaultValue) {
        case "boolean":
            return "boolean";
        case "number":
            return "number";
        case "string":
            return "string";
    }
    if (Array.isArray(defaultValue))
        return "array";
    if (Object.prototype.toString.call(defaultValue) === "[object Object]")
        return "object";
}
function parseValueTypeObject(payload) {
    const { controller, token, typeObject } = payload;
    const hasType = isSomething(typeObject.type);
    const hasDefault = isSomething(typeObject.default);
    const fullObject = hasType && hasDefault;
    const onlyType = hasType && !hasDefault;
    const onlyDefault = !hasType && hasDefault;
    const typeFromObject = parseValueTypeConstant(typeObject.type);
    const typeFromDefaultValue = parseValueTypeDefault(payload.typeObject.default);
    if (onlyType)
        return typeFromObject;
    if (onlyDefault)
        return typeFromDefaultValue;
    if (typeFromObject !== typeFromDefaultValue) {
        const propertyPath = controller ? `${controller}.${token}` : token;
        throw new Error(`The specified default value for the Stimulus Value "${propertyPath}" must match the defined type "${typeFromObject}". The provided default value of "${typeObject.default}" is of type "${typeFromDefaultValue}".`);
    }
    if (fullObject)
        return typeFromObject;
}
function parseValueTypeDefinition(payload) {
    const { controller, token, typeDefinition } = payload;
    const typeObject = { controller, token, typeObject: typeDefinition };
    const typeFromObject = parseValueTypeObject(typeObject);
    const typeFromDefaultValue = parseValueTypeDefault(typeDefinition);
    const typeFromConstant = parseValueTypeConstant(typeDefinition);
    const type = typeFromObject || typeFromDefaultValue || typeFromConstant;
    if (type)
        return type;
    const propertyPath = controller ? `${controller}.${typeDefinition}` : token;
    throw new Error(`Unknown value type "${propertyPath}" for "${token}" value`);
}
function defaultValueForDefinition(typeDefinition) {
    const constant = parseValueTypeConstant(typeDefinition);
    if (constant)
        return defaultValuesByType[constant];
    const hasDefault = hasProperty(typeDefinition, "default");
    const hasType = hasProperty(typeDefinition, "type");
    const typeObject = typeDefinition;
    if (hasDefault)
        return typeObject.default;
    if (hasType) {
        const { type } = typeObject;
        const constantFromType = parseValueTypeConstant(type);
        if (constantFromType)
            return defaultValuesByType[constantFromType];
    }
    return typeDefinition;
}
function valueDescriptorForTokenAndTypeDefinition(payload) {
    const { token, typeDefinition } = payload;
    const key = `${dasherize(token)}-value`;
    const type = parseValueTypeDefinition(payload);
    return {
        type,
        key,
        name: camelize(key),
        get defaultValue() {
            return defaultValueForDefinition(typeDefinition);
        },
        get hasCustomDefaultValue() {
            return parseValueTypeDefault(typeDefinition) !== undefined;
        },
        reader: readers[type],
        writer: writers[type] || writers.default,
    };
}
const defaultValuesByType = {
    get array() {
        return [];
    },
    boolean: false,
    number: 0,
    get object() {
        return {};
    },
    string: "",
};
const readers = {
    array(value) {
        const array = JSON.parse(value);
        if (!Array.isArray(array)) {
            throw new TypeError(`expected value of type "array" but instead got value "${value}" of type "${parseValueTypeDefault(array)}"`);
        }
        return array;
    },
    boolean(value) {
        return !(value == "0" || String(value).toLowerCase() == "false");
    },
    number(value) {
        return Number(value.replace(/_/g, ""));
    },
    object(value) {
        const object = JSON.parse(value);
        if (object === null || typeof object != "object" || Array.isArray(object)) {
            throw new TypeError(`expected value of type "object" but instead got value "${value}" of type "${parseValueTypeDefault(object)}"`);
        }
        return object;
    },
    string(value) {
        return value;
    },
};
const writers = {
    default: writeString,
    array: writeJSON,
    object: writeJSON,
};
function writeJSON(value) {
    return JSON.stringify(value);
}
function writeString(value) {
    return `${value}`;
}

class Controller {
    constructor(context) {
        this.context = context;
    }
    static get shouldLoad() {
        return true;
    }
    static afterLoad(_identifier, _application) {
        return;
    }
    get application() {
        return this.context.application;
    }
    get scope() {
        return this.context.scope;
    }
    get element() {
        return this.scope.element;
    }
    get identifier() {
        return this.scope.identifier;
    }
    get targets() {
        return this.scope.targets;
    }
    get outlets() {
        return this.scope.outlets;
    }
    get classes() {
        return this.scope.classes;
    }
    get data() {
        return this.scope.data;
    }
    initialize() {
    }
    connect() {
    }
    disconnect() {
    }
    dispatch(eventName, { target = this.element, detail = {}, prefix = this.identifier, bubbles = true, cancelable = true, } = {}) {
        const type = prefix ? `${prefix}:${eventName}` : eventName;
        const event = new CustomEvent(type, { detail, bubbles, cancelable });
        target.dispatchEvent(event);
        return event;
    }
}
Controller.blessings = [
    ClassPropertiesBlessing,
    TargetPropertiesBlessing,
    ValuePropertiesBlessing,
    OutletPropertiesBlessing,
];
Controller.targets = [];
Controller.outlets = [];
Controller.values = {};




/***/ }),

/***/ "./node_modules/@hotwired/turbo/dist/turbo.es2017-esm.js":
/*!***************************************************************!*\
  !*** ./node_modules/@hotwired/turbo/dist/turbo.es2017-esm.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   FetchEnctype: function() { return /* binding */ FetchEnctype; },
/* harmony export */   FetchMethod: function() { return /* binding */ FetchMethod; },
/* harmony export */   FetchRequest: function() { return /* binding */ FetchRequest; },
/* harmony export */   FetchResponse: function() { return /* binding */ FetchResponse; },
/* harmony export */   FrameElement: function() { return /* binding */ FrameElement; },
/* harmony export */   FrameLoadingStyle: function() { return /* binding */ FrameLoadingStyle; },
/* harmony export */   FrameRenderer: function() { return /* binding */ FrameRenderer; },
/* harmony export */   PageRenderer: function() { return /* binding */ PageRenderer; },
/* harmony export */   PageSnapshot: function() { return /* binding */ PageSnapshot; },
/* harmony export */   StreamActions: function() { return /* binding */ StreamActions; },
/* harmony export */   StreamElement: function() { return /* binding */ StreamElement; },
/* harmony export */   StreamSourceElement: function() { return /* binding */ StreamSourceElement; },
/* harmony export */   cache: function() { return /* binding */ cache; },
/* harmony export */   clearCache: function() { return /* binding */ clearCache; },
/* harmony export */   config: function() { return /* binding */ config; },
/* harmony export */   connectStreamSource: function() { return /* binding */ connectStreamSource; },
/* harmony export */   disconnectStreamSource: function() { return /* binding */ disconnectStreamSource; },
/* harmony export */   fetch: function() { return /* binding */ fetchWithTurboHeaders; },
/* harmony export */   fetchEnctypeFromString: function() { return /* binding */ fetchEnctypeFromString; },
/* harmony export */   fetchMethodFromString: function() { return /* binding */ fetchMethodFromString; },
/* harmony export */   isSafe: function() { return /* binding */ isSafe; },
/* harmony export */   navigator: function() { return /* binding */ navigator$1; },
/* harmony export */   registerAdapter: function() { return /* binding */ registerAdapter; },
/* harmony export */   renderStreamMessage: function() { return /* binding */ renderStreamMessage; },
/* harmony export */   session: function() { return /* binding */ session; },
/* harmony export */   setConfirmMethod: function() { return /* binding */ setConfirmMethod; },
/* harmony export */   setFormMode: function() { return /* binding */ setFormMode; },
/* harmony export */   setProgressBarDelay: function() { return /* binding */ setProgressBarDelay; },
/* harmony export */   start: function() { return /* binding */ start; },
/* harmony export */   visit: function() { return /* binding */ visit; }
/* harmony export */ });
/*!
Turbo 8.0.13
Copyright  2025 37signals LLC
 */
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2019 Javan Makhmali
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

(function (prototype) {
  if (typeof prototype.requestSubmit == "function") return

  prototype.requestSubmit = function (submitter) {
    if (submitter) {
      validateSubmitter(submitter, this);
      submitter.click();
    } else {
      submitter = document.createElement("input");
      submitter.type = "submit";
      submitter.hidden = true;
      this.appendChild(submitter);
      submitter.click();
      this.removeChild(submitter);
    }
  };

  function validateSubmitter(submitter, form) {
    submitter instanceof HTMLElement || raise(TypeError, "parameter 1 is not of type 'HTMLElement'");
    submitter.type == "submit" || raise(TypeError, "The specified element is not a submit button");
    submitter.form == form ||
      raise(DOMException, "The specified element is not owned by this form element", "NotFoundError");
  }

  function raise(errorConstructor, message, name) {
    throw new errorConstructor("Failed to execute 'requestSubmit' on 'HTMLFormElement': " + message + ".", name)
  }
})(HTMLFormElement.prototype);

const submittersByForm = new WeakMap();

function findSubmitterFromClickTarget(target) {
  const element = target instanceof Element ? target : target instanceof Node ? target.parentElement : null;
  const candidate = element ? element.closest("input, button") : null;
  return candidate?.type == "submit" ? candidate : null
}

function clickCaptured(event) {
  const submitter = findSubmitterFromClickTarget(event.target);

  if (submitter && submitter.form) {
    submittersByForm.set(submitter.form, submitter);
  }
}

(function () {
  if ("submitter" in Event.prototype) return

  let prototype = window.Event.prototype;
  // Certain versions of Safari 15 have a bug where they won't
  // populate the submitter. This hurts TurboDrive's enable/disable detection.
  // See https://bugs.webkit.org/show_bug.cgi?id=229660
  if ("SubmitEvent" in window) {
    const prototypeOfSubmitEvent = window.SubmitEvent.prototype;

    if (/Apple Computer/.test(navigator.vendor) && !("submitter" in prototypeOfSubmitEvent)) {
      prototype = prototypeOfSubmitEvent;
    } else {
      return // polyfill not needed
    }
  }

  addEventListener("click", clickCaptured, true);

  Object.defineProperty(prototype, "submitter", {
    get() {
      if (this.type == "submit" && this.target instanceof HTMLFormElement) {
        return submittersByForm.get(this.target)
      }
    }
  });
})();

const FrameLoadingStyle = {
  eager: "eager",
  lazy: "lazy"
};

/**
 * Contains a fragment of HTML which is updated based on navigation within
 * it (e.g. via links or form submissions).
 *
 * @customElement turbo-frame
 * @example
 *   <turbo-frame id="messages">
 *     <a href="/messages/expanded">
 *       Show all expanded messages in this frame.
 *     </a>
 *
 *     <form action="/messages">
 *       Show response from this form within this frame.
 *     </form>
 *   </turbo-frame>
 */
class FrameElement extends HTMLElement {
  static delegateConstructor = undefined

  loaded = Promise.resolve()

  static get observedAttributes() {
    return ["disabled", "loading", "src"]
  }

  constructor() {
    super();
    this.delegate = new FrameElement.delegateConstructor(this);
  }

  connectedCallback() {
    this.delegate.connect();
  }

  disconnectedCallback() {
    this.delegate.disconnect();
  }

  reload() {
    return this.delegate.sourceURLReloaded()
  }

  attributeChangedCallback(name) {
    if (name == "loading") {
      this.delegate.loadingStyleChanged();
    } else if (name == "src") {
      this.delegate.sourceURLChanged();
    } else if (name == "disabled") {
      this.delegate.disabledChanged();
    }
  }

  /**
   * Gets the URL to lazily load source HTML from
   */
  get src() {
    return this.getAttribute("src")
  }

  /**
   * Sets the URL to lazily load source HTML from
   */
  set src(value) {
    if (value) {
      this.setAttribute("src", value);
    } else {
      this.removeAttribute("src");
    }
  }

  /**
   * Gets the refresh mode for the frame.
   */
  get refresh() {
    return this.getAttribute("refresh")
  }

  /**
   * Sets the refresh mode for the frame.
   */
  set refresh(value) {
    if (value) {
      this.setAttribute("refresh", value);
    } else {
      this.removeAttribute("refresh");
    }
  }

  get shouldReloadWithMorph() {
    return this.src && this.refresh === "morph"
  }

  /**
   * Determines if the element is loading
   */
  get loading() {
    return frameLoadingStyleFromString(this.getAttribute("loading") || "")
  }

  /**
   * Sets the value of if the element is loading
   */
  set loading(value) {
    if (value) {
      this.setAttribute("loading", value);
    } else {
      this.removeAttribute("loading");
    }
  }

  /**
   * Gets the disabled state of the frame.
   *
   * If disabled, no requests will be intercepted by the frame.
   */
  get disabled() {
    return this.hasAttribute("disabled")
  }

  /**
   * Sets the disabled state of the frame.
   *
   * If disabled, no requests will be intercepted by the frame.
   */
  set disabled(value) {
    if (value) {
      this.setAttribute("disabled", "");
    } else {
      this.removeAttribute("disabled");
    }
  }

  /**
   * Gets the autoscroll state of the frame.
   *
   * If true, the frame will be scrolled into view automatically on update.
   */
  get autoscroll() {
    return this.hasAttribute("autoscroll")
  }

  /**
   * Sets the autoscroll state of the frame.
   *
   * If true, the frame will be scrolled into view automatically on update.
   */
  set autoscroll(value) {
    if (value) {
      this.setAttribute("autoscroll", "");
    } else {
      this.removeAttribute("autoscroll");
    }
  }

  /**
   * Determines if the element has finished loading
   */
  get complete() {
    return !this.delegate.isLoading
  }

  /**
   * Gets the active state of the frame.
   *
   * If inactive, source changes will not be observed.
   */
  get isActive() {
    return this.ownerDocument === document && !this.isPreview
  }

  /**
   * Sets the active state of the frame.
   *
   * If inactive, source changes will not be observed.
   */
  get isPreview() {
    return this.ownerDocument?.documentElement?.hasAttribute("data-turbo-preview")
  }
}

function frameLoadingStyleFromString(style) {
  switch (style.toLowerCase()) {
    case "lazy":
      return FrameLoadingStyle.lazy
    default:
      return FrameLoadingStyle.eager
  }
}

const drive = {
  enabled: true,
  progressBarDelay: 500,
  unvisitableExtensions: new Set(
    [
      ".7z", ".aac", ".apk", ".avi", ".bmp", ".bz2", ".css", ".csv", ".deb", ".dmg", ".doc",
      ".docx", ".exe", ".gif", ".gz", ".heic", ".heif", ".ico", ".iso", ".jpeg", ".jpg",
      ".js", ".json", ".m4a", ".mkv", ".mov", ".mp3", ".mp4", ".mpeg", ".mpg", ".msi",
      ".ogg", ".ogv", ".pdf", ".pkg", ".png", ".ppt", ".pptx", ".rar", ".rtf",
      ".svg", ".tar", ".tif", ".tiff", ".txt", ".wav", ".webm", ".webp", ".wma", ".wmv",
      ".xls", ".xlsx", ".xml", ".zip"
    ]
  )
};

function activateScriptElement(element) {
  if (element.getAttribute("data-turbo-eval") == "false") {
    return element
  } else {
    const createdScriptElement = document.createElement("script");
    const cspNonce = getCspNonce();
    if (cspNonce) {
      createdScriptElement.nonce = cspNonce;
    }
    createdScriptElement.textContent = element.textContent;
    createdScriptElement.async = false;
    copyElementAttributes(createdScriptElement, element);
    return createdScriptElement
  }
}

function copyElementAttributes(destinationElement, sourceElement) {
  for (const { name, value } of sourceElement.attributes) {
    destinationElement.setAttribute(name, value);
  }
}

function createDocumentFragment(html) {
  const template = document.createElement("template");
  template.innerHTML = html;
  return template.content
}

function dispatch(eventName, { target, cancelable, detail } = {}) {
  const event = new CustomEvent(eventName, {
    cancelable,
    bubbles: true,
    composed: true,
    detail
  });

  if (target && target.isConnected) {
    target.dispatchEvent(event);
  } else {
    document.documentElement.dispatchEvent(event);
  }

  return event
}

function cancelEvent(event) {
  event.preventDefault();
  event.stopImmediatePropagation();
}

function nextRepaint() {
  if (document.visibilityState === "hidden") {
    return nextEventLoopTick()
  } else {
    return nextAnimationFrame()
  }
}

function nextAnimationFrame() {
  return new Promise((resolve) => requestAnimationFrame(() => resolve()))
}

function nextEventLoopTick() {
  return new Promise((resolve) => setTimeout(() => resolve(), 0))
}

function nextMicrotask() {
  return Promise.resolve()
}

function parseHTMLDocument(html = "") {
  return new DOMParser().parseFromString(html, "text/html")
}

function unindent(strings, ...values) {
  const lines = interpolate(strings, values).replace(/^\n/, "").split("\n");
  const match = lines[0].match(/^\s+/);
  const indent = match ? match[0].length : 0;
  return lines.map((line) => line.slice(indent)).join("\n")
}

function interpolate(strings, values) {
  return strings.reduce((result, string, i) => {
    const value = values[i] == undefined ? "" : values[i];
    return result + string + value
  }, "")
}

function uuid() {
  return Array.from({ length: 36 })
    .map((_, i) => {
      if (i == 8 || i == 13 || i == 18 || i == 23) {
        return "-"
      } else if (i == 14) {
        return "4"
      } else if (i == 19) {
        return (Math.floor(Math.random() * 4) + 8).toString(16)
      } else {
        return Math.floor(Math.random() * 15).toString(16)
      }
    })
    .join("")
}

function getAttribute(attributeName, ...elements) {
  for (const value of elements.map((element) => element?.getAttribute(attributeName))) {
    if (typeof value == "string") return value
  }

  return null
}

function hasAttribute(attributeName, ...elements) {
  return elements.some((element) => element && element.hasAttribute(attributeName))
}

function markAsBusy(...elements) {
  for (const element of elements) {
    if (element.localName == "turbo-frame") {
      element.setAttribute("busy", "");
    }
    element.setAttribute("aria-busy", "true");
  }
}

function clearBusyState(...elements) {
  for (const element of elements) {
    if (element.localName == "turbo-frame") {
      element.removeAttribute("busy");
    }

    element.removeAttribute("aria-busy");
  }
}

function waitForLoad(element, timeoutInMilliseconds = 2000) {
  return new Promise((resolve) => {
    const onComplete = () => {
      element.removeEventListener("error", onComplete);
      element.removeEventListener("load", onComplete);
      resolve();
    };

    element.addEventListener("load", onComplete, { once: true });
    element.addEventListener("error", onComplete, { once: true });
    setTimeout(resolve, timeoutInMilliseconds);
  })
}

function getHistoryMethodForAction(action) {
  switch (action) {
    case "replace":
      return history.replaceState
    case "advance":
    case "restore":
      return history.pushState
  }
}

function isAction(action) {
  return action == "advance" || action == "replace" || action == "restore"
}

function getVisitAction(...elements) {
  const action = getAttribute("data-turbo-action", ...elements);

  return isAction(action) ? action : null
}

function getMetaElement(name) {
  return document.querySelector(`meta[name="${name}"]`)
}

function getMetaContent(name) {
  const element = getMetaElement(name);
  return element && element.content
}

function getCspNonce() {
  const element = getMetaElement("csp-nonce");

  if (element) {
    const { nonce, content } = element;
    return nonce == "" ? content : nonce
  }
}

function setMetaContent(name, content) {
  let element = getMetaElement(name);

  if (!element) {
    element = document.createElement("meta");
    element.setAttribute("name", name);

    document.head.appendChild(element);
  }

  element.setAttribute("content", content);

  return element
}

function findClosestRecursively(element, selector) {
  if (element instanceof Element) {
    return (
      element.closest(selector) || findClosestRecursively(element.assignedSlot || element.getRootNode()?.host, selector)
    )
  }
}

function elementIsFocusable(element) {
  const inertDisabledOrHidden = "[inert], :disabled, [hidden], details:not([open]), dialog:not([open])";

  return !!element && element.closest(inertDisabledOrHidden) == null && typeof element.focus == "function"
}

function queryAutofocusableElement(elementOrDocumentFragment) {
  return Array.from(elementOrDocumentFragment.querySelectorAll("[autofocus]")).find(elementIsFocusable)
}

async function around(callback, reader) {
  const before = reader();

  callback();

  await nextAnimationFrame();

  const after = reader();

  return [before, after]
}

function doesNotTargetIFrame(name) {
  if (name === "_blank") {
    return false
  } else if (name) {
    for (const element of document.getElementsByName(name)) {
      if (element instanceof HTMLIFrameElement) return false
    }

    return true
  } else {
    return true
  }
}

function findLinkFromClickTarget(target) {
  return findClosestRecursively(target, "a[href]:not([target^=_]):not([download])")
}

function getLocationForLink(link) {
  return expandURL(link.getAttribute("href") || "")
}

function debounce(fn, delay) {
  let timeoutId = null;

  return (...args) => {
    const callback = () => fn.apply(this, args);
    clearTimeout(timeoutId);
    timeoutId = setTimeout(callback, delay);
  }
}

const submitter = {
  "aria-disabled": {
    beforeSubmit: submitter => {
      submitter.setAttribute("aria-disabled", "true");
      submitter.addEventListener("click", cancelEvent);
    },

    afterSubmit: submitter => {
      submitter.removeAttribute("aria-disabled");
      submitter.removeEventListener("click", cancelEvent);
    }
  },

  "disabled": {
    beforeSubmit: submitter => submitter.disabled = true,
    afterSubmit: submitter => submitter.disabled = false
  }
};

class Config {
  #submitter = null

  constructor(config) {
    Object.assign(this, config);
  }

  get submitter() {
    return this.#submitter
  }

  set submitter(value) {
    this.#submitter = submitter[value] || value;
  }
}

const forms = new Config({
  mode: "on",
  submitter: "disabled"
});

const config = {
  drive,
  forms
};

function expandURL(locatable) {
  return new URL(locatable.toString(), document.baseURI)
}

function getAnchor(url) {
  let anchorMatch;
  if (url.hash) {
    return url.hash.slice(1)
    // eslint-disable-next-line no-cond-assign
  } else if ((anchorMatch = url.href.match(/#(.*)$/))) {
    return anchorMatch[1]
  }
}

function getAction$1(form, submitter) {
  const action = submitter?.getAttribute("formaction") || form.getAttribute("action") || form.action;

  return expandURL(action)
}

function getExtension(url) {
  return (getLastPathComponent(url).match(/\.[^.]*$/) || [])[0] || ""
}

function isPrefixedBy(baseURL, url) {
  const prefix = getPrefix(url);
  return baseURL.href === expandURL(prefix).href || baseURL.href.startsWith(prefix)
}

function locationIsVisitable(location, rootLocation) {
  return isPrefixedBy(location, rootLocation) && !config.drive.unvisitableExtensions.has(getExtension(location))
}

function getRequestURL(url) {
  const anchor = getAnchor(url);
  return anchor != null ? url.href.slice(0, -(anchor.length + 1)) : url.href
}

function toCacheKey(url) {
  return getRequestURL(url)
}

function urlsAreEqual(left, right) {
  return expandURL(left).href == expandURL(right).href
}

function getPathComponents(url) {
  return url.pathname.split("/").slice(1)
}

function getLastPathComponent(url) {
  return getPathComponents(url).slice(-1)[0]
}

function getPrefix(url) {
  return addTrailingSlash(url.origin + url.pathname)
}

function addTrailingSlash(value) {
  return value.endsWith("/") ? value : value + "/"
}

class FetchResponse {
  constructor(response) {
    this.response = response;
  }

  get succeeded() {
    return this.response.ok
  }

  get failed() {
    return !this.succeeded
  }

  get clientError() {
    return this.statusCode >= 400 && this.statusCode <= 499
  }

  get serverError() {
    return this.statusCode >= 500 && this.statusCode <= 599
  }

  get redirected() {
    return this.response.redirected
  }

  get location() {
    return expandURL(this.response.url)
  }

  get isHTML() {
    return this.contentType && this.contentType.match(/^(?:text\/([^\s;,]+\b)?html|application\/xhtml\+xml)\b/)
  }

  get statusCode() {
    return this.response.status
  }

  get contentType() {
    return this.header("Content-Type")
  }

  get responseText() {
    return this.response.clone().text()
  }

  get responseHTML() {
    if (this.isHTML) {
      return this.response.clone().text()
    } else {
      return Promise.resolve(undefined)
    }
  }

  header(name) {
    return this.response.headers.get(name)
  }
}

class LimitedSet extends Set {
  constructor(maxSize) {
    super();
    this.maxSize = maxSize;
  }

  add(value) {
    if (this.size >= this.maxSize) {
      const iterator = this.values();
      const oldestValue = iterator.next().value;
      this.delete(oldestValue);
    }
    super.add(value);
  }
}

const recentRequests = new LimitedSet(20);

const nativeFetch = window.fetch;

function fetchWithTurboHeaders(url, options = {}) {
  const modifiedHeaders = new Headers(options.headers || {});
  const requestUID = uuid();
  recentRequests.add(requestUID);
  modifiedHeaders.append("X-Turbo-Request-Id", requestUID);

  return nativeFetch(url, {
    ...options,
    headers: modifiedHeaders
  })
}

function fetchMethodFromString(method) {
  switch (method.toLowerCase()) {
    case "get":
      return FetchMethod.get
    case "post":
      return FetchMethod.post
    case "put":
      return FetchMethod.put
    case "patch":
      return FetchMethod.patch
    case "delete":
      return FetchMethod.delete
  }
}

const FetchMethod = {
  get: "get",
  post: "post",
  put: "put",
  patch: "patch",
  delete: "delete"
};

function fetchEnctypeFromString(encoding) {
  switch (encoding.toLowerCase()) {
    case FetchEnctype.multipart:
      return FetchEnctype.multipart
    case FetchEnctype.plain:
      return FetchEnctype.plain
    default:
      return FetchEnctype.urlEncoded
  }
}

const FetchEnctype = {
  urlEncoded: "application/x-www-form-urlencoded",
  multipart: "multipart/form-data",
  plain: "text/plain"
};

class FetchRequest {
  abortController = new AbortController()
  #resolveRequestPromise = (_value) => {}

  constructor(delegate, method, location, requestBody = new URLSearchParams(), target = null, enctype = FetchEnctype.urlEncoded) {
    const [url, body] = buildResourceAndBody(expandURL(location), method, requestBody, enctype);

    this.delegate = delegate;
    this.url = url;
    this.target = target;
    this.fetchOptions = {
      credentials: "same-origin",
      redirect: "follow",
      method: method.toUpperCase(),
      headers: { ...this.defaultHeaders },
      body: body,
      signal: this.abortSignal,
      referrer: this.delegate.referrer?.href
    };
    this.enctype = enctype;
  }

  get method() {
    return this.fetchOptions.method
  }

  set method(value) {
    const fetchBody = this.isSafe ? this.url.searchParams : this.fetchOptions.body || new FormData();
    const fetchMethod = fetchMethodFromString(value) || FetchMethod.get;

    this.url.search = "";

    const [url, body] = buildResourceAndBody(this.url, fetchMethod, fetchBody, this.enctype);

    this.url = url;
    this.fetchOptions.body = body;
    this.fetchOptions.method = fetchMethod.toUpperCase();
  }

  get headers() {
    return this.fetchOptions.headers
  }

  set headers(value) {
    this.fetchOptions.headers = value;
  }

  get body() {
    if (this.isSafe) {
      return this.url.searchParams
    } else {
      return this.fetchOptions.body
    }
  }

  set body(value) {
    this.fetchOptions.body = value;
  }

  get location() {
    return this.url
  }

  get params() {
    return this.url.searchParams
  }

  get entries() {
    return this.body ? Array.from(this.body.entries()) : []
  }

  cancel() {
    this.abortController.abort();
  }

  async perform() {
    const { fetchOptions } = this;
    this.delegate.prepareRequest(this);
    const event = await this.#allowRequestToBeIntercepted(fetchOptions);
    try {
      this.delegate.requestStarted(this);

      if (event.detail.fetchRequest) {
        this.response = event.detail.fetchRequest.response;
      } else {
        this.response = fetchWithTurboHeaders(this.url.href, fetchOptions);
      }

      const response = await this.response;
      return await this.receive(response)
    } catch (error) {
      if (error.name !== "AbortError") {
        if (this.#willDelegateErrorHandling(error)) {
          this.delegate.requestErrored(this, error);
        }
        throw error
      }
    } finally {
      this.delegate.requestFinished(this);
    }
  }

  async receive(response) {
    const fetchResponse = new FetchResponse(response);
    const event = dispatch("turbo:before-fetch-response", {
      cancelable: true,
      detail: { fetchResponse },
      target: this.target
    });
    if (event.defaultPrevented) {
      this.delegate.requestPreventedHandlingResponse(this, fetchResponse);
    } else if (fetchResponse.succeeded) {
      this.delegate.requestSucceededWithResponse(this, fetchResponse);
    } else {
      this.delegate.requestFailedWithResponse(this, fetchResponse);
    }
    return fetchResponse
  }

  get defaultHeaders() {
    return {
      Accept: "text/html, application/xhtml+xml"
    }
  }

  get isSafe() {
    return isSafe(this.method)
  }

  get abortSignal() {
    return this.abortController.signal
  }

  acceptResponseType(mimeType) {
    this.headers["Accept"] = [mimeType, this.headers["Accept"]].join(", ");
  }

  async #allowRequestToBeIntercepted(fetchOptions) {
    const requestInterception = new Promise((resolve) => (this.#resolveRequestPromise = resolve));
    const event = dispatch("turbo:before-fetch-request", {
      cancelable: true,
      detail: {
        fetchOptions,
        url: this.url,
        resume: this.#resolveRequestPromise
      },
      target: this.target
    });
    this.url = event.detail.url;
    if (event.defaultPrevented) await requestInterception;

    return event
  }

  #willDelegateErrorHandling(error) {
    const event = dispatch("turbo:fetch-request-error", {
      target: this.target,
      cancelable: true,
      detail: { request: this, error: error }
    });

    return !event.defaultPrevented
  }
}

function isSafe(fetchMethod) {
  return fetchMethodFromString(fetchMethod) == FetchMethod.get
}

function buildResourceAndBody(resource, method, requestBody, enctype) {
  const searchParams =
    Array.from(requestBody).length > 0 ? new URLSearchParams(entriesExcludingFiles(requestBody)) : resource.searchParams;

  if (isSafe(method)) {
    return [mergeIntoURLSearchParams(resource, searchParams), null]
  } else if (enctype == FetchEnctype.urlEncoded) {
    return [resource, searchParams]
  } else {
    return [resource, requestBody]
  }
}

function entriesExcludingFiles(requestBody) {
  const entries = [];

  for (const [name, value] of requestBody) {
    if (value instanceof File) continue
    else entries.push([name, value]);
  }

  return entries
}

function mergeIntoURLSearchParams(url, requestBody) {
  const searchParams = new URLSearchParams(entriesExcludingFiles(requestBody));

  url.search = searchParams.toString();

  return url
}

class AppearanceObserver {
  started = false

  constructor(delegate, element) {
    this.delegate = delegate;
    this.element = element;
    this.intersectionObserver = new IntersectionObserver(this.intersect);
  }

  start() {
    if (!this.started) {
      this.started = true;
      this.intersectionObserver.observe(this.element);
    }
  }

  stop() {
    if (this.started) {
      this.started = false;
      this.intersectionObserver.unobserve(this.element);
    }
  }

  intersect = (entries) => {
    const lastEntry = entries.slice(-1)[0];
    if (lastEntry?.isIntersecting) {
      this.delegate.elementAppearedInViewport(this.element);
    }
  }
}

class StreamMessage {
  static contentType = "text/vnd.turbo-stream.html"

  static wrap(message) {
    if (typeof message == "string") {
      return new this(createDocumentFragment(message))
    } else {
      return message
    }
  }

  constructor(fragment) {
    this.fragment = importStreamElements(fragment);
  }
}

function importStreamElements(fragment) {
  for (const element of fragment.querySelectorAll("turbo-stream")) {
    const streamElement = document.importNode(element, true);

    for (const inertScriptElement of streamElement.templateElement.content.querySelectorAll("script")) {
      inertScriptElement.replaceWith(activateScriptElement(inertScriptElement));
    }

    element.replaceWith(streamElement);
  }

  return fragment
}

const PREFETCH_DELAY = 100;

class PrefetchCache {
  #prefetchTimeout = null
  #prefetched = null

  get(url) {
    if (this.#prefetched && this.#prefetched.url === url && this.#prefetched.expire > Date.now()) {
      return this.#prefetched.request
    }
  }

  setLater(url, request, ttl) {
    this.clear();

    this.#prefetchTimeout = setTimeout(() => {
      request.perform();
      this.set(url, request, ttl);
      this.#prefetchTimeout = null;
    }, PREFETCH_DELAY);
  }

  set(url, request, ttl) {
    this.#prefetched = { url, request, expire: new Date(new Date().getTime() + ttl) };
  }

  clear() {
    if (this.#prefetchTimeout) clearTimeout(this.#prefetchTimeout);
    this.#prefetched = null;
  }
}

const cacheTtl = 10 * 1000;
const prefetchCache = new PrefetchCache();

const FormSubmissionState = {
  initialized: "initialized",
  requesting: "requesting",
  waiting: "waiting",
  receiving: "receiving",
  stopping: "stopping",
  stopped: "stopped"
};

class FormSubmission {
  state = FormSubmissionState.initialized

  static confirmMethod(message) {
    return Promise.resolve(confirm(message))
  }

  constructor(delegate, formElement, submitter, mustRedirect = false) {
    const method = getMethod(formElement, submitter);
    const action = getAction(getFormAction(formElement, submitter), method);
    const body = buildFormData(formElement, submitter);
    const enctype = getEnctype(formElement, submitter);

    this.delegate = delegate;
    this.formElement = formElement;
    this.submitter = submitter;
    this.fetchRequest = new FetchRequest(this, method, action, body, formElement, enctype);
    this.mustRedirect = mustRedirect;
  }

  get method() {
    return this.fetchRequest.method
  }

  set method(value) {
    this.fetchRequest.method = value;
  }

  get action() {
    return this.fetchRequest.url.toString()
  }

  set action(value) {
    this.fetchRequest.url = expandURL(value);
  }

  get body() {
    return this.fetchRequest.body
  }

  get enctype() {
    return this.fetchRequest.enctype
  }

  get isSafe() {
    return this.fetchRequest.isSafe
  }

  get location() {
    return this.fetchRequest.url
  }

  // The submission process

  async start() {
    const { initialized, requesting } = FormSubmissionState;
    const confirmationMessage = getAttribute("data-turbo-confirm", this.submitter, this.formElement);

    if (typeof confirmationMessage === "string") {
      const confirmMethod = typeof config.forms.confirm === "function" ?
        config.forms.confirm :
        FormSubmission.confirmMethod;

      const answer = await confirmMethod(confirmationMessage, this.formElement, this.submitter);
      if (!answer) {
        return
      }
    }

    if (this.state == initialized) {
      this.state = requesting;
      return this.fetchRequest.perform()
    }
  }

  stop() {
    const { stopping, stopped } = FormSubmissionState;
    if (this.state != stopping && this.state != stopped) {
      this.state = stopping;
      this.fetchRequest.cancel();
      return true
    }
  }

  // Fetch request delegate

  prepareRequest(request) {
    if (!request.isSafe) {
      const token = getCookieValue(getMetaContent("csrf-param")) || getMetaContent("csrf-token");
      if (token) {
        request.headers["X-CSRF-Token"] = token;
      }
    }

    if (this.requestAcceptsTurboStreamResponse(request)) {
      request.acceptResponseType(StreamMessage.contentType);
    }
  }

  requestStarted(_request) {
    this.state = FormSubmissionState.waiting;
    if (this.submitter) config.forms.submitter.beforeSubmit(this.submitter);
    this.setSubmitsWith();
    markAsBusy(this.formElement);
    dispatch("turbo:submit-start", {
      target: this.formElement,
      detail: { formSubmission: this }
    });
    this.delegate.formSubmissionStarted(this);
  }

  requestPreventedHandlingResponse(request, response) {
    prefetchCache.clear();

    this.result = { success: response.succeeded, fetchResponse: response };
  }

  requestSucceededWithResponse(request, response) {
    if (response.clientError || response.serverError) {
      this.delegate.formSubmissionFailedWithResponse(this, response);
      return
    }

    prefetchCache.clear();

    if (this.requestMustRedirect(request) && responseSucceededWithoutRedirect(response)) {
      const error = new Error("Form responses must redirect to another location");
      this.delegate.formSubmissionErrored(this, error);
    } else {
      this.state = FormSubmissionState.receiving;
      this.result = { success: true, fetchResponse: response };
      this.delegate.formSubmissionSucceededWithResponse(this, response);
    }
  }

  requestFailedWithResponse(request, response) {
    this.result = { success: false, fetchResponse: response };
    this.delegate.formSubmissionFailedWithResponse(this, response);
  }

  requestErrored(request, error) {
    this.result = { success: false, error };
    this.delegate.formSubmissionErrored(this, error);
  }

  requestFinished(_request) {
    this.state = FormSubmissionState.stopped;
    if (this.submitter) config.forms.submitter.afterSubmit(this.submitter);
    this.resetSubmitterText();
    clearBusyState(this.formElement);
    dispatch("turbo:submit-end", {
      target: this.formElement,
      detail: { formSubmission: this, ...this.result }
    });
    this.delegate.formSubmissionFinished(this);
  }

  // Private

  setSubmitsWith() {
    if (!this.submitter || !this.submitsWith) return

    if (this.submitter.matches("button")) {
      this.originalSubmitText = this.submitter.innerHTML;
      this.submitter.innerHTML = this.submitsWith;
    } else if (this.submitter.matches("input")) {
      const input = this.submitter;
      this.originalSubmitText = input.value;
      input.value = this.submitsWith;
    }
  }

  resetSubmitterText() {
    if (!this.submitter || !this.originalSubmitText) return

    if (this.submitter.matches("button")) {
      this.submitter.innerHTML = this.originalSubmitText;
    } else if (this.submitter.matches("input")) {
      const input = this.submitter;
      input.value = this.originalSubmitText;
    }
  }

  requestMustRedirect(request) {
    return !request.isSafe && this.mustRedirect
  }

  requestAcceptsTurboStreamResponse(request) {
    return !request.isSafe || hasAttribute("data-turbo-stream", this.submitter, this.formElement)
  }

  get submitsWith() {
    return this.submitter?.getAttribute("data-turbo-submits-with")
  }
}

function buildFormData(formElement, submitter) {
  const formData = new FormData(formElement);
  const name = submitter?.getAttribute("name");
  const value = submitter?.getAttribute("value");

  if (name) {
    formData.append(name, value || "");
  }

  return formData
}

function getCookieValue(cookieName) {
  if (cookieName != null) {
    const cookies = document.cookie ? document.cookie.split("; ") : [];
    const cookie = cookies.find((cookie) => cookie.startsWith(cookieName));
    if (cookie) {
      const value = cookie.split("=").slice(1).join("=");
      return value ? decodeURIComponent(value) : undefined
    }
  }
}

function responseSucceededWithoutRedirect(response) {
  return response.statusCode == 200 && !response.redirected
}

function getFormAction(formElement, submitter) {
  const formElementAction = typeof formElement.action === "string" ? formElement.action : null;

  if (submitter?.hasAttribute("formaction")) {
    return submitter.getAttribute("formaction") || ""
  } else {
    return formElement.getAttribute("action") || formElementAction || ""
  }
}

function getAction(formAction, fetchMethod) {
  const action = expandURL(formAction);

  if (isSafe(fetchMethod)) {
    action.search = "";
  }

  return action
}

function getMethod(formElement, submitter) {
  const method = submitter?.getAttribute("formmethod") || formElement.getAttribute("method") || "";
  return fetchMethodFromString(method.toLowerCase()) || FetchMethod.get
}

function getEnctype(formElement, submitter) {
  return fetchEnctypeFromString(submitter?.getAttribute("formenctype") || formElement.enctype)
}

class Snapshot {
  constructor(element) {
    this.element = element;
  }

  get activeElement() {
    return this.element.ownerDocument.activeElement
  }

  get children() {
    return [...this.element.children]
  }

  hasAnchor(anchor) {
    return this.getElementForAnchor(anchor) != null
  }

  getElementForAnchor(anchor) {
    return anchor ? this.element.querySelector(`[id='${anchor}'], a[name='${anchor}']`) : null
  }

  get isConnected() {
    return this.element.isConnected
  }

  get firstAutofocusableElement() {
    return queryAutofocusableElement(this.element)
  }

  get permanentElements() {
    return queryPermanentElementsAll(this.element)
  }

  getPermanentElementById(id) {
    return getPermanentElementById(this.element, id)
  }

  getPermanentElementMapForSnapshot(snapshot) {
    const permanentElementMap = {};

    for (const currentPermanentElement of this.permanentElements) {
      const { id } = currentPermanentElement;
      const newPermanentElement = snapshot.getPermanentElementById(id);
      if (newPermanentElement) {
        permanentElementMap[id] = [currentPermanentElement, newPermanentElement];
      }
    }

    return permanentElementMap
  }
}

function getPermanentElementById(node, id) {
  return node.querySelector(`#${id}[data-turbo-permanent]`)
}

function queryPermanentElementsAll(node) {
  return node.querySelectorAll("[id][data-turbo-permanent]")
}

class FormSubmitObserver {
  started = false

  constructor(delegate, eventTarget) {
    this.delegate = delegate;
    this.eventTarget = eventTarget;
  }

  start() {
    if (!this.started) {
      this.eventTarget.addEventListener("submit", this.submitCaptured, true);
      this.started = true;
    }
  }

  stop() {
    if (this.started) {
      this.eventTarget.removeEventListener("submit", this.submitCaptured, true);
      this.started = false;
    }
  }

  submitCaptured = () => {
    this.eventTarget.removeEventListener("submit", this.submitBubbled, false);
    this.eventTarget.addEventListener("submit", this.submitBubbled, false);
  }

  submitBubbled = (event) => {
    if (!event.defaultPrevented) {
      const form = event.target instanceof HTMLFormElement ? event.target : undefined;
      const submitter = event.submitter || undefined;

      if (
        form &&
        submissionDoesNotDismissDialog(form, submitter) &&
        submissionDoesNotTargetIFrame(form, submitter) &&
        this.delegate.willSubmitForm(form, submitter)
      ) {
        event.preventDefault();
        event.stopImmediatePropagation();
        this.delegate.formSubmitted(form, submitter);
      }
    }
  }
}

function submissionDoesNotDismissDialog(form, submitter) {
  const method = submitter?.getAttribute("formmethod") || form.getAttribute("method");

  return method != "dialog"
}

function submissionDoesNotTargetIFrame(form, submitter) {
  const target = submitter?.getAttribute("formtarget") || form.getAttribute("target");

  return doesNotTargetIFrame(target)
}

class View {
  #resolveRenderPromise = (_value) => {}
  #resolveInterceptionPromise = (_value) => {}

  constructor(delegate, element) {
    this.delegate = delegate;
    this.element = element;
  }

  // Scrolling

  scrollToAnchor(anchor) {
    const element = this.snapshot.getElementForAnchor(anchor);
    if (element) {
      this.scrollToElement(element);
      this.focusElement(element);
    } else {
      this.scrollToPosition({ x: 0, y: 0 });
    }
  }

  scrollToAnchorFromLocation(location) {
    this.scrollToAnchor(getAnchor(location));
  }

  scrollToElement(element) {
    element.scrollIntoView();
  }

  focusElement(element) {
    if (element instanceof HTMLElement) {
      if (element.hasAttribute("tabindex")) {
        element.focus();
      } else {
        element.setAttribute("tabindex", "-1");
        element.focus();
        element.removeAttribute("tabindex");
      }
    }
  }

  scrollToPosition({ x, y }) {
    this.scrollRoot.scrollTo(x, y);
  }

  scrollToTop() {
    this.scrollToPosition({ x: 0, y: 0 });
  }

  get scrollRoot() {
    return window
  }

  // Rendering

  async render(renderer) {
    const { isPreview, shouldRender, willRender, newSnapshot: snapshot } = renderer;

    // A workaround to ignore tracked element mismatch reloads when performing
    // a promoted Visit from a frame navigation
    const shouldInvalidate = willRender;

    if (shouldRender) {
      try {
        this.renderPromise = new Promise((resolve) => (this.#resolveRenderPromise = resolve));
        this.renderer = renderer;
        await this.prepareToRenderSnapshot(renderer);

        const renderInterception = new Promise((resolve) => (this.#resolveInterceptionPromise = resolve));
        const options = { resume: this.#resolveInterceptionPromise, render: this.renderer.renderElement, renderMethod: this.renderer.renderMethod };
        const immediateRender = this.delegate.allowsImmediateRender(snapshot, options);
        if (!immediateRender) await renderInterception;

        await this.renderSnapshot(renderer);
        this.delegate.viewRenderedSnapshot(snapshot, isPreview, this.renderer.renderMethod);
        this.delegate.preloadOnLoadLinksForView(this.element);
        this.finishRenderingSnapshot(renderer);
      } finally {
        delete this.renderer;
        this.#resolveRenderPromise(undefined);
        delete this.renderPromise;
      }
    } else if (shouldInvalidate) {
      this.invalidate(renderer.reloadReason);
    }
  }

  invalidate(reason) {
    this.delegate.viewInvalidated(reason);
  }

  async prepareToRenderSnapshot(renderer) {
    this.markAsPreview(renderer.isPreview);
    await renderer.prepareToRender();
  }

  markAsPreview(isPreview) {
    if (isPreview) {
      this.element.setAttribute("data-turbo-preview", "");
    } else {
      this.element.removeAttribute("data-turbo-preview");
    }
  }

  markVisitDirection(direction) {
    this.element.setAttribute("data-turbo-visit-direction", direction);
  }

  unmarkVisitDirection() {
    this.element.removeAttribute("data-turbo-visit-direction");
  }

  async renderSnapshot(renderer) {
    await renderer.render();
  }

  finishRenderingSnapshot(renderer) {
    renderer.finishRendering();
  }
}

class FrameView extends View {
  missing() {
    this.element.innerHTML = `<strong class="turbo-frame-error">Content missing</strong>`;
  }

  get snapshot() {
    return new Snapshot(this.element)
  }
}

class LinkInterceptor {
  constructor(delegate, element) {
    this.delegate = delegate;
    this.element = element;
  }

  start() {
    this.element.addEventListener("click", this.clickBubbled);
    document.addEventListener("turbo:click", this.linkClicked);
    document.addEventListener("turbo:before-visit", this.willVisit);
  }

  stop() {
    this.element.removeEventListener("click", this.clickBubbled);
    document.removeEventListener("turbo:click", this.linkClicked);
    document.removeEventListener("turbo:before-visit", this.willVisit);
  }

  clickBubbled = (event) => {
    if (this.clickEventIsSignificant(event)) {
      this.clickEvent = event;
    } else {
      delete this.clickEvent;
    }
  }

  linkClicked = (event) => {
    if (this.clickEvent && this.clickEventIsSignificant(event)) {
      if (this.delegate.shouldInterceptLinkClick(event.target, event.detail.url, event.detail.originalEvent)) {
        this.clickEvent.preventDefault();
        event.preventDefault();
        this.delegate.linkClickIntercepted(event.target, event.detail.url, event.detail.originalEvent);
      }
    }
    delete this.clickEvent;
  }

  willVisit = (_event) => {
    delete this.clickEvent;
  }

  clickEventIsSignificant(event) {
    const target = event.composed ? event.target?.parentElement : event.target;
    const element = findLinkFromClickTarget(target) || target;

    return element instanceof Element && element.closest("turbo-frame, html") == this.element
  }
}

class LinkClickObserver {
  started = false

  constructor(delegate, eventTarget) {
    this.delegate = delegate;
    this.eventTarget = eventTarget;
  }

  start() {
    if (!this.started) {
      this.eventTarget.addEventListener("click", this.clickCaptured, true);
      this.started = true;
    }
  }

  stop() {
    if (this.started) {
      this.eventTarget.removeEventListener("click", this.clickCaptured, true);
      this.started = false;
    }
  }

  clickCaptured = () => {
    this.eventTarget.removeEventListener("click", this.clickBubbled, false);
    this.eventTarget.addEventListener("click", this.clickBubbled, false);
  }

  clickBubbled = (event) => {
    if (event instanceof MouseEvent && this.clickEventIsSignificant(event)) {
      const target = (event.composedPath && event.composedPath()[0]) || event.target;
      const link = findLinkFromClickTarget(target);
      if (link && doesNotTargetIFrame(link.target)) {
        const location = getLocationForLink(link);
        if (this.delegate.willFollowLinkToLocation(link, location, event)) {
          event.preventDefault();
          this.delegate.followedLinkToLocation(link, location);
        }
      }
    }
  }

  clickEventIsSignificant(event) {
    return !(
      (event.target && event.target.isContentEditable) ||
      event.defaultPrevented ||
      event.which > 1 ||
      event.altKey ||
      event.ctrlKey ||
      event.metaKey ||
      event.shiftKey
    )
  }
}

class FormLinkClickObserver {
  constructor(delegate, element) {
    this.delegate = delegate;
    this.linkInterceptor = new LinkClickObserver(this, element);
  }

  start() {
    this.linkInterceptor.start();
  }

  stop() {
    this.linkInterceptor.stop();
  }

  // Link hover observer delegate

  canPrefetchRequestToLocation(link, location) {
    return false
  }

  prefetchAndCacheRequestToLocation(link, location) {
    return
  }

  // Link click observer delegate

  willFollowLinkToLocation(link, location, originalEvent) {
    return (
      this.delegate.willSubmitFormLinkToLocation(link, location, originalEvent) &&
      (link.hasAttribute("data-turbo-method") || link.hasAttribute("data-turbo-stream"))
    )
  }

  followedLinkToLocation(link, location) {
    const form = document.createElement("form");

    const type = "hidden";
    for (const [name, value] of location.searchParams) {
      form.append(Object.assign(document.createElement("input"), { type, name, value }));
    }

    const action = Object.assign(location, { search: "" });
    form.setAttribute("data-turbo", "true");
    form.setAttribute("action", action.href);
    form.setAttribute("hidden", "");

    const method = link.getAttribute("data-turbo-method");
    if (method) form.setAttribute("method", method);

    const turboFrame = link.getAttribute("data-turbo-frame");
    if (turboFrame) form.setAttribute("data-turbo-frame", turboFrame);

    const turboAction = getVisitAction(link);
    if (turboAction) form.setAttribute("data-turbo-action", turboAction);

    const turboConfirm = link.getAttribute("data-turbo-confirm");
    if (turboConfirm) form.setAttribute("data-turbo-confirm", turboConfirm);

    const turboStream = link.hasAttribute("data-turbo-stream");
    if (turboStream) form.setAttribute("data-turbo-stream", "");

    this.delegate.submittedFormLinkToLocation(link, location, form);

    document.body.appendChild(form);
    form.addEventListener("turbo:submit-end", () => form.remove(), { once: true });
    requestAnimationFrame(() => form.requestSubmit());
  }
}

class Bardo {
  static async preservingPermanentElements(delegate, permanentElementMap, callback) {
    const bardo = new this(delegate, permanentElementMap);
    bardo.enter();
    await callback();
    bardo.leave();
  }

  constructor(delegate, permanentElementMap) {
    this.delegate = delegate;
    this.permanentElementMap = permanentElementMap;
  }

  enter() {
    for (const id in this.permanentElementMap) {
      const [currentPermanentElement, newPermanentElement] = this.permanentElementMap[id];
      this.delegate.enteringBardo(currentPermanentElement, newPermanentElement);
      this.replaceNewPermanentElementWithPlaceholder(newPermanentElement);
    }
  }

  leave() {
    for (const id in this.permanentElementMap) {
      const [currentPermanentElement] = this.permanentElementMap[id];
      this.replaceCurrentPermanentElementWithClone(currentPermanentElement);
      this.replacePlaceholderWithPermanentElement(currentPermanentElement);
      this.delegate.leavingBardo(currentPermanentElement);
    }
  }

  replaceNewPermanentElementWithPlaceholder(permanentElement) {
    const placeholder = createPlaceholderForPermanentElement(permanentElement);
    permanentElement.replaceWith(placeholder);
  }

  replaceCurrentPermanentElementWithClone(permanentElement) {
    const clone = permanentElement.cloneNode(true);
    permanentElement.replaceWith(clone);
  }

  replacePlaceholderWithPermanentElement(permanentElement) {
    const placeholder = this.getPlaceholderById(permanentElement.id);
    placeholder?.replaceWith(permanentElement);
  }

  getPlaceholderById(id) {
    return this.placeholders.find((element) => element.content == id)
  }

  get placeholders() {
    return [...document.querySelectorAll("meta[name=turbo-permanent-placeholder][content]")]
  }
}

function createPlaceholderForPermanentElement(permanentElement) {
  const element = document.createElement("meta");
  element.setAttribute("name", "turbo-permanent-placeholder");
  element.setAttribute("content", permanentElement.id);
  return element
}

class Renderer {
  #activeElement = null

  static renderElement(currentElement, newElement) {
    // Abstract method
  }

  constructor(currentSnapshot, newSnapshot, isPreview, willRender = true) {
    this.currentSnapshot = currentSnapshot;
    this.newSnapshot = newSnapshot;
    this.isPreview = isPreview;
    this.willRender = willRender;
    this.renderElement = this.constructor.renderElement;
    this.promise = new Promise((resolve, reject) => (this.resolvingFunctions = { resolve, reject }));
  }

  get shouldRender() {
    return true
  }

  get shouldAutofocus() {
    return true
  }

  get reloadReason() {
    return
  }

  prepareToRender() {
    return
  }

  render() {
    // Abstract method
  }

  finishRendering() {
    if (this.resolvingFunctions) {
      this.resolvingFunctions.resolve();
      delete this.resolvingFunctions;
    }
  }

  async preservingPermanentElements(callback) {
    await Bardo.preservingPermanentElements(this, this.permanentElementMap, callback);
  }

  focusFirstAutofocusableElement() {
    if (this.shouldAutofocus) {
      const element = this.connectedSnapshot.firstAutofocusableElement;
      if (element) {
        element.focus();
      }
    }
  }

  // Bardo delegate

  enteringBardo(currentPermanentElement) {
    if (this.#activeElement) return

    if (currentPermanentElement.contains(this.currentSnapshot.activeElement)) {
      this.#activeElement = this.currentSnapshot.activeElement;
    }
  }

  leavingBardo(currentPermanentElement) {
    if (currentPermanentElement.contains(this.#activeElement) && this.#activeElement instanceof HTMLElement) {
      this.#activeElement.focus();

      this.#activeElement = null;
    }
  }

  get connectedSnapshot() {
    return this.newSnapshot.isConnected ? this.newSnapshot : this.currentSnapshot
  }

  get currentElement() {
    return this.currentSnapshot.element
  }

  get newElement() {
    return this.newSnapshot.element
  }

  get permanentElementMap() {
    return this.currentSnapshot.getPermanentElementMapForSnapshot(this.newSnapshot)
  }

  get renderMethod() {
    return "replace"
  }
}

class FrameRenderer extends Renderer {
  static renderElement(currentElement, newElement) {
    const destinationRange = document.createRange();
    destinationRange.selectNodeContents(currentElement);
    destinationRange.deleteContents();

    const frameElement = newElement;
    const sourceRange = frameElement.ownerDocument?.createRange();
    if (sourceRange) {
      sourceRange.selectNodeContents(frameElement);
      currentElement.appendChild(sourceRange.extractContents());
    }
  }

  constructor(delegate, currentSnapshot, newSnapshot, renderElement, isPreview, willRender = true) {
    super(currentSnapshot, newSnapshot, renderElement, isPreview, willRender);
    this.delegate = delegate;
  }

  get shouldRender() {
    return true
  }

  async render() {
    await nextRepaint();
    this.preservingPermanentElements(() => {
      this.loadFrameElement();
    });
    this.scrollFrameIntoView();
    await nextRepaint();
    this.focusFirstAutofocusableElement();
    await nextRepaint();
    this.activateScriptElements();
  }

  loadFrameElement() {
    this.delegate.willRenderFrame(this.currentElement, this.newElement);
    this.renderElement(this.currentElement, this.newElement);
  }

  scrollFrameIntoView() {
    if (this.currentElement.autoscroll || this.newElement.autoscroll) {
      const element = this.currentElement.firstElementChild;
      const block = readScrollLogicalPosition(this.currentElement.getAttribute("data-autoscroll-block"), "end");
      const behavior = readScrollBehavior(this.currentElement.getAttribute("data-autoscroll-behavior"), "auto");

      if (element) {
        element.scrollIntoView({ block, behavior });
        return true
      }
    }
    return false
  }

  activateScriptElements() {
    for (const inertScriptElement of this.newScriptElements) {
      const activatedScriptElement = activateScriptElement(inertScriptElement);
      inertScriptElement.replaceWith(activatedScriptElement);
    }
  }

  get newScriptElements() {
    return this.currentElement.querySelectorAll("script")
  }
}

function readScrollLogicalPosition(value, defaultValue) {
  if (value == "end" || value == "start" || value == "center" || value == "nearest") {
    return value
  } else {
    return defaultValue
  }
}

function readScrollBehavior(value, defaultValue) {
  if (value == "auto" || value == "smooth") {
    return value
  } else {
    return defaultValue
  }
}

/**
 * @typedef {object} ConfigHead
 *
 * @property {'merge' | 'append' | 'morph' | 'none'} [style]
 * @property {boolean} [block]
 * @property {boolean} [ignore]
 * @property {function(Element): boolean} [shouldPreserve]
 * @property {function(Element): boolean} [shouldReAppend]
 * @property {function(Element): boolean} [shouldRemove]
 * @property {function(Element, {added: Node[], kept: Element[], removed: Element[]}): void} [afterHeadMorphed]
 */

/**
 * @typedef {object} ConfigCallbacks
 *
 * @property {function(Node): boolean} [beforeNodeAdded]
 * @property {function(Node): void} [afterNodeAdded]
 * @property {function(Element, Node): boolean} [beforeNodeMorphed]
 * @property {function(Element, Node): void} [afterNodeMorphed]
 * @property {function(Element): boolean} [beforeNodeRemoved]
 * @property {function(Element): void} [afterNodeRemoved]
 * @property {function(string, Element, "update" | "remove"): boolean} [beforeAttributeUpdated]
 */

/**
 * @typedef {object} Config
 *
 * @property {'outerHTML' | 'innerHTML'} [morphStyle]
 * @property {boolean} [ignoreActive]
 * @property {boolean} [ignoreActiveValue]
 * @property {boolean} [restoreFocus]
 * @property {ConfigCallbacks} [callbacks]
 * @property {ConfigHead} [head]
 */

/**
 * @typedef {function} NoOp
 *
 * @returns {void}
 */

/**
 * @typedef {object} ConfigHeadInternal
 *
 * @property {'merge' | 'append' | 'morph' | 'none'} style
 * @property {boolean} [block]
 * @property {boolean} [ignore]
 * @property {(function(Element): boolean) | NoOp} shouldPreserve
 * @property {(function(Element): boolean) | NoOp} shouldReAppend
 * @property {(function(Element): boolean) | NoOp} shouldRemove
 * @property {(function(Element, {added: Node[], kept: Element[], removed: Element[]}): void) | NoOp} afterHeadMorphed
 */

/**
 * @typedef {object} ConfigCallbacksInternal
 *
 * @property {(function(Node): boolean) | NoOp} beforeNodeAdded
 * @property {(function(Node): void) | NoOp} afterNodeAdded
 * @property {(function(Node, Node): boolean) | NoOp} beforeNodeMorphed
 * @property {(function(Node, Node): void) | NoOp} afterNodeMorphed
 * @property {(function(Node): boolean) | NoOp} beforeNodeRemoved
 * @property {(function(Node): void) | NoOp} afterNodeRemoved
 * @property {(function(string, Element, "update" | "remove"): boolean) | NoOp} beforeAttributeUpdated
 */

/**
 * @typedef {object} ConfigInternal
 *
 * @property {'outerHTML' | 'innerHTML'} morphStyle
 * @property {boolean} [ignoreActive]
 * @property {boolean} [ignoreActiveValue]
 * @property {boolean} [restoreFocus]
 * @property {ConfigCallbacksInternal} callbacks
 * @property {ConfigHeadInternal} head
 */

/**
 * @typedef {Object} IdSets
 * @property {Set<string>} persistentIds
 * @property {Map<Node, Set<string>>} idMap
 */

/**
 * @typedef {Function} Morph
 *
 * @param {Element | Document} oldNode
 * @param {Element | Node | HTMLCollection | Node[] | string | null} newContent
 * @param {Config} [config]
 * @returns {undefined | Node[]}
 */

// base IIFE to define idiomorph
/**
 *
 * @type {{defaults: ConfigInternal, morph: Morph}}
 */
var Idiomorph = (function () {

  /**
   * @typedef {object} MorphContext
   *
   * @property {Element} target
   * @property {Element} newContent
   * @property {ConfigInternal} config
   * @property {ConfigInternal['morphStyle']} morphStyle
   * @property {ConfigInternal['ignoreActive']} ignoreActive
   * @property {ConfigInternal['ignoreActiveValue']} ignoreActiveValue
   * @property {ConfigInternal['restoreFocus']} restoreFocus
   * @property {Map<Node, Set<string>>} idMap
   * @property {Set<string>} persistentIds
   * @property {ConfigInternal['callbacks']} callbacks
   * @property {ConfigInternal['head']} head
   * @property {HTMLDivElement} pantry
   */

  //=============================================================================
  // AND NOW IT BEGINS...
  //=============================================================================

  const noOp = () => {};
  /**
   * Default configuration values, updatable by users now
   * @type {ConfigInternal}
   */
  const defaults = {
    morphStyle: "outerHTML",
    callbacks: {
      beforeNodeAdded: noOp,
      afterNodeAdded: noOp,
      beforeNodeMorphed: noOp,
      afterNodeMorphed: noOp,
      beforeNodeRemoved: noOp,
      afterNodeRemoved: noOp,
      beforeAttributeUpdated: noOp,
    },
    head: {
      style: "merge",
      shouldPreserve: (elt) => elt.getAttribute("im-preserve") === "true",
      shouldReAppend: (elt) => elt.getAttribute("im-re-append") === "true",
      shouldRemove: noOp,
      afterHeadMorphed: noOp,
    },
    restoreFocus: true,
  };

  /**
   * Core idiomorph function for morphing one DOM tree to another
   *
   * @param {Element | Document} oldNode
   * @param {Element | Node | HTMLCollection | Node[] | string | null} newContent
   * @param {Config} [config]
   * @returns {Promise<Node[]> | Node[]}
   */
  function morph(oldNode, newContent, config = {}) {
    oldNode = normalizeElement(oldNode);
    const newNode = normalizeParent(newContent);
    const ctx = createMorphContext(oldNode, newNode, config);

    const morphedNodes = saveAndRestoreFocus(ctx, () => {
      return withHeadBlocking(
        ctx,
        oldNode,
        newNode,
        /** @param {MorphContext} ctx */ (ctx) => {
          if (ctx.morphStyle === "innerHTML") {
            morphChildren(ctx, oldNode, newNode);
            return Array.from(oldNode.childNodes);
          } else {
            return morphOuterHTML(ctx, oldNode, newNode);
          }
        },
      );
    });

    ctx.pantry.remove();
    return morphedNodes;
  }

  /**
   * Morph just the outerHTML of the oldNode to the newContent
   * We have to be careful because the oldNode could have siblings which need to be untouched
   * @param {MorphContext} ctx
   * @param {Element} oldNode
   * @param {Element} newNode
   * @returns {Node[]}
   */
  function morphOuterHTML(ctx, oldNode, newNode) {
    const oldParent = normalizeParent(oldNode);

    // basis for calulating which nodes were morphed
    // since there may be unmorphed sibling nodes
    let childNodes = Array.from(oldParent.childNodes);
    const index = childNodes.indexOf(oldNode);
    // how many elements are to the right of the oldNode
    const rightMargin = childNodes.length - (index + 1);

    morphChildren(
      ctx,
      oldParent,
      newNode,
      // these two optional params are the secret sauce
      oldNode, // start point for iteration
      oldNode.nextSibling, // end point for iteration
    );

    // return just the morphed nodes
    childNodes = Array.from(oldParent.childNodes);
    return childNodes.slice(index, childNodes.length - rightMargin);
  }

  /**
   * @param {MorphContext} ctx
   * @param {Function} fn
   * @returns {Promise<Node[]> | Node[]}
   */
  function saveAndRestoreFocus(ctx, fn) {
    if (!ctx.config.restoreFocus) return fn();
    let activeElement =
      /** @type {HTMLInputElement|HTMLTextAreaElement|null} */ (
        document.activeElement
      );

    // don't bother if the active element is not an input or textarea
    if (
      !(
        activeElement instanceof HTMLInputElement ||
        activeElement instanceof HTMLTextAreaElement
      )
    ) {
      return fn();
    }

    const { id: activeElementId, selectionStart, selectionEnd } = activeElement;

    const results = fn();

    if (activeElementId && activeElementId !== document.activeElement?.id) {
      activeElement = ctx.target.querySelector(`#${activeElementId}`);
      activeElement?.focus();
    }
    if (activeElement && !activeElement.selectionEnd && selectionEnd) {
      activeElement.setSelectionRange(selectionStart, selectionEnd);
    }

    return results;
  }

  const morphChildren = (function () {
    /**
     * This is the core algorithm for matching up children.  The idea is to use id sets to try to match up
     * nodes as faithfully as possible.  We greedily match, which allows us to keep the algorithm fast, but
     * by using id sets, we are able to better match up with content deeper in the DOM.
     *
     * Basic algorithm:
     * - for each node in the new content:
     *   - search self and siblings for an id set match, falling back to a soft match
     *   - if match found
     *     - remove any nodes up to the match:
     *       - pantry persistent nodes
     *       - delete the rest
     *     - morph the match
     *   - elsif no match found, and node is persistent
     *     - find its match by querying the old root (future) and pantry (past)
     *     - move it and its children here
     *     - morph it
     *   - else
     *     - create a new node from scratch as a last result
     *
     * @param {MorphContext} ctx the merge context
     * @param {Element} oldParent the old content that we are merging the new content into
     * @param {Element} newParent the parent element of the new content
     * @param {Node|null} [insertionPoint] the point in the DOM we start morphing at (defaults to first child)
     * @param {Node|null} [endPoint] the point in the DOM we stop morphing at (defaults to after last child)
     */
    function morphChildren(
      ctx,
      oldParent,
      newParent,
      insertionPoint = null,
      endPoint = null,
    ) {
      // normalize
      if (
        oldParent instanceof HTMLTemplateElement &&
        newParent instanceof HTMLTemplateElement
      ) {
        // @ts-ignore we can pretend the DocumentFragment is an Element
        oldParent = oldParent.content;
        // @ts-ignore ditto
        newParent = newParent.content;
      }
      insertionPoint ||= oldParent.firstChild;

      // run through all the new content
      for (const newChild of newParent.childNodes) {
        // once we reach the end of the old parent content skip to the end and insert the rest
        if (insertionPoint && insertionPoint != endPoint) {
          const bestMatch = findBestMatch(
            ctx,
            newChild,
            insertionPoint,
            endPoint,
          );
          if (bestMatch) {
            // if the node to morph is not at the insertion point then remove/move up to it
            if (bestMatch !== insertionPoint) {
              removeNodesBetween(ctx, insertionPoint, bestMatch);
            }
            morphNode(bestMatch, newChild, ctx);
            insertionPoint = bestMatch.nextSibling;
            continue;
          }
        }

        // if the matching node is elsewhere in the original content
        if (newChild instanceof Element && ctx.persistentIds.has(newChild.id)) {
          // move it and all its children here and morph
          const movedChild = moveBeforeById(
            oldParent,
            newChild.id,
            insertionPoint,
            ctx,
          );
          morphNode(movedChild, newChild, ctx);
          insertionPoint = movedChild.nextSibling;
          continue;
        }

        // last resort: insert the new node from scratch
        const insertedNode = createNode(
          oldParent,
          newChild,
          insertionPoint,
          ctx,
        );
        // could be null if beforeNodeAdded prevented insertion
        if (insertedNode) {
          insertionPoint = insertedNode.nextSibling;
        }
      }

      // remove any remaining old nodes that didn't match up with new content
      while (insertionPoint && insertionPoint != endPoint) {
        const tempNode = insertionPoint;
        insertionPoint = insertionPoint.nextSibling;
        removeNode(ctx, tempNode);
      }
    }

    /**
     * This performs the action of inserting a new node while handling situations where the node contains
     * elements with persistent ids and possible state info we can still preserve by moving in and then morphing
     *
     * @param {Element} oldParent
     * @param {Node} newChild
     * @param {Node|null} insertionPoint
     * @param {MorphContext} ctx
     * @returns {Node|null}
     */
    function createNode(oldParent, newChild, insertionPoint, ctx) {
      if (ctx.callbacks.beforeNodeAdded(newChild) === false) return null;
      if (ctx.idMap.has(newChild)) {
        // node has children with ids with possible state so create a dummy elt of same type and apply full morph algorithm
        const newEmptyChild = document.createElement(
          /** @type {Element} */ (newChild).tagName,
        );
        oldParent.insertBefore(newEmptyChild, insertionPoint);
        morphNode(newEmptyChild, newChild, ctx);
        ctx.callbacks.afterNodeAdded(newEmptyChild);
        return newEmptyChild;
      } else {
        // optimisation: no id state to preserve so we can just insert a clone of the newChild and its descendants
        const newClonedChild = document.importNode(newChild, true); // importNode to not mutate newParent
        oldParent.insertBefore(newClonedChild, insertionPoint);
        ctx.callbacks.afterNodeAdded(newClonedChild);
        return newClonedChild;
      }
    }

    //=============================================================================
    // Matching Functions
    //=============================================================================
    const findBestMatch = (function () {
      /**
       * Scans forward from the startPoint to the endPoint looking for a match
       * for the node. It looks for an id set match first, then a soft match.
       * We abort softmatching if we find two future soft matches, to reduce churn.
       * @param {Node} node
       * @param {MorphContext} ctx
       * @param {Node | null} startPoint
       * @param {Node | null} endPoint
       * @returns {Node | null}
       */
      function findBestMatch(ctx, node, startPoint, endPoint) {
        let softMatch = null;
        let nextSibling = node.nextSibling;
        let siblingSoftMatchCount = 0;

        let cursor = startPoint;
        while (cursor && cursor != endPoint) {
          // soft matching is a prerequisite for id set matching
          if (isSoftMatch(cursor, node)) {
            if (isIdSetMatch(ctx, cursor, node)) {
              return cursor; // found an id set match, we're done!
            }

            // we haven't yet saved a soft match fallback
            if (softMatch === null) {
              // the current soft match will hard match something else in the future, leave it
              if (!ctx.idMap.has(cursor)) {
                // save this as the fallback if we get through the loop without finding a hard match
                softMatch = cursor;
              }
            }
          }
          if (
            softMatch === null &&
            nextSibling &&
            isSoftMatch(cursor, nextSibling)
          ) {
            // The next new node has a soft match with this node, so
            // increment the count of future soft matches
            siblingSoftMatchCount++;
            nextSibling = nextSibling.nextSibling;

            // If there are two future soft matches, block soft matching for this node to allow
            // future siblings to soft match. This is to reduce churn in the DOM when an element
            // is prepended.
            if (siblingSoftMatchCount >= 2) {
              softMatch = undefined;
            }
          }

          // if the current node contains active element, stop looking for better future matches,
          // because if one is found, this node will be moved to the pantry, reparenting it and thus losing focus
          if (cursor.contains(document.activeElement)) break;

          cursor = cursor.nextSibling;
        }

        return softMatch || null;
      }

      /**
       *
       * @param {MorphContext} ctx
       * @param {Node} oldNode
       * @param {Node} newNode
       * @returns {boolean}
       */
      function isIdSetMatch(ctx, oldNode, newNode) {
        let oldSet = ctx.idMap.get(oldNode);
        let newSet = ctx.idMap.get(newNode);

        if (!newSet || !oldSet) return false;

        for (const id of oldSet) {
          // a potential match is an id in the new and old nodes that
          // has not already been merged into the DOM
          // But the newNode content we call this on has not been
          // merged yet and we don't allow duplicate IDs so it is simple
          if (newSet.has(id)) {
            return true;
          }
        }
        return false;
      }

      /**
       *
       * @param {Node} oldNode
       * @param {Node} newNode
       * @returns {boolean}
       */
      function isSoftMatch(oldNode, newNode) {
        // ok to cast: if one is not element, `id` and `tagName` will be undefined and we'll just compare that.
        const oldElt = /** @type {Element} */ (oldNode);
        const newElt = /** @type {Element} */ (newNode);

        return (
          oldElt.nodeType === newElt.nodeType &&
          oldElt.tagName === newElt.tagName &&
          // If oldElt has an `id` with possible state and it doesn't match newElt.id then avoid morphing.
          // We'll still match an anonymous node with an IDed newElt, though, because if it got this far,
          // its not persistent, and new nodes can't have any hidden state.
          (!oldElt.id || oldElt.id === newElt.id)
        );
      }

      return findBestMatch;
    })();

    //=============================================================================
    // DOM Manipulation Functions
    //=============================================================================

    /**
     * Gets rid of an unwanted DOM node; strategy depends on nature of its reuse:
     * - Persistent nodes will be moved to the pantry for later reuse
     * - Other nodes will have their hooks called, and then are removed
     * @param {MorphContext} ctx
     * @param {Node} node
     */
    function removeNode(ctx, node) {
      // are we going to id set match this later?
      if (ctx.idMap.has(node)) {
        // skip callbacks and move to pantry
        moveBefore(ctx.pantry, node, null);
      } else {
        // remove for realsies
        if (ctx.callbacks.beforeNodeRemoved(node) === false) return;
        node.parentNode?.removeChild(node);
        ctx.callbacks.afterNodeRemoved(node);
      }
    }

    /**
     * Remove nodes between the start and end nodes
     * @param {MorphContext} ctx
     * @param {Node} startInclusive
     * @param {Node} endExclusive
     * @returns {Node|null}
     */
    function removeNodesBetween(ctx, startInclusive, endExclusive) {
      /** @type {Node | null} */
      let cursor = startInclusive;
      // remove nodes until the endExclusive node
      while (cursor && cursor !== endExclusive) {
        let tempNode = /** @type {Node} */ (cursor);
        cursor = cursor.nextSibling;
        removeNode(ctx, tempNode);
      }
      return cursor;
    }

    /**
     * Search for an element by id within the document and pantry, and move it using moveBefore.
     *
     * @param {Element} parentNode - The parent node to which the element will be moved.
     * @param {string} id - The ID of the element to be moved.
     * @param {Node | null} after - The reference node to insert the element before.
     *                              If `null`, the element is appended as the last child.
     * @param {MorphContext} ctx
     * @returns {Element} The found element
     */
    function moveBeforeById(parentNode, id, after, ctx) {
      const target =
        /** @type {Element} - will always be found */
        (
          ctx.target.querySelector(`#${id}`) ||
            ctx.pantry.querySelector(`#${id}`)
        );
      removeElementFromAncestorsIdMaps(target, ctx);
      moveBefore(parentNode, target, after);
      return target;
    }

    /**
     * Removes an element from its ancestors' id maps. This is needed when an element is moved from the
     * "future" via `moveBeforeId`. Otherwise, its erstwhile ancestors could be mistakenly moved to the
     * pantry rather than being deleted, preventing their removal hooks from being called.
     *
     * @param {Element} element - element to remove from its ancestors' id maps
     * @param {MorphContext} ctx
     */
    function removeElementFromAncestorsIdMaps(element, ctx) {
      const id = element.id;
      /** @ts-ignore - safe to loop in this way **/
      while ((element = element.parentNode)) {
        let idSet = ctx.idMap.get(element);
        if (idSet) {
          idSet.delete(id);
          if (!idSet.size) {
            ctx.idMap.delete(element);
          }
        }
      }
    }

    /**
     * Moves an element before another element within the same parent.
     * Uses the proposed `moveBefore` API if available (and working), otherwise falls back to `insertBefore`.
     * This is essentialy a forward-compat wrapper.
     *
     * @param {Element} parentNode - The parent node containing the after element.
     * @param {Node} element - The element to be moved.
     * @param {Node | null} after - The reference node to insert `element` before.
     *                              If `null`, `element` is appended as the last child.
     */
    function moveBefore(parentNode, element, after) {
      // @ts-ignore - use proposed moveBefore feature
      if (parentNode.moveBefore) {
        try {
          // @ts-ignore - use proposed moveBefore feature
          parentNode.moveBefore(element, after);
        } catch (e) {
          // fall back to insertBefore as some browsers may fail on moveBefore when trying to move Dom disconnected nodes to pantry
          parentNode.insertBefore(element, after);
        }
      } else {
        parentNode.insertBefore(element, after);
      }
    }

    return morphChildren;
  })();

  //=============================================================================
  // Single Node Morphing Code
  //=============================================================================
  const morphNode = (function () {
    /**
     * @param {Node} oldNode root node to merge content into
     * @param {Node} newContent new content to merge
     * @param {MorphContext} ctx the merge context
     * @returns {Node | null} the element that ended up in the DOM
     */
    function morphNode(oldNode, newContent, ctx) {
      if (ctx.ignoreActive && oldNode === document.activeElement) {
        // don't morph focused element
        return null;
      }

      if (ctx.callbacks.beforeNodeMorphed(oldNode, newContent) === false) {
        return oldNode;
      }

      if (oldNode instanceof HTMLHeadElement && ctx.head.ignore) ; else if (
        oldNode instanceof HTMLHeadElement &&
        ctx.head.style !== "morph"
      ) {
        // ok to cast: if newContent wasn't also a <head>, it would've got caught in the `!isSoftMatch` branch above
        handleHeadElement(
          oldNode,
          /** @type {HTMLHeadElement} */ (newContent),
          ctx,
        );
      } else {
        morphAttributes(oldNode, newContent, ctx);
        if (!ignoreValueOfActiveElement(oldNode, ctx)) {
          // @ts-ignore newContent can be a node here because .firstChild will be null
          morphChildren(ctx, oldNode, newContent);
        }
      }
      ctx.callbacks.afterNodeMorphed(oldNode, newContent);
      return oldNode;
    }

    /**
     * syncs the oldNode to the newNode, copying over all attributes and
     * inner element state from the newNode to the oldNode
     *
     * @param {Node} oldNode the node to copy attributes & state to
     * @param {Node} newNode the node to copy attributes & state from
     * @param {MorphContext} ctx the merge context
     */
    function morphAttributes(oldNode, newNode, ctx) {
      let type = newNode.nodeType;

      // if is an element type, sync the attributes from the
      // new node into the new node
      if (type === 1 /* element type */) {
        const oldElt = /** @type {Element} */ (oldNode);
        const newElt = /** @type {Element} */ (newNode);

        const oldAttributes = oldElt.attributes;
        const newAttributes = newElt.attributes;
        for (const newAttribute of newAttributes) {
          if (ignoreAttribute(newAttribute.name, oldElt, "update", ctx)) {
            continue;
          }
          if (oldElt.getAttribute(newAttribute.name) !== newAttribute.value) {
            oldElt.setAttribute(newAttribute.name, newAttribute.value);
          }
        }
        // iterate backwards to avoid skipping over items when a delete occurs
        for (let i = oldAttributes.length - 1; 0 <= i; i--) {
          const oldAttribute = oldAttributes[i];

          // toAttributes is a live NamedNodeMap, so iteration+mutation is unsafe
          // e.g. custom element attribute callbacks can remove other attributes
          if (!oldAttribute) continue;

          if (!newElt.hasAttribute(oldAttribute.name)) {
            if (ignoreAttribute(oldAttribute.name, oldElt, "remove", ctx)) {
              continue;
            }
            oldElt.removeAttribute(oldAttribute.name);
          }
        }

        if (!ignoreValueOfActiveElement(oldElt, ctx)) {
          syncInputValue(oldElt, newElt, ctx);
        }
      }

      // sync text nodes
      if (type === 8 /* comment */ || type === 3 /* text */) {
        if (oldNode.nodeValue !== newNode.nodeValue) {
          oldNode.nodeValue = newNode.nodeValue;
        }
      }
    }

    /**
     * NB: many bothans died to bring us information:
     *
     *  https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js
     *  https://github.com/choojs/nanomorph/blob/master/lib/morph.jsL113
     *
     * @param {Element} oldElement the element to sync the input value to
     * @param {Element} newElement the element to sync the input value from
     * @param {MorphContext} ctx the merge context
     */
    function syncInputValue(oldElement, newElement, ctx) {
      if (
        oldElement instanceof HTMLInputElement &&
        newElement instanceof HTMLInputElement &&
        newElement.type !== "file"
      ) {
        let newValue = newElement.value;
        let oldValue = oldElement.value;

        // sync boolean attributes
        syncBooleanAttribute(oldElement, newElement, "checked", ctx);
        syncBooleanAttribute(oldElement, newElement, "disabled", ctx);

        if (!newElement.hasAttribute("value")) {
          if (!ignoreAttribute("value", oldElement, "remove", ctx)) {
            oldElement.value = "";
            oldElement.removeAttribute("value");
          }
        } else if (oldValue !== newValue) {
          if (!ignoreAttribute("value", oldElement, "update", ctx)) {
            oldElement.setAttribute("value", newValue);
            oldElement.value = newValue;
          }
        }
        // TODO: QUESTION(1cg): this used to only check `newElement` unlike the other branches -- why?
        // did I break something?
      } else if (
        oldElement instanceof HTMLOptionElement &&
        newElement instanceof HTMLOptionElement
      ) {
        syncBooleanAttribute(oldElement, newElement, "selected", ctx);
      } else if (
        oldElement instanceof HTMLTextAreaElement &&
        newElement instanceof HTMLTextAreaElement
      ) {
        let newValue = newElement.value;
        let oldValue = oldElement.value;
        if (ignoreAttribute("value", oldElement, "update", ctx)) {
          return;
        }
        if (newValue !== oldValue) {
          oldElement.value = newValue;
        }
        if (
          oldElement.firstChild &&
          oldElement.firstChild.nodeValue !== newValue
        ) {
          oldElement.firstChild.nodeValue = newValue;
        }
      }
    }

    /**
     * @param {Element} oldElement element to write the value to
     * @param {Element} newElement element to read the value from
     * @param {string} attributeName the attribute name
     * @param {MorphContext} ctx the merge context
     */
    function syncBooleanAttribute(oldElement, newElement, attributeName, ctx) {
      // @ts-ignore this function is only used on boolean attrs that are reflected as dom properties
      const newLiveValue = newElement[attributeName],
        // @ts-ignore ditto
        oldLiveValue = oldElement[attributeName];
      if (newLiveValue !== oldLiveValue) {
        const ignoreUpdate = ignoreAttribute(
          attributeName,
          oldElement,
          "update",
          ctx,
        );
        if (!ignoreUpdate) {
          // update attribute's associated DOM property
          // @ts-ignore this function is only used on boolean attrs that are reflected as dom properties
          oldElement[attributeName] = newElement[attributeName];
        }
        if (newLiveValue) {
          if (!ignoreUpdate) {
            // https://developer.mozilla.org/en-US/docs/Glossary/Boolean/HTML
            // this is the correct way to set a boolean attribute to "true"
            oldElement.setAttribute(attributeName, "");
          }
        } else {
          if (!ignoreAttribute(attributeName, oldElement, "remove", ctx)) {
            oldElement.removeAttribute(attributeName);
          }
        }
      }
    }

    /**
     * @param {string} attr the attribute to be mutated
     * @param {Element} element the element that is going to be updated
     * @param {"update" | "remove"} updateType
     * @param {MorphContext} ctx the merge context
     * @returns {boolean} true if the attribute should be ignored, false otherwise
     */
    function ignoreAttribute(attr, element, updateType, ctx) {
      if (
        attr === "value" &&
        ctx.ignoreActiveValue &&
        element === document.activeElement
      ) {
        return true;
      }
      return (
        ctx.callbacks.beforeAttributeUpdated(attr, element, updateType) ===
        false
      );
    }

    /**
     * @param {Node} possibleActiveElement
     * @param {MorphContext} ctx
     * @returns {boolean}
     */
    function ignoreValueOfActiveElement(possibleActiveElement, ctx) {
      return (
        !!ctx.ignoreActiveValue &&
        possibleActiveElement === document.activeElement &&
        possibleActiveElement !== document.body
      );
    }

    return morphNode;
  })();

  //=============================================================================
  // Head Management Functions
  //=============================================================================
  /**
   * @param {MorphContext} ctx
   * @param {Element} oldNode
   * @param {Element} newNode
   * @param {function} callback
   * @returns {Node[] | Promise<Node[]>}
   */
  function withHeadBlocking(ctx, oldNode, newNode, callback) {
    if (ctx.head.block) {
      const oldHead = oldNode.querySelector("head");
      const newHead = newNode.querySelector("head");
      if (oldHead && newHead) {
        const promises = handleHeadElement(oldHead, newHead, ctx);
        // when head promises resolve, proceed ignoring the head tag
        return Promise.all(promises).then(() => {
          const newCtx = Object.assign(ctx, {
            head: {
              block: false,
              ignore: true,
            },
          });
          return callback(newCtx);
        });
      }
    }
    // just proceed if we not head blocking
    return callback(ctx);
  }

  /**
   *  The HEAD tag can be handled specially, either w/ a 'merge' or 'append' style
   *
   * @param {Element} oldHead
   * @param {Element} newHead
   * @param {MorphContext} ctx
   * @returns {Promise<void>[]}
   */
  function handleHeadElement(oldHead, newHead, ctx) {
    let added = [];
    let removed = [];
    let preserved = [];
    let nodesToAppend = [];

    // put all new head elements into a Map, by their outerHTML
    let srcToNewHeadNodes = new Map();
    for (const newHeadChild of newHead.children) {
      srcToNewHeadNodes.set(newHeadChild.outerHTML, newHeadChild);
    }

    // for each elt in the current head
    for (const currentHeadElt of oldHead.children) {
      // If the current head element is in the map
      let inNewContent = srcToNewHeadNodes.has(currentHeadElt.outerHTML);
      let isReAppended = ctx.head.shouldReAppend(currentHeadElt);
      let isPreserved = ctx.head.shouldPreserve(currentHeadElt);
      if (inNewContent || isPreserved) {
        if (isReAppended) {
          // remove the current version and let the new version replace it and re-execute
          removed.push(currentHeadElt);
        } else {
          // this element already exists and should not be re-appended, so remove it from
          // the new content map, preserving it in the DOM
          srcToNewHeadNodes.delete(currentHeadElt.outerHTML);
          preserved.push(currentHeadElt);
        }
      } else {
        if (ctx.head.style === "append") {
          // we are appending and this existing element is not new content
          // so if and only if it is marked for re-append do we do anything
          if (isReAppended) {
            removed.push(currentHeadElt);
            nodesToAppend.push(currentHeadElt);
          }
        } else {
          // if this is a merge, we remove this content since it is not in the new head
          if (ctx.head.shouldRemove(currentHeadElt) !== false) {
            removed.push(currentHeadElt);
          }
        }
      }
    }

    // Push the remaining new head elements in the Map into the
    // nodes to append to the head tag
    nodesToAppend.push(...srcToNewHeadNodes.values());

    let promises = [];
    for (const newNode of nodesToAppend) {
      // TODO: This could theoretically be null, based on type
      let newElt = /** @type {ChildNode} */ (
        document.createRange().createContextualFragment(newNode.outerHTML)
          .firstChild
      );
      if (ctx.callbacks.beforeNodeAdded(newElt) !== false) {
        if (
          ("href" in newElt && newElt.href) ||
          ("src" in newElt && newElt.src)
        ) {
          /** @type {(result?: any) => void} */ let resolve;
          let promise = new Promise(function (_resolve) {
            resolve = _resolve;
          });
          newElt.addEventListener("load", function () {
            resolve();
          });
          promises.push(promise);
        }
        oldHead.appendChild(newElt);
        ctx.callbacks.afterNodeAdded(newElt);
        added.push(newElt);
      }
    }

    // remove all removed elements, after we have appended the new elements to avoid
    // additional network requests for things like style sheets
    for (const removedElement of removed) {
      if (ctx.callbacks.beforeNodeRemoved(removedElement) !== false) {
        oldHead.removeChild(removedElement);
        ctx.callbacks.afterNodeRemoved(removedElement);
      }
    }

    ctx.head.afterHeadMorphed(oldHead, {
      added: added,
      kept: preserved,
      removed: removed,
    });
    return promises;
  }

  //=============================================================================
  // Create Morph Context Functions
  //=============================================================================
  const createMorphContext = (function () {
    /**
     *
     * @param {Element} oldNode
     * @param {Element} newContent
     * @param {Config} config
     * @returns {MorphContext}
     */
    function createMorphContext(oldNode, newContent, config) {
      const { persistentIds, idMap } = createIdMaps(oldNode, newContent);

      const mergedConfig = mergeDefaults(config);
      const morphStyle = mergedConfig.morphStyle || "outerHTML";
      if (!["innerHTML", "outerHTML"].includes(morphStyle)) {
        throw `Do not understand how to morph style ${morphStyle}`;
      }

      return {
        target: oldNode,
        newContent: newContent,
        config: mergedConfig,
        morphStyle: morphStyle,
        ignoreActive: mergedConfig.ignoreActive,
        ignoreActiveValue: mergedConfig.ignoreActiveValue,
        restoreFocus: mergedConfig.restoreFocus,
        idMap: idMap,
        persistentIds: persistentIds,
        pantry: createPantry(),
        callbacks: mergedConfig.callbacks,
        head: mergedConfig.head,
      };
    }

    /**
     * Deep merges the config object and the Idiomorph.defaults object to
     * produce a final configuration object
     * @param {Config} config
     * @returns {ConfigInternal}
     */
    function mergeDefaults(config) {
      let finalConfig = Object.assign({}, defaults);

      // copy top level stuff into final config
      Object.assign(finalConfig, config);

      // copy callbacks into final config (do this to deep merge the callbacks)
      finalConfig.callbacks = Object.assign(
        {},
        defaults.callbacks,
        config.callbacks,
      );

      // copy head config into final config  (do this to deep merge the head)
      finalConfig.head = Object.assign({}, defaults.head, config.head);

      return finalConfig;
    }

    /**
     * @returns {HTMLDivElement}
     */
    function createPantry() {
      const pantry = document.createElement("div");
      pantry.hidden = true;
      document.body.insertAdjacentElement("afterend", pantry);
      return pantry;
    }

    /**
     * Returns all elements with an ID contained within the root element and its descendants
     *
     * @param {Element} root
     * @returns {Element[]}
     */
    function findIdElements(root) {
      let elements = Array.from(root.querySelectorAll("[id]"));
      if (root.id) {
        elements.push(root);
      }
      return elements;
    }

    /**
     * A bottom-up algorithm that populates a map of Element -> IdSet.
     * The idSet for a given element is the set of all IDs contained within its subtree.
     * As an optimzation, we filter these IDs through the given list of persistent IDs,
     * because we don't need to bother considering IDed elements that won't be in the new content.
     *
     * @param {Map<Node, Set<string>>} idMap
     * @param {Set<string>} persistentIds
     * @param {Element} root
     * @param {Element[]} elements
     */
    function populateIdMapWithTree(idMap, persistentIds, root, elements) {
      for (const elt of elements) {
        if (persistentIds.has(elt.id)) {
          /** @type {Element|null} */
          let current = elt;
          // walk up the parent hierarchy of that element, adding the id
          // of element to the parent's id set
          while (current) {
            let idSet = idMap.get(current);
            // if the id set doesn't exist, create it and insert it in the map
            if (idSet == null) {
              idSet = new Set();
              idMap.set(current, idSet);
            }
            idSet.add(elt.id);

            if (current === root) break;
            current = current.parentElement;
          }
        }
      }
    }

    /**
     * This function computes a map of nodes to all ids contained within that node (inclusive of the
     * node).  This map can be used to ask if two nodes have intersecting sets of ids, which allows
     * for a looser definition of "matching" than tradition id matching, and allows child nodes
     * to contribute to a parent nodes matching.
     *
     * @param {Element} oldContent  the old content that will be morphed
     * @param {Element} newContent  the new content to morph to
     * @returns {IdSets}
     */
    function createIdMaps(oldContent, newContent) {
      const oldIdElements = findIdElements(oldContent);
      const newIdElements = findIdElements(newContent);

      const persistentIds = createPersistentIds(oldIdElements, newIdElements);

      /** @type {Map<Node, Set<string>>} */
      let idMap = new Map();
      populateIdMapWithTree(idMap, persistentIds, oldContent, oldIdElements);

      /** @ts-ignore - if newContent is a duck-typed parent, pass its single child node as the root to halt upwards iteration */
      const newRoot = newContent.__idiomorphRoot || newContent;
      populateIdMapWithTree(idMap, persistentIds, newRoot, newIdElements);

      return { persistentIds, idMap };
    }

    /**
     * This function computes the set of ids that persist between the two contents excluding duplicates
     *
     * @param {Element[]} oldIdElements
     * @param {Element[]} newIdElements
     * @returns {Set<string>}
     */
    function createPersistentIds(oldIdElements, newIdElements) {
      let duplicateIds = new Set();

      /** @type {Map<string, string>} */
      let oldIdTagNameMap = new Map();
      for (const { id, tagName } of oldIdElements) {
        if (oldIdTagNameMap.has(id)) {
          duplicateIds.add(id);
        } else {
          oldIdTagNameMap.set(id, tagName);
        }
      }

      let persistentIds = new Set();
      for (const { id, tagName } of newIdElements) {
        if (persistentIds.has(id)) {
          duplicateIds.add(id);
        } else if (oldIdTagNameMap.get(id) === tagName) {
          persistentIds.add(id);
        }
        // skip if tag types mismatch because its not possible to morph one tag into another
      }

      for (const id of duplicateIds) {
        persistentIds.delete(id);
      }
      return persistentIds;
    }

    return createMorphContext;
  })();

  //=============================================================================
  // HTML Normalization Functions
  //=============================================================================
  const { normalizeElement, normalizeParent } = (function () {
    /** @type {WeakSet<Node>} */
    const generatedByIdiomorph = new WeakSet();

    /**
     *
     * @param {Element | Document} content
     * @returns {Element}
     */
    function normalizeElement(content) {
      if (content instanceof Document) {
        return content.documentElement;
      } else {
        return content;
      }
    }

    /**
     *
     * @param {null | string | Node | HTMLCollection | Node[] | Document & {generatedByIdiomorph:boolean}} newContent
     * @returns {Element}
     */
    function normalizeParent(newContent) {
      if (newContent == null) {
        return document.createElement("div"); // dummy parent element
      } else if (typeof newContent === "string") {
        return normalizeParent(parseContent(newContent));
      } else if (
        generatedByIdiomorph.has(/** @type {Element} */ (newContent))
      ) {
        // the template tag created by idiomorph parsing can serve as a dummy parent
        return /** @type {Element} */ (newContent);
      } else if (newContent instanceof Node) {
        if (newContent.parentNode) {
          // we can't use the parent directly because newContent may have siblings
          // that we don't want in the morph, and reparenting might be expensive (TODO is it?),
          // so we create a duck-typed parent node instead.
          return createDuckTypedParent(newContent);
        } else {
          // a single node is added as a child to a dummy parent
          const dummyParent = document.createElement("div");
          dummyParent.append(newContent);
          return dummyParent;
        }
      } else {
        // all nodes in the array or HTMLElement collection are consolidated under
        // a single dummy parent element
        const dummyParent = document.createElement("div");
        for (const elt of [...newContent]) {
          dummyParent.append(elt);
        }
        return dummyParent;
      }
    }

    /**
     * Creates a fake duck-typed parent element to wrap a single node, without actually reparenting it.
     * "If it walks like a duck, and quacks like a duck, then it must be a duck!" -- James Whitcomb Riley (18491916)
     *
     * @param {Node} newContent
     * @returns {Element}
     */
    function createDuckTypedParent(newContent) {
      return /** @type {Element} */ (
        /** @type {unknown} */ ({
          childNodes: [newContent],
          /** @ts-ignore - cover your eyes for a minute, tsc */
          querySelectorAll: (s) => {
            /** @ts-ignore */
            const elements = newContent.querySelectorAll(s);
            /** @ts-ignore */
            return newContent.matches(s) ? [newContent, ...elements] : elements;
          },
          /** @ts-ignore */
          insertBefore: (n, r) => newContent.parentNode.insertBefore(n, r),
          /** @ts-ignore */
          moveBefore: (n, r) => newContent.parentNode.moveBefore(n, r),
          // for later use with populateIdMapWithTree to halt upwards iteration
          get __idiomorphRoot() {
            return newContent;
          },
        })
      );
    }

    /**
     *
     * @param {string} newContent
     * @returns {Node | null | DocumentFragment}
     */
    function parseContent(newContent) {
      let parser = new DOMParser();

      // remove svgs to avoid false-positive matches on head, etc.
      let contentWithSvgsRemoved = newContent.replace(
        /<svg(\s[^>]*>|>)([\s\S]*?)<\/svg>/gim,
        "",
      );

      // if the newContent contains a html, head or body tag, we can simply parse it w/o wrapping
      if (
        contentWithSvgsRemoved.match(/<\/html>/) ||
        contentWithSvgsRemoved.match(/<\/head>/) ||
        contentWithSvgsRemoved.match(/<\/body>/)
      ) {
        let content = parser.parseFromString(newContent, "text/html");
        // if it is a full HTML document, return the document itself as the parent container
        if (contentWithSvgsRemoved.match(/<\/html>/)) {
          generatedByIdiomorph.add(content);
          return content;
        } else {
          // otherwise return the html element as the parent container
          let htmlElement = content.firstChild;
          if (htmlElement) {
            generatedByIdiomorph.add(htmlElement);
          }
          return htmlElement;
        }
      } else {
        // if it is partial HTML, wrap it in a template tag to provide a parent element and also to help
        // deal with touchy tags like tr, tbody, etc.
        let responseDoc = parser.parseFromString(
          "<body><template>" + newContent + "</template></body>",
          "text/html",
        );
        let content = /** @type {HTMLTemplateElement} */ (
          responseDoc.body.querySelector("template")
        ).content;
        generatedByIdiomorph.add(content);
        return content;
      }
    }

    return { normalizeElement, normalizeParent };
  })();

  //=============================================================================
  // This is what ends up becoming the Idiomorph global object
  //=============================================================================
  return {
    morph,
    defaults,
  };
})();

function morphElements(currentElement, newElement, { callbacks, ...options } = {}) {
  Idiomorph.morph(currentElement, newElement, {
    ...options,
    callbacks: new DefaultIdiomorphCallbacks(callbacks)
  });
}

function morphChildren(currentElement, newElement) {
  morphElements(currentElement, newElement.childNodes, {
    morphStyle: "innerHTML"
  });
}

class DefaultIdiomorphCallbacks {
  #beforeNodeMorphed

  constructor({ beforeNodeMorphed } = {}) {
    this.#beforeNodeMorphed = beforeNodeMorphed || (() => true);
  }

  beforeNodeAdded = (node) => {
    return !(node.id && node.hasAttribute("data-turbo-permanent") && document.getElementById(node.id))
  }

  beforeNodeMorphed = (currentElement, newElement) => {
    if (currentElement instanceof Element) {
      if (!currentElement.hasAttribute("data-turbo-permanent") && this.#beforeNodeMorphed(currentElement, newElement)) {
        const event = dispatch("turbo:before-morph-element", {
          cancelable: true,
          target: currentElement,
          detail: { currentElement, newElement }
        });

        return !event.defaultPrevented
      } else {
        return false
      }
    }
  }

  beforeAttributeUpdated = (attributeName, target, mutationType) => {
    const event = dispatch("turbo:before-morph-attribute", {
      cancelable: true,
      target,
      detail: { attributeName, mutationType }
    });

    return !event.defaultPrevented
  }

  beforeNodeRemoved = (node) => {
    return this.beforeNodeMorphed(node)
  }

  afterNodeMorphed = (currentElement, newElement) => {
    if (currentElement instanceof Element) {
      dispatch("turbo:morph-element", {
        target: currentElement,
        detail: { currentElement, newElement }
      });
    }
  }
}

class MorphingFrameRenderer extends FrameRenderer {
  static renderElement(currentElement, newElement) {
    dispatch("turbo:before-frame-morph", {
      target: currentElement,
      detail: { currentElement, newElement }
    });

    morphChildren(currentElement, newElement);
  }

  async preservingPermanentElements(callback) {
    return await callback()
  }
}

class ProgressBar {
  static animationDuration = 300 /*ms*/

  static get defaultCSS() {
    return unindent`
      .turbo-progress-bar {
        position: fixed;
        display: block;
        top: 0;
        left: 0;
        height: 3px;
        background: #0076ff;
        z-index: 2147483647;
        transition:
          width ${ProgressBar.animationDuration}ms ease-out,
          opacity ${ProgressBar.animationDuration / 2}ms ${ProgressBar.animationDuration / 2}ms ease-in;
        transform: translate3d(0, 0, 0);
      }
    `
  }

  hiding = false
  value = 0
  visible = false

  constructor() {
    this.stylesheetElement = this.createStylesheetElement();
    this.progressElement = this.createProgressElement();
    this.installStylesheetElement();
    this.setValue(0);
  }

  show() {
    if (!this.visible) {
      this.visible = true;
      this.installProgressElement();
      this.startTrickling();
    }
  }

  hide() {
    if (this.visible && !this.hiding) {
      this.hiding = true;
      this.fadeProgressElement(() => {
        this.uninstallProgressElement();
        this.stopTrickling();
        this.visible = false;
        this.hiding = false;
      });
    }
  }

  setValue(value) {
    this.value = value;
    this.refresh();
  }

  // Private

  installStylesheetElement() {
    document.head.insertBefore(this.stylesheetElement, document.head.firstChild);
  }

  installProgressElement() {
    this.progressElement.style.width = "0";
    this.progressElement.style.opacity = "1";
    document.documentElement.insertBefore(this.progressElement, document.body);
    this.refresh();
  }

  fadeProgressElement(callback) {
    this.progressElement.style.opacity = "0";
    setTimeout(callback, ProgressBar.animationDuration * 1.5);
  }

  uninstallProgressElement() {
    if (this.progressElement.parentNode) {
      document.documentElement.removeChild(this.progressElement);
    }
  }

  startTrickling() {
    if (!this.trickleInterval) {
      this.trickleInterval = window.setInterval(this.trickle, ProgressBar.animationDuration);
    }
  }

  stopTrickling() {
    window.clearInterval(this.trickleInterval);
    delete this.trickleInterval;
  }

  trickle = () => {
    this.setValue(this.value + Math.random() / 100);
  }

  refresh() {
    requestAnimationFrame(() => {
      this.progressElement.style.width = `${10 + this.value * 90}%`;
    });
  }

  createStylesheetElement() {
    const element = document.createElement("style");
    element.type = "text/css";
    element.textContent = ProgressBar.defaultCSS;
    const cspNonce = getCspNonce();
    if (cspNonce) {
      element.nonce = cspNonce;
    }
    return element
  }

  createProgressElement() {
    const element = document.createElement("div");
    element.className = "turbo-progress-bar";
    return element
  }
}

class HeadSnapshot extends Snapshot {
  detailsByOuterHTML = this.children
    .filter((element) => !elementIsNoscript(element))
    .map((element) => elementWithoutNonce(element))
    .reduce((result, element) => {
      const { outerHTML } = element;
      const details =
        outerHTML in result
          ? result[outerHTML]
          : {
              type: elementType(element),
              tracked: elementIsTracked(element),
              elements: []
            };
      return {
        ...result,
        [outerHTML]: {
          ...details,
          elements: [...details.elements, element]
        }
      }
    }, {})

  get trackedElementSignature() {
    return Object.keys(this.detailsByOuterHTML)
      .filter((outerHTML) => this.detailsByOuterHTML[outerHTML].tracked)
      .join("")
  }

  getScriptElementsNotInSnapshot(snapshot) {
    return this.getElementsMatchingTypeNotInSnapshot("script", snapshot)
  }

  getStylesheetElementsNotInSnapshot(snapshot) {
    return this.getElementsMatchingTypeNotInSnapshot("stylesheet", snapshot)
  }

  getElementsMatchingTypeNotInSnapshot(matchedType, snapshot) {
    return Object.keys(this.detailsByOuterHTML)
      .filter((outerHTML) => !(outerHTML in snapshot.detailsByOuterHTML))
      .map((outerHTML) => this.detailsByOuterHTML[outerHTML])
      .filter(({ type }) => type == matchedType)
      .map(({ elements: [element] }) => element)
  }

  get provisionalElements() {
    return Object.keys(this.detailsByOuterHTML).reduce((result, outerHTML) => {
      const { type, tracked, elements } = this.detailsByOuterHTML[outerHTML];
      if (type == null && !tracked) {
        return [...result, ...elements]
      } else if (elements.length > 1) {
        return [...result, ...elements.slice(1)]
      } else {
        return result
      }
    }, [])
  }

  getMetaValue(name) {
    const element = this.findMetaElementByName(name);
    return element ? element.getAttribute("content") : null
  }

  findMetaElementByName(name) {
    return Object.keys(this.detailsByOuterHTML).reduce((result, outerHTML) => {
      const {
        elements: [element]
      } = this.detailsByOuterHTML[outerHTML];
      return elementIsMetaElementWithName(element, name) ? element : result
    }, undefined | undefined)
  }
}

function elementType(element) {
  if (elementIsScript(element)) {
    return "script"
  } else if (elementIsStylesheet(element)) {
    return "stylesheet"
  }
}

function elementIsTracked(element) {
  return element.getAttribute("data-turbo-track") == "reload"
}

function elementIsScript(element) {
  const tagName = element.localName;
  return tagName == "script"
}

function elementIsNoscript(element) {
  const tagName = element.localName;
  return tagName == "noscript"
}

function elementIsStylesheet(element) {
  const tagName = element.localName;
  return tagName == "style" || (tagName == "link" && element.getAttribute("rel") == "stylesheet")
}

function elementIsMetaElementWithName(element, name) {
  const tagName = element.localName;
  return tagName == "meta" && element.getAttribute("name") == name
}

function elementWithoutNonce(element) {
  if (element.hasAttribute("nonce")) {
    element.setAttribute("nonce", "");
  }

  return element
}

class PageSnapshot extends Snapshot {
  static fromHTMLString(html = "") {
    return this.fromDocument(parseHTMLDocument(html))
  }

  static fromElement(element) {
    return this.fromDocument(element.ownerDocument)
  }

  static fromDocument({ documentElement, body, head }) {
    return new this(documentElement, body, new HeadSnapshot(head))
  }

  constructor(documentElement, body, headSnapshot) {
    super(body);
    this.documentElement = documentElement;
    this.headSnapshot = headSnapshot;
  }

  clone() {
    const clonedElement = this.element.cloneNode(true);

    const selectElements = this.element.querySelectorAll("select");
    const clonedSelectElements = clonedElement.querySelectorAll("select");

    for (const [index, source] of selectElements.entries()) {
      const clone = clonedSelectElements[index];
      for (const option of clone.selectedOptions) option.selected = false;
      for (const option of source.selectedOptions) clone.options[option.index].selected = true;
    }

    for (const clonedPasswordInput of clonedElement.querySelectorAll('input[type="password"]')) {
      clonedPasswordInput.value = "";
    }

    return new PageSnapshot(this.documentElement, clonedElement, this.headSnapshot)
  }

  get lang() {
    return this.documentElement.getAttribute("lang")
  }

  get headElement() {
    return this.headSnapshot.element
  }

  get rootLocation() {
    const root = this.getSetting("root") ?? "/";
    return expandURL(root)
  }

  get cacheControlValue() {
    return this.getSetting("cache-control")
  }

  get isPreviewable() {
    return this.cacheControlValue != "no-preview"
  }

  get isCacheable() {
    return this.cacheControlValue != "no-cache"
  }

  get isVisitable() {
    return this.getSetting("visit-control") != "reload"
  }

  get prefersViewTransitions() {
    return this.headSnapshot.getMetaValue("view-transition") === "same-origin"
  }

  get shouldMorphPage() {
    return this.getSetting("refresh-method") === "morph"
  }

  get shouldPreserveScrollPosition() {
    return this.getSetting("refresh-scroll") === "preserve"
  }

  // Private

  getSetting(name) {
    return this.headSnapshot.getMetaValue(`turbo-${name}`)
  }
}

class ViewTransitioner {
  #viewTransitionStarted = false
  #lastOperation = Promise.resolve()

  renderChange(useViewTransition, render) {
    if (useViewTransition && this.viewTransitionsAvailable && !this.#viewTransitionStarted) {
      this.#viewTransitionStarted = true;
      this.#lastOperation = this.#lastOperation.then(async () => {
        await document.startViewTransition(render).finished;
      });
    } else {
      this.#lastOperation = this.#lastOperation.then(render);
    }

    return this.#lastOperation
  }

  get viewTransitionsAvailable() {
    return document.startViewTransition
  }
}

const defaultOptions = {
  action: "advance",
  historyChanged: false,
  visitCachedSnapshot: () => {},
  willRender: true,
  updateHistory: true,
  shouldCacheSnapshot: true,
  acceptsStreamResponse: false
};

const TimingMetric = {
  visitStart: "visitStart",
  requestStart: "requestStart",
  requestEnd: "requestEnd",
  visitEnd: "visitEnd"
};

const VisitState = {
  initialized: "initialized",
  started: "started",
  canceled: "canceled",
  failed: "failed",
  completed: "completed"
};

const SystemStatusCode = {
  networkFailure: 0,
  timeoutFailure: -1,
  contentTypeMismatch: -2
};

const Direction = {
  advance: "forward",
  restore: "back",
  replace: "none"
};

class Visit {
  identifier = uuid() // Required by turbo-ios
  timingMetrics = {}

  followedRedirect = false
  historyChanged = false
  scrolled = false
  shouldCacheSnapshot = true
  acceptsStreamResponse = false
  snapshotCached = false
  state = VisitState.initialized
  viewTransitioner = new ViewTransitioner()

  constructor(delegate, location, restorationIdentifier, options = {}) {
    this.delegate = delegate;
    this.location = location;
    this.restorationIdentifier = restorationIdentifier || uuid();

    const {
      action,
      historyChanged,
      referrer,
      snapshot,
      snapshotHTML,
      response,
      visitCachedSnapshot,
      willRender,
      updateHistory,
      shouldCacheSnapshot,
      acceptsStreamResponse,
      direction
    } = {
      ...defaultOptions,
      ...options
    };
    this.action = action;
    this.historyChanged = historyChanged;
    this.referrer = referrer;
    this.snapshot = snapshot;
    this.snapshotHTML = snapshotHTML;
    this.response = response;
    this.isSamePage = this.delegate.locationWithActionIsSamePage(this.location, this.action);
    this.isPageRefresh = this.view.isPageRefresh(this);
    this.visitCachedSnapshot = visitCachedSnapshot;
    this.willRender = willRender;
    this.updateHistory = updateHistory;
    this.scrolled = !willRender;
    this.shouldCacheSnapshot = shouldCacheSnapshot;
    this.acceptsStreamResponse = acceptsStreamResponse;
    this.direction = direction || Direction[action];
  }

  get adapter() {
    return this.delegate.adapter
  }

  get view() {
    return this.delegate.view
  }

  get history() {
    return this.delegate.history
  }

  get restorationData() {
    return this.history.getRestorationDataForIdentifier(this.restorationIdentifier)
  }

  get silent() {
    return this.isSamePage
  }

  start() {
    if (this.state == VisitState.initialized) {
      this.recordTimingMetric(TimingMetric.visitStart);
      this.state = VisitState.started;
      this.adapter.visitStarted(this);
      this.delegate.visitStarted(this);
    }
  }

  cancel() {
    if (this.state == VisitState.started) {
      if (this.request) {
        this.request.cancel();
      }
      this.cancelRender();
      this.state = VisitState.canceled;
    }
  }

  complete() {
    if (this.state == VisitState.started) {
      this.recordTimingMetric(TimingMetric.visitEnd);
      this.adapter.visitCompleted(this);
      this.state = VisitState.completed;
      this.followRedirect();

      if (!this.followedRedirect) {
        this.delegate.visitCompleted(this);
      }
    }
  }

  fail() {
    if (this.state == VisitState.started) {
      this.state = VisitState.failed;
      this.adapter.visitFailed(this);
      this.delegate.visitCompleted(this);
    }
  }

  changeHistory() {
    if (!this.historyChanged && this.updateHistory) {
      const actionForHistory = this.location.href === this.referrer?.href ? "replace" : this.action;
      const method = getHistoryMethodForAction(actionForHistory);
      this.history.update(method, this.location, this.restorationIdentifier);
      this.historyChanged = true;
    }
  }

  issueRequest() {
    if (this.hasPreloadedResponse()) {
      this.simulateRequest();
    } else if (this.shouldIssueRequest() && !this.request) {
      this.request = new FetchRequest(this, FetchMethod.get, this.location);
      this.request.perform();
    }
  }

  simulateRequest() {
    if (this.response) {
      this.startRequest();
      this.recordResponse();
      this.finishRequest();
    }
  }

  startRequest() {
    this.recordTimingMetric(TimingMetric.requestStart);
    this.adapter.visitRequestStarted(this);
  }

  recordResponse(response = this.response) {
    this.response = response;
    if (response) {
      const { statusCode } = response;
      if (isSuccessful(statusCode)) {
        this.adapter.visitRequestCompleted(this);
      } else {
        this.adapter.visitRequestFailedWithStatusCode(this, statusCode);
      }
    }
  }

  finishRequest() {
    this.recordTimingMetric(TimingMetric.requestEnd);
    this.adapter.visitRequestFinished(this);
  }

  loadResponse() {
    if (this.response) {
      const { statusCode, responseHTML } = this.response;
      this.render(async () => {
        if (this.shouldCacheSnapshot) this.cacheSnapshot();
        if (this.view.renderPromise) await this.view.renderPromise;

        if (isSuccessful(statusCode) && responseHTML != null) {
          const snapshot = PageSnapshot.fromHTMLString(responseHTML);
          await this.renderPageSnapshot(snapshot, false);

          this.adapter.visitRendered(this);
          this.complete();
        } else {
          await this.view.renderError(PageSnapshot.fromHTMLString(responseHTML), this);
          this.adapter.visitRendered(this);
          this.fail();
        }
      });
    }
  }

  getCachedSnapshot() {
    const snapshot = this.view.getCachedSnapshotForLocation(this.location) || this.getPreloadedSnapshot();

    if (snapshot && (!getAnchor(this.location) || snapshot.hasAnchor(getAnchor(this.location)))) {
      if (this.action == "restore" || snapshot.isPreviewable) {
        return snapshot
      }
    }
  }

  getPreloadedSnapshot() {
    if (this.snapshotHTML) {
      return PageSnapshot.fromHTMLString(this.snapshotHTML)
    }
  }

  hasCachedSnapshot() {
    return this.getCachedSnapshot() != null
  }

  loadCachedSnapshot() {
    const snapshot = this.getCachedSnapshot();
    if (snapshot) {
      const isPreview = this.shouldIssueRequest();
      this.render(async () => {
        this.cacheSnapshot();
        if (this.isSamePage || this.isPageRefresh) {
          this.adapter.visitRendered(this);
        } else {
          if (this.view.renderPromise) await this.view.renderPromise;

          await this.renderPageSnapshot(snapshot, isPreview);

          this.adapter.visitRendered(this);
          if (!isPreview) {
            this.complete();
          }
        }
      });
    }
  }

  followRedirect() {
    if (this.redirectedToLocation && !this.followedRedirect && this.response?.redirected) {
      this.adapter.visitProposedToLocation(this.redirectedToLocation, {
        action: "replace",
        response: this.response,
        shouldCacheSnapshot: false,
        willRender: false
      });
      this.followedRedirect = true;
    }
  }

  goToSamePageAnchor() {
    if (this.isSamePage) {
      this.render(async () => {
        this.cacheSnapshot();
        this.performScroll();
        this.changeHistory();
        this.adapter.visitRendered(this);
      });
    }
  }

  // Fetch request delegate

  prepareRequest(request) {
    if (this.acceptsStreamResponse) {
      request.acceptResponseType(StreamMessage.contentType);
    }
  }

  requestStarted() {
    this.startRequest();
  }

  requestPreventedHandlingResponse(_request, _response) {}

  async requestSucceededWithResponse(request, response) {
    const responseHTML = await response.responseHTML;
    const { redirected, statusCode } = response;
    if (responseHTML == undefined) {
      this.recordResponse({
        statusCode: SystemStatusCode.contentTypeMismatch,
        redirected
      });
    } else {
      this.redirectedToLocation = response.redirected ? response.location : undefined;
      this.recordResponse({ statusCode: statusCode, responseHTML, redirected });
    }
  }

  async requestFailedWithResponse(request, response) {
    const responseHTML = await response.responseHTML;
    const { redirected, statusCode } = response;
    if (responseHTML == undefined) {
      this.recordResponse({
        statusCode: SystemStatusCode.contentTypeMismatch,
        redirected
      });
    } else {
      this.recordResponse({ statusCode: statusCode, responseHTML, redirected });
    }
  }

  requestErrored(_request, _error) {
    this.recordResponse({
      statusCode: SystemStatusCode.networkFailure,
      redirected: false
    });
  }

  requestFinished() {
    this.finishRequest();
  }

  // Scrolling

  performScroll() {
    if (!this.scrolled && !this.view.forceReloaded && !this.view.shouldPreserveScrollPosition(this)) {
      if (this.action == "restore") {
        this.scrollToRestoredPosition() || this.scrollToAnchor() || this.view.scrollToTop();
      } else {
        this.scrollToAnchor() || this.view.scrollToTop();
      }
      if (this.isSamePage) {
        this.delegate.visitScrolledToSamePageLocation(this.view.lastRenderedLocation, this.location);
      }

      this.scrolled = true;
    }
  }

  scrollToRestoredPosition() {
    const { scrollPosition } = this.restorationData;
    if (scrollPosition) {
      this.view.scrollToPosition(scrollPosition);
      return true
    }
  }

  scrollToAnchor() {
    const anchor = getAnchor(this.location);
    if (anchor != null) {
      this.view.scrollToAnchor(anchor);
      return true
    }
  }

  // Instrumentation

  recordTimingMetric(metric) {
    this.timingMetrics[metric] = new Date().getTime();
  }

  getTimingMetrics() {
    return { ...this.timingMetrics }
  }

  // Private

  hasPreloadedResponse() {
    return typeof this.response == "object"
  }

  shouldIssueRequest() {
    if (this.isSamePage) {
      return false
    } else if (this.action == "restore") {
      return !this.hasCachedSnapshot()
    } else {
      return this.willRender
    }
  }

  cacheSnapshot() {
    if (!this.snapshotCached) {
      this.view.cacheSnapshot(this.snapshot).then((snapshot) => snapshot && this.visitCachedSnapshot(snapshot));
      this.snapshotCached = true;
    }
  }

  async render(callback) {
    this.cancelRender();
    await new Promise((resolve) => {
      this.frame =
        document.visibilityState === "hidden" ? setTimeout(() => resolve(), 0) : requestAnimationFrame(() => resolve());
    });
    await callback();
    delete this.frame;
  }

  async renderPageSnapshot(snapshot, isPreview) {
    await this.viewTransitioner.renderChange(this.view.shouldTransitionTo(snapshot), async () => {
      await this.view.renderPage(snapshot, isPreview, this.willRender, this);
      this.performScroll();
    });
  }

  cancelRender() {
    if (this.frame) {
      cancelAnimationFrame(this.frame);
      delete this.frame;
    }
  }
}

function isSuccessful(statusCode) {
  return statusCode >= 200 && statusCode < 300
}

class BrowserAdapter {
  progressBar = new ProgressBar()

  constructor(session) {
    this.session = session;
  }

  visitProposedToLocation(location, options) {
    if (locationIsVisitable(location, this.navigator.rootLocation)) {
      this.navigator.startVisit(location, options?.restorationIdentifier || uuid(), options);
    } else {
      window.location.href = location.toString();
    }
  }

  visitStarted(visit) {
    this.location = visit.location;
    visit.loadCachedSnapshot();
    visit.issueRequest();
    visit.goToSamePageAnchor();
  }

  visitRequestStarted(visit) {
    this.progressBar.setValue(0);
    if (visit.hasCachedSnapshot() || visit.action != "restore") {
      this.showVisitProgressBarAfterDelay();
    } else {
      this.showProgressBar();
    }
  }

  visitRequestCompleted(visit) {
    visit.loadResponse();
  }

  visitRequestFailedWithStatusCode(visit, statusCode) {
    switch (statusCode) {
      case SystemStatusCode.networkFailure:
      case SystemStatusCode.timeoutFailure:
      case SystemStatusCode.contentTypeMismatch:
        return this.reload({
          reason: "request_failed",
          context: {
            statusCode
          }
        })
      default:
        return visit.loadResponse()
    }
  }

  visitRequestFinished(_visit) {}

  visitCompleted(_visit) {
    this.progressBar.setValue(1);
    this.hideVisitProgressBar();
  }

  pageInvalidated(reason) {
    this.reload(reason);
  }

  visitFailed(_visit) {
    this.progressBar.setValue(1);
    this.hideVisitProgressBar();
  }

  visitRendered(_visit) {}

  // Link prefetching

  linkPrefetchingIsEnabledForLocation(location) {
    return true
  }

  // Form Submission Delegate

  formSubmissionStarted(_formSubmission) {
    this.progressBar.setValue(0);
    this.showFormProgressBarAfterDelay();
  }

  formSubmissionFinished(_formSubmission) {
    this.progressBar.setValue(1);
    this.hideFormProgressBar();
  }

  // Private

  showVisitProgressBarAfterDelay() {
    this.visitProgressBarTimeout = window.setTimeout(this.showProgressBar, this.session.progressBarDelay);
  }

  hideVisitProgressBar() {
    this.progressBar.hide();
    if (this.visitProgressBarTimeout != null) {
      window.clearTimeout(this.visitProgressBarTimeout);
      delete this.visitProgressBarTimeout;
    }
  }

  showFormProgressBarAfterDelay() {
    if (this.formProgressBarTimeout == null) {
      this.formProgressBarTimeout = window.setTimeout(this.showProgressBar, this.session.progressBarDelay);
    }
  }

  hideFormProgressBar() {
    this.progressBar.hide();
    if (this.formProgressBarTimeout != null) {
      window.clearTimeout(this.formProgressBarTimeout);
      delete this.formProgressBarTimeout;
    }
  }

  showProgressBar = () => {
    this.progressBar.show();
  }

  reload(reason) {
    dispatch("turbo:reload", { detail: reason });

    window.location.href = this.location?.toString() || window.location.href;
  }

  get navigator() {
    return this.session.navigator
  }
}

class CacheObserver {
  selector = "[data-turbo-temporary]"
  deprecatedSelector = "[data-turbo-cache=false]"

  started = false

  start() {
    if (!this.started) {
      this.started = true;
      addEventListener("turbo:before-cache", this.removeTemporaryElements, false);
    }
  }

  stop() {
    if (this.started) {
      this.started = false;
      removeEventListener("turbo:before-cache", this.removeTemporaryElements, false);
    }
  }

  removeTemporaryElements = (_event) => {
    for (const element of this.temporaryElements) {
      element.remove();
    }
  }

  get temporaryElements() {
    return [...document.querySelectorAll(this.selector), ...this.temporaryElementsWithDeprecation]
  }

  get temporaryElementsWithDeprecation() {
    const elements = document.querySelectorAll(this.deprecatedSelector);

    if (elements.length) {
      console.warn(
        `The ${this.deprecatedSelector} selector is deprecated and will be removed in a future version. Use ${this.selector} instead.`
      );
    }

    return [...elements]
  }
}

class FrameRedirector {
  constructor(session, element) {
    this.session = session;
    this.element = element;
    this.linkInterceptor = new LinkInterceptor(this, element);
    this.formSubmitObserver = new FormSubmitObserver(this, element);
  }

  start() {
    this.linkInterceptor.start();
    this.formSubmitObserver.start();
  }

  stop() {
    this.linkInterceptor.stop();
    this.formSubmitObserver.stop();
  }

  // Link interceptor delegate

  shouldInterceptLinkClick(element, _location, _event) {
    return this.#shouldRedirect(element)
  }

  linkClickIntercepted(element, url, event) {
    const frame = this.#findFrameElement(element);
    if (frame) {
      frame.delegate.linkClickIntercepted(element, url, event);
    }
  }

  // Form submit observer delegate

  willSubmitForm(element, submitter) {
    return (
      element.closest("turbo-frame") == null &&
      this.#shouldSubmit(element, submitter) &&
      this.#shouldRedirect(element, submitter)
    )
  }

  formSubmitted(element, submitter) {
    const frame = this.#findFrameElement(element, submitter);
    if (frame) {
      frame.delegate.formSubmitted(element, submitter);
    }
  }

  #shouldSubmit(form, submitter) {
    const action = getAction$1(form, submitter);
    const meta = this.element.ownerDocument.querySelector(`meta[name="turbo-root"]`);
    const rootLocation = expandURL(meta?.content ?? "/");

    return this.#shouldRedirect(form, submitter) && locationIsVisitable(action, rootLocation)
  }

  #shouldRedirect(element, submitter) {
    const isNavigatable =
      element instanceof HTMLFormElement
        ? this.session.submissionIsNavigatable(element, submitter)
        : this.session.elementIsNavigatable(element);

    if (isNavigatable) {
      const frame = this.#findFrameElement(element, submitter);
      return frame ? frame != element.closest("turbo-frame") : false
    } else {
      return false
    }
  }

  #findFrameElement(element, submitter) {
    const id = submitter?.getAttribute("data-turbo-frame") || element.getAttribute("data-turbo-frame");
    if (id && id != "_top") {
      const frame = this.element.querySelector(`#${id}:not([disabled])`);
      if (frame instanceof FrameElement) {
        return frame
      }
    }
  }
}

class History {
  location
  restorationIdentifier = uuid()
  restorationData = {}
  started = false
  pageLoaded = false
  currentIndex = 0

  constructor(delegate) {
    this.delegate = delegate;
  }

  start() {
    if (!this.started) {
      addEventListener("popstate", this.onPopState, false);
      addEventListener("load", this.onPageLoad, false);
      this.currentIndex = history.state?.turbo?.restorationIndex || 0;
      this.started = true;
      this.replace(new URL(window.location.href));
    }
  }

  stop() {
    if (this.started) {
      removeEventListener("popstate", this.onPopState, false);
      removeEventListener("load", this.onPageLoad, false);
      this.started = false;
    }
  }

  push(location, restorationIdentifier) {
    this.update(history.pushState, location, restorationIdentifier);
  }

  replace(location, restorationIdentifier) {
    this.update(history.replaceState, location, restorationIdentifier);
  }

  update(method, location, restorationIdentifier = uuid()) {
    if (method === history.pushState) ++this.currentIndex;

    const state = { turbo: { restorationIdentifier, restorationIndex: this.currentIndex } };
    method.call(history, state, "", location.href);
    this.location = location;
    this.restorationIdentifier = restorationIdentifier;
  }

  // Restoration data

  getRestorationDataForIdentifier(restorationIdentifier) {
    return this.restorationData[restorationIdentifier] || {}
  }

  updateRestorationData(additionalData) {
    const { restorationIdentifier } = this;
    const restorationData = this.restorationData[restorationIdentifier];
    this.restorationData[restorationIdentifier] = {
      ...restorationData,
      ...additionalData
    };
  }

  // Scroll restoration

  assumeControlOfScrollRestoration() {
    if (!this.previousScrollRestoration) {
      this.previousScrollRestoration = history.scrollRestoration ?? "auto";
      history.scrollRestoration = "manual";
    }
  }

  relinquishControlOfScrollRestoration() {
    if (this.previousScrollRestoration) {
      history.scrollRestoration = this.previousScrollRestoration;
      delete this.previousScrollRestoration;
    }
  }

  // Event handlers

  onPopState = (event) => {
    if (this.shouldHandlePopState()) {
      const { turbo } = event.state || {};
      if (turbo) {
        this.location = new URL(window.location.href);
        const { restorationIdentifier, restorationIndex } = turbo;
        this.restorationIdentifier = restorationIdentifier;
        const direction = restorationIndex > this.currentIndex ? "forward" : "back";
        this.delegate.historyPoppedToLocationWithRestorationIdentifierAndDirection(this.location, restorationIdentifier, direction);
        this.currentIndex = restorationIndex;
      }
    }
  }

  onPageLoad = async (_event) => {
    await nextMicrotask();
    this.pageLoaded = true;
  }

  // Private

  shouldHandlePopState() {
    // Safari dispatches a popstate event after window's load event, ignore it
    return this.pageIsLoaded()
  }

  pageIsLoaded() {
    return this.pageLoaded || document.readyState == "complete"
  }
}

class LinkPrefetchObserver {
  started = false
  #prefetchedLink = null

  constructor(delegate, eventTarget) {
    this.delegate = delegate;
    this.eventTarget = eventTarget;
  }

  start() {
    if (this.started) return

    if (this.eventTarget.readyState === "loading") {
      this.eventTarget.addEventListener("DOMContentLoaded", this.#enable, { once: true });
    } else {
      this.#enable();
    }
  }

  stop() {
    if (!this.started) return

    this.eventTarget.removeEventListener("mouseenter", this.#tryToPrefetchRequest, {
      capture: true,
      passive: true
    });
    this.eventTarget.removeEventListener("mouseleave", this.#cancelRequestIfObsolete, {
      capture: true,
      passive: true
    });

    this.eventTarget.removeEventListener("turbo:before-fetch-request", this.#tryToUsePrefetchedRequest, true);
    this.started = false;
  }

  #enable = () => {
    this.eventTarget.addEventListener("mouseenter", this.#tryToPrefetchRequest, {
      capture: true,
      passive: true
    });
    this.eventTarget.addEventListener("mouseleave", this.#cancelRequestIfObsolete, {
      capture: true,
      passive: true
    });

    this.eventTarget.addEventListener("turbo:before-fetch-request", this.#tryToUsePrefetchedRequest, true);
    this.started = true;
  }

  #tryToPrefetchRequest = (event) => {
    if (getMetaContent("turbo-prefetch") === "false") return

    const target = event.target;
    const isLink = target.matches && target.matches("a[href]:not([target^=_]):not([download])");

    if (isLink && this.#isPrefetchable(target)) {
      const link = target;
      const location = getLocationForLink(link);

      if (this.delegate.canPrefetchRequestToLocation(link, location)) {
        this.#prefetchedLink = link;

        const fetchRequest = new FetchRequest(
          this,
          FetchMethod.get,
          location,
          new URLSearchParams(),
          target
        );

        prefetchCache.setLater(location.toString(), fetchRequest, this.#cacheTtl);
      }
    }
  }

  #cancelRequestIfObsolete = (event) => {
    if (event.target === this.#prefetchedLink) this.#cancelPrefetchRequest();
  }

  #cancelPrefetchRequest = () => {
    prefetchCache.clear();
    this.#prefetchedLink = null;
  }

  #tryToUsePrefetchedRequest = (event) => {
    if (event.target.tagName !== "FORM" && event.detail.fetchOptions.method === "GET") {
      const cached = prefetchCache.get(event.detail.url.toString());

      if (cached) {
        // User clicked link, use cache response
        event.detail.fetchRequest = cached;
      }

      prefetchCache.clear();
    }
  }

  prepareRequest(request) {
    const link = request.target;

    request.headers["X-Sec-Purpose"] = "prefetch";

    const turboFrame = link.closest("turbo-frame");
    const turboFrameTarget = link.getAttribute("data-turbo-frame") || turboFrame?.getAttribute("target") || turboFrame?.id;

    if (turboFrameTarget && turboFrameTarget !== "_top") {
      request.headers["Turbo-Frame"] = turboFrameTarget;
    }
  }

  // Fetch request interface

  requestSucceededWithResponse() {}

  requestStarted(fetchRequest) {}

  requestErrored(fetchRequest) {}

  requestFinished(fetchRequest) {}

  requestPreventedHandlingResponse(fetchRequest, fetchResponse) {}

  requestFailedWithResponse(fetchRequest, fetchResponse) {}

  get #cacheTtl() {
    return Number(getMetaContent("turbo-prefetch-cache-time")) || cacheTtl
  }

  #isPrefetchable(link) {
    const href = link.getAttribute("href");

    if (!href) return false

    if (unfetchableLink(link)) return false
    if (linkToTheSamePage(link)) return false
    if (linkOptsOut(link)) return false
    if (nonSafeLink(link)) return false
    if (eventPrevented(link)) return false

    return true
  }
}

const unfetchableLink = (link) => {
  return link.origin !== document.location.origin || !["http:", "https:"].includes(link.protocol) || link.hasAttribute("target")
};

const linkToTheSamePage = (link) => {
  return (link.pathname + link.search === document.location.pathname + document.location.search) || link.href.startsWith("#")
};

const linkOptsOut = (link) => {
  if (link.getAttribute("data-turbo-prefetch") === "false") return true
  if (link.getAttribute("data-turbo") === "false") return true

  const turboPrefetchParent = findClosestRecursively(link, "[data-turbo-prefetch]");
  if (turboPrefetchParent && turboPrefetchParent.getAttribute("data-turbo-prefetch") === "false") return true

  return false
};

const nonSafeLink = (link) => {
  const turboMethod = link.getAttribute("data-turbo-method");
  if (turboMethod && turboMethod.toLowerCase() !== "get") return true

  if (isUJS(link)) return true
  if (link.hasAttribute("data-turbo-confirm")) return true
  if (link.hasAttribute("data-turbo-stream")) return true

  return false
};

const isUJS = (link) => {
  return link.hasAttribute("data-remote") || link.hasAttribute("data-behavior") || link.hasAttribute("data-confirm") || link.hasAttribute("data-method")
};

const eventPrevented = (link) => {
  const event = dispatch("turbo:before-prefetch", { target: link, cancelable: true });
  return event.defaultPrevented
};

class Navigator {
  constructor(delegate) {
    this.delegate = delegate;
  }

  proposeVisit(location, options = {}) {
    if (this.delegate.allowsVisitingLocationWithAction(location, options.action)) {
      this.delegate.visitProposedToLocation(location, options);
    }
  }

  startVisit(locatable, restorationIdentifier, options = {}) {
    this.stop();
    this.currentVisit = new Visit(this, expandURL(locatable), restorationIdentifier, {
      referrer: this.location,
      ...options
    });
    this.currentVisit.start();
  }

  submitForm(form, submitter) {
    this.stop();
    this.formSubmission = new FormSubmission(this, form, submitter, true);

    this.formSubmission.start();
  }

  stop() {
    if (this.formSubmission) {
      this.formSubmission.stop();
      delete this.formSubmission;
    }

    if (this.currentVisit) {
      this.currentVisit.cancel();
      delete this.currentVisit;
    }
  }

  get adapter() {
    return this.delegate.adapter
  }

  get view() {
    return this.delegate.view
  }

  get rootLocation() {
    return this.view.snapshot.rootLocation
  }

  get history() {
    return this.delegate.history
  }

  // Form submission delegate

  formSubmissionStarted(formSubmission) {
    // Not all adapters implement formSubmissionStarted
    if (typeof this.adapter.formSubmissionStarted === "function") {
      this.adapter.formSubmissionStarted(formSubmission);
    }
  }

  async formSubmissionSucceededWithResponse(formSubmission, fetchResponse) {
    if (formSubmission == this.formSubmission) {
      const responseHTML = await fetchResponse.responseHTML;
      if (responseHTML) {
        const shouldCacheSnapshot = formSubmission.isSafe;
        if (!shouldCacheSnapshot) {
          this.view.clearSnapshotCache();
        }

        const { statusCode, redirected } = fetchResponse;
        const action = this.#getActionForFormSubmission(formSubmission, fetchResponse);
        const visitOptions = {
          action,
          shouldCacheSnapshot,
          response: { statusCode, responseHTML, redirected }
        };
        this.proposeVisit(fetchResponse.location, visitOptions);
      }
    }
  }

  async formSubmissionFailedWithResponse(formSubmission, fetchResponse) {
    const responseHTML = await fetchResponse.responseHTML;

    if (responseHTML) {
      const snapshot = PageSnapshot.fromHTMLString(responseHTML);
      if (fetchResponse.serverError) {
        await this.view.renderError(snapshot, this.currentVisit);
      } else {
        await this.view.renderPage(snapshot, false, true, this.currentVisit);
      }
      if(!snapshot.shouldPreserveScrollPosition) {
        this.view.scrollToTop();
      }
      this.view.clearSnapshotCache();
    }
  }

  formSubmissionErrored(formSubmission, error) {
    console.error(error);
  }

  formSubmissionFinished(formSubmission) {
    // Not all adapters implement formSubmissionFinished
    if (typeof this.adapter.formSubmissionFinished === "function") {
      this.adapter.formSubmissionFinished(formSubmission);
    }
  }

  // Link prefetching

  linkPrefetchingIsEnabledForLocation(location) {
    // Not all adapters implement linkPrefetchingIsEnabledForLocation
    if (typeof this.adapter.linkPrefetchingIsEnabledForLocation === "function") {
      return this.adapter.linkPrefetchingIsEnabledForLocation(location)
    }

    return true
  }

  // Visit delegate

  visitStarted(visit) {
    this.delegate.visitStarted(visit);
  }

  visitCompleted(visit) {
    this.delegate.visitCompleted(visit);
    delete this.currentVisit;
  }

  locationWithActionIsSamePage(location, action) {
    const anchor = getAnchor(location);
    const currentAnchor = getAnchor(this.view.lastRenderedLocation);
    const isRestorationToTop = action === "restore" && typeof anchor === "undefined";

    return (
      action !== "replace" &&
      getRequestURL(location) === getRequestURL(this.view.lastRenderedLocation) &&
      (isRestorationToTop || (anchor != null && anchor !== currentAnchor))
    )
  }

  visitScrolledToSamePageLocation(oldURL, newURL) {
    this.delegate.visitScrolledToSamePageLocation(oldURL, newURL);
  }

  // Visits

  get location() {
    return this.history.location
  }

  get restorationIdentifier() {
    return this.history.restorationIdentifier
  }

  #getActionForFormSubmission(formSubmission, fetchResponse) {
    const { submitter, formElement } = formSubmission;
    return getVisitAction(submitter, formElement) || this.#getDefaultAction(fetchResponse)
  }

  #getDefaultAction(fetchResponse) {
    const sameLocationRedirect = fetchResponse.redirected && fetchResponse.location.href === this.location?.href;
    return sameLocationRedirect ? "replace" : "advance"
  }
}

const PageStage = {
  initial: 0,
  loading: 1,
  interactive: 2,
  complete: 3
};

class PageObserver {
  stage = PageStage.initial
  started = false

  constructor(delegate) {
    this.delegate = delegate;
  }

  start() {
    if (!this.started) {
      if (this.stage == PageStage.initial) {
        this.stage = PageStage.loading;
      }
      document.addEventListener("readystatechange", this.interpretReadyState, false);
      addEventListener("pagehide", this.pageWillUnload, false);
      this.started = true;
    }
  }

  stop() {
    if (this.started) {
      document.removeEventListener("readystatechange", this.interpretReadyState, false);
      removeEventListener("pagehide", this.pageWillUnload, false);
      this.started = false;
    }
  }

  interpretReadyState = () => {
    const { readyState } = this;
    if (readyState == "interactive") {
      this.pageIsInteractive();
    } else if (readyState == "complete") {
      this.pageIsComplete();
    }
  }

  pageIsInteractive() {
    if (this.stage == PageStage.loading) {
      this.stage = PageStage.interactive;
      this.delegate.pageBecameInteractive();
    }
  }

  pageIsComplete() {
    this.pageIsInteractive();
    if (this.stage == PageStage.interactive) {
      this.stage = PageStage.complete;
      this.delegate.pageLoaded();
    }
  }

  pageWillUnload = () => {
    this.delegate.pageWillUnload();
  }

  get readyState() {
    return document.readyState
  }
}

class ScrollObserver {
  started = false

  constructor(delegate) {
    this.delegate = delegate;
  }

  start() {
    if (!this.started) {
      addEventListener("scroll", this.onScroll, false);
      this.onScroll();
      this.started = true;
    }
  }

  stop() {
    if (this.started) {
      removeEventListener("scroll", this.onScroll, false);
      this.started = false;
    }
  }

  onScroll = () => {
    this.updatePosition({ x: window.pageXOffset, y: window.pageYOffset });
  }

  // Private

  updatePosition(position) {
    this.delegate.scrollPositionChanged(position);
  }
}

class StreamMessageRenderer {
  render({ fragment }) {
    Bardo.preservingPermanentElements(this, getPermanentElementMapForFragment(fragment), () => {
      withAutofocusFromFragment(fragment, () => {
        withPreservedFocus(() => {
          document.documentElement.appendChild(fragment);
        });
      });
    });
  }

  // Bardo delegate

  enteringBardo(currentPermanentElement, newPermanentElement) {
    newPermanentElement.replaceWith(currentPermanentElement.cloneNode(true));
  }

  leavingBardo() {}
}

function getPermanentElementMapForFragment(fragment) {
  const permanentElementsInDocument = queryPermanentElementsAll(document.documentElement);
  const permanentElementMap = {};
  for (const permanentElementInDocument of permanentElementsInDocument) {
    const { id } = permanentElementInDocument;

    for (const streamElement of fragment.querySelectorAll("turbo-stream")) {
      const elementInStream = getPermanentElementById(streamElement.templateElement.content, id);

      if (elementInStream) {
        permanentElementMap[id] = [permanentElementInDocument, elementInStream];
      }
    }
  }

  return permanentElementMap
}

async function withAutofocusFromFragment(fragment, callback) {
  const generatedID = `turbo-stream-autofocus-${uuid()}`;
  const turboStreams = fragment.querySelectorAll("turbo-stream");
  const elementWithAutofocus = firstAutofocusableElementInStreams(turboStreams);
  let willAutofocusId = null;

  if (elementWithAutofocus) {
    if (elementWithAutofocus.id) {
      willAutofocusId = elementWithAutofocus.id;
    } else {
      willAutofocusId = generatedID;
    }

    elementWithAutofocus.id = willAutofocusId;
  }

  callback();
  await nextRepaint();

  const hasNoActiveElement = document.activeElement == null || document.activeElement == document.body;

  if (hasNoActiveElement && willAutofocusId) {
    const elementToAutofocus = document.getElementById(willAutofocusId);

    if (elementIsFocusable(elementToAutofocus)) {
      elementToAutofocus.focus();
    }
    if (elementToAutofocus && elementToAutofocus.id == generatedID) {
      elementToAutofocus.removeAttribute("id");
    }
  }
}

async function withPreservedFocus(callback) {
  const [activeElementBeforeRender, activeElementAfterRender] = await around(callback, () => document.activeElement);

  const restoreFocusTo = activeElementBeforeRender && activeElementBeforeRender.id;

  if (restoreFocusTo) {
    const elementToFocus = document.getElementById(restoreFocusTo);

    if (elementIsFocusable(elementToFocus) && elementToFocus != activeElementAfterRender) {
      elementToFocus.focus();
    }
  }
}

function firstAutofocusableElementInStreams(nodeListOfStreamElements) {
  for (const streamElement of nodeListOfStreamElements) {
    const elementWithAutofocus = queryAutofocusableElement(streamElement.templateElement.content);

    if (elementWithAutofocus) return elementWithAutofocus
  }

  return null
}

class StreamObserver {
  sources = new Set()
  #started = false

  constructor(delegate) {
    this.delegate = delegate;
  }

  start() {
    if (!this.#started) {
      this.#started = true;
      addEventListener("turbo:before-fetch-response", this.inspectFetchResponse, false);
    }
  }

  stop() {
    if (this.#started) {
      this.#started = false;
      removeEventListener("turbo:before-fetch-response", this.inspectFetchResponse, false);
    }
  }

  connectStreamSource(source) {
    if (!this.streamSourceIsConnected(source)) {
      this.sources.add(source);
      source.addEventListener("message", this.receiveMessageEvent, false);
    }
  }

  disconnectStreamSource(source) {
    if (this.streamSourceIsConnected(source)) {
      this.sources.delete(source);
      source.removeEventListener("message", this.receiveMessageEvent, false);
    }
  }

  streamSourceIsConnected(source) {
    return this.sources.has(source)
  }

  inspectFetchResponse = (event) => {
    const response = fetchResponseFromEvent(event);
    if (response && fetchResponseIsStream(response)) {
      event.preventDefault();
      this.receiveMessageResponse(response);
    }
  }

  receiveMessageEvent = (event) => {
    if (this.#started && typeof event.data == "string") {
      this.receiveMessageHTML(event.data);
    }
  }

  async receiveMessageResponse(response) {
    const html = await response.responseHTML;
    if (html) {
      this.receiveMessageHTML(html);
    }
  }

  receiveMessageHTML(html) {
    this.delegate.receivedMessageFromStream(StreamMessage.wrap(html));
  }
}

function fetchResponseFromEvent(event) {
  const fetchResponse = event.detail?.fetchResponse;
  if (fetchResponse instanceof FetchResponse) {
    return fetchResponse
  }
}

function fetchResponseIsStream(response) {
  const contentType = response.contentType ?? "";
  return contentType.startsWith(StreamMessage.contentType)
}

class ErrorRenderer extends Renderer {
  static renderElement(currentElement, newElement) {
    const { documentElement, body } = document;

    documentElement.replaceChild(newElement, body);
  }

  async render() {
    this.replaceHeadAndBody();
    this.activateScriptElements();
  }

  replaceHeadAndBody() {
    const { documentElement, head } = document;
    documentElement.replaceChild(this.newHead, head);
    this.renderElement(this.currentElement, this.newElement);
  }

  activateScriptElements() {
    for (const replaceableElement of this.scriptElements) {
      const parentNode = replaceableElement.parentNode;
      if (parentNode) {
        const element = activateScriptElement(replaceableElement);
        parentNode.replaceChild(element, replaceableElement);
      }
    }
  }

  get newHead() {
    return this.newSnapshot.headSnapshot.element
  }

  get scriptElements() {
    return document.documentElement.querySelectorAll("script")
  }
}

class PageRenderer extends Renderer {
  static renderElement(currentElement, newElement) {
    if (document.body && newElement instanceof HTMLBodyElement) {
      document.body.replaceWith(newElement);
    } else {
      document.documentElement.appendChild(newElement);
    }
  }

  get shouldRender() {
    return this.newSnapshot.isVisitable && this.trackedElementsAreIdentical
  }

  get reloadReason() {
    if (!this.newSnapshot.isVisitable) {
      return {
        reason: "turbo_visit_control_is_reload"
      }
    }

    if (!this.trackedElementsAreIdentical) {
      return {
        reason: "tracked_element_mismatch"
      }
    }
  }

  async prepareToRender() {
    this.#setLanguage();
    await this.mergeHead();
  }

  async render() {
    if (this.willRender) {
      await this.replaceBody();
    }
  }

  finishRendering() {
    super.finishRendering();
    if (!this.isPreview) {
      this.focusFirstAutofocusableElement();
    }
  }

  get currentHeadSnapshot() {
    return this.currentSnapshot.headSnapshot
  }

  get newHeadSnapshot() {
    return this.newSnapshot.headSnapshot
  }

  get newElement() {
    return this.newSnapshot.element
  }

  #setLanguage() {
    const { documentElement } = this.currentSnapshot;
    const { lang } = this.newSnapshot;

    if (lang) {
      documentElement.setAttribute("lang", lang);
    } else {
      documentElement.removeAttribute("lang");
    }
  }

  async mergeHead() {
    const mergedHeadElements = this.mergeProvisionalElements();
    const newStylesheetElements = this.copyNewHeadStylesheetElements();
    this.copyNewHeadScriptElements();

    await mergedHeadElements;
    await newStylesheetElements;

    if (this.willRender) {
      this.removeUnusedDynamicStylesheetElements();
    }
  }

  async replaceBody() {
    await this.preservingPermanentElements(async () => {
      this.activateNewBody();
      await this.assignNewBody();
    });
  }

  get trackedElementsAreIdentical() {
    return this.currentHeadSnapshot.trackedElementSignature == this.newHeadSnapshot.trackedElementSignature
  }

  async copyNewHeadStylesheetElements() {
    const loadingElements = [];

    for (const element of this.newHeadStylesheetElements) {
      loadingElements.push(waitForLoad(element));

      document.head.appendChild(element);
    }

    await Promise.all(loadingElements);
  }

  copyNewHeadScriptElements() {
    for (const element of this.newHeadScriptElements) {
      document.head.appendChild(activateScriptElement(element));
    }
  }

  removeUnusedDynamicStylesheetElements() {
    for (const element of this.unusedDynamicStylesheetElements) {
      document.head.removeChild(element);
    }
  }

  async mergeProvisionalElements() {
    const newHeadElements = [...this.newHeadProvisionalElements];

    for (const element of this.currentHeadProvisionalElements) {
      if (!this.isCurrentElementInElementList(element, newHeadElements)) {
        document.head.removeChild(element);
      }
    }

    for (const element of newHeadElements) {
      document.head.appendChild(element);
    }
  }

  isCurrentElementInElementList(element, elementList) {
    for (const [index, newElement] of elementList.entries()) {
      // if title element...
      if (element.tagName == "TITLE") {
        if (newElement.tagName != "TITLE") {
          continue
        }
        if (element.innerHTML == newElement.innerHTML) {
          elementList.splice(index, 1);
          return true
        }
      }

      // if any other element...
      if (newElement.isEqualNode(element)) {
        elementList.splice(index, 1);
        return true
      }
    }

    return false
  }

  removeCurrentHeadProvisionalElements() {
    for (const element of this.currentHeadProvisionalElements) {
      document.head.removeChild(element);
    }
  }

  copyNewHeadProvisionalElements() {
    for (const element of this.newHeadProvisionalElements) {
      document.head.appendChild(element);
    }
  }

  activateNewBody() {
    document.adoptNode(this.newElement);
    this.activateNewBodyScriptElements();
  }

  activateNewBodyScriptElements() {
    for (const inertScriptElement of this.newBodyScriptElements) {
      const activatedScriptElement = activateScriptElement(inertScriptElement);
      inertScriptElement.replaceWith(activatedScriptElement);
    }
  }

  async assignNewBody() {
    await this.renderElement(this.currentElement, this.newElement);
  }

  get unusedDynamicStylesheetElements() {
    return this.oldHeadStylesheetElements.filter((element) => {
      return element.getAttribute("data-turbo-track") === "dynamic"
    })
  }

  get oldHeadStylesheetElements() {
    return this.currentHeadSnapshot.getStylesheetElementsNotInSnapshot(this.newHeadSnapshot)
  }

  get newHeadStylesheetElements() {
    return this.newHeadSnapshot.getStylesheetElementsNotInSnapshot(this.currentHeadSnapshot)
  }

  get newHeadScriptElements() {
    return this.newHeadSnapshot.getScriptElementsNotInSnapshot(this.currentHeadSnapshot)
  }

  get currentHeadProvisionalElements() {
    return this.currentHeadSnapshot.provisionalElements
  }

  get newHeadProvisionalElements() {
    return this.newHeadSnapshot.provisionalElements
  }

  get newBodyScriptElements() {
    return this.newElement.querySelectorAll("script")
  }
}

class MorphingPageRenderer extends PageRenderer {
  static renderElement(currentElement, newElement) {
    morphElements(currentElement, newElement, {
      callbacks: {
        beforeNodeMorphed: element => !canRefreshFrame(element)
      }
    });

    for (const frame of currentElement.querySelectorAll("turbo-frame")) {
      if (canRefreshFrame(frame)) frame.reload();
    }

    dispatch("turbo:morph", { detail: { currentElement, newElement } });
  }

  async preservingPermanentElements(callback) {
    return await callback()
  }

  get renderMethod() {
    return "morph"
  }

  get shouldAutofocus() {
    return false
  }
}

function canRefreshFrame(frame) {
  return frame instanceof FrameElement &&
    frame.src &&
    frame.refresh === "morph" &&
    !frame.closest("[data-turbo-permanent]")
}

class SnapshotCache {
  keys = []
  snapshots = {}

  constructor(size) {
    this.size = size;
  }

  has(location) {
    return toCacheKey(location) in this.snapshots
  }

  get(location) {
    if (this.has(location)) {
      const snapshot = this.read(location);
      this.touch(location);
      return snapshot
    }
  }

  put(location, snapshot) {
    this.write(location, snapshot);
    this.touch(location);
    return snapshot
  }

  clear() {
    this.snapshots = {};
  }

  // Private

  read(location) {
    return this.snapshots[toCacheKey(location)]
  }

  write(location, snapshot) {
    this.snapshots[toCacheKey(location)] = snapshot;
  }

  touch(location) {
    const key = toCacheKey(location);
    const index = this.keys.indexOf(key);
    if (index > -1) this.keys.splice(index, 1);
    this.keys.unshift(key);
    this.trim();
  }

  trim() {
    for (const key of this.keys.splice(this.size)) {
      delete this.snapshots[key];
    }
  }
}

class PageView extends View {
  snapshotCache = new SnapshotCache(10)
  lastRenderedLocation = new URL(location.href)
  forceReloaded = false

  shouldTransitionTo(newSnapshot) {
    return this.snapshot.prefersViewTransitions && newSnapshot.prefersViewTransitions
  }

  renderPage(snapshot, isPreview = false, willRender = true, visit) {
    const shouldMorphPage = this.isPageRefresh(visit) && this.snapshot.shouldMorphPage;
    const rendererClass = shouldMorphPage ? MorphingPageRenderer : PageRenderer;

    const renderer = new rendererClass(this.snapshot, snapshot, isPreview, willRender);

    if (!renderer.shouldRender) {
      this.forceReloaded = true;
    } else {
      visit?.changeHistory();
    }

    return this.render(renderer)
  }

  renderError(snapshot, visit) {
    visit?.changeHistory();
    const renderer = new ErrorRenderer(this.snapshot, snapshot, false);
    return this.render(renderer)
  }

  clearSnapshotCache() {
    this.snapshotCache.clear();
  }

  async cacheSnapshot(snapshot = this.snapshot) {
    if (snapshot.isCacheable) {
      this.delegate.viewWillCacheSnapshot();
      const { lastRenderedLocation: location } = this;
      await nextEventLoopTick();
      const cachedSnapshot = snapshot.clone();
      this.snapshotCache.put(location, cachedSnapshot);
      return cachedSnapshot
    }
  }

  getCachedSnapshotForLocation(location) {
    return this.snapshotCache.get(location)
  }

  isPageRefresh(visit) {
    return !visit || (this.lastRenderedLocation.pathname === visit.location.pathname && visit.action === "replace")
  }

  shouldPreserveScrollPosition(visit) {
    return this.isPageRefresh(visit) && this.snapshot.shouldPreserveScrollPosition
  }

  get snapshot() {
    return PageSnapshot.fromElement(this.element)
  }
}

class Preloader {
  selector = "a[data-turbo-preload]"

  constructor(delegate, snapshotCache) {
    this.delegate = delegate;
    this.snapshotCache = snapshotCache;
  }

  start() {
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", this.#preloadAll);
    } else {
      this.preloadOnLoadLinksForView(document.body);
    }
  }

  stop() {
    document.removeEventListener("DOMContentLoaded", this.#preloadAll);
  }

  preloadOnLoadLinksForView(element) {
    for (const link of element.querySelectorAll(this.selector)) {
      if (this.delegate.shouldPreloadLink(link)) {
        this.preloadURL(link);
      }
    }
  }

  async preloadURL(link) {
    const location = new URL(link.href);

    if (this.snapshotCache.has(location)) {
      return
    }

    const fetchRequest = new FetchRequest(this, FetchMethod.get, location, new URLSearchParams(), link);
    await fetchRequest.perform();
  }

  // Fetch request delegate

  prepareRequest(fetchRequest) {
    fetchRequest.headers["X-Sec-Purpose"] = "prefetch";
  }

  async requestSucceededWithResponse(fetchRequest, fetchResponse) {
    try {
      const responseHTML = await fetchResponse.responseHTML;
      const snapshot = PageSnapshot.fromHTMLString(responseHTML);

      this.snapshotCache.put(fetchRequest.url, snapshot);
    } catch (_) {
      // If we cannot preload that is ok!
    }
  }

  requestStarted(fetchRequest) {}

  requestErrored(fetchRequest) {}

  requestFinished(fetchRequest) {}

  requestPreventedHandlingResponse(fetchRequest, fetchResponse) {}

  requestFailedWithResponse(fetchRequest, fetchResponse) {}

  #preloadAll = () => {
    this.preloadOnLoadLinksForView(document.body);
  }
}

class Cache {
  constructor(session) {
    this.session = session;
  }

  clear() {
    this.session.clearCache();
  }

  resetCacheControl() {
    this.#setCacheControl("");
  }

  exemptPageFromCache() {
    this.#setCacheControl("no-cache");
  }

  exemptPageFromPreview() {
    this.#setCacheControl("no-preview");
  }

  #setCacheControl(value) {
    setMetaContent("turbo-cache-control", value);
  }
}

class Session {
  navigator = new Navigator(this)
  history = new History(this)
  view = new PageView(this, document.documentElement)
  adapter = new BrowserAdapter(this)

  pageObserver = new PageObserver(this)
  cacheObserver = new CacheObserver()
  linkPrefetchObserver = new LinkPrefetchObserver(this, document)
  linkClickObserver = new LinkClickObserver(this, window)
  formSubmitObserver = new FormSubmitObserver(this, document)
  scrollObserver = new ScrollObserver(this)
  streamObserver = new StreamObserver(this)
  formLinkClickObserver = new FormLinkClickObserver(this, document.documentElement)
  frameRedirector = new FrameRedirector(this, document.documentElement)
  streamMessageRenderer = new StreamMessageRenderer()
  cache = new Cache(this)

  enabled = true
  started = false
  #pageRefreshDebouncePeriod = 150

  constructor(recentRequests) {
    this.recentRequests = recentRequests;
    this.preloader = new Preloader(this, this.view.snapshotCache);
    this.debouncedRefresh = this.refresh;
    this.pageRefreshDebouncePeriod = this.pageRefreshDebouncePeriod;
  }

  start() {
    if (!this.started) {
      this.pageObserver.start();
      this.cacheObserver.start();
      this.linkPrefetchObserver.start();
      this.formLinkClickObserver.start();
      this.linkClickObserver.start();
      this.formSubmitObserver.start();
      this.scrollObserver.start();
      this.streamObserver.start();
      this.frameRedirector.start();
      this.history.start();
      this.preloader.start();
      this.started = true;
      this.enabled = true;
    }
  }

  disable() {
    this.enabled = false;
  }

  stop() {
    if (this.started) {
      this.pageObserver.stop();
      this.cacheObserver.stop();
      this.linkPrefetchObserver.stop();
      this.formLinkClickObserver.stop();
      this.linkClickObserver.stop();
      this.formSubmitObserver.stop();
      this.scrollObserver.stop();
      this.streamObserver.stop();
      this.frameRedirector.stop();
      this.history.stop();
      this.preloader.stop();
      this.started = false;
    }
  }

  registerAdapter(adapter) {
    this.adapter = adapter;
  }

  visit(location, options = {}) {
    const frameElement = options.frame ? document.getElementById(options.frame) : null;

    if (frameElement instanceof FrameElement) {
      const action = options.action || getVisitAction(frameElement);

      frameElement.delegate.proposeVisitIfNavigatedWithAction(frameElement, action);
      frameElement.src = location.toString();
    } else {
      this.navigator.proposeVisit(expandURL(location), options);
    }
  }

  refresh(url, requestId) {
    const isRecentRequest = requestId && this.recentRequests.has(requestId);
    const isCurrentUrl = url === document.baseURI;
    if (!isRecentRequest && !this.navigator.currentVisit && isCurrentUrl) {
      this.visit(url, { action: "replace", shouldCacheSnapshot: false });
    }
  }

  connectStreamSource(source) {
    this.streamObserver.connectStreamSource(source);
  }

  disconnectStreamSource(source) {
    this.streamObserver.disconnectStreamSource(source);
  }

  renderStreamMessage(message) {
    this.streamMessageRenderer.render(StreamMessage.wrap(message));
  }

  clearCache() {
    this.view.clearSnapshotCache();
  }

  setProgressBarDelay(delay) {
    console.warn(
      "Please replace `session.setProgressBarDelay(delay)` with `session.progressBarDelay = delay`. The function is deprecated and will be removed in a future version of Turbo.`"
    );

    this.progressBarDelay = delay;
  }

  set progressBarDelay(delay) {
    config.drive.progressBarDelay = delay;
  }

  get progressBarDelay() {
    return config.drive.progressBarDelay
  }

  set drive(value) {
    config.drive.enabled = value;
  }

  get drive() {
    return config.drive.enabled
  }

  set formMode(value) {
    config.forms.mode = value;
  }

  get formMode() {
    return config.forms.mode
  }

  get location() {
    return this.history.location
  }

  get restorationIdentifier() {
    return this.history.restorationIdentifier
  }

  get pageRefreshDebouncePeriod() {
    return this.#pageRefreshDebouncePeriod
  }

  set pageRefreshDebouncePeriod(value) {
    this.refresh = debounce(this.debouncedRefresh.bind(this), value);
    this.#pageRefreshDebouncePeriod = value;
  }

  // Preloader delegate

  shouldPreloadLink(element) {
    const isUnsafe = element.hasAttribute("data-turbo-method");
    const isStream = element.hasAttribute("data-turbo-stream");
    const frameTarget = element.getAttribute("data-turbo-frame");
    const frame = frameTarget == "_top" ?
      null :
      document.getElementById(frameTarget) || findClosestRecursively(element, "turbo-frame:not([disabled])");

    if (isUnsafe || isStream || frame instanceof FrameElement) {
      return false
    } else {
      const location = new URL(element.href);

      return this.elementIsNavigatable(element) && locationIsVisitable(location, this.snapshot.rootLocation)
    }
  }

  // History delegate

  historyPoppedToLocationWithRestorationIdentifierAndDirection(location, restorationIdentifier, direction) {
    if (this.enabled) {
      this.navigator.startVisit(location, restorationIdentifier, {
        action: "restore",
        historyChanged: true,
        direction
      });
    } else {
      this.adapter.pageInvalidated({
        reason: "turbo_disabled"
      });
    }
  }

  // Scroll observer delegate

  scrollPositionChanged(position) {
    this.history.updateRestorationData({ scrollPosition: position });
  }

  // Form click observer delegate

  willSubmitFormLinkToLocation(link, location) {
    return this.elementIsNavigatable(link) && locationIsVisitable(location, this.snapshot.rootLocation)
  }

  submittedFormLinkToLocation() {}

  // Link hover observer delegate

  canPrefetchRequestToLocation(link, location) {
    return (
      this.elementIsNavigatable(link) &&
      locationIsVisitable(location, this.snapshot.rootLocation) &&
      this.navigator.linkPrefetchingIsEnabledForLocation(location)
    )
  }

  // Link click observer delegate

  willFollowLinkToLocation(link, location, event) {
    return (
      this.elementIsNavigatable(link) &&
      locationIsVisitable(location, this.snapshot.rootLocation) &&
      this.applicationAllowsFollowingLinkToLocation(link, location, event)
    )
  }

  followedLinkToLocation(link, location) {
    const action = this.getActionForLink(link);
    const acceptsStreamResponse = link.hasAttribute("data-turbo-stream");

    this.visit(location.href, { action, acceptsStreamResponse });
  }

  // Navigator delegate

  allowsVisitingLocationWithAction(location, action) {
    return this.locationWithActionIsSamePage(location, action) || this.applicationAllowsVisitingLocation(location)
  }

  visitProposedToLocation(location, options) {
    extendURLWithDeprecatedProperties(location);
    this.adapter.visitProposedToLocation(location, options);
  }

  // Visit delegate

  visitStarted(visit) {
    if (!visit.acceptsStreamResponse) {
      markAsBusy(document.documentElement);
      this.view.markVisitDirection(visit.direction);
    }
    extendURLWithDeprecatedProperties(visit.location);
    if (!visit.silent) {
      this.notifyApplicationAfterVisitingLocation(visit.location, visit.action);
    }
  }

  visitCompleted(visit) {
    this.view.unmarkVisitDirection();
    clearBusyState(document.documentElement);
    this.notifyApplicationAfterPageLoad(visit.getTimingMetrics());
  }

  locationWithActionIsSamePage(location, action) {
    return this.navigator.locationWithActionIsSamePage(location, action)
  }

  visitScrolledToSamePageLocation(oldURL, newURL) {
    this.notifyApplicationAfterVisitingSamePageLocation(oldURL, newURL);
  }

  // Form submit observer delegate

  willSubmitForm(form, submitter) {
    const action = getAction$1(form, submitter);

    return (
      this.submissionIsNavigatable(form, submitter) &&
      locationIsVisitable(expandURL(action), this.snapshot.rootLocation)
    )
  }

  formSubmitted(form, submitter) {
    this.navigator.submitForm(form, submitter);
  }

  // Page observer delegate

  pageBecameInteractive() {
    this.view.lastRenderedLocation = this.location;
    this.notifyApplicationAfterPageLoad();
  }

  pageLoaded() {
    this.history.assumeControlOfScrollRestoration();
  }

  pageWillUnload() {
    this.history.relinquishControlOfScrollRestoration();
  }

  // Stream observer delegate

  receivedMessageFromStream(message) {
    this.renderStreamMessage(message);
  }

  // Page view delegate

  viewWillCacheSnapshot() {
    if (!this.navigator.currentVisit?.silent) {
      this.notifyApplicationBeforeCachingSnapshot();
    }
  }

  allowsImmediateRender({ element }, options) {
    const event = this.notifyApplicationBeforeRender(element, options);
    const {
      defaultPrevented,
      detail: { render }
    } = event;

    if (this.view.renderer && render) {
      this.view.renderer.renderElement = render;
    }

    return !defaultPrevented
  }

  viewRenderedSnapshot(_snapshot, _isPreview, renderMethod) {
    this.view.lastRenderedLocation = this.history.location;
    this.notifyApplicationAfterRender(renderMethod);
  }

  preloadOnLoadLinksForView(element) {
    this.preloader.preloadOnLoadLinksForView(element);
  }

  viewInvalidated(reason) {
    this.adapter.pageInvalidated(reason);
  }

  // Frame element

  frameLoaded(frame) {
    this.notifyApplicationAfterFrameLoad(frame);
  }

  frameRendered(fetchResponse, frame) {
    this.notifyApplicationAfterFrameRender(fetchResponse, frame);
  }

  // Application events

  applicationAllowsFollowingLinkToLocation(link, location, ev) {
    const event = this.notifyApplicationAfterClickingLinkToLocation(link, location, ev);
    return !event.defaultPrevented
  }

  applicationAllowsVisitingLocation(location) {
    const event = this.notifyApplicationBeforeVisitingLocation(location);
    return !event.defaultPrevented
  }

  notifyApplicationAfterClickingLinkToLocation(link, location, event) {
    return dispatch("turbo:click", {
      target: link,
      detail: { url: location.href, originalEvent: event },
      cancelable: true
    })
  }

  notifyApplicationBeforeVisitingLocation(location) {
    return dispatch("turbo:before-visit", {
      detail: { url: location.href },
      cancelable: true
    })
  }

  notifyApplicationAfterVisitingLocation(location, action) {
    return dispatch("turbo:visit", { detail: { url: location.href, action } })
  }

  notifyApplicationBeforeCachingSnapshot() {
    return dispatch("turbo:before-cache")
  }

  notifyApplicationBeforeRender(newBody, options) {
    return dispatch("turbo:before-render", {
      detail: { newBody, ...options },
      cancelable: true
    })
  }

  notifyApplicationAfterRender(renderMethod) {
    return dispatch("turbo:render", { detail: { renderMethod } })
  }

  notifyApplicationAfterPageLoad(timing = {}) {
    return dispatch("turbo:load", {
      detail: { url: this.location.href, timing }
    })
  }

  notifyApplicationAfterVisitingSamePageLocation(oldURL, newURL) {
    dispatchEvent(
      new HashChangeEvent("hashchange", {
        oldURL: oldURL.toString(),
        newURL: newURL.toString()
      })
    );
  }

  notifyApplicationAfterFrameLoad(frame) {
    return dispatch("turbo:frame-load", { target: frame })
  }

  notifyApplicationAfterFrameRender(fetchResponse, frame) {
    return dispatch("turbo:frame-render", {
      detail: { fetchResponse },
      target: frame,
      cancelable: true
    })
  }

  // Helpers

  submissionIsNavigatable(form, submitter) {
    if (config.forms.mode == "off") {
      return false
    } else {
      const submitterIsNavigatable = submitter ? this.elementIsNavigatable(submitter) : true;

      if (config.forms.mode == "optin") {
        return submitterIsNavigatable && form.closest('[data-turbo="true"]') != null
      } else {
        return submitterIsNavigatable && this.elementIsNavigatable(form)
      }
    }
  }

  elementIsNavigatable(element) {
    const container = findClosestRecursively(element, "[data-turbo]");
    const withinFrame = findClosestRecursively(element, "turbo-frame");

    // Check if Drive is enabled on the session or we're within a Frame.
    if (config.drive.enabled || withinFrame) {
      // Element is navigatable by default, unless `data-turbo="false"`.
      if (container) {
        return container.getAttribute("data-turbo") != "false"
      } else {
        return true
      }
    } else {
      // Element isn't navigatable by default, unless `data-turbo="true"`.
      if (container) {
        return container.getAttribute("data-turbo") == "true"
      } else {
        return false
      }
    }
  }

  // Private

  getActionForLink(link) {
    return getVisitAction(link) || "advance"
  }

  get snapshot() {
    return this.view.snapshot
  }
}

// Older versions of the Turbo Native adapters referenced the
// `Location#absoluteURL` property in their implementations of
// the `Adapter#visitProposedToLocation()` and `#visitStarted()`
// methods. The Location class has since been removed in favor
// of the DOM URL API, and accordingly all Adapter methods now
// receive URL objects.
//
// We alias #absoluteURL to #toString() here to avoid crashing
// older adapters which do not expect URL objects. We should
// consider removing this support at some point in the future.

function extendURLWithDeprecatedProperties(url) {
  Object.defineProperties(url, deprecatedLocationPropertyDescriptors);
}

const deprecatedLocationPropertyDescriptors = {
  absoluteURL: {
    get() {
      return this.toString()
    }
  }
};

const session = new Session(recentRequests);
const { cache, navigator: navigator$1 } = session;

/**
 * Starts the main session.
 * This initialises any necessary observers such as those to monitor
 * link interactions.
 */
function start() {
  session.start();
}

/**
 * Registers an adapter for the main session.
 *
 * @param adapter Adapter to register
 */
function registerAdapter(adapter) {
  session.registerAdapter(adapter);
}

/**
 * Performs an application visit to the given location.
 *
 * @param location Location to visit (a URL or path)
 * @param options Options to apply
 * @param options.action Type of history navigation to apply ("restore",
 * "replace" or "advance")
 * @param options.historyChanged Specifies whether the browser history has
 * already been changed for this visit or not
 * @param options.referrer Specifies the referrer of this visit such that
 * navigations to the same page will not result in a new history entry.
 * @param options.snapshotHTML Cached snapshot to render
 * @param options.response Response of the specified location
 */
function visit(location, options) {
  session.visit(location, options);
}

/**
 * Connects a stream source to the main session.
 *
 * @param source Stream source to connect
 */
function connectStreamSource(source) {
  session.connectStreamSource(source);
}

/**
 * Disconnects a stream source from the main session.
 *
 * @param source Stream source to disconnect
 */
function disconnectStreamSource(source) {
  session.disconnectStreamSource(source);
}

/**
 * Renders a stream message to the main session by appending it to the
 * current document.
 *
 * @param message Message to render
 */
function renderStreamMessage(message) {
  session.renderStreamMessage(message);
}

/**
 * Removes all entries from the Turbo Drive page cache.
 * Call this when state has changed on the server that may affect cached pages.
 *
 * @deprecated since version 7.2.0 in favor of `Turbo.cache.clear()`
 */
function clearCache() {
  console.warn(
    "Please replace `Turbo.clearCache()` with `Turbo.cache.clear()`. The top-level function is deprecated and will be removed in a future version of Turbo.`"
  );
  session.clearCache();
}

/**
 * Sets the delay after which the progress bar will appear during navigation.
 *
 * The progress bar appears after 500ms by default.
 *
 * Note that this method has no effect when used with the iOS or Android
 * adapters.
 *
 * @param delay Time to delay in milliseconds
 */
function setProgressBarDelay(delay) {
  console.warn(
    "Please replace `Turbo.setProgressBarDelay(delay)` with `Turbo.config.drive.progressBarDelay = delay`. The top-level function is deprecated and will be removed in a future version of Turbo.`"
  );
  config.drive.progressBarDelay = delay;
}

function setConfirmMethod(confirmMethod) {
  console.warn(
    "Please replace `Turbo.setConfirmMethod(confirmMethod)` with `Turbo.config.forms.confirm = confirmMethod`. The top-level function is deprecated and will be removed in a future version of Turbo.`"
  );
  config.forms.confirm = confirmMethod;
}

function setFormMode(mode) {
  console.warn(
    "Please replace `Turbo.setFormMode(mode)` with `Turbo.config.forms.mode = mode`. The top-level function is deprecated and will be removed in a future version of Turbo.`"
  );
  config.forms.mode = mode;
}

var Turbo = /*#__PURE__*/Object.freeze({
  __proto__: null,
  navigator: navigator$1,
  session: session,
  cache: cache,
  PageRenderer: PageRenderer,
  PageSnapshot: PageSnapshot,
  FrameRenderer: FrameRenderer,
  fetch: fetchWithTurboHeaders,
  config: config,
  start: start,
  registerAdapter: registerAdapter,
  visit: visit,
  connectStreamSource: connectStreamSource,
  disconnectStreamSource: disconnectStreamSource,
  renderStreamMessage: renderStreamMessage,
  clearCache: clearCache,
  setProgressBarDelay: setProgressBarDelay,
  setConfirmMethod: setConfirmMethod,
  setFormMode: setFormMode
});

class TurboFrameMissingError extends Error {}

class FrameController {
  fetchResponseLoaded = (_fetchResponse) => Promise.resolve()
  #currentFetchRequest = null
  #resolveVisitPromise = () => {}
  #connected = false
  #hasBeenLoaded = false
  #ignoredAttributes = new Set()
  #shouldMorphFrame = false
  action = null

  constructor(element) {
    this.element = element;
    this.view = new FrameView(this, this.element);
    this.appearanceObserver = new AppearanceObserver(this, this.element);
    this.formLinkClickObserver = new FormLinkClickObserver(this, this.element);
    this.linkInterceptor = new LinkInterceptor(this, this.element);
    this.restorationIdentifier = uuid();
    this.formSubmitObserver = new FormSubmitObserver(this, this.element);
  }

  // Frame delegate

  connect() {
    if (!this.#connected) {
      this.#connected = true;
      if (this.loadingStyle == FrameLoadingStyle.lazy) {
        this.appearanceObserver.start();
      } else {
        this.#loadSourceURL();
      }
      this.formLinkClickObserver.start();
      this.linkInterceptor.start();
      this.formSubmitObserver.start();
    }
  }

  disconnect() {
    if (this.#connected) {
      this.#connected = false;
      this.appearanceObserver.stop();
      this.formLinkClickObserver.stop();
      this.linkInterceptor.stop();
      this.formSubmitObserver.stop();
    }
  }

  disabledChanged() {
    if (this.loadingStyle == FrameLoadingStyle.eager) {
      this.#loadSourceURL();
    }
  }

  sourceURLChanged() {
    if (this.#isIgnoringChangesTo("src")) return

    if (this.element.isConnected) {
      this.complete = false;
    }

    if (this.loadingStyle == FrameLoadingStyle.eager || this.#hasBeenLoaded) {
      this.#loadSourceURL();
    }
  }

  sourceURLReloaded() {
    const { refresh, src } = this.element;

    this.#shouldMorphFrame = src && refresh === "morph";

    this.element.removeAttribute("complete");
    this.element.src = null;
    this.element.src = src;
    return this.element.loaded
  }

  loadingStyleChanged() {
    if (this.loadingStyle == FrameLoadingStyle.lazy) {
      this.appearanceObserver.start();
    } else {
      this.appearanceObserver.stop();
      this.#loadSourceURL();
    }
  }

  async #loadSourceURL() {
    if (this.enabled && this.isActive && !this.complete && this.sourceURL) {
      this.element.loaded = this.#visit(expandURL(this.sourceURL));
      this.appearanceObserver.stop();
      await this.element.loaded;
      this.#hasBeenLoaded = true;
    }
  }

  async loadResponse(fetchResponse) {
    if (fetchResponse.redirected || (fetchResponse.succeeded && fetchResponse.isHTML)) {
      this.sourceURL = fetchResponse.response.url;
    }

    try {
      const html = await fetchResponse.responseHTML;
      if (html) {
        const document = parseHTMLDocument(html);
        const pageSnapshot = PageSnapshot.fromDocument(document);

        if (pageSnapshot.isVisitable) {
          await this.#loadFrameResponse(fetchResponse, document);
        } else {
          await this.#handleUnvisitableFrameResponse(fetchResponse);
        }
      }
    } finally {
      this.#shouldMorphFrame = false;
      this.fetchResponseLoaded = () => Promise.resolve();
    }
  }

  // Appearance observer delegate

  elementAppearedInViewport(element) {
    this.proposeVisitIfNavigatedWithAction(element, getVisitAction(element));
    this.#loadSourceURL();
  }

  // Form link click observer delegate

  willSubmitFormLinkToLocation(link) {
    return this.#shouldInterceptNavigation(link)
  }

  submittedFormLinkToLocation(link, _location, form) {
    const frame = this.#findFrameElement(link);
    if (frame) form.setAttribute("data-turbo-frame", frame.id);
  }

  // Link interceptor delegate

  shouldInterceptLinkClick(element, _location, _event) {
    return this.#shouldInterceptNavigation(element)
  }

  linkClickIntercepted(element, location) {
    this.#navigateFrame(element, location);
  }

  // Form submit observer delegate

  willSubmitForm(element, submitter) {
    return element.closest("turbo-frame") == this.element && this.#shouldInterceptNavigation(element, submitter)
  }

  formSubmitted(element, submitter) {
    if (this.formSubmission) {
      this.formSubmission.stop();
    }

    this.formSubmission = new FormSubmission(this, element, submitter);
    const { fetchRequest } = this.formSubmission;
    this.prepareRequest(fetchRequest);
    this.formSubmission.start();
  }

  // Fetch request delegate

  prepareRequest(request) {
    request.headers["Turbo-Frame"] = this.id;

    if (this.currentNavigationElement?.hasAttribute("data-turbo-stream")) {
      request.acceptResponseType(StreamMessage.contentType);
    }
  }

  requestStarted(_request) {
    markAsBusy(this.element);
  }

  requestPreventedHandlingResponse(_request, _response) {
    this.#resolveVisitPromise();
  }

  async requestSucceededWithResponse(request, response) {
    await this.loadResponse(response);
    this.#resolveVisitPromise();
  }

  async requestFailedWithResponse(request, response) {
    await this.loadResponse(response);
    this.#resolveVisitPromise();
  }

  requestErrored(request, error) {
    console.error(error);
    this.#resolveVisitPromise();
  }

  requestFinished(_request) {
    clearBusyState(this.element);
  }

  // Form submission delegate

  formSubmissionStarted({ formElement }) {
    markAsBusy(formElement, this.#findFrameElement(formElement));
  }

  formSubmissionSucceededWithResponse(formSubmission, response) {
    const frame = this.#findFrameElement(formSubmission.formElement, formSubmission.submitter);

    frame.delegate.proposeVisitIfNavigatedWithAction(frame, getVisitAction(formSubmission.submitter, formSubmission.formElement, frame));
    frame.delegate.loadResponse(response);

    if (!formSubmission.isSafe) {
      session.clearCache();
    }
  }

  formSubmissionFailedWithResponse(formSubmission, fetchResponse) {
    this.element.delegate.loadResponse(fetchResponse);
    session.clearCache();
  }

  formSubmissionErrored(formSubmission, error) {
    console.error(error);
  }

  formSubmissionFinished({ formElement }) {
    clearBusyState(formElement, this.#findFrameElement(formElement));
  }

  // View delegate

  allowsImmediateRender({ element: newFrame }, options) {
    const event = dispatch("turbo:before-frame-render", {
      target: this.element,
      detail: { newFrame, ...options },
      cancelable: true
    });

    const {
      defaultPrevented,
      detail: { render }
    } = event;

    if (this.view.renderer && render) {
      this.view.renderer.renderElement = render;
    }

    return !defaultPrevented
  }

  viewRenderedSnapshot(_snapshot, _isPreview, _renderMethod) {}

  preloadOnLoadLinksForView(element) {
    session.preloadOnLoadLinksForView(element);
  }

  viewInvalidated() {}

  // Frame renderer delegate

  willRenderFrame(currentElement, _newElement) {
    this.previousFrameElement = currentElement.cloneNode(true);
  }

  visitCachedSnapshot = ({ element }) => {
    const frame = element.querySelector("#" + this.element.id);

    if (frame && this.previousFrameElement) {
      frame.replaceChildren(...this.previousFrameElement.children);
    }

    delete this.previousFrameElement;
  }

  // Private

  async #loadFrameResponse(fetchResponse, document) {
    const newFrameElement = await this.extractForeignFrameElement(document.body);
    const rendererClass = this.#shouldMorphFrame ? MorphingFrameRenderer : FrameRenderer;

    if (newFrameElement) {
      const snapshot = new Snapshot(newFrameElement);
      const renderer = new rendererClass(this, this.view.snapshot, snapshot, false, false);
      if (this.view.renderPromise) await this.view.renderPromise;
      this.changeHistory();

      await this.view.render(renderer);
      this.complete = true;
      session.frameRendered(fetchResponse, this.element);
      session.frameLoaded(this.element);
      await this.fetchResponseLoaded(fetchResponse);
    } else if (this.#willHandleFrameMissingFromResponse(fetchResponse)) {
      this.#handleFrameMissingFromResponse(fetchResponse);
    }
  }

  async #visit(url) {
    const request = new FetchRequest(this, FetchMethod.get, url, new URLSearchParams(), this.element);

    this.#currentFetchRequest?.cancel();
    this.#currentFetchRequest = request;

    return new Promise((resolve) => {
      this.#resolveVisitPromise = () => {
        this.#resolveVisitPromise = () => {};
        this.#currentFetchRequest = null;
        resolve();
      };
      request.perform();
    })
  }

  #navigateFrame(element, url, submitter) {
    const frame = this.#findFrameElement(element, submitter);

    frame.delegate.proposeVisitIfNavigatedWithAction(frame, getVisitAction(submitter, element, frame));

    this.#withCurrentNavigationElement(element, () => {
      frame.src = url;
    });
  }

  proposeVisitIfNavigatedWithAction(frame, action = null) {
    this.action = action;

    if (this.action) {
      const pageSnapshot = PageSnapshot.fromElement(frame).clone();
      const { visitCachedSnapshot } = frame.delegate;

      frame.delegate.fetchResponseLoaded = async (fetchResponse) => {
        if (frame.src) {
          const { statusCode, redirected } = fetchResponse;
          const responseHTML = await fetchResponse.responseHTML;
          const response = { statusCode, redirected, responseHTML };
          const options = {
            response,
            visitCachedSnapshot,
            willRender: false,
            updateHistory: false,
            restorationIdentifier: this.restorationIdentifier,
            snapshot: pageSnapshot
          };

          if (this.action) options.action = this.action;

          session.visit(frame.src, options);
        }
      };
    }
  }

  changeHistory() {
    if (this.action) {
      const method = getHistoryMethodForAction(this.action);
      session.history.update(method, expandURL(this.element.src || ""), this.restorationIdentifier);
    }
  }

  async #handleUnvisitableFrameResponse(fetchResponse) {
    console.warn(
      `The response (${fetchResponse.statusCode}) from <turbo-frame id="${this.element.id}"> is performing a full page visit due to turbo-visit-control.`
    );

    await this.#visitResponse(fetchResponse.response);
  }

  #willHandleFrameMissingFromResponse(fetchResponse) {
    this.element.setAttribute("complete", "");

    const response = fetchResponse.response;
    const visit = async (url, options) => {
      if (url instanceof Response) {
        this.#visitResponse(url);
      } else {
        session.visit(url, options);
      }
    };

    const event = dispatch("turbo:frame-missing", {
      target: this.element,
      detail: { response, visit },
      cancelable: true
    });

    return !event.defaultPrevented
  }

  #handleFrameMissingFromResponse(fetchResponse) {
    this.view.missing();
    this.#throwFrameMissingError(fetchResponse);
  }

  #throwFrameMissingError(fetchResponse) {
    const message = `The response (${fetchResponse.statusCode}) did not contain the expected <turbo-frame id="${this.element.id}"> and will be ignored. To perform a full page visit instead, set turbo-visit-control to reload.`;
    throw new TurboFrameMissingError(message)
  }

  async #visitResponse(response) {
    const wrapped = new FetchResponse(response);
    const responseHTML = await wrapped.responseHTML;
    const { location, redirected, statusCode } = wrapped;

    return session.visit(location, { response: { redirected, statusCode, responseHTML } })
  }

  #findFrameElement(element, submitter) {
    const id = getAttribute("data-turbo-frame", submitter, element) || this.element.getAttribute("target");
    return getFrameElementById(id) ?? this.element
  }

  async extractForeignFrameElement(container) {
    let element;
    const id = CSS.escape(this.id);

    try {
      element = activateElement(container.querySelector(`turbo-frame#${id}`), this.sourceURL);
      if (element) {
        return element
      }

      element = activateElement(container.querySelector(`turbo-frame[src][recurse~=${id}]`), this.sourceURL);
      if (element) {
        await element.loaded;
        return await this.extractForeignFrameElement(element)
      }
    } catch (error) {
      console.error(error);
      return new FrameElement()
    }

    return null
  }

  #formActionIsVisitable(form, submitter) {
    const action = getAction$1(form, submitter);

    return locationIsVisitable(expandURL(action), this.rootLocation)
  }

  #shouldInterceptNavigation(element, submitter) {
    const id = getAttribute("data-turbo-frame", submitter, element) || this.element.getAttribute("target");

    if (element instanceof HTMLFormElement && !this.#formActionIsVisitable(element, submitter)) {
      return false
    }

    if (!this.enabled || id == "_top") {
      return false
    }

    if (id) {
      const frameElement = getFrameElementById(id);
      if (frameElement) {
        return !frameElement.disabled
      }
    }

    if (!session.elementIsNavigatable(element)) {
      return false
    }

    if (submitter && !session.elementIsNavigatable(submitter)) {
      return false
    }

    return true
  }

  // Computed properties

  get id() {
    return this.element.id
  }

  get enabled() {
    return !this.element.disabled
  }

  get sourceURL() {
    if (this.element.src) {
      return this.element.src
    }
  }

  set sourceURL(sourceURL) {
    this.#ignoringChangesToAttribute("src", () => {
      this.element.src = sourceURL ?? null;
    });
  }

  get loadingStyle() {
    return this.element.loading
  }

  get isLoading() {
    return this.formSubmission !== undefined || this.#resolveVisitPromise() !== undefined
  }

  get complete() {
    return this.element.hasAttribute("complete")
  }

  set complete(value) {
    if (value) {
      this.element.setAttribute("complete", "");
    } else {
      this.element.removeAttribute("complete");
    }
  }

  get isActive() {
    return this.element.isActive && this.#connected
  }

  get rootLocation() {
    const meta = this.element.ownerDocument.querySelector(`meta[name="turbo-root"]`);
    const root = meta?.content ?? "/";
    return expandURL(root)
  }

  #isIgnoringChangesTo(attributeName) {
    return this.#ignoredAttributes.has(attributeName)
  }

  #ignoringChangesToAttribute(attributeName, callback) {
    this.#ignoredAttributes.add(attributeName);
    callback();
    this.#ignoredAttributes.delete(attributeName);
  }

  #withCurrentNavigationElement(element, callback) {
    this.currentNavigationElement = element;
    callback();
    delete this.currentNavigationElement;
  }
}

function getFrameElementById(id) {
  if (id != null) {
    const element = document.getElementById(id);
    if (element instanceof FrameElement) {
      return element
    }
  }
}

function activateElement(element, currentURL) {
  if (element) {
    const src = element.getAttribute("src");
    if (src != null && currentURL != null && urlsAreEqual(src, currentURL)) {
      throw new Error(`Matching <turbo-frame id="${element.id}"> element has a source URL which references itself`)
    }
    if (element.ownerDocument !== document) {
      element = document.importNode(element, true);
    }

    if (element instanceof FrameElement) {
      element.connectedCallback();
      element.disconnectedCallback();
      return element
    }
  }
}

const StreamActions = {
  after() {
    this.targetElements.forEach((e) => e.parentElement?.insertBefore(this.templateContent, e.nextSibling));
  },

  append() {
    this.removeDuplicateTargetChildren();
    this.targetElements.forEach((e) => e.append(this.templateContent));
  },

  before() {
    this.targetElements.forEach((e) => e.parentElement?.insertBefore(this.templateContent, e));
  },

  prepend() {
    this.removeDuplicateTargetChildren();
    this.targetElements.forEach((e) => e.prepend(this.templateContent));
  },

  remove() {
    this.targetElements.forEach((e) => e.remove());
  },

  replace() {
    const method = this.getAttribute("method");

    this.targetElements.forEach((targetElement) => {
      if (method === "morph") {
        morphElements(targetElement, this.templateContent);
      } else {
        targetElement.replaceWith(this.templateContent);
      }
    });
  },

  update() {
    const method = this.getAttribute("method");

    this.targetElements.forEach((targetElement) => {
      if (method === "morph") {
        morphChildren(targetElement, this.templateContent);
      } else {
        targetElement.innerHTML = "";
        targetElement.append(this.templateContent);
      }
    });
  },

  refresh() {
    session.refresh(this.baseURI, this.requestId);
  }
};

// <turbo-stream action=replace target=id><template>...

/**
 * Renders updates to the page from a stream of messages.
 *
 * Using the `action` attribute, this can be configured one of eight ways:
 *
 * - `after` - inserts the result after the target
 * - `append` - appends the result to the target
 * - `before` - inserts the result before the target
 * - `prepend` - prepends the result to the target
 * - `refresh` - initiates a page refresh
 * - `remove` - removes the target
 * - `replace` - replaces the outer HTML of the target
 * - `update` - replaces the inner HTML of the target
 *
 * @customElement turbo-stream
 * @example
 *   <turbo-stream action="append" target="dom_id">
 *     <template>
 *       Content to append to target designated with the dom_id.
 *     </template>
 *   </turbo-stream>
 */
class StreamElement extends HTMLElement {
  static async renderElement(newElement) {
    await newElement.performAction();
  }

  async connectedCallback() {
    try {
      await this.render();
    } catch (error) {
      console.error(error);
    } finally {
      this.disconnect();
    }
  }

  async render() {
    return (this.renderPromise ??= (async () => {
      const event = this.beforeRenderEvent;

      if (this.dispatchEvent(event)) {
        await nextRepaint();
        await event.detail.render(this);
      }
    })())
  }

  disconnect() {
    try {
      this.remove();
      // eslint-disable-next-line no-empty
    } catch {}
  }

  /**
   * Removes duplicate children (by ID)
   */
  removeDuplicateTargetChildren() {
    this.duplicateChildren.forEach((c) => c.remove());
  }

  /**
   * Gets the list of duplicate children (i.e. those with the same ID)
   */
  get duplicateChildren() {
    const existingChildren = this.targetElements.flatMap((e) => [...e.children]).filter((c) => !!c.getAttribute("id"));
    const newChildrenIds = [...(this.templateContent?.children || [])].filter((c) => !!c.getAttribute("id")).map((c) => c.getAttribute("id"));

    return existingChildren.filter((c) => newChildrenIds.includes(c.getAttribute("id")))
  }

  /**
   * Gets the action function to be performed.
   */
  get performAction() {
    if (this.action) {
      const actionFunction = StreamActions[this.action];
      if (actionFunction) {
        return actionFunction
      }
      this.#raise("unknown action");
    }
    this.#raise("action attribute is missing");
  }

  /**
   * Gets the target elements which the template will be rendered to.
   */
  get targetElements() {
    if (this.target) {
      return this.targetElementsById
    } else if (this.targets) {
      return this.targetElementsByQuery
    } else {
      this.#raise("target or targets attribute is missing");
    }
  }

  /**
   * Gets the contents of the main `<template>`.
   */
  get templateContent() {
    return this.templateElement.content.cloneNode(true)
  }

  /**
   * Gets the main `<template>` used for rendering
   */
  get templateElement() {
    if (this.firstElementChild === null) {
      const template = this.ownerDocument.createElement("template");
      this.appendChild(template);
      return template
    } else if (this.firstElementChild instanceof HTMLTemplateElement) {
      return this.firstElementChild
    }
    this.#raise("first child element must be a <template> element");
  }

  /**
   * Gets the current action.
   */
  get action() {
    return this.getAttribute("action")
  }

  /**
   * Gets the current target (an element ID) to which the result will
   * be rendered.
   */
  get target() {
    return this.getAttribute("target")
  }

  /**
   * Gets the current "targets" selector (a CSS selector)
   */
  get targets() {
    return this.getAttribute("targets")
  }

  /**
   * Reads the request-id attribute
   */
  get requestId() {
    return this.getAttribute("request-id")
  }

  #raise(message) {
    throw new Error(`${this.description}: ${message}`)
  }

  get description() {
    return (this.outerHTML.match(/<[^>]+>/) ?? [])[0] ?? "<turbo-stream>"
  }

  get beforeRenderEvent() {
    return new CustomEvent("turbo:before-stream-render", {
      bubbles: true,
      cancelable: true,
      detail: { newStream: this, render: StreamElement.renderElement }
    })
  }

  get targetElementsById() {
    const element = this.ownerDocument?.getElementById(this.target);

    if (element !== null) {
      return [element]
    } else {
      return []
    }
  }

  get targetElementsByQuery() {
    const elements = this.ownerDocument?.querySelectorAll(this.targets);

    if (elements.length !== 0) {
      return Array.prototype.slice.call(elements)
    } else {
      return []
    }
  }
}

class StreamSourceElement extends HTMLElement {
  streamSource = null

  connectedCallback() {
    this.streamSource = this.src.match(/^ws{1,2}:/) ? new WebSocket(this.src) : new EventSource(this.src);

    connectStreamSource(this.streamSource);
  }

  disconnectedCallback() {
    if (this.streamSource) {
      this.streamSource.close();

      disconnectStreamSource(this.streamSource);
    }
  }

  get src() {
    return this.getAttribute("src") || ""
  }
}

FrameElement.delegateConstructor = FrameController;

if (customElements.get("turbo-frame") === undefined) {
  customElements.define("turbo-frame", FrameElement);
}

if (customElements.get("turbo-stream") === undefined) {
  customElements.define("turbo-stream", StreamElement);
}

if (customElements.get("turbo-stream-source") === undefined) {
  customElements.define("turbo-stream-source", StreamSourceElement);
}

(() => {
  let element = document.currentScript;
  if (!element) return
  if (element.hasAttribute("data-turbo-suppress-warning")) return

  element = element.parentElement;
  while (element) {
    if (element == document.body) {
      return console.warn(
        unindent`
        You are loading Turbo from a <script> element inside the <body> element. This is probably not what you meant to do!

        Load your applications JavaScript bundle inside the <head> element instead. <script> elements in <body> are evaluated with each page change.

        For more information, see: https://turbo.hotwired.dev/handbook/building#working-with-script-elements

        
        Suppress this warning by adding a "data-turbo-suppress-warning" attribute to: %s
      `,
        element.outerHTML
      )
    }

    element = element.parentElement;
  }
})();

window.Turbo = { ...Turbo, StreamActions };
start();




/***/ }),

/***/ "./node_modules/@simonwep/pickr/dist/pickr.min.js":
/*!********************************************************!*\
  !*** ./node_modules/@simonwep/pickr/dist/pickr.min.js ***!
  \********************************************************/
/***/ (function(module) {

/*! Pickr 1.9.0 MIT | https://github.com/Simonwep/pickr */
!function(t,e){ true?module.exports=e():0}(self,(()=>(()=>{"use strict";var t={d:(e,o)=>{for(var n in o)t.o(o,n)&&!t.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:o[n]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},e={};t.d(e,{default:()=>E});var o={};function n(t,e,o,n,i={}){e instanceof HTMLCollection||e instanceof NodeList?e=Array.from(e):Array.isArray(e)||(e=[e]),Array.isArray(o)||(o=[o]);for(const s of e)for(const e of o)s[t](e,n,{capture:!1,...i});return Array.prototype.slice.call(arguments,1)}t.r(o),t.d(o,{adjustableInputNumbers:()=>p,createElementFromString:()=>r,createFromTemplate:()=>a,eventPath:()=>l,off:()=>s,on:()=>i,resolveElement:()=>c});const i=n.bind(null,"addEventListener"),s=n.bind(null,"removeEventListener");function r(t){const e=document.createElement("div");return e.innerHTML=t.trim(),e.firstElementChild}function a(t){const e=(t,e)=>{const o=t.getAttribute(e);return t.removeAttribute(e),o},o=(t,n={})=>{const i=e(t,":obj"),s=e(t,":ref"),r=i?n[i]={}:n;s&&(n[s]=t);for(const n of Array.from(t.children)){const t=e(n,":arr"),i=o(n,t?{}:r);t&&(r[t]||(r[t]=[])).push(Object.keys(i).length?i:n)}return n};return o(r(t))}function l(t){let e=t.path||t.composedPath&&t.composedPath();if(e)return e;let o=t.target.parentElement;for(e=[t.target,o];o=o.parentElement;)e.push(o);return e.push(document,window),e}function c(t){return t instanceof Element?t:"string"==typeof t?t.split(/>>/g).reduce(((t,e,o,n)=>(t=t.querySelector(e),o<n.length-1?t.shadowRoot:t)),document):null}function p(t,e=(t=>t)){function o(o){const n=[.001,.01,.1][Number(o.shiftKey||2*o.ctrlKey)]*(o.deltaY<0?1:-1);let i=0,s=t.selectionStart;t.value=t.value.replace(/[\d.]+/g,((t,o)=>o<=s&&o+t.length>=s?(s=o,e(Number(t),n,i)):(i++,t))),t.focus(),t.setSelectionRange(s,s),o.preventDefault(),t.dispatchEvent(new Event("input"))}i(t,"focus",(()=>i(window,"wheel",o,{passive:!1}))),i(t,"blur",(()=>s(window,"wheel",o)))}const{min:u,max:h,floor:d,round:m}=Math;function f(t,e,o){e/=100,o/=100;const n=d(t=t/360*6),i=t-n,s=o*(1-e),r=o*(1-i*e),a=o*(1-(1-i)*e),l=n%6;return[255*[o,r,s,s,a,o][l],255*[a,o,o,r,s,s][l],255*[s,s,a,o,o,r][l]]}function v(t,e,o){const n=(2-(e/=100))*(o/=100)/2;return 0!==n&&(e=1===n?0:n<.5?e*o/(2*n):e*o/(2-2*n)),[t,100*e,100*n]}function b(t,e,o){const n=u(t/=255,e/=255,o/=255),i=h(t,e,o),s=i-n;let r,a;if(0===s)r=a=0;else{a=s/i;const n=((i-t)/6+s/2)/s,l=((i-e)/6+s/2)/s,c=((i-o)/6+s/2)/s;t===i?r=c-l:e===i?r=1/3+n-c:o===i&&(r=2/3+l-n),r<0?r+=1:r>1&&(r-=1)}return[360*r,100*a,100*i]}function y(t,e,o,n){e/=100,o/=100;return[...b(255*(1-u(1,(t/=100)*(1-(n/=100))+n)),255*(1-u(1,e*(1-n)+n)),255*(1-u(1,o*(1-n)+n)))]}function g(t,e,o){e/=100;const n=2*(e*=(o/=100)<.5?o:1-o)/(o+e)*100,i=100*(o+e);return[t,isNaN(n)?0:n,i]}function _(t){return b(...t.match(/.{2}/g).map((t=>parseInt(t,16))))}function w(t){t=t.match(/^[a-zA-Z]+$/)?function(t){if("black"===t.toLowerCase())return"#000";const e=document.createElement("canvas").getContext("2d");return e.fillStyle=t,"#000"===e.fillStyle?null:e.fillStyle}(t):t;const e={cmyk:/^cmyk\D+([\d.]+)\D+([\d.]+)\D+([\d.]+)\D+([\d.]+)/i,rgba:/^rgba?\D+([\d.]+)(%?)\D+([\d.]+)(%?)\D+([\d.]+)(%?)\D*?(([\d.]+)(%?)|$)/i,hsla:/^hsla?\D+([\d.]+)\D+([\d.]+)\D+([\d.]+)\D*?(([\d.]+)(%?)|$)/i,hsva:/^hsva?\D+([\d.]+)\D+([\d.]+)\D+([\d.]+)\D*?(([\d.]+)(%?)|$)/i,hexa:/^#?(([\dA-Fa-f]{3,4})|([\dA-Fa-f]{6})|([\dA-Fa-f]{8}))$/i},o=t=>t.map((t=>/^(|\d+)\.\d+|\d+$/.test(t)?Number(t):void 0));let n;t:for(const i in e)if(n=e[i].exec(t))switch(i){case"cmyk":{const[,t,e,s,r]=o(n);if(t>100||e>100||s>100||r>100)break t;return{values:y(t,e,s,r),type:i}}case"rgba":{let[,t,,e,,s,,,r]=o(n);if(t="%"===n[2]?t/100*255:t,e="%"===n[4]?e/100*255:e,s="%"===n[6]?s/100*255:s,r="%"===n[9]?r/100:r,t>255||e>255||s>255||r<0||r>1)break t;return{values:[...b(t,e,s),r],a:r,type:i}}case"hexa":{let[,t]=n;4!==t.length&&3!==t.length||(t=t.split("").map((t=>t+t)).join(""));const e=t.substring(0,6);let o=t.substring(6);return o=o?parseInt(o,16)/255:void 0,{values:[..._(e),o],a:o,type:i}}case"hsla":{let[,t,e,s,,r]=o(n);if(r="%"===n[6]?r/100:r,t>360||e>100||s>100||r<0||r>1)break t;return{values:[...g(t,e,s),r],a:r,type:i}}case"hsva":{let[,t,e,s,,r]=o(n);if(r="%"===n[6]?r/100:r,t>360||e>100||s>100||r<0||r>1)break t;return{values:[t,e,s,r],a:r,type:i}}}return{values:null,type:null}}function A(t=0,e=0,o=0,n=1){const i=(t,e)=>(o=-1)=>e(~o?t.map((t=>Number(t.toFixed(o)))):t),s={h:t,s:e,v:o,a:n,toHSVA(){const t=[s.h,s.s,s.v,s.a];return t.toString=i(t,(t=>`hsva(${t[0]}, ${t[1]}%, ${t[2]}%, ${s.a})`)),t},toHSLA(){const t=[...v(s.h,s.s,s.v),s.a];return t.toString=i(t,(t=>`hsla(${t[0]}, ${t[1]}%, ${t[2]}%, ${s.a})`)),t},toRGBA(){const t=[...f(s.h,s.s,s.v),s.a];return t.toString=i(t,(t=>`rgba(${t[0]}, ${t[1]}, ${t[2]}, ${s.a})`)),t},toCMYK(){const t=function(t,e,o){const n=f(t,e,o),i=n[0]/255,s=n[1]/255,r=n[2]/255,a=u(1-i,1-s,1-r);return[100*(1===a?0:(1-i-a)/(1-a)),100*(1===a?0:(1-s-a)/(1-a)),100*(1===a?0:(1-r-a)/(1-a)),100*a]}(s.h,s.s,s.v);return t.toString=i(t,(t=>`cmyk(${t[0]}%, ${t[1]}%, ${t[2]}%, ${t[3]}%)`)),t},toHEXA(){const t=function(t,e,o){return f(t,e,o).map((t=>m(t).toString(16).padStart(2,"0")))}(s.h,s.s,s.v),e=s.a>=1?"":Number((255*s.a).toFixed(0)).toString(16).toUpperCase().padStart(2,"0");return e&&t.push(e),t.toString=()=>`#${t.join("").toUpperCase()}`,t},clone:()=>A(s.h,s.s,s.v,s.a)};return s}const $=t=>Math.max(Math.min(t,1),0);function C(t){const e={options:Object.assign({lock:null,onchange:()=>0,onstop:()=>0},t),_keyboard(t){const{options:o}=e,{type:n,key:i}=t;if(document.activeElement===o.wrapper){const{lock:o}=e.options,s="ArrowUp"===i,r="ArrowRight"===i,a="ArrowDown"===i,l="ArrowLeft"===i;if("keydown"===n&&(s||r||a||l)){let n=0,i=0;"v"===o?n=s||r?1:-1:"h"===o?n=s||r?-1:1:(i=s?-1:a?1:0,n=l?-1:r?1:0),e.update($(e.cache.x+.01*n),$(e.cache.y+.01*i)),t.preventDefault()}else i.startsWith("Arrow")&&(e.options.onstop(),t.preventDefault())}},_tapstart(t){i(document,["mouseup","touchend","touchcancel"],e._tapstop),i(document,["mousemove","touchmove"],e._tapmove),t.cancelable&&t.preventDefault(),e._tapmove(t)},_tapmove(t){const{options:o,cache:n}=e,{lock:i,element:s,wrapper:r}=o,a=r.getBoundingClientRect();let l=0,c=0;if(t){const e=t&&t.touches&&t.touches[0];l=t?(e||t).clientX:0,c=t?(e||t).clientY:0,l<a.left?l=a.left:l>a.left+a.width&&(l=a.left+a.width),c<a.top?c=a.top:c>a.top+a.height&&(c=a.top+a.height),l-=a.left,c-=a.top}else n&&(l=n.x*a.width,c=n.y*a.height);"h"!==i&&(s.style.left=`calc(${l/a.width*100}% - ${s.offsetWidth/2}px)`),"v"!==i&&(s.style.top=`calc(${c/a.height*100}% - ${s.offsetHeight/2}px)`),e.cache={x:l/a.width,y:c/a.height};const p=$(l/a.width),u=$(c/a.height);switch(i){case"v":return o.onchange(p);case"h":return o.onchange(u);default:return o.onchange(p,u)}},_tapstop(){e.options.onstop(),s(document,["mouseup","touchend","touchcancel"],e._tapstop),s(document,["mousemove","touchmove"],e._tapmove)},trigger(){e._tapmove()},update(t=0,o=0){const{left:n,top:i,width:s,height:r}=e.options.wrapper.getBoundingClientRect();"h"===e.options.lock&&(o=t),e._tapmove({clientX:n+s*t,clientY:i+r*o})},destroy(){const{options:t,_tapstart:o,_keyboard:n}=e;s(document,["keydown","keyup"],n),s([t.wrapper,t.element],"mousedown",o),s([t.wrapper,t.element],"touchstart",o,{passive:!1})}},{options:o,_tapstart:n,_keyboard:r}=e;return i([o.wrapper,o.element],"mousedown",n),i([o.wrapper,o.element],"touchstart",n,{passive:!1}),i(document,["keydown","keyup"],r),e}function k(t={}){t=Object.assign({onchange:()=>0,className:"",elements:[]},t);const e=i(t.elements,"click",(e=>{t.elements.forEach((o=>o.classList[e.target===o?"add":"remove"](t.className))),t.onchange(e),e.stopPropagation()}));return{destroy:()=>s(...e)}}const S={variantFlipOrder:{start:"sme",middle:"mse",end:"ems"},positionFlipOrder:{top:"tbrl",right:"rltb",bottom:"btrl",left:"lrbt"},position:"bottom",margin:8,padding:0},O=(t,e,o)=>{const n="object"!=typeof t||t instanceof HTMLElement?{reference:t,popper:e,...o}:t;return{update(t=n){const{reference:e,popper:o}=Object.assign(n,t);if(!o||!e)throw new Error("Popper- or reference-element missing.");return((t,e,o)=>{const{container:n,arrow:i,margin:s,padding:r,position:a,variantFlipOrder:l,positionFlipOrder:c}={container:document.documentElement.getBoundingClientRect(),...S,...o},{left:p,top:u}=e.style;e.style.left="0",e.style.top="0";const h=t.getBoundingClientRect(),d=e.getBoundingClientRect(),m={t:h.top-d.height-s,b:h.bottom+s,r:h.right+s,l:h.left-d.width-s},f={vs:h.left,vm:h.left+h.width/2-d.width/2,ve:h.left+h.width-d.width,hs:h.top,hm:h.bottom-h.height/2-d.height/2,he:h.bottom-d.height},[v,b="middle"]=a.split("-"),y=c[v],g=l[b],{top:_,left:w,bottom:A,right:$}=n;for(const t of y){const o="t"===t||"b"===t;let n=m[t];const[s,a]=o?["top","left"]:["left","top"],[l,c]=o?[d.height,d.width]:[d.width,d.height],[p,u]=o?[A,$]:[$,A],[v,b]=o?[_,w]:[w,_];if(!(n<v||n+l+r>p))for(const p of g){let m=f[(o?"v":"h")+p];if(!(m<b||m+c+r>u)){if(m-=d[a],n-=d[s],e.style[a]=`${m}px`,e.style[s]=`${n}px`,i){const t=o?h.width/2:h.height/2,e=2*t<c?h[a]+t:m+c/2;n<h[s]&&(n+=l),i.style[a]=`${e}px`,i.style[s]=`${n}px`}return t+p}}}return e.style.left=p,e.style.top=u,null})(e,o,n)}}};class E{static utils=o;static version="1.9.0";static I18N_DEFAULTS={"ui:dialog":"color picker dialog","btn:toggle":"toggle color picker dialog","btn:swatch":"color swatch","btn:last-color":"use previous color","btn:save":"Save","btn:cancel":"Cancel","btn:clear":"Clear","aria:btn:save":"save and close","aria:btn:cancel":"cancel and close","aria:btn:clear":"clear and close","aria:input":"color input field","aria:palette":"color selection area","aria:hue":"hue selection slider","aria:opacity":"selection slider"};static DEFAULT_OPTIONS={appClass:null,theme:"classic",useAsButton:!1,padding:8,disabled:!1,comparison:!0,closeOnScroll:!1,outputPrecision:0,lockOpacity:!1,autoReposition:!0,container:"body",components:{interaction:{}},i18n:{},swatches:null,inline:!1,sliders:null,default:"#42445a",defaultRepresentation:null,position:"bottom-middle",adjustableNumbers:!0,showAlways:!1,closeWithKey:"Escape"};_initializingActive=!0;_recalc=!0;_nanopop=null;_root=null;_color=A();_lastColor=A();_swatchColors=[];_setupAnimationFrame=null;_eventListener={init:[],save:[],hide:[],show:[],clear:[],change:[],changestop:[],cancel:[],swatchselect:[]};constructor(t){this.options=t=Object.assign({...E.DEFAULT_OPTIONS},t);const{swatches:e,components:o,theme:n,sliders:i,lockOpacity:s,padding:r}=t;["nano","monolith"].includes(n)&&!i&&(t.sliders="h"),o.interaction||(o.interaction={});const{preview:a,opacity:l,hue:c,palette:p}=o;o.opacity=!s&&l,o.palette=p||a||l||c,this._preBuild(),this._buildComponents(),this._bindEvents(),this._finalBuild(),e&&e.length&&e.forEach((t=>this.addSwatch(t)));const{button:u,app:h}=this._root;this._nanopop=O(u,h,{margin:r}),u.setAttribute("role","button"),u.setAttribute("aria-label",this._t("btn:toggle"));const d=this;this._setupAnimationFrame=requestAnimationFrame((function e(){if(!h.offsetWidth)return requestAnimationFrame(e);d.setColor(t.default),d._rePositioningPicker(),t.defaultRepresentation&&(d._representation=t.defaultRepresentation,d.setColorRepresentation(d._representation)),t.showAlways&&d.show(),d._initializingActive=!1,d._emit("init")}))}static create=t=>new E(t);_preBuild(){const{options:t}=this;for(const e of["el","container"])t[e]=c(t[e]);this._root=(t=>{const{components:e,useAsButton:o,inline:n,appClass:i,theme:s,lockOpacity:r}=t.options,l=t=>t?"":'style="display:none" hidden',c=e=>t._t(e),p=a(`\n      <div :ref="root" class="pickr">\n\n        ${o?"":'<button type="button" :ref="button" class="pcr-button"></button>'}\n\n        <div :ref="app" class="pcr-app ${i||""}" data-theme="${s}" ${n?'style="position: unset"':""} aria-label="${c("ui:dialog")}" role="window">\n          <div class="pcr-selection" ${l(e.palette)}>\n            <div :obj="preview" class="pcr-color-preview" ${l(e.preview)}>\n              <button type="button" :ref="lastColor" class="pcr-last-color" aria-label="${c("btn:last-color")}"></button>\n              <div :ref="currentColor" class="pcr-current-color"></div>\n            </div>\n\n            <div :obj="palette" class="pcr-color-palette">\n              <div :ref="picker" class="pcr-picker"></div>\n              <div :ref="palette" class="pcr-palette" tabindex="0" aria-label="${c("aria:palette")}" role="listbox"></div>\n            </div>\n\n            <div :obj="hue" class="pcr-color-chooser" ${l(e.hue)}>\n              <div :ref="picker" class="pcr-picker"></div>\n              <div :ref="slider" class="pcr-hue pcr-slider" tabindex="0" aria-label="${c("aria:hue")}" role="slider"></div>\n            </div>\n\n            <div :obj="opacity" class="pcr-color-opacity" ${l(e.opacity)}>\n              <div :ref="picker" class="pcr-picker"></div>\n              <div :ref="slider" class="pcr-opacity pcr-slider" tabindex="0" aria-label="${c("aria:opacity")}" role="slider"></div>\n            </div>\n          </div>\n\n          <div class="pcr-swatches ${e.palette?"":"pcr-last"}" :ref="swatches"></div>\n\n          <div :obj="interaction" class="pcr-interaction" ${l(Object.keys(e.interaction).length)}>\n            <input :ref="result" class="pcr-result" type="text" spellcheck="false" ${l(e.interaction.input)} aria-label="${c("aria:input")}">\n\n            <input :arr="options" class="pcr-type" data-type="HEXA" value="${r?"HEX":"HEXA"}" type="button" ${l(e.interaction.hex)}>\n            <input :arr="options" class="pcr-type" data-type="RGBA" value="${r?"RGB":"RGBA"}" type="button" ${l(e.interaction.rgba)}>\n            <input :arr="options" class="pcr-type" data-type="HSLA" value="${r?"HSL":"HSLA"}" type="button" ${l(e.interaction.hsla)}>\n            <input :arr="options" class="pcr-type" data-type="HSVA" value="${r?"HSV":"HSVA"}" type="button" ${l(e.interaction.hsva)}>\n            <input :arr="options" class="pcr-type" data-type="CMYK" value="CMYK" type="button" ${l(e.interaction.cmyk)}>\n\n            <input :ref="save" class="pcr-save" value="${c("btn:save")}" type="button" ${l(e.interaction.save)} aria-label="${c("aria:btn:save")}">\n            <input :ref="cancel" class="pcr-cancel" value="${c("btn:cancel")}" type="button" ${l(e.interaction.cancel)} aria-label="${c("aria:btn:cancel")}">\n            <input :ref="clear" class="pcr-clear" value="${c("btn:clear")}" type="button" ${l(e.interaction.clear)} aria-label="${c("aria:btn:clear")}">\n          </div>\n        </div>\n      </div>\n    `),u=p.interaction;return u.options.find((t=>!t.hidden&&!t.classList.add("active"))),u.type=()=>u.options.find((t=>t.classList.contains("active"))),p})(this),t.useAsButton&&(this._root.button=t.el),t.container.appendChild(this._root.root)}_finalBuild(){const t=this.options,e=this._root;if(t.container.removeChild(e.root),t.inline){const o=t.el.parentElement;t.el.nextSibling?o.insertBefore(e.app,t.el.nextSibling):o.appendChild(e.app)}else t.container.appendChild(e.app);t.useAsButton?t.inline&&t.el.remove():t.el.parentNode.replaceChild(e.root,t.el),t.disabled&&this.disable(),t.comparison||(e.button.style.transition="none",t.useAsButton||(e.preview.lastColor.style.transition="none")),this.hide()}_buildComponents(){const t=this,e=this.options.components,o=(t.options.sliders||"v").repeat(2),[n,i]=o.match(/^[vh]+$/g)?o:[],s=()=>this._color||(this._color=this._lastColor.clone()),r={palette:C({element:t._root.palette.picker,wrapper:t._root.palette.palette,onstop:()=>t._emit("changestop","slider",t),onchange(o,n){if(!e.palette)return;const i=s(),{_root:r,options:a}=t,{lastColor:l,currentColor:c}=r.preview;t._recalc&&(i.s=100*o,i.v=100-100*n,i.v<0&&(i.v=0),t._updateOutput("slider"));const p=i.toRGBA().toString(0);this.element.style.background=p,this.wrapper.style.background=`\n                        linear-gradient(to top, rgba(0, 0, 0, ${i.a}), transparent),\n                        linear-gradient(to left, hsla(${i.h}, 100%, 50%, ${i.a}), rgba(255, 255, 255, ${i.a}))\n                    `,a.comparison?a.useAsButton||t._lastColor||l.style.setProperty("--pcr-color",p):(r.button.style.setProperty("--pcr-color",p),r.button.classList.remove("clear"));const u=i.toHEXA().toString();for(const{el:e,color:o}of t._swatchColors)e.classList[u===o.toHEXA().toString()?"add":"remove"]("pcr-active");c.style.setProperty("--pcr-color",p)}}),hue:C({lock:"v"===i?"h":"v",element:t._root.hue.picker,wrapper:t._root.hue.slider,onstop:()=>t._emit("changestop","slider",t),onchange(o){if(!e.hue||!e.palette)return;const n=s();t._recalc&&(n.h=360*o),this.element.style.backgroundColor=`hsl(${n.h}, 100%, 50%)`,r.palette.trigger()}}),opacity:C({lock:"v"===n?"h":"v",element:t._root.opacity.picker,wrapper:t._root.opacity.slider,onstop:()=>t._emit("changestop","slider",t),onchange(o){if(!e.opacity||!e.palette)return;const n=s();t._recalc&&(n.a=Math.round(100*o)/100),this.element.style.background=`rgba(0, 0, 0, ${n.a})`,r.palette.trigger()}}),selectable:k({elements:t._root.interaction.options,className:"active",onchange(e){t._representation=e.target.getAttribute("data-type").toUpperCase(),t._recalc&&t._updateOutput("swatch")}})};this._components=r}_bindEvents(){const{_root:t,options:e}=this,o=[i(t.interaction.clear,"click",(()=>this._clearColor())),i([t.interaction.cancel,t.preview.lastColor],"click",(()=>{this.setHSVA(...(this._lastColor||this._color).toHSVA(),!0),this._emit("cancel")})),i(t.interaction.save,"click",(()=>{!this.applyColor()&&!e.showAlways&&this.hide()})),i(t.interaction.result,["keyup","input"],(t=>{this.setColor(t.target.value,!0)&&!this._initializingActive&&(this._emit("change",this._color,"input",this),this._emit("changestop","input",this)),t.stopImmediatePropagation()})),i(t.interaction.result,["focus","blur"],(t=>{this._recalc="blur"===t.type,this._recalc&&this._updateOutput(null)})),i([t.palette.palette,t.palette.picker,t.hue.slider,t.hue.picker,t.opacity.slider,t.opacity.picker],["mousedown","touchstart"],(()=>this._recalc=!0),{passive:!0})];if(!e.showAlways){const n=e.closeWithKey;o.push(i(t.button,"click",(()=>this.isOpen()?this.hide():this.show())),i(document,"keyup",(t=>this.isOpen()&&(t.key===n||t.code===n)&&this.hide())),i(document,["touchstart","mousedown"],(e=>{this.isOpen()&&!l(e).some((e=>e===t.app||e===t.button))&&this.hide()}),{capture:!0}))}if(e.adjustableNumbers){const e={rgba:[255,255,255,1],hsva:[360,100,100,1],hsla:[360,100,100,1],cmyk:[100,100,100,100]};p(t.interaction.result,((t,o,n)=>{const i=e[this.getColorRepresentation().toLowerCase()];if(i){const e=i[n],s=t+(e>=100?1e3*o:o);return s<=0?0:Number((s<e?s:e).toPrecision(3))}return t}))}if(e.autoReposition&&!e.inline){let t=null;const n=this;o.push(i(window,["scroll","resize"],(()=>{n.isOpen()&&(e.closeOnScroll&&n.hide(),null===t?(t=setTimeout((()=>t=null),100),requestAnimationFrame((function e(){n._rePositioningPicker(),null!==t&&requestAnimationFrame(e)}))):(clearTimeout(t),t=setTimeout((()=>t=null),100)))}),{capture:!0}))}this._eventBindings=o}_rePositioningPicker(){const{options:t}=this;if(!t.inline){if(!this._nanopop.update({container:document.body.getBoundingClientRect(),position:t.position})){const t=this._root.app,e=t.getBoundingClientRect();t.style.top=(window.innerHeight-e.height)/2+"px",t.style.left=(window.innerWidth-e.width)/2+"px"}}}_updateOutput(t){const{_root:e,_color:o,options:n}=this;if(e.interaction.type()){const t=`to${e.interaction.type().getAttribute("data-type")}`;e.interaction.result.value="function"==typeof o[t]?o[t]().toString(n.outputPrecision):""}!this._initializingActive&&this._recalc&&this._emit("change",o,t,this)}_clearColor(t=!1){const{_root:e,options:o}=this;o.useAsButton||e.button.style.setProperty("--pcr-color","rgba(0, 0, 0, 0.15)"),e.button.classList.add("clear"),o.showAlways||this.hide(),this._lastColor=null,this._initializingActive||t||(this._emit("save",null),this._emit("clear"))}_parseLocalColor(t){const{values:e,type:o,a:n}=w(t),{lockOpacity:i}=this.options,s=void 0!==n&&1!==n;return e&&3===e.length&&(e[3]=void 0),{values:!e||i&&s?null:e,type:o}}_t(t){return this.options.i18n[t]||E.I18N_DEFAULTS[t]}_emit(t,...e){this._eventListener[t].forEach((t=>t(...e,this)))}on(t,e){return this._eventListener[t].push(e),this}off(t,e){const o=this._eventListener[t]||[],n=o.indexOf(e);return~n&&o.splice(n,1),this}addSwatch(t){const{values:e}=this._parseLocalColor(t);if(e){const{_swatchColors:t,_root:o}=this,n=A(...e),s=r(`<button type="button" style="--pcr-color: ${n.toRGBA().toString(0)}" aria-label="${this._t("btn:swatch")}"/>`);return o.swatches.appendChild(s),t.push({el:s,color:n}),this._eventBindings.push(i(s,"click",(()=>{this.setHSVA(...n.toHSVA(),!0),this._emit("swatchselect",n),this._emit("change",n,"swatch",this)}))),!0}return!1}removeSwatch(t){const e=this._swatchColors[t];if(e){const{el:o}=e;return this._root.swatches.removeChild(o),this._swatchColors.splice(t,1),!0}return!1}applyColor(t=!1){const{preview:e,button:o}=this._root,n=this._color.toRGBA().toString(0);return e.lastColor.style.setProperty("--pcr-color",n),this.options.useAsButton||o.style.setProperty("--pcr-color",n),o.classList.remove("clear"),this._lastColor=this._color.clone(),this._initializingActive||t||this._emit("save",this._color),this}destroy(){cancelAnimationFrame(this._setupAnimationFrame),this._eventBindings.forEach((t=>s(...t))),Object.keys(this._components).forEach((t=>this._components[t].destroy()))}destroyAndRemove(){this.destroy();const{root:t,app:e}=this._root;t.parentElement&&t.parentElement.removeChild(t),e.parentElement.removeChild(e),Object.keys(this).forEach((t=>this[t]=null))}hide(){return!!this.isOpen()&&(this._root.app.classList.remove("visible"),this._emit("hide"),!0)}show(){return!this.options.disabled&&!this.isOpen()&&(this._root.app.classList.add("visible"),this._rePositioningPicker(),this._emit("show",this._color),this)}isOpen(){return this._root.app.classList.contains("visible")}setHSVA(t=360,e=0,o=0,n=1,i=!1){const s=this._recalc;if(this._recalc=!1,t<0||t>360||e<0||e>100||o<0||o>100||n<0||n>1)return!1;this._color=A(t,e,o,n);const{hue:r,opacity:a,palette:l}=this._components;return r.update(t/360),a.update(n),l.update(e/100,1-o/100),i||this.applyColor(),s&&this._updateOutput(),this._recalc=s,!0}setColor(t,e=!1){if(null===t)return this._clearColor(e),!0;const{values:o,type:n}=this._parseLocalColor(t);if(o){const t=n.toUpperCase(),{options:i}=this._root.interaction,s=i.find((e=>e.getAttribute("data-type")===t));if(s&&!s.hidden)for(const t of i)t.classList[t===s?"add":"remove"]("active");return!!this.setHSVA(...o,e)&&this.setColorRepresentation(t)}return!1}setColorRepresentation(t){return t=t.toUpperCase(),!!this._root.interaction.options.find((e=>e.getAttribute("data-type").startsWith(t)&&!e.click()))}getColorRepresentation(){return this._representation}getColor(){return this._color}getSelectedColor(){return this._lastColor}getRoot(){return this._root}disable(){return this.hide(),this.options.disabled=!0,this._root.button.classList.add("disabled"),this}enable(){return this.options.disabled=!1,this._root.button.classList.remove("disabled"),this}}return e=e.default})()));
//# sourceMappingURL=pickr.min.js.map

/***/ }),

/***/ "./node_modules/@simplewebauthn/browser/esm/helpers/base64URLStringToBuffer.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@simplewebauthn/browser/esm/helpers/base64URLStringToBuffer.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   base64URLStringToBuffer: function() { return /* binding */ base64URLStringToBuffer; }
/* harmony export */ });
/**
 * Convert from a Base64URL-encoded string to an Array Buffer. Best used when converting a
 * credential ID from a JSON string to an ArrayBuffer, like in allowCredentials or
 * excludeCredentials
 *
 * Helper method to compliment `bufferToBase64URLString`
 */
function base64URLStringToBuffer(base64URLString) {
    // Convert from Base64URL to Base64
    const base64 = base64URLString.replace(/-/g, '+').replace(/_/g, '/');
    /**
     * Pad with '=' until it's a multiple of four
     * (4 - (85 % 4 = 1) = 3) % 4 = 3 padding
     * (4 - (86 % 4 = 2) = 2) % 4 = 2 padding
     * (4 - (87 % 4 = 3) = 1) % 4 = 1 padding
     * (4 - (88 % 4 = 0) = 4) % 4 = 0 padding
     */
    const padLength = (4 - (base64.length % 4)) % 4;
    const padded = base64.padEnd(base64.length + padLength, '=');
    // Convert to a binary string
    const binary = atob(padded);
    // Convert binary string to buffer
    const buffer = new ArrayBuffer(binary.length);
    const bytes = new Uint8Array(buffer);
    for (let i = 0; i < binary.length; i++) {
        bytes[i] = binary.charCodeAt(i);
    }
    return buffer;
}


/***/ }),

/***/ "./node_modules/@simplewebauthn/browser/esm/helpers/browserSupportsWebAuthn.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@simplewebauthn/browser/esm/helpers/browserSupportsWebAuthn.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   _browserSupportsWebAuthnInternals: function() { return /* binding */ _browserSupportsWebAuthnInternals; },
/* harmony export */   browserSupportsWebAuthn: function() { return /* binding */ browserSupportsWebAuthn; }
/* harmony export */ });
/**
 * Determine if the browser is capable of Webauthn
 */
function browserSupportsWebAuthn() {
    return _browserSupportsWebAuthnInternals.stubThis(globalThis?.PublicKeyCredential !== undefined &&
        typeof globalThis.PublicKeyCredential === 'function');
}
/**
 * Make it possible to stub the return value during testing
 * @ignore Don't include this in docs output
 */
const _browserSupportsWebAuthnInternals = {
    stubThis: (value) => value,
};


/***/ }),

/***/ "./node_modules/@simplewebauthn/browser/esm/helpers/browserSupportsWebAuthnAutofill.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@simplewebauthn/browser/esm/helpers/browserSupportsWebAuthnAutofill.js ***!
  \*********************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   _browserSupportsWebAuthnAutofillInternals: function() { return /* binding */ _browserSupportsWebAuthnAutofillInternals; },
/* harmony export */   browserSupportsWebAuthnAutofill: function() { return /* binding */ browserSupportsWebAuthnAutofill; }
/* harmony export */ });
/* harmony import */ var _browserSupportsWebAuthn_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./browserSupportsWebAuthn.js */ "./node_modules/@simplewebauthn/browser/esm/helpers/browserSupportsWebAuthn.js");

/**
 * Determine if the browser supports conditional UI, so that WebAuthn credentials can
 * be shown to the user in the browser's typical password autofill popup.
 */
function browserSupportsWebAuthnAutofill() {
    if (!(0,_browserSupportsWebAuthn_js__WEBPACK_IMPORTED_MODULE_0__.browserSupportsWebAuthn)()) {
        return _browserSupportsWebAuthnAutofillInternals.stubThis(new Promise((resolve) => resolve(false)));
    }
    /**
     * I don't like the `as unknown` here but there's a `declare var PublicKeyCredential` in
     * TS' DOM lib that's making it difficult for me to just go `as PublicKeyCredentialFuture` as I
     * want. I think I'm fine with this for now since it's _supposed_ to be temporary, until TS types
     * have a chance to catch up.
     */
    const globalPublicKeyCredential = globalThis
        .PublicKeyCredential;
    if (globalPublicKeyCredential?.isConditionalMediationAvailable === undefined) {
        return _browserSupportsWebAuthnAutofillInternals.stubThis(new Promise((resolve) => resolve(false)));
    }
    return _browserSupportsWebAuthnAutofillInternals.stubThis(globalPublicKeyCredential.isConditionalMediationAvailable());
}
// Make it possible to stub the return value during testing
const _browserSupportsWebAuthnAutofillInternals = {
    stubThis: (value) => value,
};


/***/ }),

/***/ "./node_modules/@simplewebauthn/browser/esm/helpers/bufferToBase64URLString.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@simplewebauthn/browser/esm/helpers/bufferToBase64URLString.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bufferToBase64URLString: function() { return /* binding */ bufferToBase64URLString; }
/* harmony export */ });
/**
 * Convert the given array buffer into a Base64URL-encoded string. Ideal for converting various
 * credential response ArrayBuffers to string for sending back to the server as JSON.
 *
 * Helper method to compliment `base64URLStringToBuffer`
 */
function bufferToBase64URLString(buffer) {
    const bytes = new Uint8Array(buffer);
    let str = '';
    for (const charCode of bytes) {
        str += String.fromCharCode(charCode);
    }
    const base64String = btoa(str);
    return base64String.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
}


/***/ }),

/***/ "./node_modules/@simplewebauthn/browser/esm/helpers/identifyAuthenticationError.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@simplewebauthn/browser/esm/helpers/identifyAuthenticationError.js ***!
  \*****************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   identifyAuthenticationError: function() { return /* binding */ identifyAuthenticationError; }
/* harmony export */ });
/* harmony import */ var _isValidDomain_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isValidDomain.js */ "./node_modules/@simplewebauthn/browser/esm/helpers/isValidDomain.js");
/* harmony import */ var _webAuthnError_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./webAuthnError.js */ "./node_modules/@simplewebauthn/browser/esm/helpers/webAuthnError.js");


/**
 * Attempt to intuit _why_ an error was raised after calling `navigator.credentials.get()`
 */
function identifyAuthenticationError({ error, options, }) {
    const { publicKey } = options;
    if (!publicKey) {
        throw Error('options was missing required publicKey property');
    }
    if (error.name === 'AbortError') {
        if (options.signal instanceof AbortSignal) {
            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 16)
            return new _webAuthnError_js__WEBPACK_IMPORTED_MODULE_1__.WebAuthnError({
                message: 'Authentication ceremony was sent an abort signal',
                code: 'ERROR_CEREMONY_ABORTED',
                cause: error,
            });
        }
    }
    else if (error.name === 'NotAllowedError') {
        /**
         * Pass the error directly through. Platforms are overloading this error beyond what the spec
         * defines and we don't want to overwrite potentially useful error messages.
         */
        return new _webAuthnError_js__WEBPACK_IMPORTED_MODULE_1__.WebAuthnError({
            message: error.message,
            code: 'ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY',
            cause: error,
        });
    }
    else if (error.name === 'SecurityError') {
        const effectiveDomain = globalThis.location.hostname;
        if (!(0,_isValidDomain_js__WEBPACK_IMPORTED_MODULE_0__.isValidDomain)(effectiveDomain)) {
            // https://www.w3.org/TR/webauthn-2/#sctn-discover-from-external-source (Step 5)
            return new _webAuthnError_js__WEBPACK_IMPORTED_MODULE_1__.WebAuthnError({
                message: `${globalThis.location.hostname} is an invalid domain`,
                code: 'ERROR_INVALID_DOMAIN',
                cause: error,
            });
        }
        else if (publicKey.rpId !== effectiveDomain) {
            // https://www.w3.org/TR/webauthn-2/#sctn-discover-from-external-source (Step 6)
            return new _webAuthnError_js__WEBPACK_IMPORTED_MODULE_1__.WebAuthnError({
                message: `The RP ID "${publicKey.rpId}" is invalid for this domain`,
                code: 'ERROR_INVALID_RP_ID',
                cause: error,
            });
        }
    }
    else if (error.name === 'UnknownError') {
        // https://www.w3.org/TR/webauthn-2/#sctn-op-get-assertion (Step 1)
        // https://www.w3.org/TR/webauthn-2/#sctn-op-get-assertion (Step 12)
        return new _webAuthnError_js__WEBPACK_IMPORTED_MODULE_1__.WebAuthnError({
            message: 'The authenticator was unable to process the specified options, or could not create a new assertion signature',
            code: 'ERROR_AUTHENTICATOR_GENERAL_ERROR',
            cause: error,
        });
    }
    return error;
}


/***/ }),

/***/ "./node_modules/@simplewebauthn/browser/esm/helpers/identifyRegistrationError.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@simplewebauthn/browser/esm/helpers/identifyRegistrationError.js ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   identifyRegistrationError: function() { return /* binding */ identifyRegistrationError; }
/* harmony export */ });
/* harmony import */ var _isValidDomain_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isValidDomain.js */ "./node_modules/@simplewebauthn/browser/esm/helpers/isValidDomain.js");
/* harmony import */ var _webAuthnError_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./webAuthnError.js */ "./node_modules/@simplewebauthn/browser/esm/helpers/webAuthnError.js");


/**
 * Attempt to intuit _why_ an error was raised after calling `navigator.credentials.create()`
 */
function identifyRegistrationError({ error, options, }) {
    const { publicKey } = options;
    if (!publicKey) {
        throw Error('options was missing required publicKey property');
    }
    if (error.name === 'AbortError') {
        if (options.signal instanceof AbortSignal) {
            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 16)
            return new _webAuthnError_js__WEBPACK_IMPORTED_MODULE_1__.WebAuthnError({
                message: 'Registration ceremony was sent an abort signal',
                code: 'ERROR_CEREMONY_ABORTED',
                cause: error,
            });
        }
    }
    else if (error.name === 'ConstraintError') {
        if (publicKey.authenticatorSelection?.requireResidentKey === true) {
            // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 4)
            return new _webAuthnError_js__WEBPACK_IMPORTED_MODULE_1__.WebAuthnError({
                message: 'Discoverable credentials were required but no available authenticator supported it',
                code: 'ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT',
                cause: error,
            });
        }
        else if (
        // @ts-ignore: `mediation` doesn't yet exist on CredentialCreationOptions but it's possible as of Sept 2024
        options.mediation === 'conditional' &&
            publicKey.authenticatorSelection?.userVerification === 'required') {
            // https://w3c.github.io/webauthn/#sctn-createCredential (Step 22.4)
            return new _webAuthnError_js__WEBPACK_IMPORTED_MODULE_1__.WebAuthnError({
                message: 'User verification was required during automatic registration but it could not be performed',
                code: 'ERROR_AUTO_REGISTER_USER_VERIFICATION_FAILURE',
                cause: error,
            });
        }
        else if (publicKey.authenticatorSelection?.userVerification === 'required') {
            // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 5)
            return new _webAuthnError_js__WEBPACK_IMPORTED_MODULE_1__.WebAuthnError({
                message: 'User verification was required but no available authenticator supported it',
                code: 'ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT',
                cause: error,
            });
        }
    }
    else if (error.name === 'InvalidStateError') {
        // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 20)
        // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 3)
        return new _webAuthnError_js__WEBPACK_IMPORTED_MODULE_1__.WebAuthnError({
            message: 'The authenticator was previously registered',
            code: 'ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED',
            cause: error,
        });
    }
    else if (error.name === 'NotAllowedError') {
        /**
         * Pass the error directly through. Platforms are overloading this error beyond what the spec
         * defines and we don't want to overwrite potentially useful error messages.
         */
        return new _webAuthnError_js__WEBPACK_IMPORTED_MODULE_1__.WebAuthnError({
            message: error.message,
            code: 'ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY',
            cause: error,
        });
    }
    else if (error.name === 'NotSupportedError') {
        const validPubKeyCredParams = publicKey.pubKeyCredParams.filter((param) => param.type === 'public-key');
        if (validPubKeyCredParams.length === 0) {
            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 10)
            return new _webAuthnError_js__WEBPACK_IMPORTED_MODULE_1__.WebAuthnError({
                message: 'No entry in pubKeyCredParams was of type "public-key"',
                code: 'ERROR_MALFORMED_PUBKEYCREDPARAMS',
                cause: error,
            });
        }
        // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 2)
        return new _webAuthnError_js__WEBPACK_IMPORTED_MODULE_1__.WebAuthnError({
            message: 'No available authenticator supported any of the specified pubKeyCredParams algorithms',
            code: 'ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG',
            cause: error,
        });
    }
    else if (error.name === 'SecurityError') {
        const effectiveDomain = globalThis.location.hostname;
        if (!(0,_isValidDomain_js__WEBPACK_IMPORTED_MODULE_0__.isValidDomain)(effectiveDomain)) {
            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 7)
            return new _webAuthnError_js__WEBPACK_IMPORTED_MODULE_1__.WebAuthnError({
                message: `${globalThis.location.hostname} is an invalid domain`,
                code: 'ERROR_INVALID_DOMAIN',
                cause: error,
            });
        }
        else if (publicKey.rp.id !== effectiveDomain) {
            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 8)
            return new _webAuthnError_js__WEBPACK_IMPORTED_MODULE_1__.WebAuthnError({
                message: `The RP ID "${publicKey.rp.id}" is invalid for this domain`,
                code: 'ERROR_INVALID_RP_ID',
                cause: error,
            });
        }
    }
    else if (error.name === 'TypeError') {
        if (publicKey.user.id.byteLength < 1 || publicKey.user.id.byteLength > 64) {
            // https://www.w3.org/TR/webauthn-2/#sctn-createCredential (Step 5)
            return new _webAuthnError_js__WEBPACK_IMPORTED_MODULE_1__.WebAuthnError({
                message: 'User ID was not between 1 and 64 characters',
                code: 'ERROR_INVALID_USER_ID_LENGTH',
                cause: error,
            });
        }
    }
    else if (error.name === 'UnknownError') {
        // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 1)
        // https://www.w3.org/TR/webauthn-2/#sctn-op-make-cred (Step 8)
        return new _webAuthnError_js__WEBPACK_IMPORTED_MODULE_1__.WebAuthnError({
            message: 'The authenticator was unable to process the specified options, or could not create a new credential',
            code: 'ERROR_AUTHENTICATOR_GENERAL_ERROR',
            cause: error,
        });
    }
    return error;
}


/***/ }),

/***/ "./node_modules/@simplewebauthn/browser/esm/helpers/isValidDomain.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@simplewebauthn/browser/esm/helpers/isValidDomain.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isValidDomain: function() { return /* binding */ isValidDomain; }
/* harmony export */ });
/**
 * A simple test to determine if a hostname is a properly-formatted domain name
 *
 * A "valid domain" is defined here: https://url.spec.whatwg.org/#valid-domain
 *
 * Regex sourced from here:
 * https://www.oreilly.com/library/view/regular-expressions-cookbook/9781449327453/ch08s15.html
 */
function isValidDomain(hostname) {
    return (
    // Consider localhost valid as well since it's okay wrt Secure Contexts
    hostname === 'localhost' ||
        /^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(hostname));
}


/***/ }),

/***/ "./node_modules/@simplewebauthn/browser/esm/helpers/platformAuthenticatorIsAvailable.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@simplewebauthn/browser/esm/helpers/platformAuthenticatorIsAvailable.js ***!
  \**********************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   platformAuthenticatorIsAvailable: function() { return /* binding */ platformAuthenticatorIsAvailable; }
/* harmony export */ });
/* harmony import */ var _browserSupportsWebAuthn_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./browserSupportsWebAuthn.js */ "./node_modules/@simplewebauthn/browser/esm/helpers/browserSupportsWebAuthn.js");

/**
 * Determine whether the browser can communicate with a built-in authenticator, like
 * Touch ID, Android fingerprint scanner, or Windows Hello.
 *
 * This method will _not_ be able to tell you the name of the platform authenticator.
 */
function platformAuthenticatorIsAvailable() {
    if (!(0,_browserSupportsWebAuthn_js__WEBPACK_IMPORTED_MODULE_0__.browserSupportsWebAuthn)()) {
        return new Promise((resolve) => resolve(false));
    }
    return PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();
}


/***/ }),

/***/ "./node_modules/@simplewebauthn/browser/esm/helpers/toAuthenticatorAttachment.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@simplewebauthn/browser/esm/helpers/toAuthenticatorAttachment.js ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   toAuthenticatorAttachment: function() { return /* binding */ toAuthenticatorAttachment; }
/* harmony export */ });
const attachments = ['cross-platform', 'platform'];
/**
 * If possible coerce a `string` value into a known `AuthenticatorAttachment`
 */
function toAuthenticatorAttachment(attachment) {
    if (!attachment) {
        return;
    }
    if (attachments.indexOf(attachment) < 0) {
        return;
    }
    return attachment;
}


/***/ }),

/***/ "./node_modules/@simplewebauthn/browser/esm/helpers/toPublicKeyCredentialDescriptor.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@simplewebauthn/browser/esm/helpers/toPublicKeyCredentialDescriptor.js ***!
  \*********************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   toPublicKeyCredentialDescriptor: function() { return /* binding */ toPublicKeyCredentialDescriptor; }
/* harmony export */ });
/* harmony import */ var _base64URLStringToBuffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base64URLStringToBuffer.js */ "./node_modules/@simplewebauthn/browser/esm/helpers/base64URLStringToBuffer.js");

function toPublicKeyCredentialDescriptor(descriptor) {
    const { id } = descriptor;
    return {
        ...descriptor,
        id: (0,_base64URLStringToBuffer_js__WEBPACK_IMPORTED_MODULE_0__.base64URLStringToBuffer)(id),
        /**
         * `descriptor.transports` is an array of our `AuthenticatorTransportFuture` that includes newer
         * transports that TypeScript's DOM lib is ignorant of. Convince TS that our list of transports
         * are fine to pass to WebAuthn since browsers will recognize the new value.
         */
        transports: descriptor.transports,
    };
}


/***/ }),

/***/ "./node_modules/@simplewebauthn/browser/esm/helpers/webAuthnAbortService.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@simplewebauthn/browser/esm/helpers/webAuthnAbortService.js ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WebAuthnAbortService: function() { return /* binding */ WebAuthnAbortService; }
/* harmony export */ });
class BaseWebAuthnAbortService {
    constructor() {
        Object.defineProperty(this, "controller", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
    }
    createNewAbortSignal() {
        // Abort any existing calls to navigator.credentials.create() or navigator.credentials.get()
        if (this.controller) {
            const abortError = new Error('Cancelling existing WebAuthn API call for new one');
            abortError.name = 'AbortError';
            this.controller.abort(abortError);
        }
        const newController = new AbortController();
        this.controller = newController;
        return newController.signal;
    }
    cancelCeremony() {
        if (this.controller) {
            const abortError = new Error('Manually cancelling existing WebAuthn API call');
            abortError.name = 'AbortError';
            this.controller.abort(abortError);
            this.controller = undefined;
        }
    }
}
/**
 * A service singleton to help ensure that only a single WebAuthn ceremony is active at a time.
 *
 * Users of **@simplewebauthn/browser** shouldn't typically need to use this, but it can help e.g.
 * developers building projects that use client-side routing to better control the behavior of
 * their UX in response to router navigation events.
 */
const WebAuthnAbortService = new BaseWebAuthnAbortService();


/***/ }),

/***/ "./node_modules/@simplewebauthn/browser/esm/helpers/webAuthnError.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@simplewebauthn/browser/esm/helpers/webAuthnError.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WebAuthnError: function() { return /* binding */ WebAuthnError; }
/* harmony export */ });
/**
 * A custom Error used to return a more nuanced error detailing _why_ one of the eight documented
 * errors in the spec was raised after calling `navigator.credentials.create()` or
 * `navigator.credentials.get()`:
 *
 * - `AbortError`
 * - `ConstraintError`
 * - `InvalidStateError`
 * - `NotAllowedError`
 * - `NotSupportedError`
 * - `SecurityError`
 * - `TypeError`
 * - `UnknownError`
 *
 * Error messages were determined through investigation of the spec to determine under which
 * scenarios a given error would be raised.
 */
class WebAuthnError extends Error {
    constructor({ message, code, cause, name, }) {
        // @ts-ignore: help Rollup understand that `cause` is okay to set
        super(message, { cause });
        Object.defineProperty(this, "code", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.name = name ?? cause.name;
        this.code = code;
    }
}


/***/ }),

/***/ "./node_modules/@simplewebauthn/browser/esm/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@simplewebauthn/browser/esm/index.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WebAuthnAbortService: function() { return /* reexport safe */ _helpers_webAuthnAbortService_js__WEBPACK_IMPORTED_MODULE_7__.WebAuthnAbortService; },
/* harmony export */   WebAuthnError: function() { return /* reexport safe */ _helpers_webAuthnError_js__WEBPACK_IMPORTED_MODULE_8__.WebAuthnError; },
/* harmony export */   _browserSupportsWebAuthnAutofillInternals: function() { return /* reexport safe */ _helpers_browserSupportsWebAuthnAutofill_js__WEBPACK_IMPORTED_MODULE_4__._browserSupportsWebAuthnAutofillInternals; },
/* harmony export */   _browserSupportsWebAuthnInternals: function() { return /* reexport safe */ _helpers_browserSupportsWebAuthn_js__WEBPACK_IMPORTED_MODULE_2__._browserSupportsWebAuthnInternals; },
/* harmony export */   base64URLStringToBuffer: function() { return /* reexport safe */ _helpers_base64URLStringToBuffer_js__WEBPACK_IMPORTED_MODULE_5__.base64URLStringToBuffer; },
/* harmony export */   browserSupportsWebAuthn: function() { return /* reexport safe */ _helpers_browserSupportsWebAuthn_js__WEBPACK_IMPORTED_MODULE_2__.browserSupportsWebAuthn; },
/* harmony export */   browserSupportsWebAuthnAutofill: function() { return /* reexport safe */ _helpers_browserSupportsWebAuthnAutofill_js__WEBPACK_IMPORTED_MODULE_4__.browserSupportsWebAuthnAutofill; },
/* harmony export */   bufferToBase64URLString: function() { return /* reexport safe */ _helpers_bufferToBase64URLString_js__WEBPACK_IMPORTED_MODULE_6__.bufferToBase64URLString; },
/* harmony export */   platformAuthenticatorIsAvailable: function() { return /* reexport safe */ _helpers_platformAuthenticatorIsAvailable_js__WEBPACK_IMPORTED_MODULE_3__.platformAuthenticatorIsAvailable; },
/* harmony export */   startAuthentication: function() { return /* reexport safe */ _methods_startAuthentication_js__WEBPACK_IMPORTED_MODULE_1__.startAuthentication; },
/* harmony export */   startRegistration: function() { return /* reexport safe */ _methods_startRegistration_js__WEBPACK_IMPORTED_MODULE_0__.startRegistration; }
/* harmony export */ });
/* harmony import */ var _methods_startRegistration_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./methods/startRegistration.js */ "./node_modules/@simplewebauthn/browser/esm/methods/startRegistration.js");
/* harmony import */ var _methods_startAuthentication_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./methods/startAuthentication.js */ "./node_modules/@simplewebauthn/browser/esm/methods/startAuthentication.js");
/* harmony import */ var _helpers_browserSupportsWebAuthn_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./helpers/browserSupportsWebAuthn.js */ "./node_modules/@simplewebauthn/browser/esm/helpers/browserSupportsWebAuthn.js");
/* harmony import */ var _helpers_platformAuthenticatorIsAvailable_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./helpers/platformAuthenticatorIsAvailable.js */ "./node_modules/@simplewebauthn/browser/esm/helpers/platformAuthenticatorIsAvailable.js");
/* harmony import */ var _helpers_browserSupportsWebAuthnAutofill_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./helpers/browserSupportsWebAuthnAutofill.js */ "./node_modules/@simplewebauthn/browser/esm/helpers/browserSupportsWebAuthnAutofill.js");
/* harmony import */ var _helpers_base64URLStringToBuffer_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./helpers/base64URLStringToBuffer.js */ "./node_modules/@simplewebauthn/browser/esm/helpers/base64URLStringToBuffer.js");
/* harmony import */ var _helpers_bufferToBase64URLString_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./helpers/bufferToBase64URLString.js */ "./node_modules/@simplewebauthn/browser/esm/helpers/bufferToBase64URLString.js");
/* harmony import */ var _helpers_webAuthnAbortService_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./helpers/webAuthnAbortService.js */ "./node_modules/@simplewebauthn/browser/esm/helpers/webAuthnAbortService.js");
/* harmony import */ var _helpers_webAuthnError_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./helpers/webAuthnError.js */ "./node_modules/@simplewebauthn/browser/esm/helpers/webAuthnError.js");
/* harmony import */ var _types_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./types/index.js */ "./node_modules/@simplewebauthn/browser/esm/types/index.js");












/***/ }),

/***/ "./node_modules/@simplewebauthn/browser/esm/methods/startAuthentication.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@simplewebauthn/browser/esm/methods/startAuthentication.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   startAuthentication: function() { return /* binding */ startAuthentication; }
/* harmony export */ });
/* harmony import */ var _helpers_bufferToBase64URLString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/bufferToBase64URLString.js */ "./node_modules/@simplewebauthn/browser/esm/helpers/bufferToBase64URLString.js");
/* harmony import */ var _helpers_base64URLStringToBuffer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/base64URLStringToBuffer.js */ "./node_modules/@simplewebauthn/browser/esm/helpers/base64URLStringToBuffer.js");
/* harmony import */ var _helpers_browserSupportsWebAuthn_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers/browserSupportsWebAuthn.js */ "./node_modules/@simplewebauthn/browser/esm/helpers/browserSupportsWebAuthn.js");
/* harmony import */ var _helpers_browserSupportsWebAuthnAutofill_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers/browserSupportsWebAuthnAutofill.js */ "./node_modules/@simplewebauthn/browser/esm/helpers/browserSupportsWebAuthnAutofill.js");
/* harmony import */ var _helpers_toPublicKeyCredentialDescriptor_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helpers/toPublicKeyCredentialDescriptor.js */ "./node_modules/@simplewebauthn/browser/esm/helpers/toPublicKeyCredentialDescriptor.js");
/* harmony import */ var _helpers_identifyAuthenticationError_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../helpers/identifyAuthenticationError.js */ "./node_modules/@simplewebauthn/browser/esm/helpers/identifyAuthenticationError.js");
/* harmony import */ var _helpers_webAuthnAbortService_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../helpers/webAuthnAbortService.js */ "./node_modules/@simplewebauthn/browser/esm/helpers/webAuthnAbortService.js");
/* harmony import */ var _helpers_toAuthenticatorAttachment_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../helpers/toAuthenticatorAttachment.js */ "./node_modules/@simplewebauthn/browser/esm/helpers/toAuthenticatorAttachment.js");








/**
 * Begin authenticator "login" via WebAuthn assertion
 *
 * @param optionsJSON Output from **@simplewebauthn/server**'s `generateAuthenticationOptions()`
 * @param useBrowserAutofill (Optional) Initialize conditional UI to enable logging in via browser autofill prompts. Defaults to `false`.
 * @param verifyBrowserAutofillInput (Optional) Ensure a suitable `<input>` element is present when `useBrowserAutofill` is `true`. Defaults to `true`.
 */
async function startAuthentication(options) {
    // @ts-ignore: Intentionally check for old call structure to warn about improper API call
    if (!options.optionsJSON && options.challenge) {
        console.warn('startAuthentication() was not called correctly. It will try to continue with the provided options, but this call should be refactored to use the expected call structure instead. See https://simplewebauthn.dev/docs/packages/browser#typeerror-cannot-read-properties-of-undefined-reading-challenge for more information.');
        // @ts-ignore: Reassign the options, passed in as a positional argument, to the expected variable
        options = { optionsJSON: options };
    }
    const { optionsJSON, useBrowserAutofill = false, verifyBrowserAutofillInput = true, } = options;
    if (!(0,_helpers_browserSupportsWebAuthn_js__WEBPACK_IMPORTED_MODULE_2__.browserSupportsWebAuthn)()) {
        throw new Error('WebAuthn is not supported in this browser');
    }
    // We need to avoid passing empty array to avoid blocking retrieval
    // of public key
    let allowCredentials;
    if (optionsJSON.allowCredentials?.length !== 0) {
        allowCredentials = optionsJSON.allowCredentials?.map(_helpers_toPublicKeyCredentialDescriptor_js__WEBPACK_IMPORTED_MODULE_4__.toPublicKeyCredentialDescriptor);
    }
    // We need to convert some values to Uint8Arrays before passing the credentials to the navigator
    const publicKey = {
        ...optionsJSON,
        challenge: (0,_helpers_base64URLStringToBuffer_js__WEBPACK_IMPORTED_MODULE_1__.base64URLStringToBuffer)(optionsJSON.challenge),
        allowCredentials,
    };
    // Prepare options for `.get()`
    const getOptions = {};
    /**
     * Set up the page to prompt the user to select a credential for authentication via the browser's
     * input autofill mechanism.
     */
    if (useBrowserAutofill) {
        if (!(await (0,_helpers_browserSupportsWebAuthnAutofill_js__WEBPACK_IMPORTED_MODULE_3__.browserSupportsWebAuthnAutofill)())) {
            throw Error('Browser does not support WebAuthn autofill');
        }
        // Check for an <input> with "webauthn" in its `autocomplete` attribute
        const eligibleInputs = document.querySelectorAll("input[autocomplete$='webauthn']");
        // WebAuthn autofill requires at least one valid input
        if (eligibleInputs.length < 1 && verifyBrowserAutofillInput) {
            throw Error('No <input> with "webauthn" as the only or last value in its `autocomplete` attribute was detected');
        }
        // `CredentialMediationRequirement` doesn't know about "conditional" yet as of
        // typescript@4.6.3
        getOptions.mediation = 'conditional';
        // Conditional UI requires an empty allow list
        publicKey.allowCredentials = [];
    }
    // Finalize options
    getOptions.publicKey = publicKey;
    // Set up the ability to cancel this request if the user attempts another
    getOptions.signal = _helpers_webAuthnAbortService_js__WEBPACK_IMPORTED_MODULE_6__.WebAuthnAbortService.createNewAbortSignal();
    // Wait for the user to complete assertion
    let credential;
    try {
        credential = (await navigator.credentials.get(getOptions));
    }
    catch (err) {
        throw (0,_helpers_identifyAuthenticationError_js__WEBPACK_IMPORTED_MODULE_5__.identifyAuthenticationError)({ error: err, options: getOptions });
    }
    if (!credential) {
        throw new Error('Authentication was not completed');
    }
    const { id, rawId, response, type } = credential;
    let userHandle = undefined;
    if (response.userHandle) {
        userHandle = (0,_helpers_bufferToBase64URLString_js__WEBPACK_IMPORTED_MODULE_0__.bufferToBase64URLString)(response.userHandle);
    }
    // Convert values to base64 to make it easier to send back to the server
    return {
        id,
        rawId: (0,_helpers_bufferToBase64URLString_js__WEBPACK_IMPORTED_MODULE_0__.bufferToBase64URLString)(rawId),
        response: {
            authenticatorData: (0,_helpers_bufferToBase64URLString_js__WEBPACK_IMPORTED_MODULE_0__.bufferToBase64URLString)(response.authenticatorData),
            clientDataJSON: (0,_helpers_bufferToBase64URLString_js__WEBPACK_IMPORTED_MODULE_0__.bufferToBase64URLString)(response.clientDataJSON),
            signature: (0,_helpers_bufferToBase64URLString_js__WEBPACK_IMPORTED_MODULE_0__.bufferToBase64URLString)(response.signature),
            userHandle,
        },
        type,
        clientExtensionResults: credential.getClientExtensionResults(),
        authenticatorAttachment: (0,_helpers_toAuthenticatorAttachment_js__WEBPACK_IMPORTED_MODULE_7__.toAuthenticatorAttachment)(credential.authenticatorAttachment),
    };
}


/***/ }),

/***/ "./node_modules/@simplewebauthn/browser/esm/methods/startRegistration.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@simplewebauthn/browser/esm/methods/startRegistration.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   startRegistration: function() { return /* binding */ startRegistration; }
/* harmony export */ });
/* harmony import */ var _helpers_bufferToBase64URLString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/bufferToBase64URLString.js */ "./node_modules/@simplewebauthn/browser/esm/helpers/bufferToBase64URLString.js");
/* harmony import */ var _helpers_base64URLStringToBuffer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/base64URLStringToBuffer.js */ "./node_modules/@simplewebauthn/browser/esm/helpers/base64URLStringToBuffer.js");
/* harmony import */ var _helpers_browserSupportsWebAuthn_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers/browserSupportsWebAuthn.js */ "./node_modules/@simplewebauthn/browser/esm/helpers/browserSupportsWebAuthn.js");
/* harmony import */ var _helpers_toPublicKeyCredentialDescriptor_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers/toPublicKeyCredentialDescriptor.js */ "./node_modules/@simplewebauthn/browser/esm/helpers/toPublicKeyCredentialDescriptor.js");
/* harmony import */ var _helpers_identifyRegistrationError_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helpers/identifyRegistrationError.js */ "./node_modules/@simplewebauthn/browser/esm/helpers/identifyRegistrationError.js");
/* harmony import */ var _helpers_webAuthnAbortService_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../helpers/webAuthnAbortService.js */ "./node_modules/@simplewebauthn/browser/esm/helpers/webAuthnAbortService.js");
/* harmony import */ var _helpers_toAuthenticatorAttachment_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../helpers/toAuthenticatorAttachment.js */ "./node_modules/@simplewebauthn/browser/esm/helpers/toAuthenticatorAttachment.js");







/**
 * Begin authenticator "registration" via WebAuthn attestation
 *
 * @param optionsJSON Output from **@simplewebauthn/server**'s `generateRegistrationOptions()`
 * @param useAutoRegister (Optional) Try to silently create a passkey with the password manager that the user just signed in with. Defaults to `false`.
 */
async function startRegistration(options) {
    // @ts-ignore: Intentionally check for old call structure to warn about improper API call
    if (!options.optionsJSON && options.challenge) {
        console.warn('startRegistration() was not called correctly. It will try to continue with the provided options, but this call should be refactored to use the expected call structure instead. See https://simplewebauthn.dev/docs/packages/browser#typeerror-cannot-read-properties-of-undefined-reading-challenge for more information.');
        // @ts-ignore: Reassign the options, passed in as a positional argument, to the expected variable
        options = { optionsJSON: options };
    }
    const { optionsJSON, useAutoRegister = false } = options;
    if (!(0,_helpers_browserSupportsWebAuthn_js__WEBPACK_IMPORTED_MODULE_2__.browserSupportsWebAuthn)()) {
        throw new Error('WebAuthn is not supported in this browser');
    }
    // We need to convert some values to Uint8Arrays before passing the credentials to the navigator
    const publicKey = {
        ...optionsJSON,
        challenge: (0,_helpers_base64URLStringToBuffer_js__WEBPACK_IMPORTED_MODULE_1__.base64URLStringToBuffer)(optionsJSON.challenge),
        user: {
            ...optionsJSON.user,
            id: (0,_helpers_base64URLStringToBuffer_js__WEBPACK_IMPORTED_MODULE_1__.base64URLStringToBuffer)(optionsJSON.user.id),
        },
        excludeCredentials: optionsJSON.excludeCredentials?.map(_helpers_toPublicKeyCredentialDescriptor_js__WEBPACK_IMPORTED_MODULE_3__.toPublicKeyCredentialDescriptor),
    };
    // Prepare options for `.create()`
    const createOptions = {};
    /**
     * Try to use conditional create to register a passkey for the user with the password manager
     * the user just used to authenticate with. The user won't be shown any prominent UI by the
     * browser.
     */
    if (useAutoRegister) {
        // @ts-ignore: `mediation` doesn't yet exist on CredentialCreationOptions but it's possible as of Sept 2024
        createOptions.mediation = 'conditional';
    }
    // Finalize options
    createOptions.publicKey = publicKey;
    // Set up the ability to cancel this request if the user attempts another
    createOptions.signal = _helpers_webAuthnAbortService_js__WEBPACK_IMPORTED_MODULE_5__.WebAuthnAbortService.createNewAbortSignal();
    // Wait for the user to complete attestation
    let credential;
    try {
        credential = (await navigator.credentials.create(createOptions));
    }
    catch (err) {
        throw (0,_helpers_identifyRegistrationError_js__WEBPACK_IMPORTED_MODULE_4__.identifyRegistrationError)({ error: err, options: createOptions });
    }
    if (!credential) {
        throw new Error('Registration was not completed');
    }
    const { id, rawId, response, type } = credential;
    // Continue to play it safe with `getTransports()` for now, even when L3 types say it's required
    let transports = undefined;
    if (typeof response.getTransports === 'function') {
        transports = response.getTransports();
    }
    // L3 says this is required, but browser and webview support are still not guaranteed.
    let responsePublicKeyAlgorithm = undefined;
    if (typeof response.getPublicKeyAlgorithm === 'function') {
        try {
            responsePublicKeyAlgorithm = response.getPublicKeyAlgorithm();
        }
        catch (error) {
            warnOnBrokenImplementation('getPublicKeyAlgorithm()', error);
        }
    }
    let responsePublicKey = undefined;
    if (typeof response.getPublicKey === 'function') {
        try {
            const _publicKey = response.getPublicKey();
            if (_publicKey !== null) {
                responsePublicKey = (0,_helpers_bufferToBase64URLString_js__WEBPACK_IMPORTED_MODULE_0__.bufferToBase64URLString)(_publicKey);
            }
        }
        catch (error) {
            warnOnBrokenImplementation('getPublicKey()', error);
        }
    }
    // L3 says this is required, but browser and webview support are still not guaranteed.
    let responseAuthenticatorData;
    if (typeof response.getAuthenticatorData === 'function') {
        try {
            responseAuthenticatorData = (0,_helpers_bufferToBase64URLString_js__WEBPACK_IMPORTED_MODULE_0__.bufferToBase64URLString)(response.getAuthenticatorData());
        }
        catch (error) {
            warnOnBrokenImplementation('getAuthenticatorData()', error);
        }
    }
    return {
        id,
        rawId: (0,_helpers_bufferToBase64URLString_js__WEBPACK_IMPORTED_MODULE_0__.bufferToBase64URLString)(rawId),
        response: {
            attestationObject: (0,_helpers_bufferToBase64URLString_js__WEBPACK_IMPORTED_MODULE_0__.bufferToBase64URLString)(response.attestationObject),
            clientDataJSON: (0,_helpers_bufferToBase64URLString_js__WEBPACK_IMPORTED_MODULE_0__.bufferToBase64URLString)(response.clientDataJSON),
            transports,
            publicKeyAlgorithm: responsePublicKeyAlgorithm,
            publicKey: responsePublicKey,
            authenticatorData: responseAuthenticatorData,
        },
        type,
        clientExtensionResults: credential.getClientExtensionResults(),
        authenticatorAttachment: (0,_helpers_toAuthenticatorAttachment_js__WEBPACK_IMPORTED_MODULE_6__.toAuthenticatorAttachment)(credential.authenticatorAttachment),
    };
}
/**
 * Visibly warn when we detect an issue related to a passkey provider intercepting WebAuthn API
 * calls
 */
function warnOnBrokenImplementation(methodName, cause) {
    console.warn(`The browser extension that intercepted this WebAuthn API call incorrectly implemented ${methodName}. You should report this error to them.\n`, cause);
}


/***/ }),

/***/ "./node_modules/@simplewebauthn/browser/esm/types/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@simplewebauthn/browser/esm/types/index.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);



/***/ }),

/***/ "./node_modules/@stimulus-components/color-picker/dist/stimulus-color-picker.mjs":
/*!***************************************************************************************!*\
  !*** ./node_modules/@stimulus-components/color-picker/dist/stimulus-color-picker.mjs ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ ColorPicker; }
/* harmony export */ });
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");
/* harmony import */ var _simonwep_pickr__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @simonwep/pickr */ "./node_modules/@simonwep/pickr/dist/pickr.min.js");


const _ColorPicker = class _ColorPicker extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  initialize() {
    this.onSave = this.onSave.bind(this);
  }
  connect() {
    this.picker = _simonwep_pickr__WEBPACK_IMPORTED_MODULE_1__.create({
      el: this.buttonTarget,
      theme: this.themeValue,
      default: this.inputTarget.value,
      swatches: this.swatches,
      components: this.componentOptions
    }), this.picker.on("save", this.onSave);
  }
  disconnect() {
    this.picker.destroy();
  }
  onSave(color) {
    this.inputTarget.value = null, color && (this.inputTarget.value = color.toHEXA().toString()), this.picker.hide();
  }
  get componentOptions() {
    return {
      preview: !0,
      hue: !0,
      interaction: {
        input: !0,
        clear: !0,
        save: !0
      }
    };
  }
  get swatches() {
    return [
      "#A0AEC0",
      "#F56565",
      "#ED8936",
      "#ECC94B",
      "#48BB78",
      "#38B2AC",
      "#4299E1",
      "#667EEA",
      "#9F7AEA",
      "#ED64A6"
    ];
  }
};
_ColorPicker.targets = ["button", "input"], _ColorPicker.values = {
  theme: {
    type: String,
    default: "classic"
  }
};
let ColorPicker = _ColorPicker;



/***/ }),

/***/ "./node_modules/accessible-menu/dist/accessible-menu.es.js":
/*!*****************************************************************!*\
  !*** ./node_modules/accessible-menu/dist/accessible-menu.es.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ se; }
/* harmony export */ });
var P = Object.defineProperty;
var R = (r, e, t) => e in r ? P(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t;
var u = (r, e, t) => R(r, typeof e != "symbol" ? e + "" : e, t);
function S(r, e) {
  r === "" || r.length === 0 || (typeof r == "string" ? e.classList.add(r) : e.classList.add(...r));
}
function D(r, e) {
  r === "" || r.length === 0 || (typeof r == "string" ? e.classList.remove(r) : e.classList.remove(...r));
}
function A(r, e) {
  try {
    if (typeof e != "object") {
      const t = typeof e;
      throw new TypeError(
        `Elements given to isValidInstance() must be inside of an object. "${t}" given.`
      );
    }
    for (const t in e)
      if (!(e[t] instanceof r)) {
        const s = typeof e[t];
        throw new TypeError(
          `${t} must be an instance of ${r.name}. "${s}" given.`
        );
      }
    return {
      status: !0,
      error: null
    };
  } catch (t) {
    return {
      status: !1,
      error: t
    };
  }
}
function c(r, e) {
  try {
    if (typeof e != "object") {
      const t = typeof e;
      throw new TypeError(
        `Values given to isValidType() must be inside of an object. "${t}" given.`
      );
    }
    for (const t in e) {
      const s = typeof e[t];
      if (s !== r)
        throw new TypeError(`${t} must be a ${r}. "${s}" given.`);
    }
    return {
      status: !0,
      error: null
    };
  } catch (t) {
    return {
      status: !1,
      error: t
    };
  }
}
function x(r) {
  try {
    if (typeof r != "object") {
      const e = typeof r;
      throw new TypeError(
        `Values given to isQuerySelector() must be inside of an object. "${e}" given.`
      );
    }
    for (const e in r)
      try {
        if (r[e] === null)
          throw new Error();
        document.querySelector(r[e]);
      } catch {
        throw new TypeError(
          `${e} must be a valid query selector. "${r[e]}" given.`
        );
      }
    return {
      status: !0,
      error: null
    };
  } catch (e) {
    return {
      status: !1,
      error: e
    };
  }
}
function k(r) {
  try {
    if (typeof r != "object" || Array.isArray(r)) {
      const e = typeof r;
      throw new TypeError(
        `Values given to isValidClassList() must be inside of an object. "${e}" given.`
      );
    }
    for (const e in r) {
      const t = typeof r[e];
      if (t !== "string")
        if (Array.isArray(r[e]))
          r[e].forEach((s) => {
            if (typeof s != "string")
              throw new TypeError(
                `${e} must be a string or an array of strings. An array containing non-strings given.`
              );
          });
        else
          throw new TypeError(
            `${e} must be a string or an array of strings. "${t}" given.`
          );
      else {
        const s = {};
        s[e] = r[e], x(s);
      }
    }
    return {
      status: !0,
      error: null
    };
  } catch (e) {
    return {
      status: !1,
      error: e
    };
  }
}
function U(r) {
  try {
    if (typeof r != "object") {
      const t = typeof r;
      throw new TypeError(
        `Values given to isValidState() must be inside of an object. "${t}" given.`
      );
    }
    const e = ["none", "self", "child"];
    for (const t in r)
      if (!e.includes(r[t]))
        throw new TypeError(
          `${t} must be one of the following values: ${e.join(
            ", "
          )}. "${r[t]}" given.`
        );
    return {
      status: !0,
      error: null
    };
  } catch (e) {
    return {
      status: !1,
      error: e
    };
  }
}
function W(r) {
  try {
    if (typeof r != "object") {
      const t = typeof r;
      throw new TypeError(
        `Values given to isValidEvent() must be inside of an object. "${t}" given.`
      );
    }
    const e = ["none", "mouse", "keyboard", "character"];
    for (const t in r)
      if (!e.includes(r[t]))
        throw new TypeError(
          `${t} must be one of the following values: ${e.join(
            ", "
          )}. "${r[t]}" given.`
        );
    return {
      status: !0,
      error: null
    };
  } catch (e) {
    return {
      status: !1,
      error: e
    };
  }
}
function N(r) {
  try {
    if (typeof r != "object") {
      const t = typeof r;
      throw new TypeError(
        `Values given to isValidHoverType() must be inside of an object. "${t}" given.`
      );
    }
    const e = ["off", "on", "dynamic"];
    for (const t in r)
      if (!e.includes(r[t]))
        throw new TypeError(
          `${t} must be one of the following values: ${e.join(
            ", "
          )}. "${r[t]}" given.`
        );
    return {
      status: !0,
      error: null
    };
  } catch (e) {
    return {
      status: !1,
      error: e
    };
  }
}
function F(r, e) {
  if (c("string", { tagName: r }).status && A(HTMLElement, e).status) {
    const t = r.toLowerCase();
    let s = !0;
    for (const n in e)
      e[n].tagName.toLowerCase() !== t && (s = !1);
    return s;
  } else
    return !1;
}
class L {
  /**
   * Constructs a new `BaseMenuToggle`.
   *
   * @param {object}      options                     - The options for generating the menu toggle.
   * @param {HTMLElement} options.menuToggleElement   - The toggle element in the DOM.
   * @param {HTMLElement} options.parentElement       - The element containing the controlled menu.
   * @param {BaseMenu}    options.controlledMenu      - The menu controlled by this toggle.
   * @param {?BaseMenu}   [options.parentMenu = null] - The menu containing this toggle.
   */
  constructor({
    menuToggleElement: e,
    parentElement: t,
    controlledMenu: s,
    parentMenu: n = null
  }) {
    /**
     * The DOM elements within the menu toggle.
     *
     * @protected
     *
     * @type {Object<HTMLElement>}
     *
     * @property {HTMLElement} toggle - The menu toggle.
     * @property {HTMLElement} parent - The menu containing this toggle.
     */
    u(this, "_dom", {
      toggle: null,
      parent: null
    });
    /**
     * The declared accessible-menu elements within the menu toggle.
     *
     * @protected
     *
     * @type {Object<BaseMenu>}
     *
     * @property {BaseMenu} controlledMenu - The menu controlled by this toggle.
     * @property {BaseMenu} parentMenu     - The menu containing this toggle.
     */
    u(this, "_elements", {
      controlledMenu: null,
      parentMenu: null
    });
    /**
     * The open state of the menu toggle.
     *
     * @protected
     *
     * @type {boolean}
     */
    u(this, "_open", !1);
    /**
     * The event that is triggered when the menu toggle expands.
     *
     * @protected
     *
     * @event accessibleMenuExpand
     *
     * @type {CustomEvent}
     *
     * @property {boolean}                bubbles - A flag to bubble the event.
     * @property {Object<BaseMenuToggle>} details - The details object containing the BaseMenuToggle itself.
     */
    u(this, "_expandEvent", new CustomEvent("accessibleMenuExpand", {
      bubbles: !0,
      detail: { toggle: this }
    }));
    /**
     * The event that is triggered when the menu toggle collapses.
     *
     * @protected
     *
     * @event accessibleMenuCollapse
     *
     * @type {CustomEvent}
     *
     * @property {boolean}                bubbles - A flag to bubble the event.
     * @property {Object<BaseMenuToggle>} details - The details object containing the BaseMenuToggle itself.
     */
    u(this, "_collapseEvent", new CustomEvent("accessibleMenuCollapse", {
      bubbles: !0,
      detail: { toggle: this }
    }));
    this._dom.toggle = e, this._dom.parent = t, this._elements.controlledMenu = s, this._elements.parentMenu = n;
  }
  /**
   * Initializes the menu toggle.
   *
   * The first steps are to ensure that the toggle and controlled menu have IDs
   * using the setIds method, and to set the ARIA attributes on the toggle
   * and controlled menu using the setAriaAttributes method.
   *
   * Then the collapse method is called to make sure the submenu is closed.
   */
  initialize() {
    this._setIds(), this._setAriaAttributes(), this._collapse(!1);
  }
  /**
   * The DOM elements within the toggle.
   *
   * @readonly
   *
   * @type {Object<HTMLElement>}
   *
   * @see _dom
   */
  get dom() {
    return this._dom;
  }
  /**
   * The declared accessible-menu elements within the toggle.
   *
   * @readonly
   *
   * @type {Object<BaseMenu>}
   *
   * @see _elements
   */
  get elements() {
    return this._elements;
  }
  /**
   * The open state on the toggle.
   *
   * @type {boolean}
   *
   * @see _open
   */
  get isOpen() {
    return this._open;
  }
  set isOpen(e) {
    c("boolean", { value: e }), this._open = e;
  }
  /**
   * Sets unique IDs for the toggle and controlled menu.
   *
   * If the toggle and controlled menu do not have IDs, the following steps take place:
   * - Generate a random string 1-10 characters long,
   * - Get the innerText of the toggle,
   * - Set the toggle's ID to: `menu-button-${toggle-inner-text}-${the-random-string}`
   * - Set the menu's ID to: `menu-${toggle-inner-text}-${the-random-string}`
   *
   * @protected
   */
  _setIds() {
    var e;
    if (this.dom.toggle.id === "" || this.elements.controlledMenu.dom.menu.id === "") {
      const t = Math.random().toString(36).replace(/[^a-z]+/g, "").substring(0, 10);
      let s = ((e = this.dom.toggle.innerText) == null ? void 0 : e.replace(/[^a-zA-Z0-9\s]/g, "")) || "", n = t;
      !s.replace(/\s/g, "").length && this.dom.toggle.getAttribute("aria-label") && (s = this.dom.toggle.getAttribute("aria-label").replace(/[^a-zA-Z0-9\s]/g, "")), s.replace(/\s/g, "").length > 0 && (s = s.toLowerCase().replace(/\s+/g, "-"), s.startsWith("-") && (s = s.substring(1)), s.endsWith("-") && (s = s.slice(0, -1)), n = `${s}-${n}`), this.dom.toggle.id = this.dom.toggle.id || `menu-button-${n}`, this.elements.controlledMenu.dom.menu.id = this.elements.controlledMenu.dom.menu.id || `menu-${n}`;
    }
  }
  /**
   * Sets the ARIA attributes on the toggle and controlled menu.
   *
   * The first steps are to ensure that the toggle has `aria-expanded`
   * is initially set to "false".
   *
   * Then using the toggle and menu's IDs, the menu's `aria-labelledby` is set to
   * the toggle's ID.
   *
   * @protected
   */
  _setAriaAttributes() {
    this.dom.toggle.setAttribute("aria-expanded", "false"), this.elements.controlledMenu.dom.menu.setAttribute(
      "aria-labelledby",
      this.dom.toggle.id
    );
  }
  /**
   * Expands the controlled menu.
   *
   * Sets the toggle's `aria-expanded` to "true", adds the
   * open class to the toggle's parent menu item
   * and controlled menu, and removes the closed class
   * from the toggle's parent menu item and controlled menu.
   *
   * If `emit` is set to `true`, this will also emit a custom event
   * called accessibleMenuExpand
   *
   * @protected
   *
   * @fires accessibleMenuExpand
   *
   * @param {boolean} [emit = true] - A toggle to emit the expand event once expanded.
   */
  _expand(e = !0) {
    const { closeClass: t, openClass: s, transitionClass: n, openDuration: i } = this.elements.controlledMenu;
    this.dom.toggle.setAttribute("aria-expanded", "true"), this.elements.controlledMenu.elements.rootMenu.hasOpened = !0, n !== "" ? (S(n, this.elements.controlledMenu.dom.menu), requestAnimationFrame(() => {
      D(t, this.elements.controlledMenu.dom.menu), requestAnimationFrame(() => {
        S(s, this.elements.controlledMenu.dom.menu), requestAnimationFrame(() => {
          setTimeout(() => {
            D(
              n,
              this.elements.controlledMenu.dom.menu
            );
          }, i);
        });
      });
    })) : (S(s, this.elements.controlledMenu.dom.menu), D(t, this.elements.controlledMenu.dom.menu)), e && this.dom.toggle.dispatchEvent(this._expandEvent);
  }
  /**
   * Collapses the controlled menu.
   *
   * Sets the toggle's `aria-expanded` to "false", adds the
   * closed class to the toggle's parent menu item
   * and controlled menu, and removes the open class
   * from the toggle's parent menu item and controlled menu.
   *
   * If `emit` is set to `true`, this will also emit a custom event
   * called accessibleMenuCollapse
   *
   * @protected
   *
   * @fires accessibleMenuCollapse
   *
   * @param {boolean} [emit = true] - A toggle to emit the collapse event once collapsed.
   */
  _collapse(e = !0) {
    const { closeClass: t, openClass: s, transitionClass: n, closeDuration: i } = this.elements.controlledMenu;
    this.dom.toggle.setAttribute("aria-expanded", "false"), n !== "" ? (S(n, this.elements.controlledMenu.dom.menu), requestAnimationFrame(() => {
      D(s, this.elements.controlledMenu.dom.menu), requestAnimationFrame(() => {
        S(t, this.elements.controlledMenu.dom.menu), requestAnimationFrame(() => {
          setTimeout(() => {
            D(
              n,
              this.elements.controlledMenu.dom.menu
            );
          }, i);
        });
      });
    })) : (S(t, this.elements.controlledMenu.dom.menu), D(s, this.elements.controlledMenu.dom.menu)), e && this.dom.toggle.dispatchEvent(this._collapseEvent);
  }
  /**
   * Opens the controlled menu.
   *
   * Sets the controlled menu's focus state to "self"
   * and the parent menu's focus state to "child", calls expand,
   * and sets the isOpen value to `true`.
   *
   * @public
   */
  open() {
    this.elements.controlledMenu.focusState = "self", this.isOpen || (this._expand(), this.isOpen = !0);
  }
  /**
   * Opens the controlled menu without the current focus entering it.
   *
   * Sets the controlled menu's focus state to "self"
   * and the parent menu's focus state to "child",
   * and calls expand.
   *
   * @public
   */
  preview() {
    this.elements.parentMenu && (this.elements.parentMenu.focusState = "self"), this.isOpen || (this._expand(), this.isOpen = !0);
  }
  /**
   * Closes the controlled menu.
   *
   * Sets the controlled menu's focus state to "none"
   * and the parent menu's focus state to "self", blurs the controlled menu
   * and sets it's current child index to 0,
   * calls collapse, and sets
   * the isOpen value to `false`.
   *
   * @public
   */
  close() {
    this.isOpen && (this.elements.controlledMenu.blur(), this.elements.parentMenu && (this.elements.parentMenu.focusState = "self"), this._collapse(), this.isOpen = !1);
  }
  /**
   * Toggles the open state of the controlled menu between `true` and `false`.
   *
   * @public
   */
  toggle() {
    this.isOpen ? this.close() : this.open();
  }
  /**
   * Closes all sibling menus.
   *
   * @public
   */
  closeSiblings() {
    this.elements.parentMenu && this.elements.parentMenu.elements.submenuToggles.forEach((e) => {
      e !== this && e.close();
    });
  }
  /**
   * Closes all child menus.
   *
   * @public
   */
  closeChildren() {
    this.elements.controlledMenu.elements.submenuToggles.forEach(
      (e) => e.close()
    );
  }
}
class O {
  /**
   * Constructs a new `BaseMenuItem`.
   *
   * @param {object}          options                         - The options for generating the menu item.
   * @param {HTMLElement}     options.menuItemElement         - The menu item in the DOM.
   * @param {HTMLElement}     options.menuLinkElement         - The menu item's link in the DOM.
   * @param {BaseMenu}        options.parentMenu              - The parent menu.
   * @param {boolean}         [options.isSubmenuItem = false] - A flag to mark if the menu item is controlling a submenu.
   * @param {?BaseMenu}       [options.childMenu = null]      - The child menu.
   * @param {?BaseMenuToggle} [options.toggle = null]         - The controller for the child menu.
   */
  constructor({
    menuItemElement: e,
    menuLinkElement: t,
    parentMenu: s,
    isSubmenuItem: n = !1,
    childMenu: i = null,
    toggle: l = null
  }) {
    /**
     * The DOM elements within the menu item.
     *
     * @protected
     *
     * @type {Object<HTMLElement>}
     *
     * @property {HTMLElement} item - The menu item.
     * @property {HTMLElement} link - The menu item's link.
     */
    u(this, "_dom", {
      item: null,
      link: null
    });
    /**
     * The declared accessible-menu elements within the menu item.
     *
     * @protected
     *
     * @type {Object<BaseMenu, BaseMenuToggle>}
     *
     * @property {BaseMenu}        parentMenu - The menu containing this menu item.
     * @property {?BaseMenu}       childMenu  - The menu contained within this menu item.
     * @property {?BaseMenuToggle} toggle     - The menu toggle within this menu item that controls the `childMenu`.
     */
    u(this, "_elements", {
      parentMenu: null,
      childMenu: null,
      toggle: null
    });
    /**
     * A flag marking a submenu item.
     *
     * @protected
     *
     * @type {boolean}
     */
    u(this, "_submenu", !1);
    this._dom.item = e, this._dom.link = t, this._elements.parentMenu = s, this._elements.childMenu = i, this._elements.toggle = l, this._submenu = n;
  }
  /**
   * Initialize the menu item.
   */
  initialize() {
  }
  /**
   * The DOM elements within the menu item.
   *
   * @readonly
   *
   * @type {Object<HTMLElement>}
   *
   * @see _dom
   */
  get dom() {
    return this._dom;
  }
  /**
   * The declared accessible-menu elements within the menu item.
   *
   * @readonly
   *
   * @type {Object<BaseMenu, BaseMenuToggle>}
   *
   * @see _elements
   */
  get elements() {
    return this._elements;
  }
  /**
   * A flag marking a submenu item.
   *
   * @readonly
   *
   * @type {boolean}
   *
   * @see _submenu
   */
  get isSubmenuItem() {
    return this._submenu;
  }
  /**
   * Focuses the menu item's link if the parent menu's
   * shouldFocus value is `true`.
   *
   * @public
   */
  focus() {
    this.elements.parentMenu.shouldFocus && requestAnimationFrame(() => {
      this.dom.link.focus();
    });
  }
  /**
   * Blurs the menu item's link if the parent menu's
   * shouldFocus value is `true`.
   *
   * @public
   */
  blur() {
    this.elements.parentMenu.shouldFocus && requestAnimationFrame(() => {
      this.dom.link.blur();
    });
  }
}
function _(r) {
  try {
    const e = r.key || r.keyCode, t = {
      Enter: e === "Enter" || e === 13,
      Space: e === " " || e === "Spacebar" || e === 32,
      Escape: e === "Escape" || e === "Esc" || e === 27,
      ArrowUp: e === "ArrowUp" || e === "Up" || e === 38,
      ArrowRight: e === "ArrowRight" || e === "Right" || e === 39,
      ArrowDown: e === "ArrowDown" || e === "Down" || e === 40,
      ArrowLeft: e === "ArrowLeft" || e === "Left" || e === 37,
      Home: e === "Home" || e === 36,
      End: e === "End" || e === 35,
      Character: isNaN(e) && !!e.match(/^[a-zA-Z]{1}$/),
      Tab: e === "Tab" || e === 9,
      Asterisk: e === "*" || e === 56
    };
    return Object.keys(t).find((s) => t[s] === !0) || "";
  } catch {
    return "";
  }
}
function o(r) {
  r.preventDefault(), r.stopPropagation();
}
class w {
  /**
   * Constructs a new `BaseMenu`.
   *
   * @param {object}             options                                    - The options for generating the menu.
   * @param {HTMLElement}        options.menuElement                        - The menu element in the DOM.
   * @param {string}             [options.menuItemSelector = li]            - The query selector string for menu items.
   * @param {string}             [options.menuLinkSelector = a]             - The query selector string for menu links.
   * @param {string}             [options.submenuItemSelector = li:has(ul)] - The query selector string for menu items containing submenus.
   * @param {string}             [options.submenuToggleSelector = a]        - The query selector string for submenu toggle buttons/links.
   * @param {string}             [options.submenuSelector = ul]             - The query selector string for submenus.
   * @param {?HTMLElement}       [options.controllerElement = null]         - The element controlling the menu in the DOM.
   * @param {?HTMLElement}       [options.containerElement = null]          - The element containing the menu in the DOM.
   * @param {?(string|string[])} [options.openClass = show]                 - The class to apply when a menu is "open".
   * @param {?(string|string[])} [options.closeClass = hide]                - The class to apply when a menu is "closed".
   * @param {?(string|string[])} [options.transitionClass = transitioning]  - The class to apply when a menu is transitioning between "open" and "closed" states.
   * @param {number}             [options.transitionDuration = 250]         - The duration of the transition between "open" and "closed" states (in milliseconds).
   * @param {boolean}            [options.openDuration = -1]                - The duration of the transition from "closed" to "open" states (in milliseconds).
   * @param {boolean}            [options.closeDuration = -1]               - The duration of the transition from "open" to "closed" states (in milliseconds).
   * @param {boolean}            [options.isTopLevel = false]               - A flag to mark the root menu.
   * @param {?BaseMenu}          [options.parentMenu = null]                - The parent menu to this menu.
   * @param {string}             [options.hoverType = off]                  - The type of hoverability a menu has.
   * @param {number}             [options.hoverDelay = 250]                 - The delay for opening and closing menus if the menu is hoverable (in milliseconds).
   * @param {number}             [options.enterDelay = -1]                  - The delay for opening menus if the menu is hoverable (in milliseconds).
   * @param {number}             [options.leaveDelay = -1]                  - The delay for closing menus if the menu is hoverable (in milliseconds).
   * @param {?string}            [options.prefix = am-]                     - The prefix to use for CSS custom properties.
   */
  constructor({
    menuElement: e,
    menuItemSelector: t = "li",
    menuLinkSelector: s = "a",
    submenuItemSelector: n = "li:has(ul)",
    submenuToggleSelector: i = "a",
    submenuSelector: l = "ul",
    controllerElement: h = null,
    containerElement: m = null,
    openClass: a = "show",
    closeClass: p = "hide",
    transitionClass: f = "transitioning",
    transitionDuration: g = 250,
    openDuration: d = -1,
    closeDuration: M = -1,
    isTopLevel: y = !0,
    parentMenu: b = null,
    hoverType: C = "off",
    hoverDelay: T = 250,
    enterDelay: E = -1,
    leaveDelay: v = -1,
    prefix: I = "am-"
  }) {
    /**
     * The class to use when generating submenus.
     *
     * @protected
     *
     * @type {typeof BaseMenu}
     */
    u(this, "_MenuType", w);
    /**
     * The class to use when generating menu items.
     *
     * @protected
     *
     * @type {typeof BaseMenuItem}
     */
    u(this, "_MenuItemType", O);
    /**
     * The class to use when generating submenu toggles.
     *
     * @protected
     *
     * @type {typeof BaseMenuToggle}
     */
    u(this, "_MenuToggleType", L);
    /**
     * The DOM elements within the menu.
     *
     * @protected
     *
     * @type {Object<HTMLElement, HTMLElement[]>}
     *
     * @property {HTMLElement}   menu           - The menu element.
     * @property {HTMLElement[]} menuItems      - An array of menu items.
     * @property {HTMLElement[]} submenuItems   - An array of menu items that also contain submenu elements.
     * @property {HTMLElement[]} submenuToggles - An array of menu links that function as submenu toggles.
     * @property {HTMLElement[]} submenus       - An array of submenu elements.
     * @property {HTMLElement}   controller     - The toggle for this menu.
     * @property {HTMLElement}   container      - The container for this menu.
     */
    u(this, "_dom", {
      menu: null,
      menuItems: [],
      submenuItems: [],
      submenuToggles: [],
      submenus: [],
      controller: null,
      container: null
    });
    /**
     * The query selectors used by the menu to populate the dom.
     *
     * @protected
     *
     * @type {Object<string>}
     *
     * @property {string} menuItems      - The query selector for menu items.
     * @property {string} menuLinks      - The query selector for menu links.
     * @property {string} submenuItems   - The query selector for menu items containing submenus.
     * @property {string} submenuToggles - The query selector for menu links that function as submenu toggles.
     * @property {string} submenus       - The query selector for for submenus.
     */
    u(this, "_selectors", {
      menuItems: "",
      menuLinks: "",
      submenuItems: "",
      submenuToggles: "",
      submenus: ""
    });
    /**
     * The declared accessible-menu elements within the menu.
     *
     * @protected
     *
     * @type {Object<BaseMenu, BaseMenuToggle, BaseMenuItem[], BaseMenuToggle[]>}
     *
     * @property {BaseMenuItem[]}   menuItems      - An array of menu items.
     * @property {BaseMenuToggle[]} submenuToggles - An array of menu toggles.
     * @property {?BaseMenuToggle}  controller     - A menu toggle that controls this menu.
     * @property {?BaseMenu}        parentMenu     - The parent menu.
     * @property {?BaseMenu}        rootMenu       - The root menu of the menu tree.
     */
    u(this, "_elements", {
      menuItems: [],
      submenuToggles: [],
      controller: null,
      parentMenu: null,
      rootMenu: null
    });
    /**
     * The class(es) to apply when the menu is open.
     *
     * @protected
     *
     * @type {string|string[]}
     */
    u(this, "_openClass", "show");
    /**
     * The class(es) to apply when the menu is closed.
     *
     * @protected
     *
     * @type {string|string[]}
     */
    u(this, "_closeClass", "hide");
    /**
     * The class(es) to apply when the menu is transitioning between states.
     *
     * @protected
     *
     * @type {string|string[]}
     */
    u(this, "_transitionClass", "transitioning");
    /**
     * The duration time (in milliseconds) for the transition between open and closed states.
     *
     * @protected
     *
     * @type {number}
     */
    u(this, "_transitionDuration", 250);
    /**
     * The duration time (in milliseconds) for the transition from closed to open states.
     *
     * @protected
     *
     * @type {number}
     */
    u(this, "_openDuration", -1);
    /**
     * The duration time (in milliseconds) for the transition from open to closed states.
     *
     * @protected
     *
     * @type {number}
     */
    u(this, "_closeDuration", -1);
    /**
     * A flag marking the root menu.
     *
     * @protected
     *
     * @type {boolean}
     */
    u(this, "_root", !0);
    /**
     * The index of the currently selected menu item in the menu.
     *
     * @protected
     *
     * @type {number}
     */
    u(this, "_currentChild", 0);
    /**
     * The current state of the menu's focus.
     *
     * @protected
     *
     * @type {string}
     */
    u(this, "_focusState", "none");
    /**
     * This last event triggered on the menu.
     *
     * @protected
     *
     * @type {string}
     */
    u(this, "_currentEvent", "none");
    /**
     * The type of hoverability for the menu.
     *
     * @protected
     *
     * @type {string}
     */
    u(this, "_hoverType", "off");
    /**
     * The delay time (in milliseconds) used for pointerenter/pointerleave events to take place.
     *
     * @protected
     *
     * @type {number}
     */
    u(this, "_hoverDelay", 250);
    /**
     * The delay time (in milliseconds) used for pointerenter events to take place.
     *
     * @protected
     *
     * @type {number}
     */
    u(this, "_enterDelay", -1);
    /**
     * The delay time (in milliseconds) used for pointerleave events to take place.
     *
     * @protected
     *
     * @type {number}
     */
    u(this, "_leaveDelay", -1);
    /**
     * The prefix to use for CSS custom properties.
     *
     * @protected
     *
     * @type {string}
     */
    u(this, "_prefix", "am-");
    /**
     * A variable to hold the hover timeout function.
     *
     * @protected
     *
     * @type {?Function}
     */
    u(this, "_hoverTimeout", null);
    /**
     * A flag to check if the menu can dynamically hover based on if a menu has been opened already.
     *
     * @protected
     *
     * @type {boolean}
     */
    u(this, "_hasOpened", !1);
    /**
     * An array of error messages generated by the menu.
     *
     * @protected
     *
     * @type {string[]}
     */
    u(this, "_errors", []);
    this._dom.menu = e, this._dom.controller = h, this._dom.container = m, this._selectors.menuItems = t, this._selectors.menuLinks = s, this._selectors.submenuItems = n, this._selectors.submenuToggles = i, this._selectors.submenus = l, this._elements.menuItems = [], this._elements.submenuToggles = [], this._elements.controller = null, this._elements.parentMenu = b, this._elements.rootMenu = y ? this : null, this._openClass = a || "", this._closeClass = p || "", this._transitionClass = f || "", this._transitionDuration = g, this._openDuration = d, this._closeDuration = M, this._prefix = I || "", this._root = y, this._hoverType = C, this._hoverDelay = T, this._enterDelay = E, this._leaveDelay = v;
  }
  /**
   * Initializes the menu.
   *
   * The following steps will be taken to initialize the menu:
   * - Validate that the menu can initialize.
   * - Find the root menu of the menu tree if it isn't already set.
   * - Populate all DOM elements within the dom.
   * - If the current menu is the root menu _and_ has a controller, initialize
   *   the controller.
   * - Populate the menu elements within the elements.
   * - Set the transition duration custom prop for the menu.
   *
   * @public
   *
   * @throws {Error} Will throw an Error if validate returns `false`.
   */
  initialize() {
    if (!this._validate())
      throw new Error(
        `AccessibleMenu: cannot initialize menu. The following errors have been found:
 - ${this.errors.join(
          `
 - `
        )}`
      );
    if (this.elements.rootMenu === null && this._findRootMenu(this), this._setDOMElements(), this.isTopLevel && this.dom.controller && this.dom.container) {
      const e = new this._MenuToggleType({
        menuToggleElement: this.dom.controller,
        parentElement: this.dom.container,
        controlledMenu: this
      });
      F("button", { toggle: e.dom.toggle }) || e.dom.toggle.setAttribute("role", "button"), e.dom.toggle.setAttribute("aria-controls", this.dom.menu.id), this._elements.controller = e;
    }
    this._createChildElements(), this._setTransitionDurations(), this.isTopLevel && (window.AccessibleMenu = window.AccessibleMenu || {
      menus: {}
    }, window.AccessibleMenu.menus[this.dom.menu.id] = this);
  }
  /**
   * The DOM elements within the menu.
   *
   * @readonly
   *
   * @type {Object<HTMLElement, HTMLElement[]>}
   *
   * @see _dom
   */
  get dom() {
    return this._dom;
  }
  /**
   * The query selectors used by the menu to populate the dom.
   *
   * @readonly
   *
   * @type {Object<string>}
   *
   * @see _selectors
   */
  get selectors() {
    return this._selectors;
  }
  /**
   * The declared accessible-menu elements within the menu.
   *
   * @readonly
   *
   * @type {Object<BaseMenu, BaseMenuToggle, BaseMenuItem[], BaseMenuToggle[]>}
   *
   * @see _elements
   */
  get elements() {
    return this._elements;
  }
  /**
   * The flag marking the root menu.
   *
   * @readonly
   *
   * @type {boolean}
   *
   * @see _root
   */
  get isTopLevel() {
    return this._root;
  }
  /**
   * The class(es) to apply when the menu is open.
   *
   * This functions differently for root vs. submenus.
   * Submenus will always inherit their root menu's open class(es).
   *
   * @type {string|string[]}
   *
   * @see _openClass
   */
  get openClass() {
    return this.isTopLevel ? this._openClass : this.elements.rootMenu.openClass;
  }
  /**
   * The class(es) to apply when the menu is closed.
   *
   * This functions differently for root vs. submenus.
   * Submenus will always inherit their root menu's close class(es).
   *
   * @type {string|string[]}
   *
   * @see _closeClass
   */
  get closeClass() {
    return this.isTopLevel ? this._closeClass : this.elements.rootMenu.closeClass;
  }
  /**
   * The class(es) to apply when the menu is transitioning between open and closed.
   *
   * This functions differently for root vs. submenus.
   * Submenus will always inherit their root menu's transition class(es).
   *
   * @type {string|string[]}
   *
   * @see _transitionClass
   */
  get transitionClass() {
    return this.isTopLevel ? this._transitionClass : this.elements.rootMenu.transitionClass;
  }
  /**
   * The duration time (in milliseconds) for the transition between open and closed states.
   *
   * This functions differently for root vs. submenus.
   * Submenus will always inherit their root menu's transition duration.
   *
   * Setting this value will also set the --am-transition-duration CSS custom property on the menu.
   *
   * @type {number}
   *
   * @see _transitionDuration
   */
  get transitionDuration() {
    return this.isTopLevel ? this._transitionDuration : this.elements.rootMenu.transitionDuration;
  }
  /**
   * The duration time (in milliseconds) for the transition from closed to open states.
   *
   * This functions differently for root vs. submenus.
   * Submenus will always inherit their root menu's openDuration.
   *
   * If openDuration is set to -1, the transitionDuration value will be used instead.
   *
   * Setting this value will also set the --am-open-transition-duration CSS custom property on the menu.
   *
   * @type {number}
   *
   * @see _openDuration
   */
  get openDuration() {
    return this._openDuration === -1 ? this.transitionDuration : this.isTopLevel ? this._openDuration : this.elements.rootMenu.openDuration;
  }
  /**
   * The duration time (in milliseconds) for the transition from open to closed states.
   *
   * This functions differently for root vs. submenus.
   * Submenus will always inherit their root menu's closeDuration.
   *
   * If closeDuration is set to -1, the transitionDuration value will be used instead.
   *
   * Setting this value will also set the --am-close-transition-duration CSS custom property on the menu.
   *
   * @type {number}
   *
   * @see _closeDuration
   */
  get closeDuration() {
    return this._closeDuration === -1 ? this.transitionDuration : this.isTopLevel ? this._closeDuration : this.elements.rootMenu.closeDuration;
  }
  /**
   * The index of the currently selected menu item in the menu.
   *
   * - Attempting to set a value less than -1 will set the current child to -1.
   * - Attempting to set a value greater than or equal to the number of menu items
   *   will set the current child to the index of the last menu item in the menu.
   *
   * If the current menu has a parent menu _and_ the menu's
   * current event is "mouse", The parent menu
   * will have it's current child updated as well to help with transitioning
   * between mouse and keyboard navigation.
   *
   * @type {number}
   *
   * @see _currentChild
   */
  get currentChild() {
    return this._currentChild;
  }
  /**
   * The current state of the menu's focus.
   *
   * - If the menu has submenus, setting the focus state to "none" or "self" will
   *   update all child menus to have the focus state of "none".
   * - If the menu has a parent menu, setting the focus state to "self" or "child"
   *   will update all parent menus to have the focus state of "child".
   *
   * @type {string}
   *
   * @see _focusState
   */
  get focusState() {
    return this._focusState;
  }
  /**
   * The last event triggered on the menu.
   *
   * @type {string}
   *
   * @see _currentEvent
   */
  get currentEvent() {
    return this._currentEvent;
  }
  /**
   * The currently selected menu item.
   *
   * @readonly
   *
   * @type {BaseMenuItem}
   */
  get currentMenuItem() {
    return this.elements.menuItems[this.currentChild];
  }
  /**
   * The type of hoverability for the menu.
   *
   * This functions differently for root vs. submenus.
   * Submenus will always inherit their root menu's hoverability.
   *
   * @type {string}
   *
   * @see _hoverType
   */
  get hoverType() {
    return this._root ? this._hoverType : this.elements.rootMenu.hoverType;
  }
  /**
   * The delay time (in milliseconds) used for pointerenter/pointerleave events to take place.
   *
   * This functions differently for root vs. submenus.
   * Submenus will always inherit their root menu's hover delay.
   *
   * @type {number}
   *
   * @see _hoverDelay
   */
  get hoverDelay() {
    return this._root ? this._hoverDelay : this.elements.rootMenu.hoverDelay;
  }
  /**
   * The delay time (in milliseconds) used for pointerenter events to take place.
   *
   * This functions differently for root vs. submenus.
   * Submenus will always inherit their root menu's enter delay.
   *
   * If enterDelay is set to -1, the hoverDelay value will be used instead.
   *
   * @type {number}
   *
   * @see _enterDelay
   */
  get enterDelay() {
    return this._enterDelay === -1 ? this.hoverDelay : this._root ? this._enterDelay : this.elements.rootMenu.enterDelay;
  }
  /**
   * The delay time (in milliseconds) used for pointerleave events to take place.
   *
   * This functions differently for root vs. submenus.
   * Submenus will always inherit their root menu's leave delay.
   *
   * If leaveDelay is set to -1, the hoverDelay value will be used instead.
   *
   * @type {number}
   *
   * @see _leaveDelay
   */
  get leaveDelay() {
    return this._leaveDelay === -1 ? this.hoverDelay : this._root ? this._leaveDelay : this.elements.rootMenu.leaveDelay;
  }
  /**
   * The prefix to use for CSS custom properties.
   *
   * This functions differently for root vs. submenus.
   * Submenus will always inherit their root menu's prefix.
   *
   * @type {string}
   *
   * @see _prefix
   */
  get prefix() {
    return this._root ? this._prefix : this.elements.rootMenu.prefix;
  }
  /**
   * A flag to check if the menu's focus methods should _actually_ move the focus in the DOM.
   *
   * This will be `false` unless any of the following criteria are met:
   * - The menu's current event is "keyboard".
   * - The menu's current event is "character".
   * - The menu's current event is "mouse" _and_ the menu's
   *   hover type is "dynamic".
   *
   * @readonly
   *
   * @type {boolean}
   */
  get shouldFocus() {
    let e = !1;
    return (this.currentEvent === "keyboard" || this.currentEvent === "character") && (e = !0), this.currentEvent === "mouse" && this.hoverType === "dynamic" && (e = !0), e;
  }
  /**
   * A flag to check if the menu can dynamically hover.
   *
   * This functions differently for root vs. submenus.
   * Submenus will always inherit their root menu's hasOpened.
   *
   * @type {boolean}
   *
   * @see _hasOpened
   */
  get hasOpened() {
    return this._root ? this._hasOpened : this.elements.rootMenu.hasOpened;
  }
  /**
   * An array of error messages generated by the menu.
   *
   * @readonly
   *
   * @type {string[]}
   *
   * @see _errors
   */
  get errors() {
    return this._errors;
  }
  set openClass(e) {
    k({ openClass: e }), this._openClass !== e && (this._openClass = e);
  }
  set closeClass(e) {
    k({ closeClass: e }), this._closeClass !== e && (this._closeClass = e);
  }
  set transitionClass(e) {
    k({ transitionClass: e }), this._transitionClass !== e && (this._transitionClass = e);
  }
  set transitionDuration(e) {
    c("number", { value: e }), this._transitionDuration !== e && (this._transitionDuration = e, this._setTransitionDurations());
  }
  set openDuration(e) {
    c("number", { value: e }), this._openDuration !== e && (this._openDuration = e, this._setTransitionDurations());
  }
  set closeDuration(e) {
    c("number", { value: e }), this._closeDuration !== e && (this._closeDuration = e, this._setTransitionDurations());
  }
  set currentChild(e) {
    c("number", { value: e });
    function t(s) {
      if (["mouse", "character"].includes(s.currentEvent) && s.elements.parentMenu) {
        let i = 0, l = !1;
        for (; !l && i < s.elements.parentMenu.elements.menuItems.length; ) {
          const h = s.elements.parentMenu.elements.menuItems[i];
          h.isSubmenuItem && h.elements.toggle.elements.controlledMenu === s && (l = !0, s.elements.parentMenu.currentEvent = s.currentEvent, s.elements.parentMenu.currentChild = i), i++;
        }
      }
    }
    e < -1 ? (this._currentChild = -1, t(this)) : e >= this.elements.menuItems.length ? (this._currentChild = this.elements.menuItems.length - 1, t(this)) : this.focusChild !== e && (this._currentChild = e, t(this));
  }
  set focusState(e) {
    U({ value: e }), this._focusState !== e && (this._focusState = e), this.elements.submenuToggles.length > 0 && (e === "self" || e === "none") && this.elements.submenuToggles.forEach((t) => {
      t.elements.controlledMenu.focusState = "none";
    }), this.elements.parentMenu && (e === "self" || e === "child") && (this.elements.parentMenu.focusState = "child");
  }
  set currentEvent(e) {
    W({ value: e }), this._currentEvent !== e && (this._currentEvent = e, this.elements.submenuToggles.length > 0 && this.elements.submenuToggles.forEach((t) => {
      t.elements.controlledMenu.currentEvent = e;
    }));
  }
  set hoverType(e) {
    N({ value: e }), this._hoverType !== e && (this._hoverType = e);
  }
  set hoverDelay(e) {
    c("number", { value: e }), this._hoverDelay !== e && (this._hoverDelay = e);
  }
  set enterDelay(e) {
    c("number", { value: e }), this._enterDelay !== e && (this._enterDelay = e);
  }
  set leaveDelay(e) {
    c("number", { value: e }), this._leaveDelay !== e && (this._leaveDelay = e);
  }
  set prefix(e) {
    c("string", { value: e }), this._prefix !== e && (this._prefix = e);
  }
  set hasOpened(e) {
    c("boolean", { value: e }), this._hasOpened !== e && (this._hasOpened = e);
  }
  /**
   * Validates all aspects of the menu to ensure proper functionality.
   *
   * @protected
   *
   * @return {boolean} - The result of the validation.
   */
  _validate() {
    let e = !0, t;
    this._dom.container !== null || this._dom.controller !== null ? t = A(HTMLElement, {
      menuElement: this._dom.menu,
      controllerElement: this._dom.controller,
      containerElement: this._dom.container
    }) : t = A(HTMLElement, {
      menuElement: this._dom.menu
    }), t.status || (this._errors.push(t.error.message), e = !1);
    let s;
    if (this._selectors.submenuItems !== "" ? s = x({
      menuItemSelector: this._selectors.menuItems,
      menuLinkSelector: this._selectors.menuLinks,
      submenuItemSelector: this._selectors.submenuItems,
      submenuToggleSelector: this._selectors.submenuToggles,
      submenuSelector: this._selectors.submenus
    }) : s = x({
      menuItemSelector: this._selectors.menuItems,
      menuLinkSelector: this._selectors.menuLinks
    }), s.status || (this._errors.push(s.error.message), e = !1), this._openClass !== "") {
      const d = k({ openClass: this._openClass });
      d.status || (this._errors.push(d.error.message), e = !1);
    }
    if (this._closeClass !== "") {
      const d = k({
        closeClass: this._closeClass
      });
      d.status || (this._errors.push(d.error.message), e = !1);
    }
    if (this._transitionClass !== "") {
      const d = k({
        transitionClass: this._transitionClass
      });
      d.status || (this._errors.push(d.error.message), e = !1);
    }
    const n = c("number", {
      transitionDuration: this._transitionDuration
    });
    n.status || (this._errors.push(n.error.message), e = !1);
    const i = c("number", {
      openDuration: this._openDuration
    });
    i.status || (this._errors.push(i.error.message), e = !1);
    const l = c("number", {
      closeDuration: this._closeDuration
    });
    l.status || (this._errors.push(l.error.message), e = !1);
    const h = c("boolean", { isTopLevel: this._root });
    if (h.status || (this._errors.push(h.error.message), e = !1), this._elements.parentMenu !== null) {
      const d = A(w, {
        parentMenu: this._elements.parentMenu
      });
      d.status || (this._errors.push(d.error.message), e = !1);
    }
    const m = N({ hoverType: this._hoverType });
    m.status || (this._errors.push(m.error.message), e = !1);
    const a = c("number", {
      hoverDelay: this._hoverDelay
    });
    a.status || (this._errors.push(a.error.message), e = !1);
    const p = c("number", {
      enterDelay: this._enterDelay
    });
    p.status || (this._errors.push(p.error.message), e = !1);
    const f = c("number", {
      leaveDelay: this._leaveDelay
    });
    f.status || (this._errors.push(f.error.message), e = !1);
    const g = c("string", { prefix: this._prefix });
    return g.status || (this._errors.push(g.error.message), e = !1), e;
  }
  /**
   * Sets DOM elements within the menu.
   *
   * Elements that are not stored inside an array cannot be set through this method.
   *
   * @protected
   *
   * @param {string}      elementType            - The type of element to populate.
   * @param {HTMLElement} [base = this.dom.menu] - The element used as the base for the querySelect.
   * @param {boolean}     [overwrite = true]     - A flag to set if the existing elements will be overwritten.
   */
  _setDOMElementType(e, t = this.dom.menu, s = !0) {
    if (typeof this.selectors[e] == "string") {
      if (!Array.isArray(this.dom[e]))
        throw new Error(
          `AccessibleMenu: The "${e}" element cannot be set through _setDOMElementType.`
        );
      t !== this.dom.menu && A(HTMLElement, { base: t });
      const i = Array.from(
        t.querySelectorAll(this.selectors[e])
      ).filter(
        (l) => l.parentElement === t
      );
      s ? this._dom[e] = i : this._dom[e] = [
        ...this._dom[e],
        ...i
      ];
    } else
      throw new Error(
        `AccessibleMenu: "${e}" is not a valid element type within the menu.`
      );
  }
  /**
   * Resets DOM elements within the menu.
   *
   * Elements that are not stored inside an array cannot be reset through this method.
   *
   * @protected
   *
   * @param {string} elementType - The type of element to clear.
   */
  _resetDOMElementType(e) {
    if (typeof this.dom[e] < "u") {
      if (!Array.isArray(this.dom[e]))
        throw new Error(
          `AccessibleMenu: The "${e}" element cannot be reset through _resetDOMElementType.`
        );
      this._dom[e] = [];
    } else
      throw new Error(
        `AccessibleMenu: "${e}" is not a valid element type within the menu.`
      );
  }
  /**
   * Sets all DOM elements within the menu.
   *
   * Utilizes _setDOMElementType and
   * _resetDOMElementType.
   *
   * @protected
   */
  _setDOMElements() {
    this._setDOMElementType("menuItems"), this.selectors.submenuItems !== "" && (this._setDOMElementType("submenuItems"), this._resetDOMElementType("submenuToggles"), this._resetDOMElementType("submenus"), this.dom.submenuItems.forEach((e) => {
      this._setDOMElementType("submenuToggles", e, !1), this._setDOMElementType("submenus", e, !1);
    }));
  }
  /**
   * Finds the root menu element.
   *
   * @protected
   *
   * @param {BaseMenu} menu - The menu to check.
   */
  _findRootMenu(e) {
    if (e.isTopLevel)
      this._elements.rootMenu = e;
    else if (e.elements.parentMenu !== null)
      this._findRootMenu(e.elements.parentMenu);
    else
      throw new Error("Cannot find root menu.");
  }
  /**
   * Creates and initializes all menu items and submenus.
   *
   * @protected
   */
  _createChildElements() {
    this.dom.menuItems.forEach((e) => {
      let t;
      if (this.dom.submenuItems.includes(e)) {
        const s = e.querySelector(this.selectors.submenuToggles), n = e.querySelector(this.selectors.submenus), i = new this._MenuType({
          menuElement: n,
          menuItemSelector: this.selectors.menuItems,
          menuLinkSelector: this.selectors.menuLinks,
          submenuItemSelector: this.selectors.submenuItems,
          submenuToggleSelector: this.selectors.submenuToggles,
          submenuSelector: this.selectors.submenus,
          openClass: this.openClass,
          closeClass: this.closeClass,
          transitionClass: this.transitionClass,
          transitionDuration: this.transitionDuration,
          openDuration: this.openDuration,
          closeDuration: this.closeDuration,
          isTopLevel: !1,
          parentMenu: this,
          hoverType: this.hoverType,
          hoverDelay: this.hoverDelay,
          enterDelay: this.enterDelay,
          leaveDelay: this.leaveDelay
        }), l = new this._MenuToggleType({
          menuToggleElement: s,
          parentElement: e,
          controlledMenu: i,
          parentMenu: this
        });
        this._elements.submenuToggles.push(l), t = new this._MenuItemType({
          menuItemElement: e,
          menuLinkElement: s,
          parentMenu: this,
          isSubmenuItem: !0,
          childMenu: i,
          toggle: l
        });
      } else {
        const s = e.querySelector(this.selectors.menuLinks);
        t = new this._MenuItemType({
          menuItemElement: e,
          menuLinkElement: s,
          parentMenu: this
        });
      }
      this._elements.menuItems.push(t);
    });
  }
  /**
   * Clears the hover timeout.
   *
   * @protected
   */
  _clearTimeout() {
    clearTimeout(this._hoverTimeout);
  }
  /**
   * Sets the hover timeout.
   *
   * @protected
   *
   * @param {Function} callback - The callback function to execute.
   * @param {number}   delay    - The delay time in milliseconds.
   */
  _setTimeout(e, t) {
    c("function", { callback: e }), c("number", { delay: t }), this._hoverTimeout = setTimeout(e, t);
  }
  /**
   * Handles focus events throughout the menu for proper menu use.
   *
   * - Adds a `focus` listener to every menu item so when it gains focus,
   *   it will set the item's containing menu's focus state
   *   to "self".
   * - Adds a `focusout` listener to the menu so when the menu loses focus,
   *   it will close.
   *
   * @protected
   */
  _handleFocus() {
    this.elements.menuItems.forEach((e, t) => {
      e.dom.link.addEventListener("focus", () => {
        this.focusState = "self", this.currentChild = t;
      });
    }), this.dom.menu.addEventListener("focusout", (e) => {
      this.currentEvent !== "keyboard" || e.relatedTarget === null || this.dom.menu.contains(e.relatedTarget) || (this.focusState = "none", this.closeChildren());
    });
  }
  /**
   * Handles click events throughout the menu for proper use.
   *
   * - Adds a `pointerdown` listener to every menu item that will blur
   *   all menu items in the entire menu structure (starting at the root menu) and
   *   then properly focus the clicked item.
   * - Adds a `pointerup` listener to every submenu item that will properly
   *   toggle the submenu open/closed.
   * - Adds a `pointerup` listener to the menu's controller
   *   (if the menu is the root menu) so when it is clicked it will properly
   *   toggle open/closed.
   *
   * @protected
   */
  _handleClick() {
    function e(t, s, n) {
      o(n), n.button === 0 && (s.toggle(), s.isOpen && (t.focusState = "self", s.elements.controlledMenu.focusState = "none"));
    }
    this.elements.menuItems.forEach((t, s) => {
      t.dom.link.addEventListener(
        "pointerdown",
        () => {
          this.currentEvent = "mouse", this.elements.rootMenu.blurChildren(), this._clearTimeout(), this.focusChild(s);
        },
        { passive: !0 }
      ), t.isSubmenuItem && t.elements.toggle.dom.toggle.addEventListener(
        "pointerup",
        (n) => {
          this.currentEvent = "mouse", e(this, t.elements.toggle, n);
        }
      );
    }), this.isTopLevel && this.elements.controller && this.elements.controller.dom.toggle.addEventListener(
      "pointerup",
      (t) => {
        this.currentEvent = "mouse", e(this, this.elements.controller, t);
      }
    ), document.addEventListener("pointerup", (t) => {
      this.focusState !== "none" && (this.currentEvent = "mouse", !this.dom.menu.contains(t.target) && !this.dom.menu !== t.target && (this.elements.rootMenu.hasOpened = this.elements.submenuToggles.some(
        (s) => s.isOpen
      )));
    });
  }
  /**
   * Handles hover events throughout the menu for proper use.
   *
   * Adds `pointerenter` listeners to all menu items and `pointerleave` listeners
   * to all submenu items which function differently depending on
   * the menu's hover type.
   *
   * Before executing anything, the event is checked to make sure the event wasn't
   * triggered by a pen or touch.
   *
   * <strong>Hover Type "on"</strong>
   * - When a `pointerenter` event triggers on any menu item the menu's
   *    current child value will change to that
   *   menu item.
   * - When a `pointerenter` event triggers on a submenu item the
   *   preview method for the submenu item's
   *   toggle will be called.
   * - When a `pointerleave` event triggers on an open submenu item the
   *   close method for the submenu item's toggle
   *   will be called after a delay set by the menu's hover delay.
   *
   * <strong>Hover Type "dynamic"</strong>
   * - When a `pointerenter` event triggers on any menu item the menu's
   *   current child value will change to that menu item.
   * - When a `pointerenter` event triggers on any menu item, and the menu's
   *   focus state is not "none", the menu item
   *   will be focused.
   * - When a `pointerenter` event triggers on a submenu item, and a submenu is
   *   already open, the preview method for the submenu item's toggle will be called.
   * - When a `pointerenter` event triggers on a non-submenu item, and a submenu
   *   is already open, the closeChildren method for the menu will be called.
   * - When a `pointerenter` event triggers on a submenu item, and no submenu is
   *   open, no submenu-specific methods will be called.
   * - When a `pointerleave` event triggers on an open submenu item that is not a
   *   root-level submenu item the close method for the submenu item's toggle
   *   will be called and the submenu item will be focused after a delay set by
   *   the menu's hover delay.
   * - When a `pointerleave` event triggers on an open submenu item that is a
   *   root-level submenu item no submenu-specific methods will be called.
   *
   * <strong>Hover Type "off"</strong>
   * All `pointerenter` and `pointerleave` events are ignored.
   *
   * @protected
   */
  _handleHover() {
    this.elements.menuItems.forEach((e, t) => {
      e.dom.link.addEventListener("pointerenter", (s) => {
        s.pointerType === "pen" || s.pointerType === "touch" || (this.hoverType === "on" ? (this.currentEvent = "mouse", this.elements.rootMenu.blurChildren(), this.focusChild(t), e.isSubmenuItem && (this.enterDelay > 0 ? (this._clearTimeout(), this._setTimeout(() => {
          e.elements.toggle.preview();
        }, this.enterDelay)) : e.elements.toggle.preview())) : this.hoverType === "dynamic" && (this.currentChild = t, (!this.isTopLevel || this.focusState !== "none") && (this.currentEvent = "mouse", this.elements.rootMenu.blurChildren(), this.focusCurrentChild()), (!this.isTopLevel || this.hasOpened) && (this.currentEvent = "mouse", this.elements.rootMenu.blurChildren(), this.focusCurrentChild(), e.isSubmenuItem ? this.enterDelay > 0 ? (this._clearTimeout(), this._setTimeout(() => {
          e.elements.toggle.preview();
        }, this.enterDelay)) : e.elements.toggle.preview() : this.enterDelay > 0 ? (this._clearTimeout(), this._setTimeout(() => {
          this.closeChildren();
        }, this.enterDelay)) : this.closeChildren())));
      }), e.isSubmenuItem && (e.dom.item.addEventListener("pointerleave", (s) => {
        s.pointerType === "pen" || s.pointerType === "touch" || (this.hoverType === "on" ? this.leaveDelay > 0 ? (this._clearTimeout(), this._setTimeout(() => {
          this.currentEvent = "mouse", e.elements.toggle.close();
        }, this.leaveDelay)) : (this.currentEvent = "mouse", e.elements.toggle.close()) : this.hoverType === "dynamic" && (this.leaveDelay > 0 ? (this._clearTimeout(), this._setTimeout(() => {
          this.currentEvent = "mouse";
        }, this.leaveDelay)) : this.currentEvent = "mouse"));
      }), e.dom.item.addEventListener("pointerenter", (s) => {
        s.pointerType === "pen" || s.pointerType === "touch" || e.isSubmenuItem && (this.hoverType === "on" || this.hoverType === "dynamic") && this.leaveDelay > 0 && this._clearTimeout();
      }));
    });
  }
  /**
   * Handles keydown events throughout the menu for proper menu use.
   *
   * This method exists to assist the _handleKeyup method.
   *
   * - Adds a `keydown` listener to the menu's controller (if the menu is the root menu).
   *   - Blocks propagation on "Space", "Enter", and "Escape" keys.
   *
   * @protected
   */
  _handleKeydown() {
    this.isTopLevel && this.elements.controller && this.elements.controller.dom.toggle.addEventListener(
      "keydown",
      (e) => {
        this.currentEvent = "keyboard";
        const t = _(e);
        (t === "Space" || t === "Enter") && o(e);
      }
    );
  }
  /**
   * Handles keyup events throughout the menu for proper menu use.
   *
   * - Adds a `keyup` listener to the menu's controller (if the menu is the root menu).
   *   - Toggles the menu when the user hits "Space" or "Enter".
   *
   * @protected
   */
  _handleKeyup() {
    this.isTopLevel && this.elements.controller && this.elements.controller.dom.toggle.addEventListener("keyup", (e) => {
      this.currentEvent = "keyboard";
      const t = _(e);
      (t === "Space" || t === "Enter") && (o(e), this.elements.controller.toggle(), this.elements.controller.isOpen && this.focusFirstChild());
    });
  }
  /**
   * Sets the transition durations of the menu as a CSS custom properties.
   *
   * The custom properties are:
   *   - `--am-transition-duration`,
   *   - `--am-open-transition-duration`, and
   *   - `--am-close-transition-duration`.
   *
   * The prefix of `am-` can be changed by setting the menu's prefix value.
   *
   * @protected
   */
  _setTransitionDurations() {
    this.dom.menu.style.setProperty(
      `--${this.prefix}transition-duration`,
      `${this.transitionDuration}ms`
    ), this.dom.menu.style.setProperty(
      `--${this.prefix}open-transition-duration`,
      `${this.openDuration}ms`
    ), this.dom.menu.style.setProperty(
      `--${this.prefix}close-transition-duration`,
      `${this.closeDuration}ms`
    );
  }
  /**
   * Focus the menu.
   *
   * Sets the menu's focus state to "self" and
   * focusses the menu if the menu's shouldFocus
   * value is `true`.
   *
   * @public
   */
  focus() {
    this.focusState = "self", this.shouldFocus && this.dom.menu.focus();
  }
  /**
   * Unfocus the menu.
   *
   * Sets the menu's focus state to "none"
   * and blurs the menu if the menu's shouldFocus
   * value is `true`.
   *
   * @public
   */
  blur() {
    this.focusState = "none", this.shouldFocus && this.dom.menu.blur();
  }
  /**
   * Focus the menu's current child.
   *
   * @public
   */
  focusCurrentChild() {
    this.focusState = "self", this.currentChild !== -1 && this.currentMenuItem.focus();
  }
  /**
   * Focuses the menu's child at a given index.
   *
   * @public
   *
   * @param {number} index - The index of the child to focus.
   */
  focusChild(e) {
    this.blurCurrentChild(), this.currentChild = e, this.focusCurrentChild();
  }
  /**
   * Focuses the menu's first child.
   *
   * @public
   */
  focusFirstChild() {
    this.focusChild(0);
  }
  /**
   * Focus the menu's last child.
   *
   * @public
   */
  focusLastChild() {
    this.focusChild(this.elements.menuItems.length - 1);
  }
  /**
   * Focus the menu's next child.
   *
   * @public
   */
  focusNextChild() {
    this.currentChild < this.elements.menuItems.length - 1 ? this.focusChild(this.currentChild + 1) : this.focusCurrentChild();
  }
  /**
   * Focus the menu's previous child.
   *
   * @public
   */
  focusPreviousChild() {
    this.currentChild > 0 ? this.focusChild(this.currentChild - 1) : this.focusCurrentChild();
  }
  /**
   * Blurs the menu's current child.
   *
   * @public
   */
  blurCurrentChild() {
    this.focusState = "none", this.currentChild !== -1 && this.currentMenuItem.blur();
  }
  /**
   * Focus the menu's controller.
   *
   * @public
   */
  focusController() {
    this.dom.controller && (this.shouldFocus && this.dom.controller.focus(), this.focusState = "none");
  }
  /**
   * Focus the menu's container.
   *
   * @public
   */
  focusContainer() {
    this.dom.container && (this.shouldFocus && this.dom.container.focus(), this.focusState = "none");
  }
  /**
   * Close all submenu children.
   *
   * @public
   */
  closeChildren() {
    this.elements.submenuToggles.forEach((e) => e.close());
  }
  /**
   * Blurs all children and submenu's children.
   *
   * @public
   */
  blurChildren() {
    this.elements.menuItems.forEach((e) => {
      e.blur(), e.isSubmenuItem && e.elements.childMenu.blurChildren();
    });
  }
}
class Z extends O {
  /**
   * Constructs a new `DisclosureMenuItem`.
   *
   * @param {object}                options                         - The options for generating the menu item.
   * @param {HTMLElement}           options.menuItemElement         - The menu item in the DOM.
   * @param {HTMLElement}           options.menuLinkElement         - The menu item's link in the DOM.
   * @param {DisclosureMenu}        options.parentMenu              - The parent menu.
   * @param {boolean}               [options.isSubmenuItem = false] - A flag to mark if the menu item is controlling a submenu.
   * @param {?DisclosureMenu}       [options.childMenu = null]      - The child menu.
   * @param {?DisclosureMenuToggle} [options.toggle = null]         - The controller for the child menu.
   * @param {boolean}               [options.initialize = true]     - A flag to initialize the menu item immediately upon creation.
   */
  constructor({
    menuItemElement: e,
    menuLinkElement: t,
    parentMenu: s,
    isSubmenuItem: n = !1,
    childMenu: i = null,
    toggle: l = null,
    initialize: h = !0
  }) {
    super({
      menuItemElement: e,
      menuLinkElement: t,
      parentMenu: s,
      isSubmenuItem: n,
      childMenu: i,
      toggle: l
    }), h && this.initialize();
  }
}
class Q extends L {
  /**
   * Constructs a new `DisclosureMenuToggle`.
   *
   * @param {object}          options                     - The options for generating the menu toggle.
   * @param {HTMLElement}     options.menuToggleElement   - The toggle element in the DOM.
   * @param {HTMLElement}     options.parentElement       - The element containing the controlled menu.
   * @param {DisclosureMenu}  options.controlledMenu      - The menu controlled by this toggle.
   * @param {?DisclosureMenu} [options.parentMenu = null] - The menu containing this toggle.
   * @param {boolean}         [options.initialize = true] - A flag to initialize the menu toggle immediately upon creation.
   */
  constructor({
    menuToggleElement: e,
    parentElement: t,
    controlledMenu: s,
    parentMenu: n = null,
    initialize: i = !0
  }) {
    super({
      menuToggleElement: e,
      parentElement: t,
      controlledMenu: s,
      parentMenu: n
    }), i && this.initialize();
  }
  /**
   * Sets the ARIA attributes on the toggle and controlled menu.
   *
   * Calls the BaseMenuToggle's _setAriaAttributes method.
   *
   * Ensures the toggle element has a `role` of "button" if it is not
   * already a button.
   *
   * Then using the toggle and menu's IDs, the toggle's `aria-controls`
   * is set to the menu's ID.
   *
   * @protected
   */
  _setAriaAttributes() {
    super._setAriaAttributes(), F("button", { toggle: this.dom.toggle }) || this.dom.toggle.setAttribute("role", "button"), this.dom.toggle.setAttribute(
      "aria-controls",
      this.elements.controlledMenu.dom.menu.id
    );
  }
  /**
   * Opens the controlled menu.
   *
   * Calls the  closeSiblings method
   * and _then_ BaseMenuToggle's open method.
   *
   * @public
   */
  open() {
    this.closeSiblings(), super.open();
  }
  /**
   * Opens the controlled menu without the current focus entering it.
   *
   * Calls the  closeSiblings method
   * and _then_ BaseMenuToggle's preview method.
   *
   * @public
   */
  preview() {
    this.closeSiblings(), super.preview();
  }
  /**
   * Closes the controlled menu.
   *
   * Calls the  closeChildren method
   * and _then_ BaseMenuToggle's close method.
   *
   * @public
   */
  close() {
    this.isOpen && this.closeChildren(), super.close();
  }
}
class z extends w {
  /**
   * Constructs a new `DisclosureMenu`.
   *
   * @param {object}             options                                    - The options for generating the menu.
   * @param {HTMLElement}        options.menuElement                        - The menu element in the DOM.
   * @param {string}             [options.menuItemSelector = li]            - The query selector string for menu items.
   * @param {string}             [options.menuLinkSelector = a]             - The query selector string for menu links.
   * @param {string}             [options.submenuItemSelector = li:has(ul)] - The query selector string for menu items containing submenus.
   * @param {string}             [options.submenuToggleSelector = button]   - The query selector string for submenu toggle buttons/links.
   * @param {string}             [options.submenuSelector = ul]             - The query selector string for submenus.
   * @param {?HTMLElement}       [options.controllerElement = null]         - The element controlling the menu in the DOM.
   * @param {?HTMLElement}       [options.containerElement = null]          - The element containing the menu in the DOM.
   * @param {?(string|string[])} [options.openClass = show]                 - The class to apply when a menu is "open".
   * @param {?(string|string[])} [options.closeClass = hide]                - The class to apply when a menu is "closed".
   * @param {?(string|string[])} [options.transitionClass = transitioning]  - The class to apply when a menu is transitioning between "open" and "closed" states.
   * @param {number}             [options.transitionDuration = 250]         - The duration of the transition between "open" and "closed" states (in milliseconds).
   * @param {boolean}            [options.openDuration = -1]                - The duration of the transition from "closed" to "open" states (in milliseconds).
   * @param {boolean}            [options.closeDuration = -1]               - The duration of the transition from "open" to "closed" states (in milliseconds).
   * @param {boolean}            [options.isTopLevel = true]                - A flag to mark the root menu.
   * @param {?DisclosureMenu}    [options.parentMenu = null]                - The parent menu to this menu.
   * @param {string}             [options.hoverType = off]                  - The type of hoverability a menu has.
   * @param {number}             [options.hoverDelay = 250]                 - The delay for opening and closing menus if the menu is hoverable (in milliseconds).
   * @param {number}             [options.enterDelay = -1]                  - The delay for opening a menu if the menu is focusable (in milliseconds).
   * @param {number}             [options.leaveDelay = -1]                  - The delay for closing a menu if the menu is focusable (in milliseconds).
   * @param {boolean}            [options.optionalKeySupport = false]       - A flag to add optional keyboard support (Arrow keys, Home, and End) to the menu.
   * @param {?string}            [options.prefix = am-]                     - The prefix to use for CSS custom properties.
   * @param {boolean}            [options.initialize = true]                - A flag to initialize the menu immediately upon creation.
   */
  constructor({
    menuElement: t,
    menuItemSelector: s = "li",
    menuLinkSelector: n = "a",
    submenuItemSelector: i = "li:has(ul)",
    submenuToggleSelector: l = "button",
    submenuSelector: h = "ul",
    controllerElement: m = null,
    containerElement: a = null,
    openClass: p = "show",
    closeClass: f = "hide",
    transitionClass: g = "transitioning",
    transitionDuration: d = 250,
    openDuration: M = -1,
    closeDuration: y = -1,
    isTopLevel: b = !0,
    parentMenu: C = null,
    hoverType: T = "off",
    hoverDelay: E = 250,
    enterDelay: v = -1,
    leaveDelay: I = -1,
    optionalKeySupport: K = !1,
    prefix: $ = "am-",
    initialize: V = !0
  }) {
    super({
      menuElement: t,
      menuItemSelector: s,
      menuLinkSelector: n,
      submenuItemSelector: i,
      submenuToggleSelector: l,
      submenuSelector: h,
      controllerElement: m,
      containerElement: a,
      openClass: p,
      closeClass: f,
      transitionClass: g,
      transitionDuration: d,
      openDuration: M,
      closeDuration: y,
      isTopLevel: b,
      parentMenu: C,
      hoverType: T,
      hoverDelay: E,
      enterDelay: v,
      leaveDelay: I,
      prefix: $
    });
    /**
     * The class to use when generating submenus.
     *
     * @protected
     *
     * @type {typeof DisclosureMenu}
     */
    u(this, "_MenuType", z);
    /**
     * The class to use when generating menu items.
     *
     * @protected
     *
     * @type {typeof DisclosureMenuItem}
     */
    u(this, "_MenuItemType", Z);
    /**
     * The class to use when generating submenu toggles.
     *
     * @protected
     *
     * @type {typeof DisclosureMenuToggle}
     */
    u(this, "_MenuToggleType", Q);
    /**
     * The index of the currently selected menu item in the menu.
     *
     * @protected
     *
     * @type {number}
     */
    u(this, "_currentChild", -1);
    /**
     * A flag to add optional keyboard support (Arrow keys, "Home", and "End") to the menu.
     *
     * @protected
     *
     * @type {boolean}
     */
    u(this, "_optionalSupport", !1);
    this._optionalSupport = K, V && this.initialize();
  }
  /**
   * Initializes the menu.
   *
   * Initialize will call BaseMenu's initialize method
   * as well as set up focus,
   * click,
   * hover,
   * keydown, and
   * keyup events for the menu.
   *
   * If the BaseMenu's initialize method throws an error,
   * this will catch it and log it to the console.
   */
  initialize() {
    try {
      super.initialize(), this._handleFocus(), this._handleClick(), this._handleHover(), this._handleKeydown(), this._handleKeyup();
    } catch (t) {
      console.error(t);
    }
  }
  /**
   * A flag to add optional keyboard support (Arrow keys, "Home", and "End") to the menu.
   *
   * This functions differently for root vs. submenus.
   * Submenus will always inherit their root menu's optionalKeySupport.
   *
   * @type {boolean}
   *
   * @see _optionalSupport
   */
  get optionalKeySupport() {
    return this.isTopLevel ? this._optionalSupport : this.elements.rootMenu.optionalKeySupport;
  }
  set optionalKeySupport(t) {
    c("boolean", { optionalKeySupport: t }), this._optionalSupport = t;
  }
  /**
   * Validates all aspects of the menu to ensure proper functionality.
   *
   * @protected
   *
   * @return {boolean} - The result of the validation.
   */
  _validate() {
    let t = super._validate();
    const s = c("boolean", {
      optionalKeySupport: this._optionalSupport
    });
    return s.status || (this._errors.push(s.error.message), t = !1), t;
  }
  /**
   * Handles click events throughout the menu for proper use.
   *
   * - Adds all event listeners listed in
   *   BaseMenu's _handleClick method.
   * - Adds a `pointerup` listener to the `document` so if the user
   *   clicks outside of the menu it will close if it is open.
   *
   * @protected
   */
  _handleClick() {
    super._handleClick(), document.addEventListener("pointerup", (t) => {
      this.focusState !== "none" && (this.currentEvent = "mouse", !this.dom.menu.contains(t.target) && !this.dom.menu !== t.target && (this.closeChildren(), this.blur(), this.elements.controller && this.elements.controller.close(), this.elements.rootMenu.hasOpened = !1));
    });
  }
  /**
   * Handles keydown events throughout the menu for proper menu use.
   *
   * This method exists to assist the _handleKeyup method.
   * - Adds all `keydown` listeners from BaseMenu's _handleKeydown method
   * - Adds a `keydown` listener to the menu/all submenus.
   *   - Blocks propagation on the following keys: "Space", "Enter", and "Escape".
   *   - _If_ optional keyboard support
   *     is enabled, blocks propagation on the following keys:
   *     "ArrowUp", "ArrowRight", "ArrowDown", "ArrowLeft", "Home", and "End".
   *
   * @protected
   */
  _handleKeydown() {
    super._handleKeydown(), this.dom.menu.addEventListener("keydown", (t) => {
      this.currentEvent = "keyboard";
      const s = _(t);
      if (this.focusState === "self") {
        const n = ["Space", "Enter"], i = ["Escape"], l = ["Escape"], h = [
          "ArrowUp",
          "ArrowRight",
          "ArrowDown",
          "ArrowLeft",
          "Home",
          "End"
        ];
        (n.includes(s) || this.optionalKeySupport && h.includes(s) || this.elements.controller && i.includes(s) || this.elements.parentMenu && l.includes(s)) && o(t);
      }
    });
  }
  /**
   * Handles keyup events throughout the menu for proper menu use.
   *
   * Adds all `keyup` listeners from BaseMenu's _handleKeyup method.
   *
   * Adds the following keybindings (explanations are taken from the
   * WAI ARIA Practices Example Disclosure for Navigation Menus):
   *
   * | Key | Function |
   * | --- | --- |
   * | _Tab_ or _Shift + Tab_ | Move keyboard focus among top-level buttons, and if a dropdown is open, into and through links in the dropdown. |
   * | _Space_ or _Enter_ | <ul><li>If focus is on a disclosure button, activates the button, which toggles the visibility of the dropdown.</li><li>If focus is on a link:<ul><li>If any link has aria-current set, removes it.</li><li>Sets aria-current="page" on the focused link.</li><li>Activates the focused link.</li></ul></li></ul> |
   * | _Escape_ | If a dropdown is open, closes it and sets focus on the button that controls that dropdown. |
   * | _Down Arrow_ or _Right Arrow_ (Optional}) | <ul><li>If focus is on a button and its dropdown is collapsed, and it is not the last button, moves focus to the next button.</li><li>if focus is on a button and its dropdown is expanded, moves focus to the first link in the dropdown.</li><li>If focus is on a link, and it is not the last link, moves focus to the next link.</li></ul> |
   * | _Up Arrow_ or _Left Arrow_ (Optional}) | <ul><li>If focus is on a button, and it is not the first button, moves focus to the previous button.</li><li>If focus is on a link, and it is not the first link, moves focus to the previous link.</li></ul> |
   * | _Home_ (Optional) | <ul><li>If focus is on a button, and it is not the first button, moves focus to the first button.</li><li>If focus is on a link, and it is not the first link, moves focus to the first link.</li></ul> |
   * | _End_ (Optional) | <ul><li>If focus is on a button, and it is not the last button, moves focus to the last button.</li><li>If focus is on a link, and it is not the last link, moves focus to the last link.</li></ul> |
   *
   * The optional keybindings are controlled by the menu's optionalKeySupport value.
   *
   * @protected
   */
  _handleKeyup() {
    super._handleKeyup(), this.dom.menu.addEventListener("keyup", (t) => {
      this.currentEvent = "keyboard";
      const s = _(t);
      this.focusState === "self" && (s === "Space" || s === "Enter" ? (o(t), this.currentMenuItem.isSubmenuItem ? this.currentMenuItem.elements.toggle.isOpen ? this.currentMenuItem.elements.toggle.close() : this.currentMenuItem.elements.toggle.preview() : this.currentMenuItem.dom.link.click()) : s === "Escape" ? this.elements.submenuToggles.some(
        (i) => i.isOpen
      ) ? (o(t), this.closeChildren()) : this.elements.parentMenu ? (o(t), this.elements.parentMenu.currentEvent = this.currentEvent, this.elements.parentMenu.closeChildren(), this.elements.parentMenu.focusCurrentChild()) : this.isTopLevel && this.elements.controller && this.elements.controller.isOpen && (this.elements.controller.close(), this.focusController()) : this.optionalKeySupport && (s === "ArrowDown" || s === "ArrowRight" ? (o(t), this.currentMenuItem.isSubmenuItem && this.currentMenuItem.elements.toggle.isOpen ? (this.currentMenuItem.elements.childMenu.currentEvent = "keyboard", this.currentMenuItem.elements.childMenu.focusFirstChild()) : this.focusNextChild()) : s === "ArrowUp" || s === "ArrowLeft" ? (o(t), this.focusPreviousChild()) : s === "Home" ? (o(t), this.focusFirstChild()) : s === "End" && (o(t), this.focusLastChild())));
    });
  }
}
class B extends O {
  /**
   * Constructs a new `MenubarItem`.
   *
   * @param {object}         options                         - The options for generating the menu item.
   * @param {HTMLElement}    options.menuItemElement         - The menu item in the DOM.
   * @param {HTMLElement}    options.menuLinkElement         - The menu item's link in the DOM.
   * @param {Menubar}        options.parentMenu              - The parent menu.
   * @param {boolean}        [options.isSubmenuItem = false] - A flag to mark if the menu item is controlling a submenu.
   * @param {?Menubar}       [options.childMenu = null]      - The child menu.
   * @param {?MenubarToggle} [options.toggle = null]         - The controller for the child menu.
   * @param {boolean}        [options.initialize = true]     - A flag to initialize the menu item immediately upon creation.
   */
  constructor({
    menuItemElement: e,
    menuLinkElement: t,
    parentMenu: s,
    isSubmenuItem: n = !1,
    childMenu: i = null,
    toggle: l = null,
    initialize: h = !0
  }) {
    super({
      menuItemElement: e,
      menuLinkElement: t,
      parentMenu: s,
      isSubmenuItem: n,
      childMenu: i,
      toggle: l
    }), h && this.initialize();
  }
  /**
   * Initialize the menu item.
   *
   * Initialize will call the BaseMenuItem's initialize method
   * as well as set the menu item's `role` to "none",
   * the menu link's `role` to "menuitem", and
   * the menu link's `tabIndex` to -1 in the DOM.
   */
  initialize() {
    super.initialize(), this.dom.item.setAttribute("role", "none"), this.dom.link.setAttribute("role", "menuitem"), this.dom.link.tabIndex = -1;
  }
  /**
   * Focuses the menu item's link if the parent menu's
   * shouldFocus value is `true`.
   *
   * This will call the BaseMenuItem's focus method
   * as well as set the menu link's `tabIndex` to 0 if the parent menu
   * is the root menu.
   *
   * @public
   */
  focus() {
    super.focus(), this.elements.parentMenu.isTopLevel && (this.dom.link.tabIndex = 0);
  }
  /**
   * Blurs the menu item's link if the parent menu's
   * shouldFocus value is `true`.
   *
   * This will call the BaseMenuItem's blur method
   * as well as set the menu link's `tabIndex` to -1 if the parent menu
   * is the root menu.
   *
   * @public
   */
  blur() {
    super.blur(), this.elements.parentMenu.isTopLevel && (this.dom.link.tabIndex = -1);
  }
}
class G extends L {
  /**
   * Constructs a new `MenubarToggle`.
   *
   * @param {object}      options                     - The options for generating the menu toggle.
   * @param {HTMLElement} options.menuToggleElement   - The toggle element in the DOM.
   * @param {HTMLElement} options.parentElement       - The element containing the controlled menu.
   * @param {Menubar}     options.controlledMenu      - The menu controlled by this toggle.
   * @param {?Menubar}    [options.parentMenu = null] - The menu containing this toggle.
   * @param {boolean}     [options.initialize = true] - A flag to initialize the menu toggle immediately upon creation.
   */
  constructor({
    menuToggleElement: e,
    parentElement: t,
    controlledMenu: s,
    parentMenu: n = null,
    initialize: i = !0
  }) {
    super({
      menuToggleElement: e,
      parentElement: t,
      controlledMenu: s,
      parentMenu: n
    }), i && this.initialize();
  }
  /**
   * Sets the ARIA attributes on the toggle and controlled menu.
   *
   * Calls the BaseMenuToggle's _setAriaAttributes method.
   *
   * Then sets the toggle's `aria-haspopup` attribute to "true".
   *
   * @protected
   */
  _setAriaAttributes() {
    super._setAriaAttributes(), this.dom.toggle.setAttribute("aria-haspopup", "true");
  }
  /**
   * Opens the controlled menu.
   *
   * Calls the  closeSiblings method
   * and _then_ BaseMenuToggle's open method.
   *
   * @public
   */
  open() {
    this.closeSiblings(), super.open();
  }
  /**
   * Opens the controlled menu without the current focus entering it.
   *
   * Calls the  closeSiblings method
   * and _then_ BaseMenuToggle's preview method.
   *
   * @public
   */
  preview() {
    this.closeSiblings(), super.preview();
  }
  /**
   * Closes the controlled menu.
   *
   * Calls the  closeChildren method
   * and _then_ BaseMenuToggle's close method.
   *
   * @public
   */
  close() {
    this.isOpen && (this.closeChildren(), this.elements.parentMenu && this.elements.parentMenu.focusCurrentChild()), super.close();
  }
}
class H extends w {
  /**
   * Constructs a new `Menubar`.
   *
   * @param {object}             options                                    - The options for generating the menu.
   * @param {HTMLElement}        options.menuElement                        - The menu element in the DOM.
   * @param {string}             [options.menuItemSelector = li]            - The query selector string for menu items.
   * @param {string}             [options.menuLinkSelector = a]             - The query selector string for menu links.
   * @param {string}             [options.submenuItemSelector = li:has(ul)] - The query selector string for menu items containing submenus.
   * @param {string}             [options.submenuToggleSelector = a]        - The query selector string for submenu toggle buttons/links.
   * @param {string}             [options.submenuSelector = ul]             - The query selector string for submenus.
   * @param {?HTMLElement}       [options.controllerElement = null]         - The element controlling the menu in the DOM.
   * @param {?HTMLElement}       [options.containerElement = null]          - The element containing the menu in the DOM.
   * @param {?(string|string[])} [options.openClass = show]                 - The class to apply when a menu is "open".
   * @param {?(string|string[])} [options.closeClass = hide]                - The class to apply when a menu is "closed".
   * @param {?(string|string[])} [options.transitionClass = transitioning]  - The class to apply when a menu is transitioning between "open" and "closed" states.
   * @param {number}             [options.transitionDuration = 250]         - The duration of the transition between "open" and "closed" states (in milliseconds).
   * @param {boolean}            [options.isTopLevel = true]                - A flag to mark the root menu.
   * @param {?Menubar}           [options.parentMenu = null]                - The parent menu to this menu.
   * @param {string}             [options.hoverType = off]                  - The type of hoverability a menu has.
   * @param {number}             [options.hoverDelay = 250]                 - The delay for opening and closing menus if the menu is hoverable (in milliseconds).
   * @param {number}             [options.enterDelay = -1]                  - The delay for opening a menu if the menu is focusable (in milliseconds).
   * @param {number}             [options.leaveDelay = -1]                  - The delay for closing a menu if the menu is focusable (in milliseconds).
   * @param {?string}            [options.prefix = am-]                     - The prefix to use for CSS custom properties.
   * @param {boolean}            [options.initialize = true]                - A flag to initialize the menu immediately upon creation.
   */
  constructor({
    menuElement: t,
    menuItemSelector: s = "li",
    menuLinkSelector: n = "a",
    submenuItemSelector: i = "li:has(ul)",
    submenuToggleSelector: l = "a",
    submenuSelector: h = "ul",
    controllerElement: m = null,
    containerElement: a = null,
    openClass: p = "show",
    closeClass: f = "hide",
    transitionClass: g = "transitioning",
    transitionDuration: d = 250,
    isTopLevel: M = !0,
    parentMenu: y = null,
    hoverType: b = "off",
    hoverDelay: C = 250,
    enterDelay: T = -1,
    leaveDelay: E = -1,
    prefix: v = "am-",
    initialize: I = !0
  }) {
    super({
      menuElement: t,
      menuItemSelector: s,
      menuLinkSelector: n,
      submenuItemSelector: i,
      submenuToggleSelector: l,
      submenuSelector: h,
      controllerElement: m,
      containerElement: a,
      openClass: p,
      closeClass: f,
      transitionClass: g,
      transitionDuration: d,
      isTopLevel: M,
      parentMenu: y,
      hoverType: b,
      hoverDelay: C,
      enterDelay: T,
      leaveDelay: E,
      prefix: v
    });
    /**
     * The class to use when generating submenus.
     *
     * @protected
     *
     * @type {typeof Menubar}
     */
    u(this, "_MenuType", H);
    /**
     * The class to use when generating menu items.
     *
     * @protected
     *
     * @type {typeof MenubarItem}
     */
    u(this, "_MenuItemType", B);
    /**
     * The class to use when generating submenu toggles.
     *
     * @protected
     *
     * @type {typeof MenubarToggle}
     */
    u(this, "_MenuToggleType", G);
    I && this.initialize();
  }
  /**
   * Initializes the menu.
   *
   * Initialize will call the BaseMenu's initialize method
   * as well as set up focus,
   * click,
   * hover,
   * keydown, and
   * keyup events for the menu.
   *
   * This will also set the menu's `role` to "menubar" in the DOM.
   *
   * If the menu is a root menu the first menu item's `tabIndex` will be set to
   * 0 in the DOM.
   *
   * If the BaseMenu's initialize method throws an error,
   * this will catch it and log it to the console.
   */
  initialize() {
    try {
      super.initialize(), this.isTopLevel ? this.dom.menu.setAttribute("role", "menubar") : this.dom.menu.setAttribute("role", "menu"), this._handleFocus(), this._handleClick(), this._handleHover(), this._handleKeydown(), this._handleKeyup(), this.isTopLevel && (this.elements.menuItems[0].dom.link.tabIndex = 0, this.elements.controller && this.elements.controller.dom.toggle.removeAttribute("aria-haspopup"));
    } catch (t) {
      console.error(t);
    }
  }
  /**
   * Handles click events throughout the menu for proper use.
   *
   * - Adds all event listeners listed in
   *   BaseMenu's _handleClick method.
   * - Adds a `pointerup` listener to the `document` so if the user
   *   clicks outside of the menu it will close if it is open.
   *
   * @protected
   */
  _handleClick() {
    super._handleClick(), document.addEventListener("pointerup", (t) => {
      this.focusState !== "none" && (this.currentEvent = "mouse", !this.dom.menu.contains(t.target) && !this.dom.menu !== t.target && (this.closeChildren(), this.blur(), this.elements.controller && this.elements.controller.close(), this.elements.rootMenu.hasOpened = !1));
    });
  }
  /**
   * Handles keydown events throughout the menu for proper menu use.
   *
   * This method exists to assist the _handleKeyup method.
   * - Adds all `keydown` listeners from BaseMenu's _handleKeydown method
   * - Adds a `keydown` listener to the menu/all submenus.
   *   - Blocks propagation on the following keys: "ArrowUp", "ArrowRight",
   *     "ArrowDown", "ArrowLeft", "Home", "End", "Space", "Enter", "Escape",
   *     and "A" through "Z".
   *   - Completely closes the menu and moves focus out if the "Tab" key is pressed.
   *
   * @protected
   */
  _handleKeydown() {
    super._handleKeydown(), this.dom.menu.addEventListener("keydown", (t) => {
      this.currentEvent = "keyboard";
      const s = _(t);
      if (s === "Tab" && (this.elements.rootMenu.focusState !== "none" ? (this.elements.rootMenu.blur(), this.elements.rootMenu.closeChildren()) : this.elements.rootMenu.focus()), s === "Character")
        o(t);
      else if (this.isTopLevel) {
        if (this.focusState === "self") {
          const n = [
            "Space",
            "Enter",
            "ArrowRight",
            "ArrowLeft",
            "Home",
            "End"
          ], i = ["ArrowDown", "ArrowUp"], l = ["Escape"];
          (n.includes(s) || this.currentMenuItem.isSubmenuItem && i.includes(s) || this.elements.controller && l.includes(s)) && o(t);
        }
      } else
        [
          "Space",
          "Enter",
          "Escape",
          "ArrowRight",
          "ArrowLeft",
          "ArrowDown",
          "ArrowUp",
          "Home",
          "End"
        ].includes(s) && o(t);
    });
  }
  /**
   * Handles keyup events throughout the menu for proper menu use.
   *
   * Adds all `keyup` listeners from BaseMenu's _handleKeyup method.
   *
   * Adds the following keybindings (explanations are taken from the
   * Navigation Menubar Example):
   *
   * <strong>Menubar</strong>
   *
   * | Key | Function |
   * | --- | --- |
   * | _Space_ or _Enter_ | Opens submenu and moves focus to first item in the submenu. |
   * | _Right Arrow_ | <ul><li>Moves focus to the next item in the menubar.</li><li>If focus is on the last item, moves focus to the first item.</li></ul> |
   * | _Left Arrow_ | <ul><li>Moves focus to the previous item in the menubar.</li><li>If focus is on the first item, moves focus to the last item.</li></ul> |
   * | _Down Arrow_ | Opens submenu and moves focus to first item in the submenu. |
   * | _Up Arrow_ | Opens submenu and moves focus to last item in the submenu. |
   * | _Home_ | Moves focus to first item in the menubar. |
   * | _End_ | Moves focus to last item in the menubar. |
   * | _Character_ | <ul><li>Moves focus to next item in the menubar having a name that starts with the typed character.</li><li>If none of the items have a name starting with the typed character, focus does not move.</li></ul> |
   *
   * <strong>Submenu</strong>
   *
   * | Key | Function |
   * | --- | --- |
   * | _Space_ or _Enter_ | <ul><li>Activates menu item, causing the link to be activated.</li><li>NOTE: the links go to dummy pages; use the browser go-back function to return to this menubar example page.</li></ul> |
   * | _Escape_ | <ul><li>Closes submenu.</li><li>Moves focus to parent menubar item.</li></ul> |
   * | _Right Arrow_ | <ul><li>If focus is on an item with a submenu, opens the submenu and places focus on the first item.</li><li>If focus is on an item that does not have a submenu:<ul><li>Closes submenu.</li><li>Moves focus to next item in the menubar.</li><li>Opens submenu of newly focused menubar item, keeping focus on that parent menubar item.</li></ul></li></ul> |
   * | _Left Arrow_ | <ul><li>Closes submenu and moves focus to parent menu item.</li><li>If parent menu item is in the menubar, also:<ul><li>moves focus to previous item in the menubar.</li><li>Opens submenu of newly focused menubar item, keeping focus on that parent menubar item.</li></ul></li></ul> |
   * | _Down Arrow_ | <ul><li>Moves focus to the next item in the submenu.</li><li>If focus is on the last item, moves focus to the first item.</li></ul> |
   * | _Up Arrow_ | <ul><li>Moves focus to previous item in the submenu.</li><li>If focus is on the first item, moves focus to the last item.</li></ul> |
   * | Home | Moves focus to the first item in the submenu. |
   * | End | Moves focus to the last item in the submenu. |
   * | _Character_ | <ul><li>Moves focus to the next item having a name that starts with the typed character.</li><li>If none of the items have a name starting with the typed character, focus does not move.</li></ul> |
   *
   * @protected
   */
  _handleKeyup() {
    super._handleKeyup(), this.dom.menu.addEventListener("keyup", (t) => {
      this.currentEvent = "keyboard";
      const s = _(t), { altKey: n, crtlKey: i, metaKey: l } = t;
      if (s === "Character" && !(n || i || l))
        o(t), this.elements.rootMenu.currentEvent = "character", this.focusNextChildWithCharacter(t.key);
      else if (this.isTopLevel) {
        if (this.focusState === "self")
          if (s === "Space" || s === "Enter")
            o(t), this.currentMenuItem.isSubmenuItem ? (this.currentMenuItem.elements.childMenu.currentEvent = "keyboard", this.currentMenuItem.elements.toggle.open(), requestAnimationFrame(() => {
              this.currentMenuItem.elements.childMenu.focusFirstChild();
            })) : this.currentMenuItem.dom.link.click();
          else if (s === "ArrowRight") {
            o(t);
            const m = this.currentMenuItem.isSubmenuItem && this.currentMenuItem.elements.toggle.isOpen;
            this.focusNextChild(), m && (this.currentMenuItem.isSubmenuItem ? (this.currentMenuItem.elements.childMenu.currentEvent = "keyboard", this.currentMenuItem.elements.toggle.preview()) : this.closeChildren());
          } else if (s === "ArrowLeft") {
            o(t);
            const m = this.currentMenuItem.isSubmenuItem && this.currentMenuItem.elements.toggle.isOpen;
            this.focusPreviousChild(), m && (this.currentMenuItem.isSubmenuItem ? (this.currentMenuItem.elements.childMenu.currentEvent = "keyboard", this.currentMenuItem.elements.toggle.preview()) : this.closeChildren());
          } else s === "ArrowDown" ? this.currentMenuItem.isSubmenuItem && (o(t), this.currentMenuItem.elements.childMenu.currentEvent = "keyboard", this.currentMenuItem.elements.toggle.open(), requestAnimationFrame(() => {
            this.currentMenuItem.elements.childMenu.focusFirstChild();
          })) : s === "ArrowUp" ? this.currentMenuItem.isSubmenuItem && (o(t), this.currentMenuItem.elements.childMenu.currentEvent = "keyboard", this.currentMenuItem.elements.toggle.open(), requestAnimationFrame(() => {
            this.currentMenuItem.elements.childMenu.focusLastChild();
          })) : s === "Home" ? (o(t), this.focusFirstChild()) : s === "End" ? (o(t), this.focusLastChild()) : s === "Escape" && (this.elements.submenuToggles.some(
            (a) => a.isOpen
          ) ? (o(t), this.closeChildren()) : this.isTopLevel && this.elements.controller && this.elements.controller.isOpen && (o(t), this.elements.controller.close(), this.focusController()));
      } else
        s === "Space" || s === "Enter" ? (o(t), this.currentMenuItem.isSubmenuItem ? (this.currentMenuItem.elements.childMenu.currentEvent = "keyboard", this.currentMenuItem.elements.toggle.open(), requestAnimationFrame(() => {
          this.currentMenuItem.elements.childMenu.focusFirstChild();
        })) : this.currentMenuItem.dom.link.click()) : s === "Escape" ? (o(t), this.elements.rootMenu.closeChildren(), this.elements.rootMenu.focusCurrentChild()) : s === "ArrowRight" ? this.currentMenuItem.isSubmenuItem ? (o(t), this.currentMenuItem.elements.childMenu.currentEvent = "keyboard", this.currentMenuItem.elements.toggle.open(), requestAnimationFrame(() => {
          this.currentMenuItem.elements.childMenu.focusFirstChild();
        })) : (o(t), this.elements.rootMenu.closeChildren(), this.elements.rootMenu.focusNextChild(), this.elements.rootMenu.currentMenuItem.isSubmenuItem && this.elements.rootMenu.currentMenuItem.elements.toggle.preview()) : s === "ArrowLeft" ? this.elements.parentMenu.currentMenuItem.isSubmenuItem && (o(t), this.elements.parentMenu.currentMenuItem.elements.toggle.close(), this.elements.parentMenu.focusCurrentChild(), this.elements.parentMenu === this.elements.rootMenu && (this.elements.rootMenu.closeChildren(), this.elements.rootMenu.focusPreviousChild(), this.elements.rootMenu.currentMenuItem.isSubmenuItem && (this.elements.rootMenu.currentMenuItem.elements.childMenu.currentEvent = "keyboard", this.elements.rootMenu.currentMenuItem.elements.toggle.preview()))) : s === "ArrowDown" ? (o(t), this.focusNextChild()) : s === "ArrowUp" ? (o(t), this.focusPreviousChild()) : s === "Home" ? (o(t), this.focusFirstChild()) : s === "End" && (o(t), this.focusLastChild());
    });
  }
  /**
   * Focus the menu's next child.
   *
   * If the currently focussed child in the menu is the last child then this will
   * focus the first child in the menu.
   *
   * @public
   */
  focusNextChild() {
    this.currentChild === this.elements.menuItems.length - 1 ? this.focusFirstChild() : this.focusChild(this.currentChild + 1);
  }
  /**
   * Focus the menu's previous child.
   *
   * If the currently focussed child in the menu is the first child then this will
   * focus the last child in the menu.
   *
   * @public
   */
  focusPreviousChild() {
    this.currentChild === 0 ? this.focusLastChild() : this.focusChild(this.currentChild - 1);
  }
  /**
   * Focus the menu's next child starting with a specific letter.
   *
   * @public
   *
   * @param {string} char - The character to look for.
   */
  focusNextChildWithCharacter(t) {
    const s = t.toLowerCase();
    let n = this.currentChild + 1, i = !1;
    for (; !i && n < this.elements.menuItems.length; ) {
      let l = "";
      this.elements.menuItems[n].dom.item.innerText ? l = this.elements.menuItems[n].dom.item.innerText : l = this.elements.menuItems[n].dom.item.textContent, l = l.replace(/[\s]/g, "").toLowerCase().charAt(0), l === s && (i = !0, this.focusChild(n)), n++;
    }
  }
}
class J extends O {
  /**
   * Constructs a new `TopLinkDisclosureMenuItem`.
   *
   * @param {object}                       options                         - The options for generating the menu item.
   * @param {HTMLElement}                  options.menuItemElement         - The menu item in the DOM.
   * @param {HTMLElement}                  options.menuLinkElement         - The menu item's link in the DOM.
   * @param {TopLinkDisclosureMenu}        options.parentMenu              - The parent menu.
   * @param {boolean}                      [options.isSubmenuItem = false] - A flag to mark if the menu item is controlling a submenu.
   * @param {?TopLinkDisclosureMenu}       [options.childMenu = null]      - The child menu.
   * @param {?TopLinkDisclosureMenuToggle} [options.toggle = null]         - The controller for the child menu.
   * @param {boolean}                      [options.initialize = true]     - A flag to initialize the menu item immediately upon creation.
   * @param {?TopLinkDisclosureMenuItem}   [options.submenuSibling = null] - The sibling menu item that controls a submenu.
   */
  constructor({
    menuItemElement: t,
    menuLinkElement: s,
    parentMenu: n,
    isSubmenuItem: i = !1,
    childMenu: l = null,
    toggle: h = null,
    initialize: m = !0,
    submenuSibling: a = null
  }) {
    super({
      menuItemElement: t,
      menuLinkElement: s,
      parentMenu: n,
      isSubmenuItem: i,
      childMenu: l,
      toggle: h
    });
    /**
     * The declared accessible-menu elements within the menu item.
     *
     * @type {Object<TopLinkDisclosureMenu, TopLinkDisclosureMenuToggle>}
     *
     * @protected
     *
     * @property {TopLinkDisclosureMenu}                   parentMenu - The menu containing this menu item.
     * @property {?TopLinkDisclosureMenu}                  childMenu  - The menu contained within this menu item.
     * @property {?TopLinkDisclosureMenuToggle}            toggle     - The menu toggle within this menu item that controls the `childMenu`.
     * @property {?TopLinkDisclosureMenuItem}              sibling    - The sibling menu item that is a submenu item.
     */
    u(this, "_elements", {
      parentMenu: null,
      childMenu: null,
      toggle: null,
      sibling: null
    });
    this._elements.parentMenu = n, this._elements.childMenu = l, this._elements.toggle = h, this._elements.sibling = a, m && this.initialize();
  }
}
class X extends L {
  /**
   * Constructs a new `TopLinkDisclosureMenuToggle`.
   *
   * @param {object}                 options                     - The options for generating the menu toggle.
   * @param {HTMLElement}            options.menuToggleElement   - The toggle element in the DOM.
   * @param {HTMLElement}            options.parentElement       - The element containing the controlled menu.
   * @param {TopLinkDisclosureMenu}  options.controlledMenu      - The menu controlled by this toggle.
   * @param {?TopLinkDisclosureMenu} [options.parentMenu = null] - The menu containing this toggle.
   * @param {boolean}                [options.initialize = true] - A flag to initialize the menu toggle immediately upon creation.
   */
  constructor({
    menuToggleElement: e,
    parentElement: t,
    controlledMenu: s,
    parentMenu: n = null,
    initialize: i = !0
  }) {
    super({
      menuToggleElement: e,
      parentElement: t,
      controlledMenu: s,
      parentMenu: n
    }), i && this.initialize();
  }
  /**
   * Sets the ARIA attributes on the toggle and controlled menu.
   *
   * Calls the BaseMenuToggle's _setAriaAttributes method.
   *
   * Ensures the toggle element has a `role` of "button" if it is not
   * already a button.
   *
   * Then using the toggle and menu's IDs, the toggle's `aria-controls`
   * is set to the menu's ID.
   *
   * @protected
   */
  _setAriaAttributes() {
    super._setAriaAttributes(), F("button", { toggle: this.dom.toggle }) || this.dom.toggle.setAttribute("role", "button"), this.dom.toggle.setAttribute(
      "aria-controls",
      this.elements.controlledMenu.dom.menu.id
    );
  }
  /**
   * Opens the controlled menu.
   *
   * Calls the  closeSiblings method
   * and _then_ BaseMenuToggle's open method.
   */
  open() {
    this.closeSiblings(), super.open();
  }
  /**
   * Opens the controlled menu without the current focus entering it.
   *
   * Calls the  closeSiblings method
   * and _then_ BaseMenuToggle's preview method.
   */
  preview() {
    this.closeSiblings(), super.preview();
  }
  /**
   * Closes the controlled menu.
   *
   * Calls the  closeChildren method
   * and _then_ BaseMenuToggle's close method.
   */
  close() {
    this.isOpen && this.closeChildren(), super.close();
  }
}
class q extends w {
  /**
   * Constructs a new `TopLinkDisclosureMenu`.
   *
   * @param {object}                 options                                    - The options for generating the menu.
   * @param {HTMLElement}            options.menuElement                        - The menu element in the DOM.
   * @param {string}                 [options.menuItemSelector = li]            - The query selector string for menu items.
   * @param {string}                 [options.menuLinkSelector = a]             - The query selector string for menu links.
   * @param {string}                 [options.submenuItemSelector = li:has(ul)] - The query selector string for menu items containing submenus.
   * @param {string}                 [options.submenuToggleSelector = button]   - The query selector string for submenu toggle buttons/links.
   * @param {string}                 [options.submenuSelector = ul]             - The query selector string for submenus.
   * @param {string}                 [options.submenuSubtoggleSelector = a]     - The query selector string for submenu toggle buttons/links below the top level.
   * @param {?HTMLElement}           [options.controllerElement = null]         - The element controlling the menu in the DOM.
   * @param {?HTMLElement}           [options.containerElement = null]          - The element containing the menu in the DOM.
   * @param {?(string|string[])}     [options.openClass = show]                 - The class to apply when a menu is "open".
   * @param {?(string|string[])}     [options.closeClass = hide]                - The class to apply when a menu is "closed".
   * @param {?(string|string[])}     [options.transitionClass = transitioning]  - The class to apply when a menu is transitioning between "open" and "closed" states.
   * @param {number}                 [options.transitionDuration = 250]         - The duration of the transition between "open" and "closed" states (in milliseconds).
   * @param {boolean}                [options.isTopLevel = true]                - A flag to mark the root menu.
   * @param {?TopLinkDisclosureMenu} [options.parentMenu = null]                - The parent menu to this menu.
   * @param {string}                 [options.hoverType = off]                  - The type of hoverability a menu has.
   * @param {number}                 [options.hoverDelay = 250]                 - The delay for opening and closing menus if the menu is hoverable (in milliseconds).
   * @param {number}                 [options.enterDelay = -1]                  - The delay for opening a menu if the menu is focusable (in milliseconds).
   * @param {number}                 [options.leaveDelay = -1]                  - The delay for closing a menu if the menu is focusable (in milliseconds).
   * @param {boolean}                [options.optionalKeySupport = false]       - A flag to add optional keyboard support (Arrow keys, Home, and End) to the menu.
   * @param {?string}                [options.prefix = am-]                     - The prefix to use for CSS custom properties.
   * @param {boolean}                [options.initialize = true]                - A flag to initialize the menu immediately upon creation.
   */
  constructor({
    menuElement: t,
    menuItemSelector: s = "li",
    menuLinkSelector: n = "a",
    submenuItemSelector: i = "li:has(ul)",
    submenuToggleSelector: l = "button",
    submenuSelector: h = "ul",
    submenuSubtoggleSelector: m = "a",
    controllerElement: a = null,
    containerElement: p = null,
    openClass: f = "show",
    closeClass: g = "hide",
    transitionClass: d = "transitioning",
    transitionDuration: M = 250,
    isTopLevel: y = !0,
    parentMenu: b = null,
    hoverType: C = "off",
    hoverDelay: T = 250,
    enterDelay: E = -1,
    leaveDelay: v = -1,
    optionalKeySupport: I = !1,
    prefix: K = "am-",
    initialize: $ = !0
  }) {
    super({
      menuElement: t,
      menuItemSelector: s,
      menuLinkSelector: n,
      submenuItemSelector: i,
      submenuSelector: h,
      submenuToggleSelector: l,
      controllerElement: a,
      containerElement: p,
      openClass: f,
      closeClass: g,
      transitionClass: d,
      transitionDuration: M,
      isTopLevel: y,
      parentMenu: b,
      hoverType: C,
      hoverDelay: T,
      enterDelay: E,
      leaveDelay: v,
      prefix: K
    });
    /**
     * The class to use when generating submenus.
     *
     * @protected
     *
     * @type {typeof TopLinkDisclosureMenu}
     */
    u(this, "_MenuType", q);
    /**
     * The class to use when generating menu items.
     *
     * @protected
     *
     * @type {typeof TopLinkDisclosureMenuItem}
     */
    u(this, "_MenuItemType", J);
    /**
     * The class to use when generating submenu toggles.
     *
     * @protected
     *
     * @type {typeof TopLinkDisclosureMenuToggle}
     */
    u(this, "_MenuToggleType", X);
    /**
     * The index of the currently selected menu item in the menu.
     *
     * @protected
     *
     * @type {number}
     */
    u(this, "_currentChild", -1);
    /**
     * The query selectors used by the menu to populate the dom.
     *
     * @protected
     *
     * @type {Object<string>}
     *
     * @property {string} menuItems         - The query selector for menu items.
     * @property {string} menuLinks         - The query selector for menu links.
     * @property {string} submenuItems      - The query selector for menu items containing submenus.
     * @property {string} submenuToggles    - The query selector for menu links that function as submenu toggles.
     * @property {string} submenus          - The query selector for for submenus.
     * @property {string} submenuSubtoggles - The query selector for menu links that function as submenu toggles below the top level.
     */
    u(this, "_selectors", {
      menuItems: "",
      menuLinks: "",
      submenuItems: "",
      submenuToggles: "",
      submenus: "",
      submenuSubtoggles: ""
    });
    /**
     * A flag to add optional keyboard support (Arrow keys, "Home", and "End") to the menu.
     *
     * @protected
     *
     * @type {boolean}
     */
    u(this, "_optionalSupport", !1);
    this._optionalSupport = I, this._selectors.menuItems = s, this._selectors.submenuItems = i, this._selectors.submenuToggles = l, this._selectors.submenus = h, this._selectors.submenuSubtoggles = m, this._selectors.menuLinks = [
      .../* @__PURE__ */ new Set([n, l])
    ].join(","), $ && this.initialize();
  }
  /**
   * Initializes the menu.
   *
   * Initialize will call the BaseMenu's initialize method
   * as well as set up focus,
   * click,
   * hover,
   * keydown, and
   * keyup events for the menu.
   *
   * If the BaseMenu's initialize method throws an error,
   * this will catch it and log it to the console.
   */
  initialize() {
    try {
      super.initialize(), this._handleFocus(), this._handleClick(), this._handleHover(), this._handleKeydown(), this._handleKeyup();
    } catch (t) {
      console.error(t);
    }
  }
  /**
   * A flag to add optional keyboard support (Arrow keys, "Home", and "End") to the menu.
   *
   * This functions differently for root vs. submenus.
   * Submenus will always inherit their root menu's optionalKeySupport.
   *
   * @type {boolean}
   *
   * @see _optionalSupport
   */
  get optionalKeySupport() {
    return this.isTopLevel ? this._optionalSupport : this.elements.rootMenu.optionalKeySupport;
  }
  set optionalKeySupport(t) {
    c("boolean", { optionalKeySupport: t }), this._optionalSupport = t;
  }
  /**
   * Creates and initializes all menu items and submenus.
   *
   * @protected
   */
  _createChildElements() {
    this.dom.menuItems.forEach((t) => {
      let s, n;
      const i = t.querySelector(this.selectors.menuLinks);
      if (this.dom.submenuItems.includes(t)) {
        const l = t.querySelector(this.selectors.submenuToggles), h = t.querySelector(this.selectors.submenus), m = new this._MenuType({
          menuElement: h,
          menuItemSelector: this.selectors.menuItems,
          menuLinkSelector: this.selectors.menuLinks,
          submenuItemSelector: this.selectors.submenuItems,
          submenuToggleSelector: this.selectors.submenuSubtoggles,
          submenuSelector: this.selectors.submenus,
          submenuSubtoggleSelector: this.selectors.submenuSubtoggles,
          openClass: this.openClass,
          closeClass: this.closeClass,
          transitionClass: this.transitionClass,
          isTopLevel: !1,
          parentMenu: this,
          hoverType: this.hoverType,
          hoverDelay: this.hoverDelay,
          enterDelay: this.enterDelay,
          leaveDelay: this.leaveDelay
        }), a = new this._MenuToggleType({
          menuToggleElement: l,
          parentElement: t,
          controlledMenu: m,
          parentMenu: this
        });
        this._elements.submenuToggles.push(a), l !== i ? (n = new this._MenuItemType({
          menuItemElement: t,
          menuLinkElement: l,
          parentMenu: this,
          isSubmenuItem: !0,
          childMenu: m,
          toggle: a
        }), s = new this._MenuItemType({
          menuItemElement: t,
          menuLinkElement: i,
          parentMenu: this,
          submenuSibling: n
        })) : s = new this._MenuItemType({
          menuItemElement: t,
          menuLinkElement: i,
          parentMenu: this,
          isSubmenuItem: !0,
          childMenu: m,
          toggle: a
        });
      } else
        s = new this._MenuItemType({
          menuItemElement: t,
          menuLinkElement: i,
          parentMenu: this
        });
      this._elements.menuItems.push(s), typeof n < "u" && this._elements.menuItems.push(n);
    });
  }
  /**
   * Validates all aspects of the menu to ensure proper functionality.
   *
   * @protected
   *
   * @return {boolean} - The result of the validation.
   */
  _validate() {
    let t = super._validate();
    const s = x({
      submenuSubtoggleSelector: this._selectors.submenuSubtoggles
    });
    s.status || (this._errors.push(s.error.message), t = !1);
    const n = c("boolean", {
      optionalKeySupport: this._optionalSupport
    });
    return n.status || (this._errors.push(n.error.message), t = !1), t;
  }
  /**
   * Handles click events throughout the menu for proper use.
   *
   * - Adds all event listeners listed in
   *   BaseMenu's _handleClick method, and
   * - adds a `pointerup` listener to the `document` so if the user
   *   clicks outside of the menu it will close if it is open.
   *
   * @protected
   */
  _handleClick() {
    super._handleClick(), document.addEventListener("pointerup", (t) => {
      this.focusState !== "none" && (this.currentEvent = "mouse", !this.dom.menu.contains(t.target) && !this.dom.menu !== t.target && (this.closeChildren(), this.blur(), this.elements.controller && this.elements.controller.close(), this.elements.rootMenu.hasOpened = !1));
    });
  }
  /**
   * Handles hover events throughout the menu for proper use.
   *
   * Adds `pointerenter` listeners to all menu items and `pointerleave` listeners
   * to all submenu items which function differently depending on
   * the menu's hover type.
   *
   * Before executing anything, the event is checked to make sure the event wasn't
   * triggered by a pen or touch.
   *
   * <strong>Hover Type "on"</strong>
   * - When a `pointerenter` event triggers on any menu item the menu's
   *    current child value will change to that
   *   menu item.
   * - When a `pointerenter` event triggers on a submenu item the
   *   preview method for the submenu item's
   *   toggle will be called.
   * - When a `pointerleave` event triggers on an open submenu item the
   *   close method for the submenu item's toggle
   *   will be called after a delay set by the menu's hover delay.
   *
   * <strong>Hover Type "dynamic"</strong>
   * - When a `pointerenter` event triggers on any menu item the menu's
   *   current child value will change to that menu item.
   * - When a `pointerenter` event triggers on any menu item, and the menu's
   *   focus state is not "none", the menu item
   *   will be focused.
   * - When a `pointerenter` event triggers on a submenu item, and a submenu is
   *   already open, the preview method for the submenu item's toggle will be called.
   * - When a `pointerenter` event triggers on a non-submenu item, and a submenu
   *   is already open, the closeChildren method for the menu will be called.
   * - When a `pointerenter` event triggers on a submenu item, and no submenu is
   *   open, no submenu-specific methods will be called.
   * - When a `pointerleave` event triggers on an open submenu item that is not a
   *   root-level submenu item the close method for the submenu item's toggle
   *   will be called and the submenu item will be focused after a delay set by
   *   the menu's hover delay.
   * - When a `pointerleave` event triggers on an open submenu item that is a
   *   root-level submenu item no submenu-specific methods will be called.
   *
   * <strong>Hover Type "off"</strong>
   * All `pointerenter` and `pointerleave` events are ignored.
   *
   * @protected
   */
  _handleHover() {
    this.elements.menuItems.forEach((t, s) => {
      t.dom.link.addEventListener("pointerenter", (n) => {
        if (!(n.pointerType === "pen" || n.pointerType === "touch")) {
          if (this.hoverType === "on") {
            this.currentEvent = "mouse", this.elements.rootMenu.blurChildren(), this.focusChild(s);
            let i = t.isSubmenuItem ? t.elements.toggle : null;
            if (t.elements.sibling !== null && (i = t.elements.sibling.elements.toggle), i === null) return;
            this.enterDelay > 0 ? (this._clearTimeout(), this._setTimeout(() => {
              i.preview();
            }, this.enterDelay)) : i.preview();
          } else if (this.hoverType === "dynamic" && (this.currentChild = s, (!this.isTopLevel || this.focusState !== "none") && (this.currentEvent = "mouse", this.elements.rootMenu.blurChildren(), this.focusCurrentChild()), !this.isTopLevel || this.hasOpened)) {
            this.currentEvent = "mouse", this.elements.rootMenu.blurChildren(), this.focusCurrentChild();
            let i = t.isSubmenuItem ? t.elements.toggle : null;
            t.elements.sibling !== null && (i = t.elements.sibling.elements.toggle), i !== null ? this.enterDelay > 0 ? (this._clearTimeout(), this._setTimeout(() => {
              i.preview();
            }, this.enterDelay)) : i.preview() : this.enterDelay > 0 ? (this._clearTimeout(), this._setTimeout(() => {
              this.closeChildren();
            }, this.enterDelay)) : this.closeChildren();
          }
        }
      }), t.isSubmenuItem && (t.dom.item.addEventListener("pointerleave", (n) => {
        n.pointerType === "pen" || n.pointerType === "touch" || (this.hoverType === "on" ? this.leaveDelay > 0 ? (this._clearTimeout(), this._setTimeout(() => {
          this.currentEvent = "mouse", t.elements.toggle.close();
        }, this.leaveDelay)) : (this.currentEvent = "mouse", t.elements.toggle.close()) : this.hoverType === "dynamic" && (this.leaveDelay > 0 ? (this._clearTimeout(), this._setTimeout(() => {
          this.currentEvent = "mouse";
        }, this.leaveDelay)) : this.currentEvent = "mouse"));
      }), t.dom.item.addEventListener("pointerenter", (n) => {
        n.pointerType === "pen" || n.pointerType === "touch" || t.isSubmenuItem && (this.hoverType === "on" || this.hoverType === "dynamic") && this.leaveDelay > 0 && this._clearTimeout();
      }));
    });
  }
  /**
   * Handles keydown events throughout the menu for proper menu use.
   *
   * This method exists to assist the _handleKeyup method.
   * - Adds all `keydown` listeners from BaseMenu's _handleKeydown method
   * - Adds a `keydown` listener to the menu/all submenus.
   *   - Blocks propagation on the following keys: "Space", "Enter", and "Escape".
   *   - _If_ optional keyboard support
   *     is enabled, blocks propagation on the following keys:
   *     "ArrowUp", "ArrowRight", "ArrowDown", "ArrowLeft", "Home", and "End".
   *
   * @protected
   */
  _handleKeydown() {
    super._handleKeydown(), this.dom.menu.addEventListener("keydown", (t) => {
      this.currentEvent = "keyboard";
      const s = _(t);
      if (this.focusState === "self") {
        const n = ["Space", "Enter"], i = ["Escape"], l = ["Escape"], h = [
          "ArrowUp",
          "ArrowRight",
          "ArrowDown",
          "ArrowLeft",
          "Home",
          "End"
        ];
        (n.includes(s) || this.optionalKeySupport && h.includes(s) || this.elements.controller && i.includes(s) || this.elements.parentMenu && l.includes(s)) && o(t);
      }
    });
  }
  /**
   * Handles keyup events throughout the menu for proper menu use.
   *
   * Adds all `keyup` listeners from BaseMenu's _handleKeyup method.
   *
   * Adds the following keybindings (explanations are taken from the
   * WAI ARIA Practices Example Disclosure for Navigation Menus):
   *
   * | Key | Function |
   * | --- | --- |
   * | _Tab_ or _Shift + Tab_ | Move keyboard focus among top-level buttons, and if a dropdown is open, into and through links in the dropdown. |
   * | _Space_ or _Enter_ | <ul><li>If focus is on a disclosure button, activates the button, which toggles the visibility of the dropdown.</li><li>If focus is on a link:<ul><li>If any link has aria-current set, removes it.</li><li>Sets aria-current="page" on the focused link.</li><li>Activates the focused link.</li></ul></li></ul> |
   * | _Escape_ | If a dropdown is open, closes it and sets focus on the button that controls that dropdown. |
   * | _Down Arrow_ or _Right Arrow_ (Optional}) | <ul><li>If focus is on a button and its dropdown is collapsed, and it is not the last button, moves focus to the next button.</li><li>if focus is on a button and its dropdown is expanded, moves focus to the first link in the dropdown.</li><li>If focus is on a link, and it is not the last link, moves focus to the next link.</li></ul> |
   * | _Up Arrow_ or _Left Arrow_ (Optional}) | <ul><li>If focus is on a button, and it is not the first button, moves focus to the previous button.</li><li>If focus is on a link, and it is not the first link, moves focus to the previous link.</li></ul> |
   * | _Home_ (Optional}) | <ul><li>If focus is on a button, and it is not the first button, moves focus to the first button.</li><li>If focus is on a link, and it is not the first link, moves focus to the first link.</li></ul> |
   * | _End_ (Optional}) | <ul><li>If focus is on a button, and it is not the last button, moves focus to the last button.</li><li>If focus is on a link, and it is not the last link, moves focus to the last link.</li></ul> |
   *
   * The optional keybindings are controlled by the menu's optionalKeySupport value.
   *
   * @protected
   */
  _handleKeyup() {
    super._handleKeyup(), this.dom.menu.addEventListener("keyup", (t) => {
      this.currentEvent = "keyboard";
      const s = _(t);
      this.focusState === "self" && (s === "Space" || s === "Enter" ? (o(t), this.currentMenuItem.isSubmenuItem ? this.currentMenuItem.elements.toggle.isOpen ? this.currentMenuItem.elements.toggle.close() : this.currentMenuItem.elements.toggle.preview() : this.currentMenuItem.dom.link.click()) : s === "Escape" ? this.elements.submenuToggles.some(
        (i) => i.isOpen
      ) ? (o(t), this.closeChildren()) : this.elements.parentMenu ? (o(t), this.elements.parentMenu.currentEvent = this.currentEvent, this.elements.parentMenu.closeChildren(), this.elements.parentMenu.focusCurrentChild()) : this.isTopLevel && this.elements.controller && this.elements.controller.isOpen && (this.elements.controller.close(), this.focusController()) : this.optionalKeySupport && (s === "ArrowDown" || s === "ArrowRight" ? (o(t), this.currentMenuItem.isSubmenuItem && this.currentMenuItem.elements.toggle.isOpen ? (this.currentMenuItem.elements.childMenu.currentEvent = "keyboard", this.currentMenuItem.elements.childMenu.focusFirstChild()) : this.focusNextChild()) : s === "ArrowUp" || s === "ArrowLeft" ? (o(t), this.focusPreviousChild()) : s === "Home" ? (o(t), this.focusFirstChild()) : s === "End" && (o(t), this.focusLastChild())));
    });
  }
}
class Y extends O {
  /**
   * Constructs a new `TreeviewItem`.
   *
   * @param {object}          options                         - The options for generating the menu item.
   * @param {HTMLElement}     options.menuItemElement         - The menu item in the DOM.
   * @param {HTMLElement}     options.menuLinkElement         - The menu item's link in the DOM.
   * @param {Treeview}        options.parentMenu              - The parent menu.
   * @param {boolean}         [options.isSubmenuItem = false] - A flag to mark if the menu item is controlling a submenu.
   * @param {?Treeview}       [options.childMenu = null]      - The child menu.
   * @param {?TreeviewToggle} [options.toggle = null]         - The controller for the child menu.
   * @param {boolean}         [options.initialize = true]     - A flag to initialize the menu item immediately upon creation.
   */
  constructor({
    menuItemElement: e,
    menuLinkElement: t,
    parentMenu: s,
    isSubmenuItem: n = !1,
    childMenu: i = null,
    toggle: l = null,
    initialize: h = !0
  }) {
    super({
      menuItemElement: e,
      menuLinkElement: t,
      parentMenu: s,
      isSubmenuItem: n,
      childMenu: i,
      toggle: l
    }), h && this.initialize();
  }
  /**
   * Initialize the menu item.
   *
   * Initialize will call the BaseMenuItem's initialize method
   * as well as set the menu item's `role` to "none",
   * the menu link's `role` to "treeitem", and
   * the menu link's `tabIndex` to -1 in the DOM.
   */
  initialize() {
    super.initialize(), this.dom.item.setAttribute("role", "none"), this.dom.link.setAttribute("role", "treeitem"), this.dom.link.tabIndex = -1;
  }
  /**
   * Focuses the menu item's link if the parent menu's
   * shouldFocus value is `true`.
   *
   * This will call the BaseMenuItem's focus method
   * as well as set the menu link's `tabIndex` to 0.
   */
  focus() {
    super.focus(), this.dom.link.tabIndex = 0;
  }
  /**
   * Blurs the menu item's link if the parent menu's
   * shouldFocus value is `true`.
   *
   * This will call the BaseMenuItem's blur method
   * as well as set the menu link's `tabIndex` to -1.
   */
  blur() {
    super.blur(), this.dom.link.tabIndex = -1;
  }
}
class ee extends L {
  /**
   * Constructs a new `TreeviewToggle`.
   *
   * @param {object}      options                     - The options for generating the menu toggle.
   * @param {HTMLElement} options.menuToggleElement   - The toggle element in the DOM.
   * @param {HTMLElement} options.parentElement       - The element containing the controlled menu.
   * @param {Treeview}    options.controlledMenu      - The menu controlled by this toggle.
   * @param {?Treeview}   [options.parentMenu = null] - The menu containing this toggle.
   * @param {boolean}     [options.initialize = true] - A flag to initialize the menu toggle immediately upon creation.
   */
  constructor({
    menuToggleElement: e,
    parentElement: t,
    controlledMenu: s,
    parentMenu: n = null,
    initialize: i = !0
  }) {
    super({
      menuToggleElement: e,
      parentElement: t,
      controlledMenu: s,
      parentMenu: n
    }), i && this.initialize();
  }
  /**
   * Initializes the menu toggle.
   *
   * The first steps are to ensure that the toggle and controlled menu have IDs
   * using the setIds method, and to set the ARIA attributes on the toggle
   * and controlled menu using the setAriaAttributes method.
   *
   * Then the open or collapse method is called based on the state of the
   * toggle's aria-expanded attribute.
   */
  initialize() {
    this._setIds(), this._setAriaAttributes(), this.dom.toggle.getAttribute("aria-expanded") === "true" ? this.open() : this._collapse(!1);
  }
  /**
   * Sets the ARIA attributes on the toggle and controlled menu.
   *
   * The first steps are to ensure that the toggle has `aria-expanded`
   * set to "false" if it's not already set explicitly to "true".
   *
   * Then using the toggle and menu's IDs, the menu's `aria-labelledby` is set to
   * the toggle's ID, and the toggle's `aria-owns` is set to the menu's ID.
   *
   * @protected
   */
  _setAriaAttributes() {
    this.dom.toggle.getAttribute("aria-expanded") !== "true" && this.dom.toggle.setAttribute("aria-expanded", "false"), this.elements.controlledMenu.dom.menu.setAttribute(
      "aria-labelledby",
      this.dom.toggle.id
    ), this.dom.toggle.setAttribute(
      "aria-owns",
      this.elements.controlledMenu.dom.menu.id
    );
  }
}
class j extends w {
  /**
   * Constructs a new `Treeview`.
   *
   * @param {object}             options                                    - The options for generating the menu.
   * @param {HTMLElement}        options.menuElement                        - The menu element in the DOM.
   * @param {string}             [options.menuItemSelector = li]            - The query selector string for menu items.
   * @param {string}             [options.menuLinkSelector = a]             - The query selector string for menu links.
   * @param {string}             [options.submenuItemSelector = li:has(ul)] - The query selector string for menu items containing submenus.
   * @param {string}             [options.submenuToggleSelector = a]        - The query selector string for submenu toggle buttons/links.
   * @param {string}             [options.submenuSelector = ul]             - The query selector string for submenus.
   * @param {?HTMLElement}       [options.controllerElement = null]         - The element controlling the menu in the DOM.
   * @param {?HTMLElement}       [options.containerElement = null]          - The element containing the menu in the DOM.
   * @param {?(string|string[])} [options.openClass = show]                 - The class to apply when a menu is "open".
   * @param {?(string|string[])} [options.closeClass = hide]                - The class to apply when a menu is "closed".
   * @param {?(string|string[])} [options.transitionClass = transitioning]  - The class to apply when a menu is transitioning between "open" and "closed" states.
   * @param {number}             [options.transitionDuration = 250]         - The duration of the transition between "open" and "closed" states (in milliseconds).
   * @param {boolean}            [options.isTopLevel = true]                - A flag to mark the root menu.
   * @param {?Treeview}          [options.parentMenu = null]                - The parent menu to this menu.
   * @param {string}             [options.hoverType = off]                  - The type of hoverability a menu has.
   * @param {number}             [options.hoverDelay = 250]                 - The delay for opening and closing menus if the menu is hoverable (in milliseconds).
   * @param {number}             [options.enterDelay = -1]                  - The delay for opening a menu if the menu is focusable (in milliseconds).
   * @param {number}             [options.leaveDelay = -1]                  - The delay for closing a menu if the menu is focusable (in milliseconds).
   * @param {?string}            [options.prefix = am-]                     - The prefix to use for CSS custom properties.
   * @param {boolean}            [options.initialize = true]                - A flag to initialize the menu immediately upon creation.
   */
  constructor({
    menuElement: t,
    menuItemSelector: s = "li",
    menuLinkSelector: n = "a",
    submenuItemSelector: i = "li:has(ul)",
    submenuToggleSelector: l = "a",
    submenuSelector: h = "ul",
    controllerElement: m = null,
    containerElement: a = null,
    openClass: p = "show",
    closeClass: f = "hide",
    transitionClass: g = "transitioning",
    transitionDuration: d = 250,
    isTopLevel: M = !0,
    parentMenu: y = null,
    hoverType: b = "off",
    hoverDelay: C = 250,
    enterDelay: T = -1,
    leaveDelay: E = -1,
    prefix: v = "am-",
    initialize: I = !0
  }) {
    super({
      menuElement: t,
      menuItemSelector: s,
      menuLinkSelector: n,
      submenuItemSelector: i,
      submenuToggleSelector: l,
      submenuSelector: h,
      controllerElement: m,
      containerElement: a,
      openClass: p,
      closeClass: f,
      transitionClass: g,
      transitionDuration: d,
      isTopLevel: M,
      parentMenu: y,
      hoverType: b,
      hoverDelay: C,
      enterDelay: T,
      leaveDelay: E,
      prefix: v
    });
    /**
     * The class to use when generating submenus.
     *
     * @protected
     *
     * @type {typeof Treeview}
     */
    u(this, "_MenuType", j);
    /**
     * The class to use when generating menu items.
     *
     * @protected
     *
     * @type {typeof TreeviewItem}
     */
    u(this, "_MenuItemType", Y);
    /**
     * The class to use when generating submenu toggles.
     *
     * @protected
     *
     * @type {typeof TreeviewToggle}
     */
    u(this, "_MenuToggleType", ee);
    I && this.initialize();
  }
  /**
   * Initializes the menu.
   *
   * Initialize will call the BaseMenu's initialize method
   * as well as set up focus,
   * click,
   * hover,
   * keydown, and
   * keyup events for the menu.
   *
   * If the menu is a root menu it's `role` will be set to "tree" and the first
   * menu item's `tabIndex` will be set to 0 in the DOM.
   *
   * If the menu is _not_ a root menu it's `role` will be set to "group".
   *
   * If the BaseMenu's initialize method throws an error,
   * this will catch it and log it to the console.
   */
  initialize() {
    try {
      super.initialize(), this.isTopLevel ? (this.dom.menu.setAttribute("role", "tree"), this.elements.menuItems[0].dom.link.tabIndex = 0) : this.dom.menu.setAttribute("role", "group"), this._handleFocus(), this._handleClick(), this._handleHover(), this._handleKeydown(), this._handleKeyup(), this.isTopLevel && this.elements.controller && this.elements.controller.dom.toggle.removeAttribute("aria-owns");
    } catch (t) {
      console.error(t);
    }
  }
  /**
   * Handles hover events throughout the menu for proper use.
   *
   * Adds `pointerenter` listeners to all menu items and `pointerleave` listeners
   * to all submenu items which function differently depending on
   * the menu's hover type.
   *
   * Before executing anything, the event is checked to make sure the event wasn't
   * triggered by a pen or touch.
   *
   * <strong>Hover Type "on"</strong>
   * - When a `pointerenter` event triggers on any menu item the menu's
   *    current child value will change to that
   *   menu item.
   * - When a `pointerenter` event triggers on a submenu item the
   *   preview method for the submenu item's
   *   toggle will be called.
   * - When a `pointerleave` event triggers on the menu itself the
   *   closeChildren method will be called after a delay
   *   set by the menu's hover delay.
   *
   * <strong>Hover Type "dynamic"</strong>
   * - When a `pointerenter` event triggers on any menu item the menu's
   *   current child value will change to that menu item.
   * - When a `pointerenter` event triggers on any menu item, and the menu's
   *   focus state is not "none", the menu item
   *   will be focused.
   * - When a `pointerenter` event triggers on a submenu item, and a submenu is
   *   already open, the preview method for the submenu item's toggle will be called.
   * - When a `pointerenter` event triggers on a non-submenu item, and a submenu
   *   is already open, the closeChildren method for the menu will be called.
   * - When a `pointerenter` event triggers on a submenu item, and no submenu is
   *   open, no submenu-specific methods will be called.
   *
   * <strong>Hover Type "off"</strong>
   * All `pointerenter` and `pointerleave` events are ignored.
   *
   * @protected
   */
  _handleHover() {
    this.elements.menuItems.forEach((t, s) => {
      t.dom.link.addEventListener("pointerenter", (n) => {
        n.pointerType === "pen" || n.pointerType === "touch" || (this.hoverType === "on" ? (this.currentEvent = "mouse", this.elements.rootMenu.blurChildren(), this.focusChild(s), t.isSubmenuItem && (this.enterDelay > 0 ? (this._clearTimeout(), this._setTimeout(() => {
          t.elements.toggle.preview();
        }, this.enterDelay)) : t.elements.toggle.preview())) : this.hoverType === "dynamic" && (this.currentChild = s, (!this.isTopLevel || this.focusState !== "none") && (this.currentEvent = "mouse", this.elements.rootMenu.blurChildren(), this.focusCurrentChild()), (!this.isTopLevel || this.hasOpened) && (this.currentEvent = "mouse", this.elements.rootMenu.blurChildren(), this.focusCurrentChild(), t.isSubmenuItem ? this.enterDelay > 0 ? (this._clearTimeout(), this._setTimeout(() => {
          t.elements.toggle.preview();
        }, this.enterDelay)) : t.elements.toggle.preview() : this.enterDelay > 0 && this._clearTimeout())));
      }), t.isSubmenuItem && (t.dom.item.addEventListener("pointerleave", (n) => {
        n.pointerType === "pen" || n.pointerType === "touch" || (this.hoverType === "on" ? this.leaveDelay > 0 && this._clearTimeout() : this.hoverType === "dynamic" && (this.leaveDelay > 0 ? (this._clearTimeout(), this._setTimeout(() => {
          this.currentEvent = "mouse";
        }, this.leaveDelay)) : this.currentEvent = "mouse"));
      }), t.dom.item.addEventListener("pointerenter", (n) => {
        n.pointerType === "pen" || n.pointerType === "touch" || t.isSubmenuItem && (this.hoverType === "on" || this.hoverType === "dynamic") && this.leaveDelay > 0 && this._clearTimeout();
      })), this.isTopLevel && this.dom.menu.addEventListener("pointerleave", (n) => {
        n.pointerType === "pen" || n.pointerType === "touch" || this.hoverType === "on" && (this.leaveDelay > 0 ? (this._clearTimeout(), this._setTimeout(() => {
          this.closeChildren(), this.blur();
        }, this.leaveDelay)) : (this.closeChildren(), this.blur()));
      });
    });
  }
  /**
   * Handles keydown events throughout the menu for proper menu use.
   *
   * This method exists to assist the _handleKeyup method.
   * - Adds all `keydown` listeners from BaseMenu's _handleKeydown method
   * - Adds a `keydown` listener to the menu/all submenus.
   *   - Blocks propagation on the following keys: "ArrowUp", "ArrowRight",
   *     "ArrowDown", "ArrowLeft", "Home", "End", "Space", "Enter", "Escape",
   *     "*" (asterisk), and "A" through "Z".
   *   - Moves focus out if the "Tab" key is pressed.
   *
   * @protected
   */
  _handleKeydown() {
    super._handleKeydown(), this.dom.menu.addEventListener("keydown", (t) => {
      this.currentEvent = "keyboard";
      const s = _(t);
      if (s === "Tab" && (this.elements.rootMenu.focusState !== "none" ? this.elements.rootMenu.blur() : this.elements.rootMenu.focus()), this.focusState === "self") {
        const n = [
          "Space",
          "Enter",
          "ArrowUp",
          "ArrowDown",
          "ArrowLeft",
          "Asterisk",
          "Home",
          "End"
        ], i = ["ArrowRight"], l = ["Escape"];
        (n.includes(s) || this.currentMenuItem.isSubmenuItem && i.includes(s) || this.elements.controller && l.includes(s)) && o(t);
      }
    });
  }
  /**
   * Handles keyup events throughout the menu for proper menu use.
   *
   * Adds all `keyup` listeners from BaseMenu's _handleKeyup method.
   *
   * Adds the following keybindings (explanations are taken from the
   * Navigation Treeview Example Using Computed Properties):
   *
   * | Key | Function |
   * | --- | --- |
   * | _Enter_ or _Space_ | Performs the default action (e.g. onclick event) for the focused node. |
   * | _Down arrow_ | <ul><li>Moves focus to the next node that is focusable without opening or closing a node.</li><li>If focus is on the last node, does nothing.</li></ul> |
   * | _Up arrow_ | <ul><li>Moves focus to the previous node that is focusable without opening or closing a node.</li><li>If focus is on the first node, does nothing.</li></ul> |
   * | _Right arrow_ | <ul><li>When focus is on a closed node, opens the node; focus does not move.</li><li>When focus is on a open node, moves focus to the first child node.</li><li>When focus is on an end node, does nothing.</li></ul> |
   * | _Left arrow_ | <ul><li>When focus is on an open node, closes the node.</li><li>When focus is on a child node that is also either an end node or a closed node, moves focus to its parent node.</li><li>When focus is on a root node that is also either an end node or a closed node, does nothing.</li></ul> |
   * | _Home_ | Moves focus to first node without opening or closing a node. |
   * | _End_ | Moves focus to the last node that can be focused without expanding any nodes that are closed. |
   * | _a-z_, _A-Z_ | <ul><li>Focus moves to the next node with a name that starts with the typed character.</li><li>Search wraps to first node if a matching name is not found among the nodes that follow the focused node.</li><li>Search ignores nodes that are descendants of closed nodes.</li></ul> |
   * | _* (asterisk)_ | <ul><li>Expands all closed sibling nodes that are at the same level as the focused node.</li><li>Focus does not move.</li></ul> |
   * | _Escape_ | If the root menu is collapsible, collapses the menu and focuses the menu's controlling element. |
   *
   * @protected
   */
  _handleKeyup() {
    super._handleKeyup(), this.dom.menu.addEventListener("keyup", (t) => {
      this.currentEvent = "keyboard";
      const s = _(t), { altKey: n, crtlKey: i, metaKey: l } = t;
      if (s === "Character" && !(n || i || l))
        o(t), this.elements.rootMenu.currentEvent = "character", this.focusNextNodeWithCharacter(t.key);
      else if (this.focusState === "self")
        if (s === "Enter" || s === "Space")
          o(t), this.currentMenuItem.isSubmenuItem ? this.currentMenuItem.elements.toggle.isOpen ? this.currentMenuItem.elements.toggle.close() : this.currentMenuItem.elements.toggle.preview() : this.currentMenuItem.dom.link.click();
        else if (s === "Escape")
          this.isTopLevel && this.elements.controller && this.elements.controller.isOpen && (this.elements.controller.close(), this.focusController());
        else if (s === "ArrowDown")
          o(t), this.currentMenuItem.isSubmenuItem && this.currentMenuItem.elements.toggle.isOpen ? (this.blurCurrentChild(), this.currentMenuItem.elements.childMenu.currentEvent = this.currentEvent, this.currentMenuItem.elements.childMenu.focusFirstChild()) : !this.isTopLevel && this.currentChild === this.elements.menuItems.length - 1 ? this.focusParentsNextChild() : this.focusNextChild();
        else if (s === "ArrowUp") {
          o(t);
          const m = this.elements.menuItems[this.currentChild - 1];
          m && m.isSubmenuItem && m.elements.toggle.isOpen ? (this.blurCurrentChild(), this.currentChild = this.currentChild - 1, this.currentMenuItem.elements.childMenu.currentEvent = this.currentEvent, this.focusChildsLastNode()) : !this.isTopLevel && this.currentChild === 0 ? (this.blurCurrentChild(), this.elements.parentMenu.currentEvent = this.currentEvent, this.elements.parentMenu.focusCurrentChild()) : this.focusPreviousChild();
        } else s === "ArrowRight" ? this.currentMenuItem.isSubmenuItem && (o(t), this.currentMenuItem.elements.toggle.isOpen ? (this.blurCurrentChild(), this.currentMenuItem.elements.childMenu.currentEvent = this.currentEvent, this.currentMenuItem.elements.childMenu.focusFirstChild()) : this.currentMenuItem.elements.toggle.preview()) : s === "ArrowLeft" ? (o(t), this.currentMenuItem.isSubmenuItem && this.currentMenuItem.elements.toggle.isOpen ? (this.currentMenuItem.elements.childMenu.blurCurrentChild(), this.currentMenuItem.elements.toggle.close()) : this.isTopLevel || (this.blurCurrentChild(), this.elements.parentMenu.currentEvent = this.currentEvent, this.elements.parentMenu.focusCurrentChild())) : s === "Home" ? (o(t), this.blurCurrentChild(), this.elements.rootMenu.focusFirstChild()) : s === "End" ? (o(t), this.blurCurrentChild(), this.elements.rootMenu.focusLastNode()) : s === "Asterisk" && (o(t), this.openChildren());
    });
  }
  /**
   * Focus the menu's last node of the entire expanded menu.
   *
   * This includes all _open_ child menu items.
   *
   * @public
   */
  focusLastNode() {
    const t = this.elements.menuItems.length - 1, s = this.elements.menuItems[t];
    s.isSubmenuItem && s.elements.toggle.isOpen ? (this.currentChild = t, s.elements.childMenu.currentEvent = this.currentEvent, s.elements.childMenu.focusLastNode()) : this.focusLastChild();
  }
  /**
   * Open all submenu children.
   *
   * @public
   */
  openChildren() {
    this.elements.submenuToggles.forEach((t) => t.preview());
  }
  /**
   * Focus the menu's next node starting with a specific letter.
   *
   * This includes all _open_ child menu items.
   *
   * Wraps to the first node if no match is found after the current node.
   *
   * @public
   *
   * @param {string} char - The character to look for.
   */
  focusNextNodeWithCharacter(t) {
    function s(p) {
      let f = [];
      return p.elements.menuItems.forEach((g) => {
        f.push(g), g.isSubmenuItem && g.elements.toggle.isOpen && (f = [
          ...f,
          ...s(
            g.elements.toggle.elements.controlledMenu
          )
        ]);
      }), f;
    }
    const n = t.toLowerCase(), i = s(this.elements.rootMenu), l = i.indexOf(this.currentMenuItem) + 1, h = [
      ...i.slice(l),
      ...i.slice(0, l)
    ];
    let m = 0, a = !1;
    for (; !a && m < h.length; ) {
      let p = "";
      if (h[m].dom.item.innerText ? p = h[m].dom.item.innerText : p = h[m].dom.item.textContent, p = p.replace(/[\s]/g, "").toLowerCase().charAt(0), p === n) {
        a = !0;
        const f = h[m].elements.parentMenu, g = f.elements.menuItems.indexOf(h[m]);
        this.elements.rootMenu.blurChildren(), f.focusChild(g);
      }
      m++;
    }
  }
  /**
   * Focus the parent menu's next child.
   *
   * This will cascade up through to the root menu.
   *
   * @public
   */
  focusParentsNextChild() {
    this.elements.parentMenu && (this.elements.parentMenu.currentEvent = this.currentEvent, this.elements.parentMenu.currentChild === this.elements.parentMenu.elements.menuItems.length - 1 ? (this.elements.parentMenu.blurCurrentChild(), this.elements.parentMenu.focusParentsNextChild()) : (this.blurChildren(), this.elements.parentMenu.focusNextChild()));
  }
  /**
   * Focus the last child of the current child's submenu.
   *
   * This will cascade down through to the last open menu.
   *
   * @public
   */
  focusChildsLastNode() {
    this.currentMenuItem.elements.childMenu.currentEvent = this.currentEvent, this.currentMenuItem.elements.childMenu.focusLastChild(), this.currentMenuItem.elements.childMenu.currentMenuItem.isSubmenuItem && this.currentMenuItem.elements.childMenu.currentMenuItem.elements.toggle.isOpen && (this.currentMenuItem.elements.childMenu.blurCurrentChild(), this.currentMenuItem.elements.childMenu.focusChildsLastNode());
  }
}
const se = {
  DisclosureMenu: z,
  Menubar: H,
  TopLinkDisclosureMenu: q,
  Treeview: j
};



/***/ }),

/***/ "./node_modules/focus-trap/dist/focus-trap.esm.js":
/*!********************************************************!*\
  !*** ./node_modules/focus-trap/dist/focus-trap.esm.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createFocusTrap: function() { return /* binding */ createFocusTrap; }
/* harmony export */ });
/* harmony import */ var tabbable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tabbable */ "./node_modules/tabbable/dist/index.esm.js");
/*!
* focus-trap 7.6.5
* @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
*/


function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
function _arrayWithoutHoles(r) {
  if (Array.isArray(r)) return _arrayLikeToArray(r);
}
function _defineProperty(e, r, t) {
  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
    value: t,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e[r] = t, e;
}
function _iterableToArray(r) {
  if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function (r) {
      return Object.getOwnPropertyDescriptor(e, r).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), true).forEach(function (r) {
      _defineProperty(e, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return e;
}
function _toConsumableArray(r) {
  return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
}
function _toPrimitive(t, r) {
  if ("object" != typeof t || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r);
    if ("object" != typeof i) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == typeof i ? i : i + "";
}
function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
  }
}

var activeFocusTraps = {
  activateTrap: function activateTrap(trapStack, trap) {
    if (trapStack.length > 0) {
      var activeTrap = trapStack[trapStack.length - 1];
      if (activeTrap !== trap) {
        activeTrap._setPausedState(true);
      }
    }
    var trapIndex = trapStack.indexOf(trap);
    if (trapIndex === -1) {
      trapStack.push(trap);
    } else {
      // move this existing trap to the front of the queue
      trapStack.splice(trapIndex, 1);
      trapStack.push(trap);
    }
  },
  deactivateTrap: function deactivateTrap(trapStack, trap) {
    var trapIndex = trapStack.indexOf(trap);
    if (trapIndex !== -1) {
      trapStack.splice(trapIndex, 1);
    }
    if (trapStack.length > 0 && !trapStack[trapStack.length - 1]._isManuallyPaused()) {
      trapStack[trapStack.length - 1]._setPausedState(false);
    }
  }
};
var isSelectableInput = function isSelectableInput(node) {
  return node.tagName && node.tagName.toLowerCase() === 'input' && typeof node.select === 'function';
};
var isEscapeEvent = function isEscapeEvent(e) {
  return (e === null || e === void 0 ? void 0 : e.key) === 'Escape' || (e === null || e === void 0 ? void 0 : e.key) === 'Esc' || (e === null || e === void 0 ? void 0 : e.keyCode) === 27;
};
var isTabEvent = function isTabEvent(e) {
  return (e === null || e === void 0 ? void 0 : e.key) === 'Tab' || (e === null || e === void 0 ? void 0 : e.keyCode) === 9;
};

// checks for TAB by default
var isKeyForward = function isKeyForward(e) {
  return isTabEvent(e) && !e.shiftKey;
};

// checks for SHIFT+TAB by default
var isKeyBackward = function isKeyBackward(e) {
  return isTabEvent(e) && e.shiftKey;
};
var delay = function delay(fn) {
  return setTimeout(fn, 0);
};

/**
 * Get an option's value when it could be a plain value, or a handler that provides
 *  the value.
 * @param {*} value Option's value to check.
 * @param {...*} [params] Any parameters to pass to the handler, if `value` is a function.
 * @returns {*} The `value`, or the handler's returned value.
 */
var valueOrHandler = function valueOrHandler(value) {
  for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    params[_key - 1] = arguments[_key];
  }
  return typeof value === 'function' ? value.apply(void 0, params) : value;
};
var getActualTarget = function getActualTarget(event) {
  // NOTE: If the trap is _inside_ a shadow DOM, event.target will always be the
  //  shadow host. However, event.target.composedPath() will be an array of
  //  nodes "clicked" from inner-most (the actual element inside the shadow) to
  //  outer-most (the host HTML document). If we have access to composedPath(),
  //  then use its first element; otherwise, fall back to event.target (and
  //  this only works for an _open_ shadow DOM; otherwise,
  //  composedPath()[0] === event.target always).
  return event.target.shadowRoot && typeof event.composedPath === 'function' ? event.composedPath()[0] : event.target;
};

// NOTE: this must be _outside_ `createFocusTrap()` to make sure all traps in this
//  current instance use the same stack if `userOptions.trapStack` isn't specified
var internalTrapStack = [];
var createFocusTrap = function createFocusTrap(elements, userOptions) {
  // SSR: a live trap shouldn't be created in this type of environment so this
  //  should be safe code to execute if the `document` option isn't specified
  var doc = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;
  var trapStack = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.trapStack) || internalTrapStack;
  var config = _objectSpread2({
    returnFocusOnDeactivate: true,
    escapeDeactivates: true,
    delayInitialFocus: true,
    isKeyForward: isKeyForward,
    isKeyBackward: isKeyBackward
  }, userOptions);
  var state = {
    // containers given to createFocusTrap()
    // @type {Array<HTMLElement>}
    containers: [],
    // list of objects identifying tabbable nodes in `containers` in the trap
    // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap
    //  is active, but the trap should never get to a state where there isn't at least one group
    //  with at least one tabbable node in it (that would lead to an error condition that would
    //  result in an error being thrown)
    // @type {Array<{
    //   container: HTMLElement,
    //   tabbableNodes: Array<HTMLElement>, // empty if none
    //   focusableNodes: Array<HTMLElement>, // empty if none
    //   posTabIndexesFound: boolean,
    //   firstTabbableNode: HTMLElement|undefined,
    //   lastTabbableNode: HTMLElement|undefined,
    //   firstDomTabbableNode: HTMLElement|undefined,
    //   lastDomTabbableNode: HTMLElement|undefined,
    //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined
    // }>}
    containerGroups: [],
    // same order/length as `containers` list

    // references to objects in `containerGroups`, but only those that actually have
    //  tabbable nodes in them
    // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__
    //  the same length
    tabbableGroups: [],
    nodeFocusedBeforeActivation: null,
    mostRecentlyFocusedNode: null,
    active: false,
    paused: false,
    manuallyPaused: false,
    // timer ID for when delayInitialFocus is true and initial focus in this trap
    //  has been delayed during activation
    delayInitialFocusTimer: undefined,
    // the most recent KeyboardEvent for the configured nav key (typically [SHIFT+]TAB), if any
    recentNavEvent: undefined
  };
  var trap; // eslint-disable-line prefer-const -- some private functions reference it, and its methods reference private functions, so we must declare here and define later

  /**
   * Gets a configuration option value.
   * @param {Object|undefined} configOverrideOptions If true, and option is defined in this set,
   *  value will be taken from this object. Otherwise, value will be taken from base configuration.
   * @param {string} optionName Name of the option whose value is sought.
   * @param {string|undefined} [configOptionName] Name of option to use __instead of__ `optionName`
   *  IIF `configOverrideOptions` is not defined. Otherwise, `optionName` is used.
   */
  var getOption = function getOption(configOverrideOptions, optionName, configOptionName) {
    return configOverrideOptions && configOverrideOptions[optionName] !== undefined ? configOverrideOptions[optionName] : config[configOptionName || optionName];
  };

  /**
   * Finds the index of the container that contains the element.
   * @param {HTMLElement} element
   * @param {Event} [event] If available, and `element` isn't directly found in any container,
   *  the event's composed path is used to see if includes any known trap containers in the
   *  case where the element is inside a Shadow DOM.
   * @returns {number} Index of the container in either `state.containers` or
   *  `state.containerGroups` (the order/length of these lists are the same); -1
   *  if the element isn't found.
   */
  var findContainerIndex = function findContainerIndex(element, event) {
    var composedPath = typeof (event === null || event === void 0 ? void 0 : event.composedPath) === 'function' ? event.composedPath() : undefined;
    // NOTE: search `containerGroups` because it's possible a group contains no tabbable
    //  nodes, but still contains focusable nodes (e.g. if they all have `tabindex=-1`)
    //  and we still need to find the element in there
    return state.containerGroups.findIndex(function (_ref) {
      var container = _ref.container,
        tabbableNodes = _ref.tabbableNodes;
      return container.contains(element) || (// fall back to explicit tabbable search which will take into consideration any
      //  web components if the `tabbableOptions.getShadowRoot` option was used for
      //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't
      //  look inside web components even if open)
      composedPath === null || composedPath === void 0 ? void 0 : composedPath.includes(container)) || tabbableNodes.find(function (node) {
        return node === element;
      });
    });
  };

  /**
   * Gets the node for the given option, which is expected to be an option that
   *  can be either a DOM node, a string that is a selector to get a node, `false`
   *  (if a node is explicitly NOT given), or a function that returns any of these
   *  values.
   * @param {string} optionName
   * @param {Object} options
   * @param {boolean} [options.hasFallback] True if the option could be a selector string
   *  and the option allows for a fallback scenario in the case where the selector is
   *  valid but does not match a node (i.e. the queried node doesn't exist in the DOM).
   * @param {Array} [options.params] Params to pass to the option if it's a function.
   * @returns {undefined | null | false | HTMLElement | SVGElement} Returns
   *  `undefined` if the option is not specified; `null` if the option didn't resolve
   *  to a node but `options.hasFallback=true`, `false` if the option resolved to `false`
   *  (node explicitly not given); otherwise, the resolved DOM node.
   * @throws {Error} If the option is set, not `false`, and is not, or does not
   *  resolve to a node, unless the option is a selector string and `options.hasFallback=true`.
   */
  var getNodeForOption = function getNodeForOption(optionName) {
    var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref2$hasFallback = _ref2.hasFallback,
      hasFallback = _ref2$hasFallback === void 0 ? false : _ref2$hasFallback,
      _ref2$params = _ref2.params,
      params = _ref2$params === void 0 ? [] : _ref2$params;
    var optionValue = config[optionName];
    if (typeof optionValue === 'function') {
      optionValue = optionValue.apply(void 0, _toConsumableArray(params));
    }
    if (optionValue === true) {
      optionValue = undefined; // use default value
    }
    if (!optionValue) {
      if (optionValue === undefined || optionValue === false) {
        return optionValue;
      }
      // else, empty string (invalid), null (invalid), 0 (invalid)

      throw new Error("`".concat(optionName, "` was specified but was not a node, or did not return a node"));
    }
    var node = optionValue; // could be HTMLElement, SVGElement, or non-empty string at this point

    if (typeof optionValue === 'string') {
      try {
        node = doc.querySelector(optionValue); // resolve to node, or null if fails
      } catch (err) {
        throw new Error("`".concat(optionName, "` appears to be an invalid selector; error=\"").concat(err.message, "\""));
      }
      if (!node) {
        if (!hasFallback) {
          throw new Error("`".concat(optionName, "` as selector refers to no known node"));
        }
        // else, `node` MUST be `null` because that's what `Document.querySelector()` returns
        //  if the selector is valid but doesn't match anything
      }
    }
    return node;
  };
  var getInitialFocusNode = function getInitialFocusNode() {
    var node = getNodeForOption('initialFocus', {
      hasFallback: true
    });

    // false explicitly indicates we want no initialFocus at all
    if (node === false) {
      return false;
    }
    if (node === undefined || node && !(0,tabbable__WEBPACK_IMPORTED_MODULE_0__.isFocusable)(node, config.tabbableOptions)) {
      // option not specified nor focusable: use fallback options
      if (findContainerIndex(doc.activeElement) >= 0) {
        node = doc.activeElement;
      } else {
        var firstTabbableGroup = state.tabbableGroups[0];
        var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;

        // NOTE: `fallbackFocus` option function cannot return `false` (not supported)
        node = firstTabbableNode || getNodeForOption('fallbackFocus');
      }
    } else if (node === null) {
      // option is a VALID selector string that doesn't yield a node: use the `fallbackFocus`
      //  option instead of the default behavior when the option isn't specified at all
      node = getNodeForOption('fallbackFocus');
    }
    if (!node) {
      throw new Error('Your focus-trap needs to have at least one focusable element');
    }
    return node;
  };
  var updateTabbableNodes = function updateTabbableNodes() {
    state.containerGroups = state.containers.map(function (container) {
      var tabbableNodes = (0,tabbable__WEBPACK_IMPORTED_MODULE_0__.tabbable)(container, config.tabbableOptions);

      // NOTE: if we have tabbable nodes, we must have focusable nodes; focusable nodes
      //  are a superset of tabbable nodes since nodes with negative `tabindex` attributes
      //  are focusable but not tabbable
      var focusableNodes = (0,tabbable__WEBPACK_IMPORTED_MODULE_0__.focusable)(container, config.tabbableOptions);
      var firstTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[0] : undefined;
      var lastTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : undefined;
      var firstDomTabbableNode = focusableNodes.find(function (node) {
        return (0,tabbable__WEBPACK_IMPORTED_MODULE_0__.isTabbable)(node);
      });
      var lastDomTabbableNode = focusableNodes.slice().reverse().find(function (node) {
        return (0,tabbable__WEBPACK_IMPORTED_MODULE_0__.isTabbable)(node);
      });
      var posTabIndexesFound = !!tabbableNodes.find(function (node) {
        return (0,tabbable__WEBPACK_IMPORTED_MODULE_0__.getTabIndex)(node) > 0;
      });
      return {
        container: container,
        tabbableNodes: tabbableNodes,
        focusableNodes: focusableNodes,
        /** True if at least one node with positive `tabindex` was found in this container. */
        posTabIndexesFound: posTabIndexesFound,
        /** First tabbable node in container, __tabindex__ order; `undefined` if none. */
        firstTabbableNode: firstTabbableNode,
        /** Last tabbable node in container, __tabindex__ order; `undefined` if none. */
        lastTabbableNode: lastTabbableNode,
        // NOTE: DOM order is NOT NECESSARILY "document position" order, but figuring that out
        //  would require more than just https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition
        //  because that API doesn't work with Shadow DOM as well as it should (@see
        //  https://github.com/whatwg/dom/issues/320) and since this first/last is only needed, so far,
        //  to address an edge case related to positive tabindex support, this seems like a much easier,
        //  "close enough most of the time" alternative for positive tabindexes which should generally
        //  be avoided anyway...
        /** First tabbable node in container, __DOM__ order; `undefined` if none. */
        firstDomTabbableNode: firstDomTabbableNode,
        /** Last tabbable node in container, __DOM__ order; `undefined` if none. */
        lastDomTabbableNode: lastDomTabbableNode,
        /**
         * Finds the __tabbable__ node that follows the given node in the specified direction,
         *  in this container, if any.
         * @param {HTMLElement} node
         * @param {boolean} [forward] True if going in forward tab order; false if going
         *  in reverse.
         * @returns {HTMLElement|undefined} The next tabbable node, if any.
         */
        nextTabbableNode: function nextTabbableNode(node) {
          var forward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
          var nodeIdx = tabbableNodes.indexOf(node);
          if (nodeIdx < 0) {
            // either not tabbable nor focusable, or was focused but not tabbable (negative tabindex):
            //  since `node` should at least have been focusable, we assume that's the case and mimic
            //  what browsers do, which is set focus to the next node in __document position order__,
            //  regardless of positive tabindexes, if any -- and for reasons explained in the NOTE
            //  above related to `firstDomTabbable` and `lastDomTabbable` properties, we fall back to
            //  basic DOM order
            if (forward) {
              return focusableNodes.slice(focusableNodes.indexOf(node) + 1).find(function (el) {
                return (0,tabbable__WEBPACK_IMPORTED_MODULE_0__.isTabbable)(el);
              });
            }
            return focusableNodes.slice(0, focusableNodes.indexOf(node)).reverse().find(function (el) {
              return (0,tabbable__WEBPACK_IMPORTED_MODULE_0__.isTabbable)(el);
            });
          }
          return tabbableNodes[nodeIdx + (forward ? 1 : -1)];
        }
      };
    });
    state.tabbableGroups = state.containerGroups.filter(function (group) {
      return group.tabbableNodes.length > 0;
    });

    // throw if no groups have tabbable nodes and we don't have a fallback focus node either
    if (state.tabbableGroups.length <= 0 && !getNodeForOption('fallbackFocus') // returning false not supported for this option
    ) {
      throw new Error('Your focus-trap must have at least one container with at least one tabbable node in it at all times');
    }

    // NOTE: Positive tabindexes are only properly supported in single-container traps because
    //  doing it across multiple containers where tabindexes could be all over the place
    //  would require Tabbable to support multiple containers, would require additional
    //  specialized Shadow DOM support, and would require Tabbable's multi-container support
    //  to look at those containers in document position order rather than user-provided
    //  order (as they are treated in Focus-trap, for legacy reasons). See discussion on
    //  https://github.com/focus-trap/focus-trap/issues/375 for more details.
    if (state.containerGroups.find(function (g) {
      return g.posTabIndexesFound;
    }) && state.containerGroups.length > 1) {
      throw new Error("At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.");
    }
  };

  /**
   * Gets the current activeElement. If it's a web-component and has open shadow-root
   * it will recursively search inside shadow roots for the "true" activeElement.
   *
   * @param {Document | ShadowRoot} el
   *
   * @returns {HTMLElement} The element that currently has the focus
   **/
  var _getActiveElement = function getActiveElement(el) {
    var activeElement = el.activeElement;
    if (!activeElement) {
      return;
    }
    if (activeElement.shadowRoot && activeElement.shadowRoot.activeElement !== null) {
      return _getActiveElement(activeElement.shadowRoot);
    }
    return activeElement;
  };
  var _tryFocus = function tryFocus(node) {
    if (node === false) {
      return;
    }
    if (node === _getActiveElement(document)) {
      return;
    }
    if (!node || !node.focus) {
      _tryFocus(getInitialFocusNode());
      return;
    }
    node.focus({
      preventScroll: !!config.preventScroll
    });
    // NOTE: focus() API does not trigger focusIn event so set MRU node manually
    state.mostRecentlyFocusedNode = node;
    if (isSelectableInput(node)) {
      node.select();
    }
  };
  var getReturnFocusNode = function getReturnFocusNode(previousActiveElement) {
    var node = getNodeForOption('setReturnFocus', {
      params: [previousActiveElement]
    });
    return node ? node : node === false ? false : previousActiveElement;
  };

  /**
   * Finds the next node (in either direction) where focus should move according to a
   *  keyboard focus-in event.
   * @param {Object} params
   * @param {Node} [params.target] Known target __from which__ to navigate, if any.
   * @param {KeyboardEvent|FocusEvent} [params.event] Event to use if `target` isn't known (event
   *  will be used to determine the `target`). Ignored if `target` is specified.
   * @param {boolean} [params.isBackward] True if focus should move backward.
   * @returns {Node|undefined} The next node, or `undefined` if a next node couldn't be
   *  determined given the current state of the trap.
   */
  var findNextNavNode = function findNextNavNode(_ref3) {
    var target = _ref3.target,
      event = _ref3.event,
      _ref3$isBackward = _ref3.isBackward,
      isBackward = _ref3$isBackward === void 0 ? false : _ref3$isBackward;
    target = target || getActualTarget(event);
    updateTabbableNodes();
    var destinationNode = null;
    if (state.tabbableGroups.length > 0) {
      // make sure the target is actually contained in a group
      // NOTE: the target may also be the container itself if it's focusable
      //  with tabIndex='-1' and was given initial focus
      var containerIndex = findContainerIndex(target, event);
      var containerGroup = containerIndex >= 0 ? state.containerGroups[containerIndex] : undefined;
      if (containerIndex < 0) {
        // target not found in any group: quite possible focus has escaped the trap,
        //  so bring it back into...
        if (isBackward) {
          // ...the last node in the last group
          destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;
        } else {
          // ...the first node in the first group
          destinationNode = state.tabbableGroups[0].firstTabbableNode;
        }
      } else if (isBackward) {
        // REVERSE

        // is the target the first tabbable node in a group?
        var startOfGroupIndex = state.tabbableGroups.findIndex(function (_ref4) {
          var firstTabbableNode = _ref4.firstTabbableNode;
          return target === firstTabbableNode;
        });
        if (startOfGroupIndex < 0 && (containerGroup.container === target || (0,tabbable__WEBPACK_IMPORTED_MODULE_0__.isFocusable)(target, config.tabbableOptions) && !(0,tabbable__WEBPACK_IMPORTED_MODULE_0__.isTabbable)(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {
          // an exception case where the target is either the container itself, or
          //  a non-tabbable node that was given focus (i.e. tabindex is negative
          //  and user clicked on it or node was programmatically given focus)
          //  and is not followed by any other tabbable node, in which
          //  case, we should handle shift+tab as if focus were on the container's
          //  first tabbable node, and go to the last tabbable node of the LAST group
          startOfGroupIndex = containerIndex;
        }
        if (startOfGroupIndex >= 0) {
          // YES: then shift+tab should go to the last tabbable node in the
          //  previous group (and wrap around to the last tabbable node of
          //  the LAST group if it's the first tabbable node of the FIRST group)
          var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;
          var destinationGroup = state.tabbableGroups[destinationGroupIndex];
          destinationNode = (0,tabbable__WEBPACK_IMPORTED_MODULE_0__.getTabIndex)(target) >= 0 ? destinationGroup.lastTabbableNode : destinationGroup.lastDomTabbableNode;
        } else if (!isTabEvent(event)) {
          // user must have customized the nav keys so we have to move focus manually _within_
          //  the active group: do this based on the order determined by tabbable()
          destinationNode = containerGroup.nextTabbableNode(target, false);
        }
      } else {
        // FORWARD

        // is the target the last tabbable node in a group?
        var lastOfGroupIndex = state.tabbableGroups.findIndex(function (_ref5) {
          var lastTabbableNode = _ref5.lastTabbableNode;
          return target === lastTabbableNode;
        });
        if (lastOfGroupIndex < 0 && (containerGroup.container === target || (0,tabbable__WEBPACK_IMPORTED_MODULE_0__.isFocusable)(target, config.tabbableOptions) && !(0,tabbable__WEBPACK_IMPORTED_MODULE_0__.isTabbable)(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {
          // an exception case where the target is the container itself, or
          //  a non-tabbable node that was given focus (i.e. tabindex is negative
          //  and user clicked on it or node was programmatically given focus)
          //  and is not followed by any other tabbable node, in which
          //  case, we should handle tab as if focus were on the container's
          //  last tabbable node, and go to the first tabbable node of the FIRST group
          lastOfGroupIndex = containerIndex;
        }
        if (lastOfGroupIndex >= 0) {
          // YES: then tab should go to the first tabbable node in the next
          //  group (and wrap around to the first tabbable node of the FIRST
          //  group if it's the last tabbable node of the LAST group)
          var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;
          var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];
          destinationNode = (0,tabbable__WEBPACK_IMPORTED_MODULE_0__.getTabIndex)(target) >= 0 ? _destinationGroup.firstTabbableNode : _destinationGroup.firstDomTabbableNode;
        } else if (!isTabEvent(event)) {
          // user must have customized the nav keys so we have to move focus manually _within_
          //  the active group: do this based on the order determined by tabbable()
          destinationNode = containerGroup.nextTabbableNode(target);
        }
      }
    } else {
      // no groups available
      // NOTE: the fallbackFocus option does not support returning false to opt-out
      destinationNode = getNodeForOption('fallbackFocus');
    }
    return destinationNode;
  };

  // This needs to be done on mousedown and touchstart instead of click
  // so that it precedes the focus event.
  var checkPointerDown = function checkPointerDown(e) {
    var target = getActualTarget(e);
    if (findContainerIndex(target, e) >= 0) {
      // allow the click since it ocurred inside the trap
      return;
    }
    if (valueOrHandler(config.clickOutsideDeactivates, e)) {
      // immediately deactivate the trap
      trap.deactivate({
        // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,
        //  which will result in the outside click setting focus to the node
        //  that was clicked (and if not focusable, to "nothing"); by setting
        //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused
        //  on activation (or the configured `setReturnFocus` node), whether the
        //  outside click was on a focusable node or not
        returnFocus: config.returnFocusOnDeactivate
      });
      return;
    }

    // This is needed for mobile devices.
    // (If we'll only let `click` events through,
    // then on mobile they will be blocked anyways if `touchstart` is blocked.)
    if (valueOrHandler(config.allowOutsideClick, e)) {
      // allow the click outside the trap to take place
      return;
    }

    // otherwise, prevent the click
    e.preventDefault();
  };

  // In case focus escapes the trap for some strange reason, pull it back in.
  // NOTE: the focusIn event is NOT cancelable, so if focus escapes, it may cause unexpected
  //  scrolling if the node that got focused was out of view; there's nothing we can do to
  //  prevent that from happening by the time we discover that focus escaped
  var checkFocusIn = function checkFocusIn(event) {
    var target = getActualTarget(event);
    var targetContained = findContainerIndex(target, event) >= 0;

    // In Firefox when you Tab out of an iframe the Document is briefly focused.
    if (targetContained || target instanceof Document) {
      if (targetContained) {
        state.mostRecentlyFocusedNode = target;
      }
    } else {
      // escaped! pull it back in to where it just left
      event.stopImmediatePropagation();

      // focus will escape if the MRU node had a positive tab index and user tried to nav forward;
      //  it will also escape if the MRU node had a 0 tab index and user tried to nav backward
      //  toward a node with a positive tab index
      var nextNode; // next node to focus, if we find one
      var navAcrossContainers = true;
      if (state.mostRecentlyFocusedNode) {
        if ((0,tabbable__WEBPACK_IMPORTED_MODULE_0__.getTabIndex)(state.mostRecentlyFocusedNode) > 0) {
          // MRU container index must be >=0 otherwise we wouldn't have it as an MRU node...
          var mruContainerIdx = findContainerIndex(state.mostRecentlyFocusedNode);
          // there MAY not be any tabbable nodes in the container if there are at least 2 containers
          //  and the MRU node is focusable but not tabbable (focus-trap requires at least 1 container
          //  with at least one tabbable node in order to function, so this could be the other container
          //  with nothing tabbable in it)
          var tabbableNodes = state.containerGroups[mruContainerIdx].tabbableNodes;
          if (tabbableNodes.length > 0) {
            // MRU tab index MAY not be found if the MRU node is focusable but not tabbable
            var mruTabIdx = tabbableNodes.findIndex(function (node) {
              return node === state.mostRecentlyFocusedNode;
            });
            if (mruTabIdx >= 0) {
              if (config.isKeyForward(state.recentNavEvent)) {
                if (mruTabIdx + 1 < tabbableNodes.length) {
                  nextNode = tabbableNodes[mruTabIdx + 1];
                  navAcrossContainers = false;
                }
                // else, don't wrap within the container as focus should move to next/previous
                //  container
              } else {
                if (mruTabIdx - 1 >= 0) {
                  nextNode = tabbableNodes[mruTabIdx - 1];
                  navAcrossContainers = false;
                }
                // else, don't wrap within the container as focus should move to next/previous
                //  container
              }
              // else, don't find in container order without considering direction too
            }
          }
          // else, no tabbable nodes in that container (which means we must have at least one other
          //  container with at least one tabbable node in it, otherwise focus-trap would've thrown
          //  an error the last time updateTabbableNodes() was run): find next node among all known
          //  containers
        } else {
          // check to see if there's at least one tabbable node with a positive tab index inside
          //  the trap because focus seems to escape when navigating backward from a tabbable node
          //  with tabindex=0 when this is the case (instead of wrapping to the tabbable node with
          //  the greatest positive tab index like it should)
          if (!state.containerGroups.some(function (g) {
            return g.tabbableNodes.some(function (n) {
              return (0,tabbable__WEBPACK_IMPORTED_MODULE_0__.getTabIndex)(n) > 0;
            });
          })) {
            // no containers with tabbable nodes with positive tab indexes which means the focus
            //  escaped for some other reason and we should just execute the fallback to the
            //  MRU node or initial focus node, if any
            navAcrossContainers = false;
          }
        }
      } else {
        // no MRU node means we're likely in some initial condition when the trap has just
        //  been activated and initial focus hasn't been given yet, in which case we should
        //  fall through to trying to focus the initial focus node, which is what should
        //  happen below at this point in the logic
        navAcrossContainers = false;
      }
      if (navAcrossContainers) {
        nextNode = findNextNavNode({
          // move FROM the MRU node, not event-related node (which will be the node that is
          //  outside the trap causing the focus escape we're trying to fix)
          target: state.mostRecentlyFocusedNode,
          isBackward: config.isKeyBackward(state.recentNavEvent)
        });
      }
      if (nextNode) {
        _tryFocus(nextNode);
      } else {
        _tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());
      }
    }
    state.recentNavEvent = undefined; // clear
  };

  // Hijack key nav events on the first and last focusable nodes of the trap,
  // in order to prevent focus from escaping. If it escapes for even a
  // moment it can end up scrolling the page and causing confusion so we
  // kind of need to capture the action at the keydown phase.
  var checkKeyNav = function checkKeyNav(event) {
    var isBackward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    state.recentNavEvent = event;
    var destinationNode = findNextNavNode({
      event: event,
      isBackward: isBackward
    });
    if (destinationNode) {
      if (isTabEvent(event)) {
        // since tab natively moves focus, we wouldn't have a destination node unless we
        //  were on the edge of a container and had to move to the next/previous edge, in
        //  which case we want to prevent default to keep the browser from moving focus
        //  to where it normally would
        event.preventDefault();
      }
      _tryFocus(destinationNode);
    }
    // else, let the browser take care of [shift+]tab and move the focus
  };
  var checkTabKey = function checkTabKey(event) {
    if (config.isKeyForward(event) || config.isKeyBackward(event)) {
      checkKeyNav(event, config.isKeyBackward(event));
    }
  };

  // we use a different event phase for the Escape key to allow canceling the event and checking for this in escapeDeactivates
  var checkEscapeKey = function checkEscapeKey(event) {
    if (isEscapeEvent(event) && valueOrHandler(config.escapeDeactivates, event) !== false) {
      event.preventDefault();
      trap.deactivate();
    }
  };
  var checkClick = function checkClick(e) {
    var target = getActualTarget(e);
    if (findContainerIndex(target, e) >= 0) {
      return;
    }
    if (valueOrHandler(config.clickOutsideDeactivates, e)) {
      return;
    }
    if (valueOrHandler(config.allowOutsideClick, e)) {
      return;
    }
    e.preventDefault();
    e.stopImmediatePropagation();
  };

  //
  // EVENT LISTENERS
  //

  var addListeners = function addListeners() {
    if (!state.active) {
      return;
    }

    // There can be only one listening focus trap at a time
    activeFocusTraps.activateTrap(trapStack, trap);

    // Delay ensures that the focused element doesn't capture the event
    // that caused the focus trap activation.
    state.delayInitialFocusTimer = config.delayInitialFocus ? delay(function () {
      _tryFocus(getInitialFocusNode());
    }) : _tryFocus(getInitialFocusNode());
    doc.addEventListener('focusin', checkFocusIn, true);
    doc.addEventListener('mousedown', checkPointerDown, {
      capture: true,
      passive: false
    });
    doc.addEventListener('touchstart', checkPointerDown, {
      capture: true,
      passive: false
    });
    doc.addEventListener('click', checkClick, {
      capture: true,
      passive: false
    });
    doc.addEventListener('keydown', checkTabKey, {
      capture: true,
      passive: false
    });
    doc.addEventListener('keydown', checkEscapeKey);
    return trap;
  };
  var removeListeners = function removeListeners() {
    if (!state.active) {
      return;
    }
    doc.removeEventListener('focusin', checkFocusIn, true);
    doc.removeEventListener('mousedown', checkPointerDown, true);
    doc.removeEventListener('touchstart', checkPointerDown, true);
    doc.removeEventListener('click', checkClick, true);
    doc.removeEventListener('keydown', checkTabKey, true);
    doc.removeEventListener('keydown', checkEscapeKey);
    return trap;
  };

  //
  // MUTATION OBSERVER
  //

  var checkDomRemoval = function checkDomRemoval(mutations) {
    var isFocusedNodeRemoved = mutations.some(function (mutation) {
      var removedNodes = Array.from(mutation.removedNodes);
      return removedNodes.some(function (node) {
        return node === state.mostRecentlyFocusedNode;
      });
    });

    // If the currently focused is removed then browsers will move focus to the
    // <body> element. If this happens, try to move focus back into the trap.
    if (isFocusedNodeRemoved) {
      _tryFocus(getInitialFocusNode());
    }
  };

  // Use MutationObserver - if supported - to detect if focused node is removed
  // from the DOM.
  var mutationObserver = typeof window !== 'undefined' && 'MutationObserver' in window ? new MutationObserver(checkDomRemoval) : undefined;
  var updateObservedNodes = function updateObservedNodes() {
    if (!mutationObserver) {
      return;
    }
    mutationObserver.disconnect();
    if (state.active && !state.paused) {
      state.containers.map(function (container) {
        mutationObserver.observe(container, {
          subtree: true,
          childList: true
        });
      });
    }
  };

  //
  // TRAP DEFINITION
  //

  trap = {
    get active() {
      return state.active;
    },
    get paused() {
      return state.paused;
    },
    activate: function activate(activateOptions) {
      if (state.active) {
        return this;
      }
      var onActivate = getOption(activateOptions, 'onActivate');
      var onPostActivate = getOption(activateOptions, 'onPostActivate');
      var checkCanFocusTrap = getOption(activateOptions, 'checkCanFocusTrap');
      if (!checkCanFocusTrap) {
        updateTabbableNodes();
      }
      state.active = true;
      state.paused = false;
      state.nodeFocusedBeforeActivation = _getActiveElement(doc);
      onActivate === null || onActivate === void 0 || onActivate();
      var finishActivation = function finishActivation() {
        if (checkCanFocusTrap) {
          updateTabbableNodes();
        }
        addListeners();
        updateObservedNodes();
        onPostActivate === null || onPostActivate === void 0 || onPostActivate();
      };
      if (checkCanFocusTrap) {
        checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);
        return this;
      }
      finishActivation();
      return this;
    },
    deactivate: function deactivate(deactivateOptions) {
      if (!state.active) {
        return this;
      }
      var options = _objectSpread2({
        onDeactivate: config.onDeactivate,
        onPostDeactivate: config.onPostDeactivate,
        checkCanReturnFocus: config.checkCanReturnFocus
      }, deactivateOptions);
      clearTimeout(state.delayInitialFocusTimer); // noop if undefined
      state.delayInitialFocusTimer = undefined;
      removeListeners();
      state.active = false;
      state.paused = false;
      updateObservedNodes();
      activeFocusTraps.deactivateTrap(trapStack, trap);
      var onDeactivate = getOption(options, 'onDeactivate');
      var onPostDeactivate = getOption(options, 'onPostDeactivate');
      var checkCanReturnFocus = getOption(options, 'checkCanReturnFocus');
      var returnFocus = getOption(options, 'returnFocus', 'returnFocusOnDeactivate');
      onDeactivate === null || onDeactivate === void 0 || onDeactivate();
      var finishDeactivation = function finishDeactivation() {
        delay(function () {
          if (returnFocus) {
            _tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));
          }
          onPostDeactivate === null || onPostDeactivate === void 0 || onPostDeactivate();
        });
      };
      if (returnFocus && checkCanReturnFocus) {
        checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);
        return this;
      }
      finishDeactivation();
      return this;
    },
    pause: function pause(pauseOptions) {
      if (!state.active) {
        return this;
      }
      state.manuallyPaused = true;
      return this._setPausedState(true, pauseOptions);
    },
    unpause: function unpause(unpauseOptions) {
      if (!state.active) {
        return this;
      }
      state.manuallyPaused = false;
      if (trapStack[trapStack.length - 1] !== this) {
        return this;
      }
      return this._setPausedState(false, unpauseOptions);
    },
    updateContainerElements: function updateContainerElements(containerElements) {
      var elementsAsArray = [].concat(containerElements).filter(Boolean);
      state.containers = elementsAsArray.map(function (element) {
        return typeof element === 'string' ? doc.querySelector(element) : element;
      });
      if (state.active) {
        updateTabbableNodes();
      }
      updateObservedNodes();
      return this;
    }
  };
  Object.defineProperties(trap, {
    _isManuallyPaused: {
      value: function value() {
        return state.manuallyPaused;
      }
    },
    _setPausedState: {
      value: function value(paused, options) {
        if (state.paused === paused) {
          return this;
        }
        state.paused = paused;
        if (paused) {
          var onPause = getOption(options, 'onPause');
          var onPostPause = getOption(options, 'onPostPause');
          onPause === null || onPause === void 0 || onPause();
          removeListeners();
          updateObservedNodes();
          onPostPause === null || onPostPause === void 0 || onPostPause();
        } else {
          var onUnpause = getOption(options, 'onUnpause');
          var onPostUnpause = getOption(options, 'onPostUnpause');
          onUnpause === null || onUnpause === void 0 || onUnpause();
          updateTabbableNodes();
          addListeners();
          updateObservedNodes();
          onPostUnpause === null || onPostUnpause === void 0 || onPostUnpause();
        }
        return this;
      }
    }
  });

  // initialize container elements
  trap.updateContainerElements(elements);
  return trap;
};


//# sourceMappingURL=focus-trap.esm.js.map


/***/ }),

/***/ "./node_modules/sortablejs/modular/sortable.esm.js":
/*!*********************************************************!*\
  !*** ./node_modules/sortablejs/modular/sortable.esm.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MultiDrag: function() { return /* binding */ MultiDragPlugin; },
/* harmony export */   Sortable: function() { return /* binding */ Sortable; },
/* harmony export */   Swap: function() { return /* binding */ SwapPlugin; }
/* harmony export */ });
/**!
 * Sortable 1.15.6
 * @author	RubaXa   <trash@rubaxa.org>
 * @author	owenm    <owen23355@gmail.com>
 * @license MIT
 */
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }
  return _typeof(obj);
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];
  return arr2;
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var version = "1.15.6";

function userAgent(pattern) {
  if (typeof window !== 'undefined' && window.navigator) {
    return !! /*@__PURE__*/navigator.userAgent.match(pattern);
  }
}
var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
var Edge = userAgent(/Edge/i);
var FireFox = userAgent(/firefox/i);
var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
var IOS = userAgent(/iP(ad|od|hone)/i);
var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);

var captureMode = {
  capture: false,
  passive: false
};
function on(el, event, fn) {
  el.addEventListener(event, fn, !IE11OrLess && captureMode);
}
function off(el, event, fn) {
  el.removeEventListener(event, fn, !IE11OrLess && captureMode);
}
function matches( /**HTMLElement*/el, /**String*/selector) {
  if (!selector) return;
  selector[0] === '>' && (selector = selector.substring(1));
  if (el) {
    try {
      if (el.matches) {
        return el.matches(selector);
      } else if (el.msMatchesSelector) {
        return el.msMatchesSelector(selector);
      } else if (el.webkitMatchesSelector) {
        return el.webkitMatchesSelector(selector);
      }
    } catch (_) {
      return false;
    }
  }
  return false;
}
function getParentOrHost(el) {
  return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
}
function closest( /**HTMLElement*/el, /**String*/selector, /**HTMLElement*/ctx, includeCTX) {
  if (el) {
    ctx = ctx || document;
    do {
      if (selector != null && (selector[0] === '>' ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {
        return el;
      }
      if (el === ctx) break;
      /* jshint boss:true */
    } while (el = getParentOrHost(el));
  }
  return null;
}
var R_SPACE = /\s+/g;
function toggleClass(el, name, state) {
  if (el && name) {
    if (el.classList) {
      el.classList[state ? 'add' : 'remove'](name);
    } else {
      var className = (' ' + el.className + ' ').replace(R_SPACE, ' ').replace(' ' + name + ' ', ' ');
      el.className = (className + (state ? ' ' + name : '')).replace(R_SPACE, ' ');
    }
  }
}
function css(el, prop, val) {
  var style = el && el.style;
  if (style) {
    if (val === void 0) {
      if (document.defaultView && document.defaultView.getComputedStyle) {
        val = document.defaultView.getComputedStyle(el, '');
      } else if (el.currentStyle) {
        val = el.currentStyle;
      }
      return prop === void 0 ? val : val[prop];
    } else {
      if (!(prop in style) && prop.indexOf('webkit') === -1) {
        prop = '-webkit-' + prop;
      }
      style[prop] = val + (typeof val === 'string' ? '' : 'px');
    }
  }
}
function matrix(el, selfOnly) {
  var appliedTransforms = '';
  if (typeof el === 'string') {
    appliedTransforms = el;
  } else {
    do {
      var transform = css(el, 'transform');
      if (transform && transform !== 'none') {
        appliedTransforms = transform + ' ' + appliedTransforms;
      }
      /* jshint boss:true */
    } while (!selfOnly && (el = el.parentNode));
  }
  var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  /*jshint -W056 */
  return matrixFn && new matrixFn(appliedTransforms);
}
function find(ctx, tagName, iterator) {
  if (ctx) {
    var list = ctx.getElementsByTagName(tagName),
      i = 0,
      n = list.length;
    if (iterator) {
      for (; i < n; i++) {
        iterator(list[i], i);
      }
    }
    return list;
  }
  return [];
}
function getWindowScrollingElement() {
  var scrollingElement = document.scrollingElement;
  if (scrollingElement) {
    return scrollingElement;
  } else {
    return document.documentElement;
  }
}

/**
 * Returns the "bounding client rect" of given element
 * @param  {HTMLElement} el                       The element whose boundingClientRect is wanted
 * @param  {[Boolean]} relativeToContainingBlock  Whether the rect should be relative to the containing block of (including) the container
 * @param  {[Boolean]} relativeToNonStaticParent  Whether the rect should be relative to the relative parent of (including) the contaienr
 * @param  {[Boolean]} undoScale                  Whether the container's scale() should be undone
 * @param  {[HTMLElement]} container              The parent the element will be placed in
 * @return {Object}                               The boundingClientRect of el, with specified adjustments
 */
function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
  if (!el.getBoundingClientRect && el !== window) return;
  var elRect, top, left, bottom, right, height, width;
  if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {
    elRect = el.getBoundingClientRect();
    top = elRect.top;
    left = elRect.left;
    bottom = elRect.bottom;
    right = elRect.right;
    height = elRect.height;
    width = elRect.width;
  } else {
    top = 0;
    left = 0;
    bottom = window.innerHeight;
    right = window.innerWidth;
    height = window.innerHeight;
    width = window.innerWidth;
  }
  if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
    // Adjust for translate()
    container = container || el.parentNode;

    // solves #1123 (see: https://stackoverflow.com/a/37953806/6088312)
    // Not needed on <= IE11
    if (!IE11OrLess) {
      do {
        if (container && container.getBoundingClientRect && (css(container, 'transform') !== 'none' || relativeToNonStaticParent && css(container, 'position') !== 'static')) {
          var containerRect = container.getBoundingClientRect();

          // Set relative to edges of padding box of container
          top -= containerRect.top + parseInt(css(container, 'border-top-width'));
          left -= containerRect.left + parseInt(css(container, 'border-left-width'));
          bottom = top + elRect.height;
          right = left + elRect.width;
          break;
        }
        /* jshint boss:true */
      } while (container = container.parentNode);
    }
  }
  if (undoScale && el !== window) {
    // Adjust for scale()
    var elMatrix = matrix(container || el),
      scaleX = elMatrix && elMatrix.a,
      scaleY = elMatrix && elMatrix.d;
    if (elMatrix) {
      top /= scaleY;
      left /= scaleX;
      width /= scaleX;
      height /= scaleY;
      bottom = top + height;
      right = left + width;
    }
  }
  return {
    top: top,
    left: left,
    bottom: bottom,
    right: right,
    width: width,
    height: height
  };
}

/**
 * Checks if a side of an element is scrolled past a side of its parents
 * @param  {HTMLElement}  el           The element who's side being scrolled out of view is in question
 * @param  {String}       elSide       Side of the element in question ('top', 'left', 'right', 'bottom')
 * @param  {String}       parentSide   Side of the parent in question ('top', 'left', 'right', 'bottom')
 * @return {HTMLElement}               The parent scroll element that the el's side is scrolled past, or null if there is no such element
 */
function isScrolledPast(el, elSide, parentSide) {
  var parent = getParentAutoScrollElement(el, true),
    elSideVal = getRect(el)[elSide];

  /* jshint boss:true */
  while (parent) {
    var parentSideVal = getRect(parent)[parentSide],
      visible = void 0;
    if (parentSide === 'top' || parentSide === 'left') {
      visible = elSideVal >= parentSideVal;
    } else {
      visible = elSideVal <= parentSideVal;
    }
    if (!visible) return parent;
    if (parent === getWindowScrollingElement()) break;
    parent = getParentAutoScrollElement(parent, false);
  }
  return false;
}

/**
 * Gets nth child of el, ignoring hidden children, sortable's elements (does not ignore clone if it's visible)
 * and non-draggable elements
 * @param  {HTMLElement} el       The parent element
 * @param  {Number} childNum      The index of the child
 * @param  {Object} options       Parent Sortable's options
 * @return {HTMLElement}          The child at index childNum, or null if not found
 */
function getChild(el, childNum, options, includeDragEl) {
  var currentChild = 0,
    i = 0,
    children = el.children;
  while (i < children.length) {
    if (children[i].style.display !== 'none' && children[i] !== Sortable.ghost && (includeDragEl || children[i] !== Sortable.dragged) && closest(children[i], options.draggable, el, false)) {
      if (currentChild === childNum) {
        return children[i];
      }
      currentChild++;
    }
    i++;
  }
  return null;
}

/**
 * Gets the last child in the el, ignoring ghostEl or invisible elements (clones)
 * @param  {HTMLElement} el       Parent element
 * @param  {selector} selector    Any other elements that should be ignored
 * @return {HTMLElement}          The last child, ignoring ghostEl
 */
function lastChild(el, selector) {
  var last = el.lastElementChild;
  while (last && (last === Sortable.ghost || css(last, 'display') === 'none' || selector && !matches(last, selector))) {
    last = last.previousElementSibling;
  }
  return last || null;
}

/**
 * Returns the index of an element within its parent for a selected set of
 * elements
 * @param  {HTMLElement} el
 * @param  {selector} selector
 * @return {number}
 */
function index(el, selector) {
  var index = 0;
  if (!el || !el.parentNode) {
    return -1;
  }

  /* jshint boss:true */
  while (el = el.previousElementSibling) {
    if (el.nodeName.toUpperCase() !== 'TEMPLATE' && el !== Sortable.clone && (!selector || matches(el, selector))) {
      index++;
    }
  }
  return index;
}

/**
 * Returns the scroll offset of the given element, added with all the scroll offsets of parent elements.
 * The value is returned in real pixels.
 * @param  {HTMLElement} el
 * @return {Array}             Offsets in the format of [left, top]
 */
function getRelativeScrollOffset(el) {
  var offsetLeft = 0,
    offsetTop = 0,
    winScroller = getWindowScrollingElement();
  if (el) {
    do {
      var elMatrix = matrix(el),
        scaleX = elMatrix.a,
        scaleY = elMatrix.d;
      offsetLeft += el.scrollLeft * scaleX;
      offsetTop += el.scrollTop * scaleY;
    } while (el !== winScroller && (el = el.parentNode));
  }
  return [offsetLeft, offsetTop];
}

/**
 * Returns the index of the object within the given array
 * @param  {Array} arr   Array that may or may not hold the object
 * @param  {Object} obj  An object that has a key-value pair unique to and identical to a key-value pair in the object you want to find
 * @return {Number}      The index of the object in the array, or -1
 */
function indexOfObject(arr, obj) {
  for (var i in arr) {
    if (!arr.hasOwnProperty(i)) continue;
    for (var key in obj) {
      if (obj.hasOwnProperty(key) && obj[key] === arr[i][key]) return Number(i);
    }
  }
  return -1;
}
function getParentAutoScrollElement(el, includeSelf) {
  // skip to window
  if (!el || !el.getBoundingClientRect) return getWindowScrollingElement();
  var elem = el;
  var gotSelf = false;
  do {
    // we don't need to get elem css if it isn't even overflowing in the first place (performance)
    if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
      var elemCSS = css(elem);
      if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == 'auto' || elemCSS.overflowX == 'scroll') || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == 'auto' || elemCSS.overflowY == 'scroll')) {
        if (!elem.getBoundingClientRect || elem === document.body) return getWindowScrollingElement();
        if (gotSelf || includeSelf) return elem;
        gotSelf = true;
      }
    }
    /* jshint boss:true */
  } while (elem = elem.parentNode);
  return getWindowScrollingElement();
}
function extend(dst, src) {
  if (dst && src) {
    for (var key in src) {
      if (src.hasOwnProperty(key)) {
        dst[key] = src[key];
      }
    }
  }
  return dst;
}
function isRectEqual(rect1, rect2) {
  return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
}
var _throttleTimeout;
function throttle(callback, ms) {
  return function () {
    if (!_throttleTimeout) {
      var args = arguments,
        _this = this;
      if (args.length === 1) {
        callback.call(_this, args[0]);
      } else {
        callback.apply(_this, args);
      }
      _throttleTimeout = setTimeout(function () {
        _throttleTimeout = void 0;
      }, ms);
    }
  };
}
function cancelThrottle() {
  clearTimeout(_throttleTimeout);
  _throttleTimeout = void 0;
}
function scrollBy(el, x, y) {
  el.scrollLeft += x;
  el.scrollTop += y;
}
function clone(el) {
  var Polymer = window.Polymer;
  var $ = window.jQuery || window.Zepto;
  if (Polymer && Polymer.dom) {
    return Polymer.dom(el).cloneNode(true);
  } else if ($) {
    return $(el).clone(true)[0];
  } else {
    return el.cloneNode(true);
  }
}
function setRect(el, rect) {
  css(el, 'position', 'absolute');
  css(el, 'top', rect.top);
  css(el, 'left', rect.left);
  css(el, 'width', rect.width);
  css(el, 'height', rect.height);
}
function unsetRect(el) {
  css(el, 'position', '');
  css(el, 'top', '');
  css(el, 'left', '');
  css(el, 'width', '');
  css(el, 'height', '');
}
function getChildContainingRectFromElement(container, options, ghostEl) {
  var rect = {};
  Array.from(container.children).forEach(function (child) {
    var _rect$left, _rect$top, _rect$right, _rect$bottom;
    if (!closest(child, options.draggable, container, false) || child.animated || child === ghostEl) return;
    var childRect = getRect(child);
    rect.left = Math.min((_rect$left = rect.left) !== null && _rect$left !== void 0 ? _rect$left : Infinity, childRect.left);
    rect.top = Math.min((_rect$top = rect.top) !== null && _rect$top !== void 0 ? _rect$top : Infinity, childRect.top);
    rect.right = Math.max((_rect$right = rect.right) !== null && _rect$right !== void 0 ? _rect$right : -Infinity, childRect.right);
    rect.bottom = Math.max((_rect$bottom = rect.bottom) !== null && _rect$bottom !== void 0 ? _rect$bottom : -Infinity, childRect.bottom);
  });
  rect.width = rect.right - rect.left;
  rect.height = rect.bottom - rect.top;
  rect.x = rect.left;
  rect.y = rect.top;
  return rect;
}
var expando = 'Sortable' + new Date().getTime();

function AnimationStateManager() {
  var animationStates = [],
    animationCallbackId;
  return {
    captureAnimationState: function captureAnimationState() {
      animationStates = [];
      if (!this.options.animation) return;
      var children = [].slice.call(this.el.children);
      children.forEach(function (child) {
        if (css(child, 'display') === 'none' || child === Sortable.ghost) return;
        animationStates.push({
          target: child,
          rect: getRect(child)
        });
        var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect);

        // If animating: compensate for current animation
        if (child.thisAnimationDuration) {
          var childMatrix = matrix(child, true);
          if (childMatrix) {
            fromRect.top -= childMatrix.f;
            fromRect.left -= childMatrix.e;
          }
        }
        child.fromRect = fromRect;
      });
    },
    addAnimationState: function addAnimationState(state) {
      animationStates.push(state);
    },
    removeAnimationState: function removeAnimationState(target) {
      animationStates.splice(indexOfObject(animationStates, {
        target: target
      }), 1);
    },
    animateAll: function animateAll(callback) {
      var _this = this;
      if (!this.options.animation) {
        clearTimeout(animationCallbackId);
        if (typeof callback === 'function') callback();
        return;
      }
      var animating = false,
        animationTime = 0;
      animationStates.forEach(function (state) {
        var time = 0,
          target = state.target,
          fromRect = target.fromRect,
          toRect = getRect(target),
          prevFromRect = target.prevFromRect,
          prevToRect = target.prevToRect,
          animatingRect = state.rect,
          targetMatrix = matrix(target, true);
        if (targetMatrix) {
          // Compensate for current animation
          toRect.top -= targetMatrix.f;
          toRect.left -= targetMatrix.e;
        }
        target.toRect = toRect;
        if (target.thisAnimationDuration) {
          // Could also check if animatingRect is between fromRect and toRect
          if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) &&
          // Make sure animatingRect is on line between toRect & fromRect
          (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
            // If returning to same place as started from animation and on same axis
            time = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
          }
        }

        // if fromRect != toRect: animate
        if (!isRectEqual(toRect, fromRect)) {
          target.prevFromRect = fromRect;
          target.prevToRect = toRect;
          if (!time) {
            time = _this.options.animation;
          }
          _this.animate(target, animatingRect, toRect, time);
        }
        if (time) {
          animating = true;
          animationTime = Math.max(animationTime, time);
          clearTimeout(target.animationResetTimer);
          target.animationResetTimer = setTimeout(function () {
            target.animationTime = 0;
            target.prevFromRect = null;
            target.fromRect = null;
            target.prevToRect = null;
            target.thisAnimationDuration = null;
          }, time);
          target.thisAnimationDuration = time;
        }
      });
      clearTimeout(animationCallbackId);
      if (!animating) {
        if (typeof callback === 'function') callback();
      } else {
        animationCallbackId = setTimeout(function () {
          if (typeof callback === 'function') callback();
        }, animationTime);
      }
      animationStates = [];
    },
    animate: function animate(target, currentRect, toRect, duration) {
      if (duration) {
        css(target, 'transition', '');
        css(target, 'transform', '');
        var elMatrix = matrix(this.el),
          scaleX = elMatrix && elMatrix.a,
          scaleY = elMatrix && elMatrix.d,
          translateX = (currentRect.left - toRect.left) / (scaleX || 1),
          translateY = (currentRect.top - toRect.top) / (scaleY || 1);
        target.animatingX = !!translateX;
        target.animatingY = !!translateY;
        css(target, 'transform', 'translate3d(' + translateX + 'px,' + translateY + 'px,0)');
        this.forRepaintDummy = repaint(target); // repaint

        css(target, 'transition', 'transform ' + duration + 'ms' + (this.options.easing ? ' ' + this.options.easing : ''));
        css(target, 'transform', 'translate3d(0,0,0)');
        typeof target.animated === 'number' && clearTimeout(target.animated);
        target.animated = setTimeout(function () {
          css(target, 'transition', '');
          css(target, 'transform', '');
          target.animated = false;
          target.animatingX = false;
          target.animatingY = false;
        }, duration);
      }
    }
  };
}
function repaint(target) {
  return target.offsetWidth;
}
function calculateRealTime(animatingRect, fromRect, toRect, options) {
  return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
}

var plugins = [];
var defaults = {
  initializeByDefault: true
};
var PluginManager = {
  mount: function mount(plugin) {
    // Set default static properties
    for (var option in defaults) {
      if (defaults.hasOwnProperty(option) && !(option in plugin)) {
        plugin[option] = defaults[option];
      }
    }
    plugins.forEach(function (p) {
      if (p.pluginName === plugin.pluginName) {
        throw "Sortable: Cannot mount plugin ".concat(plugin.pluginName, " more than once");
      }
    });
    plugins.push(plugin);
  },
  pluginEvent: function pluginEvent(eventName, sortable, evt) {
    var _this = this;
    this.eventCanceled = false;
    evt.cancel = function () {
      _this.eventCanceled = true;
    };
    var eventNameGlobal = eventName + 'Global';
    plugins.forEach(function (plugin) {
      if (!sortable[plugin.pluginName]) return;
      // Fire global events if it exists in this sortable
      if (sortable[plugin.pluginName][eventNameGlobal]) {
        sortable[plugin.pluginName][eventNameGlobal](_objectSpread2({
          sortable: sortable
        }, evt));
      }

      // Only fire plugin event if plugin is enabled in this sortable,
      // and plugin has event defined
      if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {
        sortable[plugin.pluginName][eventName](_objectSpread2({
          sortable: sortable
        }, evt));
      }
    });
  },
  initializePlugins: function initializePlugins(sortable, el, defaults, options) {
    plugins.forEach(function (plugin) {
      var pluginName = plugin.pluginName;
      if (!sortable.options[pluginName] && !plugin.initializeByDefault) return;
      var initialized = new plugin(sortable, el, sortable.options);
      initialized.sortable = sortable;
      initialized.options = sortable.options;
      sortable[pluginName] = initialized;

      // Add default options from plugin
      _extends(defaults, initialized.defaults);
    });
    for (var option in sortable.options) {
      if (!sortable.options.hasOwnProperty(option)) continue;
      var modified = this.modifyOption(sortable, option, sortable.options[option]);
      if (typeof modified !== 'undefined') {
        sortable.options[option] = modified;
      }
    }
  },
  getEventProperties: function getEventProperties(name, sortable) {
    var eventProperties = {};
    plugins.forEach(function (plugin) {
      if (typeof plugin.eventProperties !== 'function') return;
      _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name));
    });
    return eventProperties;
  },
  modifyOption: function modifyOption(sortable, name, value) {
    var modifiedValue;
    plugins.forEach(function (plugin) {
      // Plugin must exist on the Sortable
      if (!sortable[plugin.pluginName]) return;

      // If static option listener exists for this option, call in the context of the Sortable's instance of this plugin
      if (plugin.optionListeners && typeof plugin.optionListeners[name] === 'function') {
        modifiedValue = plugin.optionListeners[name].call(sortable[plugin.pluginName], value);
      }
    });
    return modifiedValue;
  }
};

function dispatchEvent(_ref) {
  var sortable = _ref.sortable,
    rootEl = _ref.rootEl,
    name = _ref.name,
    targetEl = _ref.targetEl,
    cloneEl = _ref.cloneEl,
    toEl = _ref.toEl,
    fromEl = _ref.fromEl,
    oldIndex = _ref.oldIndex,
    newIndex = _ref.newIndex,
    oldDraggableIndex = _ref.oldDraggableIndex,
    newDraggableIndex = _ref.newDraggableIndex,
    originalEvent = _ref.originalEvent,
    putSortable = _ref.putSortable,
    extraEventProperties = _ref.extraEventProperties;
  sortable = sortable || rootEl && rootEl[expando];
  if (!sortable) return;
  var evt,
    options = sortable.options,
    onName = 'on' + name.charAt(0).toUpperCase() + name.substr(1);
  // Support for new CustomEvent feature
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent(name, {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent('Event');
    evt.initEvent(name, true, true);
  }
  evt.to = toEl || rootEl;
  evt.from = fromEl || rootEl;
  evt.item = targetEl || rootEl;
  evt.clone = cloneEl;
  evt.oldIndex = oldIndex;
  evt.newIndex = newIndex;
  evt.oldDraggableIndex = oldDraggableIndex;
  evt.newDraggableIndex = newDraggableIndex;
  evt.originalEvent = originalEvent;
  evt.pullMode = putSortable ? putSortable.lastPutMode : undefined;
  var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name, sortable));
  for (var option in allEventProperties) {
    evt[option] = allEventProperties[option];
  }
  if (rootEl) {
    rootEl.dispatchEvent(evt);
  }
  if (options[onName]) {
    options[onName].call(sortable, evt);
  }
}

var _excluded = ["evt"];
var pluginEvent = function pluginEvent(eventName, sortable) {
  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
    originalEvent = _ref.evt,
    data = _objectWithoutProperties(_ref, _excluded);
  PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({
    dragEl: dragEl,
    parentEl: parentEl,
    ghostEl: ghostEl,
    rootEl: rootEl,
    nextEl: nextEl,
    lastDownEl: lastDownEl,
    cloneEl: cloneEl,
    cloneHidden: cloneHidden,
    dragStarted: moved,
    putSortable: putSortable,
    activeSortable: Sortable.active,
    originalEvent: originalEvent,
    oldIndex: oldIndex,
    oldDraggableIndex: oldDraggableIndex,
    newIndex: newIndex,
    newDraggableIndex: newDraggableIndex,
    hideGhostForTarget: _hideGhostForTarget,
    unhideGhostForTarget: _unhideGhostForTarget,
    cloneNowHidden: function cloneNowHidden() {
      cloneHidden = true;
    },
    cloneNowShown: function cloneNowShown() {
      cloneHidden = false;
    },
    dispatchSortableEvent: function dispatchSortableEvent(name) {
      _dispatchEvent({
        sortable: sortable,
        name: name,
        originalEvent: originalEvent
      });
    }
  }, data));
};
function _dispatchEvent(info) {
  dispatchEvent(_objectSpread2({
    putSortable: putSortable,
    cloneEl: cloneEl,
    targetEl: dragEl,
    rootEl: rootEl,
    oldIndex: oldIndex,
    oldDraggableIndex: oldDraggableIndex,
    newIndex: newIndex,
    newDraggableIndex: newDraggableIndex
  }, info));
}
var dragEl,
  parentEl,
  ghostEl,
  rootEl,
  nextEl,
  lastDownEl,
  cloneEl,
  cloneHidden,
  oldIndex,
  newIndex,
  oldDraggableIndex,
  newDraggableIndex,
  activeGroup,
  putSortable,
  awaitingDragStarted = false,
  ignoreNextClick = false,
  sortables = [],
  tapEvt,
  touchEvt,
  lastDx,
  lastDy,
  tapDistanceLeft,
  tapDistanceTop,
  moved,
  lastTarget,
  lastDirection,
  pastFirstInvertThresh = false,
  isCircumstantialInvert = false,
  targetMoveDistance,
  // For positioning ghost absolutely
  ghostRelativeParent,
  ghostRelativeParentInitialScroll = [],
  // (left, top)

  _silent = false,
  savedInputChecked = [];

/** @const */
var documentExists = typeof document !== 'undefined',
  PositionGhostAbsolutely = IOS,
  CSSFloatProperty = Edge || IE11OrLess ? 'cssFloat' : 'float',
  // This will not pass for IE9, because IE9 DnD only works on anchors
  supportDraggable = documentExists && !ChromeForAndroid && !IOS && 'draggable' in document.createElement('div'),
  supportCssPointerEvents = function () {
    if (!documentExists) return;
    // false when <= IE11
    if (IE11OrLess) {
      return false;
    }
    var el = document.createElement('x');
    el.style.cssText = 'pointer-events:auto';
    return el.style.pointerEvents === 'auto';
  }(),
  _detectDirection = function _detectDirection(el, options) {
    var elCSS = css(el),
      elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth),
      child1 = getChild(el, 0, options),
      child2 = getChild(el, 1, options),
      firstChildCSS = child1 && css(child1),
      secondChildCSS = child2 && css(child2),
      firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width,
      secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;
    if (elCSS.display === 'flex') {
      return elCSS.flexDirection === 'column' || elCSS.flexDirection === 'column-reverse' ? 'vertical' : 'horizontal';
    }
    if (elCSS.display === 'grid') {
      return elCSS.gridTemplateColumns.split(' ').length <= 1 ? 'vertical' : 'horizontal';
    }
    if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== 'none') {
      var touchingSideChild2 = firstChildCSS["float"] === 'left' ? 'left' : 'right';
      return child2 && (secondChildCSS.clear === 'both' || secondChildCSS.clear === touchingSideChild2) ? 'vertical' : 'horizontal';
    }
    return child1 && (firstChildCSS.display === 'block' || firstChildCSS.display === 'flex' || firstChildCSS.display === 'table' || firstChildCSS.display === 'grid' || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === 'none' || child2 && elCSS[CSSFloatProperty] === 'none' && firstChildWidth + secondChildWidth > elWidth) ? 'vertical' : 'horizontal';
  },
  _dragElInRowColumn = function _dragElInRowColumn(dragRect, targetRect, vertical) {
    var dragElS1Opp = vertical ? dragRect.left : dragRect.top,
      dragElS2Opp = vertical ? dragRect.right : dragRect.bottom,
      dragElOppLength = vertical ? dragRect.width : dragRect.height,
      targetS1Opp = vertical ? targetRect.left : targetRect.top,
      targetS2Opp = vertical ? targetRect.right : targetRect.bottom,
      targetOppLength = vertical ? targetRect.width : targetRect.height;
    return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
  },
  /**
   * Detects first nearest empty sortable to X and Y position using emptyInsertThreshold.
   * @param  {Number} x      X position
   * @param  {Number} y      Y position
   * @return {HTMLElement}   Element of the first found nearest Sortable
   */
  _detectNearestEmptySortable = function _detectNearestEmptySortable(x, y) {
    var ret;
    sortables.some(function (sortable) {
      var threshold = sortable[expando].options.emptyInsertThreshold;
      if (!threshold || lastChild(sortable)) return;
      var rect = getRect(sortable),
        insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold,
        insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;
      if (insideHorizontally && insideVertically) {
        return ret = sortable;
      }
    });
    return ret;
  },
  _prepareGroup = function _prepareGroup(options) {
    function toFn(value, pull) {
      return function (to, from, dragEl, evt) {
        var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;
        if (value == null && (pull || sameGroup)) {
          // Default pull value
          // Default pull and put value if same group
          return true;
        } else if (value == null || value === false) {
          return false;
        } else if (pull && value === 'clone') {
          return value;
        } else if (typeof value === 'function') {
          return toFn(value(to, from, dragEl, evt), pull)(to, from, dragEl, evt);
        } else {
          var otherGroup = (pull ? to : from).options.group.name;
          return value === true || typeof value === 'string' && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
        }
      };
    }
    var group = {};
    var originalGroup = options.group;
    if (!originalGroup || _typeof(originalGroup) != 'object') {
      originalGroup = {
        name: originalGroup
      };
    }
    group.name = originalGroup.name;
    group.checkPull = toFn(originalGroup.pull, true);
    group.checkPut = toFn(originalGroup.put);
    group.revertClone = originalGroup.revertClone;
    options.group = group;
  },
  _hideGhostForTarget = function _hideGhostForTarget() {
    if (!supportCssPointerEvents && ghostEl) {
      css(ghostEl, 'display', 'none');
    }
  },
  _unhideGhostForTarget = function _unhideGhostForTarget() {
    if (!supportCssPointerEvents && ghostEl) {
      css(ghostEl, 'display', '');
    }
  };

// #1184 fix - Prevent click event on fallback if dragged but item not changed position
if (documentExists && !ChromeForAndroid) {
  document.addEventListener('click', function (evt) {
    if (ignoreNextClick) {
      evt.preventDefault();
      evt.stopPropagation && evt.stopPropagation();
      evt.stopImmediatePropagation && evt.stopImmediatePropagation();
      ignoreNextClick = false;
      return false;
    }
  }, true);
}
var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent(evt) {
  if (dragEl) {
    evt = evt.touches ? evt.touches[0] : evt;
    var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);
    if (nearest) {
      // Create imitation event
      var event = {};
      for (var i in evt) {
        if (evt.hasOwnProperty(i)) {
          event[i] = evt[i];
        }
      }
      event.target = event.rootEl = nearest;
      event.preventDefault = void 0;
      event.stopPropagation = void 0;
      nearest[expando]._onDragOver(event);
    }
  }
};
var _checkOutsideTargetEl = function _checkOutsideTargetEl(evt) {
  if (dragEl) {
    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
  }
};

/**
 * @class  Sortable
 * @param  {HTMLElement}  el
 * @param  {Object}       [options]
 */
function Sortable(el, options) {
  if (!(el && el.nodeType && el.nodeType === 1)) {
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));
  }
  this.el = el; // root element
  this.options = options = _extends({}, options);

  // Export instance
  el[expando] = this;
  var defaults = {
    group: null,
    sort: true,
    disabled: false,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(el.nodeName) ? '>li' : '>*',
    swapThreshold: 1,
    // percentage; 0 <= x <= 1
    invertSwap: false,
    // invert always
    invertedSwapThreshold: null,
    // will be set to same as swapThreshold if default
    removeCloneOnHide: true,
    direction: function direction() {
      return _detectDirection(el, this.options);
    },
    ghostClass: 'sortable-ghost',
    chosenClass: 'sortable-chosen',
    dragClass: 'sortable-drag',
    ignore: 'a, img',
    filter: null,
    preventOnFilter: true,
    animation: 0,
    easing: null,
    setData: function setData(dataTransfer, dragEl) {
      dataTransfer.setData('Text', dragEl.textContent);
    },
    dropBubble: false,
    dragoverBubble: false,
    dataIdAttr: 'data-id',
    delay: 0,
    delayOnTouchOnly: false,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: false,
    fallbackClass: 'sortable-fallback',
    fallbackOnBody: false,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    // Disabled on Safari: #1571; Enabled on Safari IOS: #2244
    supportPointer: Sortable.supportPointer !== false && 'PointerEvent' in window && (!Safari || IOS),
    emptyInsertThreshold: 5
  };
  PluginManager.initializePlugins(this, el, defaults);

  // Set default options
  for (var name in defaults) {
    !(name in options) && (options[name] = defaults[name]);
  }
  _prepareGroup(options);

  // Bind all private methods
  for (var fn in this) {
    if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
      this[fn] = this[fn].bind(this);
    }
  }

  // Setup drag mode
  this.nativeDraggable = options.forceFallback ? false : supportDraggable;
  if (this.nativeDraggable) {
    // Touch start threshold cannot be greater than the native dragstart threshold
    this.options.touchStartThreshold = 1;
  }

  // Bind events
  if (options.supportPointer) {
    on(el, 'pointerdown', this._onTapStart);
  } else {
    on(el, 'mousedown', this._onTapStart);
    on(el, 'touchstart', this._onTapStart);
  }
  if (this.nativeDraggable) {
    on(el, 'dragover', this);
    on(el, 'dragenter', this);
  }
  sortables.push(this.el);

  // Restore sorting
  options.store && options.store.get && this.sort(options.store.get(this) || []);

  // Add animation state manager
  _extends(this, AnimationStateManager());
}
Sortable.prototype = /** @lends Sortable.prototype */{
  constructor: Sortable,
  _isOutsideThisEl: function _isOutsideThisEl(target) {
    if (!this.el.contains(target) && target !== this.el) {
      lastTarget = null;
    }
  },
  _getDirection: function _getDirection(evt, target) {
    return typeof this.options.direction === 'function' ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
  },
  _onTapStart: function _onTapStart( /** Event|TouchEvent */evt) {
    if (!evt.cancelable) return;
    var _this = this,
      el = this.el,
      options = this.options,
      preventOnFilter = options.preventOnFilter,
      type = evt.type,
      touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === 'touch' && evt,
      target = (touch || evt).target,
      originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target,
      filter = options.filter;
    _saveInputCheckedState(el);

    // Don't trigger start event when an element is been dragged, otherwise the evt.oldindex always wrong when set option.group.
    if (dragEl) {
      return;
    }
    if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
      return; // only left button and enabled
    }

    // cancel dnd if original target is content editable
    if (originalTarget.isContentEditable) {
      return;
    }

    // Safari ignores further event handling after mousedown
    if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === 'SELECT') {
      return;
    }
    target = closest(target, options.draggable, el, false);
    if (target && target.animated) {
      return;
    }
    if (lastDownEl === target) {
      // Ignoring duplicate `down`
      return;
    }

    // Get the index of the dragged element within its parent
    oldIndex = index(target);
    oldDraggableIndex = index(target, options.draggable);

    // Check filter
    if (typeof filter === 'function') {
      if (filter.call(this, evt, target, this)) {
        _dispatchEvent({
          sortable: _this,
          rootEl: originalTarget,
          name: 'filter',
          targetEl: target,
          toEl: el,
          fromEl: el
        });
        pluginEvent('filter', _this, {
          evt: evt
        });
        preventOnFilter && evt.preventDefault();
        return; // cancel dnd
      }
    } else if (filter) {
      filter = filter.split(',').some(function (criteria) {
        criteria = closest(originalTarget, criteria.trim(), el, false);
        if (criteria) {
          _dispatchEvent({
            sortable: _this,
            rootEl: criteria,
            name: 'filter',
            targetEl: target,
            fromEl: el,
            toEl: el
          });
          pluginEvent('filter', _this, {
            evt: evt
          });
          return true;
        }
      });
      if (filter) {
        preventOnFilter && evt.preventDefault();
        return; // cancel dnd
      }
    }
    if (options.handle && !closest(originalTarget, options.handle, el, false)) {
      return;
    }

    // Prepare `dragstart`
    this._prepareDragStart(evt, touch, target);
  },
  _prepareDragStart: function _prepareDragStart( /** Event */evt, /** Touch */touch, /** HTMLElement */target) {
    var _this = this,
      el = _this.el,
      options = _this.options,
      ownerDocument = el.ownerDocument,
      dragStartFn;
    if (target && !dragEl && target.parentNode === el) {
      var dragRect = getRect(target);
      rootEl = el;
      dragEl = target;
      parentEl = dragEl.parentNode;
      nextEl = dragEl.nextSibling;
      lastDownEl = target;
      activeGroup = options.group;
      Sortable.dragged = dragEl;
      tapEvt = {
        target: dragEl,
        clientX: (touch || evt).clientX,
        clientY: (touch || evt).clientY
      };
      tapDistanceLeft = tapEvt.clientX - dragRect.left;
      tapDistanceTop = tapEvt.clientY - dragRect.top;
      this._lastX = (touch || evt).clientX;
      this._lastY = (touch || evt).clientY;
      dragEl.style['will-change'] = 'all';
      dragStartFn = function dragStartFn() {
        pluginEvent('delayEnded', _this, {
          evt: evt
        });
        if (Sortable.eventCanceled) {
          _this._onDrop();
          return;
        }
        // Delayed drag has been triggered
        // we can re-enable the events: touchmove/mousemove
        _this._disableDelayedDragEvents();
        if (!FireFox && _this.nativeDraggable) {
          dragEl.draggable = true;
        }

        // Bind the events: dragstart/dragend
        _this._triggerDragStart(evt, touch);

        // Drag start event
        _dispatchEvent({
          sortable: _this,
          name: 'choose',
          originalEvent: evt
        });

        // Chosen item
        toggleClass(dragEl, options.chosenClass, true);
      };

      // Disable "draggable"
      options.ignore.split(',').forEach(function (criteria) {
        find(dragEl, criteria.trim(), _disableDraggable);
      });
      on(ownerDocument, 'dragover', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'mousemove', nearestEmptyInsertDetectEvent);
      on(ownerDocument, 'touchmove', nearestEmptyInsertDetectEvent);
      if (options.supportPointer) {
        on(ownerDocument, 'pointerup', _this._onDrop);
        // Native D&D triggers pointercancel
        !this.nativeDraggable && on(ownerDocument, 'pointercancel', _this._onDrop);
      } else {
        on(ownerDocument, 'mouseup', _this._onDrop);
        on(ownerDocument, 'touchend', _this._onDrop);
        on(ownerDocument, 'touchcancel', _this._onDrop);
      }

      // Make dragEl draggable (must be before delay for FireFox)
      if (FireFox && this.nativeDraggable) {
        this.options.touchStartThreshold = 4;
        dragEl.draggable = true;
      }
      pluginEvent('delayStart', this, {
        evt: evt
      });

      // Delay is impossible for native DnD in Edge or IE
      if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
        if (Sortable.eventCanceled) {
          this._onDrop();
          return;
        }
        // If the user moves the pointer or let go the click or touch
        // before the delay has been reached:
        // disable the delayed drag
        if (options.supportPointer) {
          on(ownerDocument, 'pointerup', _this._disableDelayedDrag);
          on(ownerDocument, 'pointercancel', _this._disableDelayedDrag);
        } else {
          on(ownerDocument, 'mouseup', _this._disableDelayedDrag);
          on(ownerDocument, 'touchend', _this._disableDelayedDrag);
          on(ownerDocument, 'touchcancel', _this._disableDelayedDrag);
        }
        on(ownerDocument, 'mousemove', _this._delayedDragTouchMoveHandler);
        on(ownerDocument, 'touchmove', _this._delayedDragTouchMoveHandler);
        options.supportPointer && on(ownerDocument, 'pointermove', _this._delayedDragTouchMoveHandler);
        _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
      } else {
        dragStartFn();
      }
    }
  },
  _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler( /** TouchEvent|PointerEvent **/e) {
    var touch = e.touches ? e.touches[0] : e;
    if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
      this._disableDelayedDrag();
    }
  },
  _disableDelayedDrag: function _disableDelayedDrag() {
    dragEl && _disableDraggable(dragEl);
    clearTimeout(this._dragStartTimer);
    this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function _disableDelayedDragEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, 'mouseup', this._disableDelayedDrag);
    off(ownerDocument, 'touchend', this._disableDelayedDrag);
    off(ownerDocument, 'touchcancel', this._disableDelayedDrag);
    off(ownerDocument, 'pointerup', this._disableDelayedDrag);
    off(ownerDocument, 'pointercancel', this._disableDelayedDrag);
    off(ownerDocument, 'mousemove', this._delayedDragTouchMoveHandler);
    off(ownerDocument, 'touchmove', this._delayedDragTouchMoveHandler);
    off(ownerDocument, 'pointermove', this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function _triggerDragStart( /** Event */evt, /** Touch */touch) {
    touch = touch || evt.pointerType == 'touch' && evt;
    if (!this.nativeDraggable || touch) {
      if (this.options.supportPointer) {
        on(document, 'pointermove', this._onTouchMove);
      } else if (touch) {
        on(document, 'touchmove', this._onTouchMove);
      } else {
        on(document, 'mousemove', this._onTouchMove);
      }
    } else {
      on(dragEl, 'dragend', this);
      on(rootEl, 'dragstart', this._onDragStart);
    }
    try {
      if (document.selection) {
        _nextTick(function () {
          document.selection.empty();
        });
      } else {
        window.getSelection().removeAllRanges();
      }
    } catch (err) {}
  },
  _dragStarted: function _dragStarted(fallback, evt) {
    awaitingDragStarted = false;
    if (rootEl && dragEl) {
      pluginEvent('dragStarted', this, {
        evt: evt
      });
      if (this.nativeDraggable) {
        on(document, 'dragover', _checkOutsideTargetEl);
      }
      var options = this.options;

      // Apply effect
      !fallback && toggleClass(dragEl, options.dragClass, false);
      toggleClass(dragEl, options.ghostClass, true);
      Sortable.active = this;
      fallback && this._appendGhost();

      // Drag start event
      _dispatchEvent({
        sortable: this,
        name: 'start',
        originalEvent: evt
      });
    } else {
      this._nulling();
    }
  },
  _emulateDragOver: function _emulateDragOver() {
    if (touchEvt) {
      this._lastX = touchEvt.clientX;
      this._lastY = touchEvt.clientY;
      _hideGhostForTarget();
      var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
      var parent = target;
      while (target && target.shadowRoot) {
        target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
        if (target === parent) break;
        parent = target;
      }
      dragEl.parentNode[expando]._isOutsideThisEl(target);
      if (parent) {
        do {
          if (parent[expando]) {
            var inserted = void 0;
            inserted = parent[expando]._onDragOver({
              clientX: touchEvt.clientX,
              clientY: touchEvt.clientY,
              target: target,
              rootEl: parent
            });
            if (inserted && !this.options.dragoverBubble) {
              break;
            }
          }
          target = parent; // store last element
        }
        /* jshint boss:true */ while (parent = getParentOrHost(parent));
      }
      _unhideGhostForTarget();
    }
  },
  _onTouchMove: function _onTouchMove( /**TouchEvent*/evt) {
    if (tapEvt) {
      var options = this.options,
        fallbackTolerance = options.fallbackTolerance,
        fallbackOffset = options.fallbackOffset,
        touch = evt.touches ? evt.touches[0] : evt,
        ghostMatrix = ghostEl && matrix(ghostEl, true),
        scaleX = ghostEl && ghostMatrix && ghostMatrix.a,
        scaleY = ghostEl && ghostMatrix && ghostMatrix.d,
        relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent),
        dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1),
        dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1);

      // only set the status to dragging, when we are actually dragging
      if (!Sortable.active && !awaitingDragStarted) {
        if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
          return;
        }
        this._onDragStart(evt, true);
      }
      if (ghostEl) {
        if (ghostMatrix) {
          ghostMatrix.e += dx - (lastDx || 0);
          ghostMatrix.f += dy - (lastDy || 0);
        } else {
          ghostMatrix = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            e: dx,
            f: dy
          };
        }
        var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
        css(ghostEl, 'webkitTransform', cssMatrix);
        css(ghostEl, 'mozTransform', cssMatrix);
        css(ghostEl, 'msTransform', cssMatrix);
        css(ghostEl, 'transform', cssMatrix);
        lastDx = dx;
        lastDy = dy;
        touchEvt = touch;
      }
      evt.cancelable && evt.preventDefault();
    }
  },
  _appendGhost: function _appendGhost() {
    // Bug if using scale(): https://stackoverflow.com/questions/2637058
    // Not being adjusted for
    if (!ghostEl) {
      var container = this.options.fallbackOnBody ? document.body : rootEl,
        rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container),
        options = this.options;

      // Position absolutely
      if (PositionGhostAbsolutely) {
        // Get relatively positioned parent
        ghostRelativeParent = container;
        while (css(ghostRelativeParent, 'position') === 'static' && css(ghostRelativeParent, 'transform') === 'none' && ghostRelativeParent !== document) {
          ghostRelativeParent = ghostRelativeParent.parentNode;
        }
        if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
          if (ghostRelativeParent === document) ghostRelativeParent = getWindowScrollingElement();
          rect.top += ghostRelativeParent.scrollTop;
          rect.left += ghostRelativeParent.scrollLeft;
        } else {
          ghostRelativeParent = getWindowScrollingElement();
        }
        ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
      }
      ghostEl = dragEl.cloneNode(true);
      toggleClass(ghostEl, options.ghostClass, false);
      toggleClass(ghostEl, options.fallbackClass, true);
      toggleClass(ghostEl, options.dragClass, true);
      css(ghostEl, 'transition', '');
      css(ghostEl, 'transform', '');
      css(ghostEl, 'box-sizing', 'border-box');
      css(ghostEl, 'margin', 0);
      css(ghostEl, 'top', rect.top);
      css(ghostEl, 'left', rect.left);
      css(ghostEl, 'width', rect.width);
      css(ghostEl, 'height', rect.height);
      css(ghostEl, 'opacity', '0.8');
      css(ghostEl, 'position', PositionGhostAbsolutely ? 'absolute' : 'fixed');
      css(ghostEl, 'zIndex', '100000');
      css(ghostEl, 'pointerEvents', 'none');
      Sortable.ghost = ghostEl;
      container.appendChild(ghostEl);

      // Set transform-origin
      css(ghostEl, 'transform-origin', tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + '% ' + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + '%');
    }
  },
  _onDragStart: function _onDragStart( /**Event*/evt, /**boolean*/fallback) {
    var _this = this;
    var dataTransfer = evt.dataTransfer;
    var options = _this.options;
    pluginEvent('dragStart', this, {
      evt: evt
    });
    if (Sortable.eventCanceled) {
      this._onDrop();
      return;
    }
    pluginEvent('setupClone', this);
    if (!Sortable.eventCanceled) {
      cloneEl = clone(dragEl);
      cloneEl.removeAttribute("id");
      cloneEl.draggable = false;
      cloneEl.style['will-change'] = '';
      this._hideClone();
      toggleClass(cloneEl, this.options.chosenClass, false);
      Sortable.clone = cloneEl;
    }

    // #1143: IFrame support workaround
    _this.cloneId = _nextTick(function () {
      pluginEvent('clone', _this);
      if (Sortable.eventCanceled) return;
      if (!_this.options.removeCloneOnHide) {
        rootEl.insertBefore(cloneEl, dragEl);
      }
      _this._hideClone();
      _dispatchEvent({
        sortable: _this,
        name: 'clone'
      });
    });
    !fallback && toggleClass(dragEl, options.dragClass, true);

    // Set proper drop events
    if (fallback) {
      ignoreNextClick = true;
      _this._loopId = setInterval(_this._emulateDragOver, 50);
    } else {
      // Undo what was set in _prepareDragStart before drag started
      off(document, 'mouseup', _this._onDrop);
      off(document, 'touchend', _this._onDrop);
      off(document, 'touchcancel', _this._onDrop);
      if (dataTransfer) {
        dataTransfer.effectAllowed = 'move';
        options.setData && options.setData.call(_this, dataTransfer, dragEl);
      }
      on(document, 'drop', _this);

      // #1276 fix:
      css(dragEl, 'transform', 'translateZ(0)');
    }
    awaitingDragStarted = true;
    _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
    on(document, 'selectstart', _this);
    moved = true;
    window.getSelection().removeAllRanges();
    if (Safari) {
      css(document.body, 'user-select', 'none');
    }
  },
  // Returns true - if no further action is needed (either inserted or another condition)
  _onDragOver: function _onDragOver( /**Event*/evt) {
    var el = this.el,
      target = evt.target,
      dragRect,
      targetRect,
      revert,
      options = this.options,
      group = options.group,
      activeSortable = Sortable.active,
      isOwner = activeGroup === group,
      canSort = options.sort,
      fromSortable = putSortable || activeSortable,
      vertical,
      _this = this,
      completedFired = false;
    if (_silent) return;
    function dragOverEvent(name, extra) {
      pluginEvent(name, _this, _objectSpread2({
        evt: evt,
        isOwner: isOwner,
        axis: vertical ? 'vertical' : 'horizontal',
        revert: revert,
        dragRect: dragRect,
        targetRect: targetRect,
        canSort: canSort,
        fromSortable: fromSortable,
        target: target,
        completed: completed,
        onMove: function onMove(target, after) {
          return _onMove(rootEl, el, dragEl, dragRect, target, getRect(target), evt, after);
        },
        changed: changed
      }, extra));
    }

    // Capture animation state
    function capture() {
      dragOverEvent('dragOverAnimationCapture');
      _this.captureAnimationState();
      if (_this !== fromSortable) {
        fromSortable.captureAnimationState();
      }
    }

    // Return invocation when dragEl is inserted (or completed)
    function completed(insertion) {
      dragOverEvent('dragOverCompleted', {
        insertion: insertion
      });
      if (insertion) {
        // Clones must be hidden before folding animation to capture dragRectAbsolute properly
        if (isOwner) {
          activeSortable._hideClone();
        } else {
          activeSortable._showClone(_this);
        }
        if (_this !== fromSortable) {
          // Set ghost class to new sortable's ghost class
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
          toggleClass(dragEl, options.ghostClass, true);
        }
        if (putSortable !== _this && _this !== Sortable.active) {
          putSortable = _this;
        } else if (_this === Sortable.active && putSortable) {
          putSortable = null;
        }

        // Animation
        if (fromSortable === _this) {
          _this._ignoreWhileAnimating = target;
        }
        _this.animateAll(function () {
          dragOverEvent('dragOverAnimationComplete');
          _this._ignoreWhileAnimating = null;
        });
        if (_this !== fromSortable) {
          fromSortable.animateAll();
          fromSortable._ignoreWhileAnimating = null;
        }
      }

      // Null lastTarget if it is not inside a previously swapped element
      if (target === dragEl && !dragEl.animated || target === el && !target.animated) {
        lastTarget = null;
      }

      // no bubbling and not fallback
      if (!options.dragoverBubble && !evt.rootEl && target !== document) {
        dragEl.parentNode[expando]._isOutsideThisEl(evt.target);

        // Do not detect for empty insert if already inserted
        !insertion && nearestEmptyInsertDetectEvent(evt);
      }
      !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
      return completedFired = true;
    }

    // Call when dragEl has been inserted
    function changed() {
      newIndex = index(dragEl);
      newDraggableIndex = index(dragEl, options.draggable);
      _dispatchEvent({
        sortable: _this,
        name: 'change',
        toEl: el,
        newIndex: newIndex,
        newDraggableIndex: newDraggableIndex,
        originalEvent: evt
      });
    }
    if (evt.preventDefault !== void 0) {
      evt.cancelable && evt.preventDefault();
    }
    target = closest(target, options.draggable, el, true);
    dragOverEvent('dragOver');
    if (Sortable.eventCanceled) return completedFired;
    if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
      return completed(false);
    }
    ignoreNextClick = false;
    if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) // Reverting item into the original list
    : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
      vertical = this._getDirection(evt, target) === 'vertical';
      dragRect = getRect(dragEl);
      dragOverEvent('dragOverValid');
      if (Sortable.eventCanceled) return completedFired;
      if (revert) {
        parentEl = rootEl; // actualization
        capture();
        this._hideClone();
        dragOverEvent('revert');
        if (!Sortable.eventCanceled) {
          if (nextEl) {
            rootEl.insertBefore(dragEl, nextEl);
          } else {
            rootEl.appendChild(dragEl);
          }
        }
        return completed(true);
      }
      var elLastChild = lastChild(el, options.draggable);
      if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
        // Insert to end of list

        // If already at end of list: Do not insert
        if (elLastChild === dragEl) {
          return completed(false);
        }

        // if there is a last element, it is the target
        if (elLastChild && el === evt.target) {
          target = elLastChild;
        }
        if (target) {
          targetRect = getRect(target);
        }
        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
          capture();
          if (elLastChild && elLastChild.nextSibling) {
            // the last draggable element is not the last node
            el.insertBefore(dragEl, elLastChild.nextSibling);
          } else {
            el.appendChild(dragEl);
          }
          parentEl = el; // actualization

          changed();
          return completed(true);
        }
      } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {
        // Insert to start of list
        var firstChild = getChild(el, 0, options, true);
        if (firstChild === dragEl) {
          return completed(false);
        }
        target = firstChild;
        targetRect = getRect(target);
        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, false) !== false) {
          capture();
          el.insertBefore(dragEl, firstChild);
          parentEl = el; // actualization

          changed();
          return completed(true);
        }
      } else if (target.parentNode === el) {
        targetRect = getRect(target);
        var direction = 0,
          targetBeforeFirstSwap,
          differentLevel = dragEl.parentNode !== el,
          differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical),
          side1 = vertical ? 'top' : 'left',
          scrolledPastTop = isScrolledPast(target, 'top', 'top') || isScrolledPast(dragEl, 'top', 'top'),
          scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;
        if (lastTarget !== target) {
          targetBeforeFirstSwap = targetRect[side1];
          pastFirstInvertThresh = false;
          isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
        }
        direction = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
        var sibling;
        if (direction !== 0) {
          // Check if target is beside dragEl in respective direction (ignoring hidden elements)
          var dragIndex = index(dragEl);
          do {
            dragIndex -= direction;
            sibling = parentEl.children[dragIndex];
          } while (sibling && (css(sibling, 'display') === 'none' || sibling === ghostEl));
        }
        // If dragEl is already beside target: Do not insert
        if (direction === 0 || sibling === target) {
          return completed(false);
        }
        lastTarget = target;
        lastDirection = direction;
        var nextSibling = target.nextElementSibling,
          after = false;
        after = direction === 1;
        var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);
        if (moveVector !== false) {
          if (moveVector === 1 || moveVector === -1) {
            after = moveVector === 1;
          }
          _silent = true;
          setTimeout(_unsilent, 30);
          capture();
          if (after && !nextSibling) {
            el.appendChild(dragEl);
          } else {
            target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
          }

          // Undo chrome's scroll adjustment (has no effect on other browsers)
          if (scrolledPastTop) {
            scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
          }
          parentEl = dragEl.parentNode; // actualization

          // must be done before animation
          if (targetBeforeFirstSwap !== undefined && !isCircumstantialInvert) {
            targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
          }
          changed();
          return completed(true);
        }
      }
      if (el.contains(dragEl)) {
        return completed(false);
      }
    }
    return false;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function _offMoveEvents() {
    off(document, 'mousemove', this._onTouchMove);
    off(document, 'touchmove', this._onTouchMove);
    off(document, 'pointermove', this._onTouchMove);
    off(document, 'dragover', nearestEmptyInsertDetectEvent);
    off(document, 'mousemove', nearestEmptyInsertDetectEvent);
    off(document, 'touchmove', nearestEmptyInsertDetectEvent);
  },
  _offUpEvents: function _offUpEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, 'mouseup', this._onDrop);
    off(ownerDocument, 'touchend', this._onDrop);
    off(ownerDocument, 'pointerup', this._onDrop);
    off(ownerDocument, 'pointercancel', this._onDrop);
    off(ownerDocument, 'touchcancel', this._onDrop);
    off(document, 'selectstart', this);
  },
  _onDrop: function _onDrop( /**Event*/evt) {
    var el = this.el,
      options = this.options;

    // Get the index of the dragged element within its parent
    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);
    pluginEvent('drop', this, {
      evt: evt
    });
    parentEl = dragEl && dragEl.parentNode;

    // Get again after plugin event
    newIndex = index(dragEl);
    newDraggableIndex = index(dragEl, options.draggable);
    if (Sortable.eventCanceled) {
      this._nulling();
      return;
    }
    awaitingDragStarted = false;
    isCircumstantialInvert = false;
    pastFirstInvertThresh = false;
    clearInterval(this._loopId);
    clearTimeout(this._dragStartTimer);
    _cancelNextTick(this.cloneId);
    _cancelNextTick(this._dragStartId);

    // Unbind events
    if (this.nativeDraggable) {
      off(document, 'drop', this);
      off(el, 'dragstart', this._onDragStart);
    }
    this._offMoveEvents();
    this._offUpEvents();
    if (Safari) {
      css(document.body, 'user-select', '');
    }
    css(dragEl, 'transform', '');
    if (evt) {
      if (moved) {
        evt.cancelable && evt.preventDefault();
        !options.dropBubble && evt.stopPropagation();
      }
      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);
      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {
        // Remove clone(s)
        cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
      }
      if (dragEl) {
        if (this.nativeDraggable) {
          off(dragEl, 'dragend', this);
        }
        _disableDraggable(dragEl);
        dragEl.style['will-change'] = '';

        // Remove classes
        // ghostClass is added in dragStarted
        if (moved && !awaitingDragStarted) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
        }
        toggleClass(dragEl, this.options.chosenClass, false);

        // Drag stop event
        _dispatchEvent({
          sortable: this,
          name: 'unchoose',
          toEl: parentEl,
          newIndex: null,
          newDraggableIndex: null,
          originalEvent: evt
        });
        if (rootEl !== parentEl) {
          if (newIndex >= 0) {
            // Add event
            _dispatchEvent({
              rootEl: parentEl,
              name: 'add',
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });

            // Remove event
            _dispatchEvent({
              sortable: this,
              name: 'remove',
              toEl: parentEl,
              originalEvent: evt
            });

            // drag from one list and drop into another
            _dispatchEvent({
              rootEl: parentEl,
              name: 'sort',
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });
            _dispatchEvent({
              sortable: this,
              name: 'sort',
              toEl: parentEl,
              originalEvent: evt
            });
          }
          putSortable && putSortable.save();
        } else {
          if (newIndex !== oldIndex) {
            if (newIndex >= 0) {
              // drag & drop within the same list
              _dispatchEvent({
                sortable: this,
                name: 'update',
                toEl: parentEl,
                originalEvent: evt
              });
              _dispatchEvent({
                sortable: this,
                name: 'sort',
                toEl: parentEl,
                originalEvent: evt
              });
            }
          }
        }
        if (Sortable.active) {
          /* jshint eqnull:true */
          if (newIndex == null || newIndex === -1) {
            newIndex = oldIndex;
            newDraggableIndex = oldDraggableIndex;
          }
          _dispatchEvent({
            sortable: this,
            name: 'end',
            toEl: parentEl,
            originalEvent: evt
          });

          // Save sorting
          this.save();
        }
      }
    }
    this._nulling();
  },
  _nulling: function _nulling() {
    pluginEvent('nulling', this);
    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
    savedInputChecked.forEach(function (el) {
      el.checked = true;
    });
    savedInputChecked.length = lastDx = lastDy = 0;
  },
  handleEvent: function handleEvent( /**Event*/evt) {
    switch (evt.type) {
      case 'drop':
      case 'dragend':
        this._onDrop(evt);
        break;
      case 'dragenter':
      case 'dragover':
        if (dragEl) {
          this._onDragOver(evt);
          _globalDragOver(evt);
        }
        break;
      case 'selectstart':
        evt.preventDefault();
        break;
    }
  },
  /**
   * Serializes the item into an array of string.
   * @returns {String[]}
   */
  toArray: function toArray() {
    var order = [],
      el,
      children = this.el.children,
      i = 0,
      n = children.length,
      options = this.options;
    for (; i < n; i++) {
      el = children[i];
      if (closest(el, options.draggable, this.el, false)) {
        order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
      }
    }
    return order;
  },
  /**
   * Sorts the elements according to the array.
   * @param  {String[]}  order  order of the items
   */
  sort: function sort(order, useAnimation) {
    var items = {},
      rootEl = this.el;
    this.toArray().forEach(function (id, i) {
      var el = rootEl.children[i];
      if (closest(el, this.options.draggable, rootEl, false)) {
        items[id] = el;
      }
    }, this);
    useAnimation && this.captureAnimationState();
    order.forEach(function (id) {
      if (items[id]) {
        rootEl.removeChild(items[id]);
        rootEl.appendChild(items[id]);
      }
    });
    useAnimation && this.animateAll();
  },
  /**
   * Save the current sorting
   */
  save: function save() {
    var store = this.options.store;
    store && store.set && store.set(this);
  },
  /**
   * For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
   * @param   {HTMLElement}  el
   * @param   {String}       [selector]  default: `options.draggable`
   * @returns {HTMLElement|null}
   */
  closest: function closest$1(el, selector) {
    return closest(el, selector || this.options.draggable, this.el, false);
  },
  /**
   * Set/get option
   * @param   {string} name
   * @param   {*}      [value]
   * @returns {*}
   */
  option: function option(name, value) {
    var options = this.options;
    if (value === void 0) {
      return options[name];
    } else {
      var modifiedValue = PluginManager.modifyOption(this, name, value);
      if (typeof modifiedValue !== 'undefined') {
        options[name] = modifiedValue;
      } else {
        options[name] = value;
      }
      if (name === 'group') {
        _prepareGroup(options);
      }
    }
  },
  /**
   * Destroy
   */
  destroy: function destroy() {
    pluginEvent('destroy', this);
    var el = this.el;
    el[expando] = null;
    off(el, 'mousedown', this._onTapStart);
    off(el, 'touchstart', this._onTapStart);
    off(el, 'pointerdown', this._onTapStart);
    if (this.nativeDraggable) {
      off(el, 'dragover', this);
      off(el, 'dragenter', this);
    }
    // Remove draggable attributes
    Array.prototype.forEach.call(el.querySelectorAll('[draggable]'), function (el) {
      el.removeAttribute('draggable');
    });
    this._onDrop();
    this._disableDelayedDragEvents();
    sortables.splice(sortables.indexOf(this.el), 1);
    this.el = el = null;
  },
  _hideClone: function _hideClone() {
    if (!cloneHidden) {
      pluginEvent('hideClone', this);
      if (Sortable.eventCanceled) return;
      css(cloneEl, 'display', 'none');
      if (this.options.removeCloneOnHide && cloneEl.parentNode) {
        cloneEl.parentNode.removeChild(cloneEl);
      }
      cloneHidden = true;
    }
  },
  _showClone: function _showClone(putSortable) {
    if (putSortable.lastPutMode !== 'clone') {
      this._hideClone();
      return;
    }
    if (cloneHidden) {
      pluginEvent('showClone', this);
      if (Sortable.eventCanceled) return;

      // show clone at dragEl or original position
      if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {
        rootEl.insertBefore(cloneEl, dragEl);
      } else if (nextEl) {
        rootEl.insertBefore(cloneEl, nextEl);
      } else {
        rootEl.appendChild(cloneEl);
      }
      if (this.options.group.revertClone) {
        this.animate(dragEl, cloneEl);
      }
      css(cloneEl, 'display', '');
      cloneHidden = false;
    }
  }
};
function _globalDragOver( /**Event*/evt) {
  if (evt.dataTransfer) {
    evt.dataTransfer.dropEffect = 'move';
  }
  evt.cancelable && evt.preventDefault();
}
function _onMove(fromEl, toEl, dragEl, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
  var evt,
    sortable = fromEl[expando],
    onMoveFn = sortable.options.onMove,
    retVal;
  // Support for new CustomEvent feature
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent('move', {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent('Event');
    evt.initEvent('move', true, true);
  }
  evt.to = toEl;
  evt.from = fromEl;
  evt.dragged = dragEl;
  evt.draggedRect = dragRect;
  evt.related = targetEl || toEl;
  evt.relatedRect = targetRect || getRect(toEl);
  evt.willInsertAfter = willInsertAfter;
  evt.originalEvent = originalEvent;
  fromEl.dispatchEvent(evt);
  if (onMoveFn) {
    retVal = onMoveFn.call(sortable, evt, originalEvent);
  }
  return retVal;
}
function _disableDraggable(el) {
  el.draggable = false;
}
function _unsilent() {
  _silent = false;
}
function _ghostIsFirst(evt, vertical, sortable) {
  var firstElRect = getRect(getChild(sortable.el, 0, sortable.options, true));
  var childContainingRect = getChildContainingRectFromElement(sortable.el, sortable.options, ghostEl);
  var spacer = 10;
  return vertical ? evt.clientX < childContainingRect.left - spacer || evt.clientY < firstElRect.top && evt.clientX < firstElRect.right : evt.clientY < childContainingRect.top - spacer || evt.clientY < firstElRect.bottom && evt.clientX < firstElRect.left;
}
function _ghostIsLast(evt, vertical, sortable) {
  var lastElRect = getRect(lastChild(sortable.el, sortable.options.draggable));
  var childContainingRect = getChildContainingRectFromElement(sortable.el, sortable.options, ghostEl);
  var spacer = 10;
  return vertical ? evt.clientX > childContainingRect.right + spacer || evt.clientY > lastElRect.bottom && evt.clientX > lastElRect.left : evt.clientY > childContainingRect.bottom + spacer || evt.clientX > lastElRect.right && evt.clientY > lastElRect.top;
}
function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
  var mouseOnAxis = vertical ? evt.clientY : evt.clientX,
    targetLength = vertical ? targetRect.height : targetRect.width,
    targetS1 = vertical ? targetRect.top : targetRect.left,
    targetS2 = vertical ? targetRect.bottom : targetRect.right,
    invert = false;
  if (!invertSwap) {
    // Never invert or create dragEl shadow when target movemenet causes mouse to move past the end of regular swapThreshold
    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
      // multiplied only by swapThreshold because mouse will already be inside target by (1 - threshold) * targetLength / 2
      // check if past first invert threshold on side opposite of lastDirection
      if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
        // past first invert threshold, do not restrict inverted threshold to dragEl shadow
        pastFirstInvertThresh = true;
      }
      if (!pastFirstInvertThresh) {
        // dragEl shadow (target move distance shadow)
        if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance // over dragEl shadow
        : mouseOnAxis > targetS2 - targetMoveDistance) {
          return -lastDirection;
        }
      } else {
        invert = true;
      }
    } else {
      // Regular
      if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
        return _getInsertDirection(target);
      }
    }
  }
  invert = invert || invertSwap;
  if (invert) {
    // Invert of regular
    if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
    }
  }
  return 0;
}

/**
 * Gets the direction dragEl must be swapped relative to target in order to make it
 * seem that dragEl has been "inserted" into that element's position
 * @param  {HTMLElement} target       The target whose position dragEl is being inserted at
 * @return {Number}                   Direction dragEl must be swapped
 */
function _getInsertDirection(target) {
  if (index(dragEl) < index(target)) {
    return 1;
  } else {
    return -1;
  }
}

/**
 * Generate id
 * @param   {HTMLElement} el
 * @returns {String}
 * @private
 */
function _generateId(el) {
  var str = el.tagName + el.className + el.src + el.href + el.textContent,
    i = str.length,
    sum = 0;
  while (i--) {
    sum += str.charCodeAt(i);
  }
  return sum.toString(36);
}
function _saveInputCheckedState(root) {
  savedInputChecked.length = 0;
  var inputs = root.getElementsByTagName('input');
  var idx = inputs.length;
  while (idx--) {
    var el = inputs[idx];
    el.checked && savedInputChecked.push(el);
  }
}
function _nextTick(fn) {
  return setTimeout(fn, 0);
}
function _cancelNextTick(id) {
  return clearTimeout(id);
}

// Fixed #973:
if (documentExists) {
  on(document, 'touchmove', function (evt) {
    if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
      evt.preventDefault();
    }
  });
}

// Export utils
Sortable.utils = {
  on: on,
  off: off,
  css: css,
  find: find,
  is: function is(el, selector) {
    return !!closest(el, selector, el, false);
  },
  extend: extend,
  throttle: throttle,
  closest: closest,
  toggleClass: toggleClass,
  clone: clone,
  index: index,
  nextTick: _nextTick,
  cancelNextTick: _cancelNextTick,
  detectDirection: _detectDirection,
  getChild: getChild,
  expando: expando
};

/**
 * Get the Sortable instance of an element
 * @param  {HTMLElement} element The element
 * @return {Sortable|undefined}         The instance of Sortable
 */
Sortable.get = function (element) {
  return element[expando];
};

/**
 * Mount a plugin to Sortable
 * @param  {...SortablePlugin|SortablePlugin[]} plugins       Plugins being mounted
 */
Sortable.mount = function () {
  for (var _len = arguments.length, plugins = new Array(_len), _key = 0; _key < _len; _key++) {
    plugins[_key] = arguments[_key];
  }
  if (plugins[0].constructor === Array) plugins = plugins[0];
  plugins.forEach(function (plugin) {
    if (!plugin.prototype || !plugin.prototype.constructor) {
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
    }
    if (plugin.utils) Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin.utils);
    PluginManager.mount(plugin);
  });
};

/**
 * Create sortable instance
 * @param {HTMLElement}  el
 * @param {Object}      [options]
 */
Sortable.create = function (el, options) {
  return new Sortable(el, options);
};

// Export
Sortable.version = version;

var autoScrolls = [],
  scrollEl,
  scrollRootEl,
  scrolling = false,
  lastAutoScrollX,
  lastAutoScrollY,
  touchEvt$1,
  pointerElemChangedInterval;
function AutoScrollPlugin() {
  function AutoScroll() {
    this.defaults = {
      scroll: true,
      forceAutoScrollFallback: false,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: true
    };

    // Bind all private methods
    for (var fn in this) {
      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
        this[fn] = this[fn].bind(this);
      }
    }
  }
  AutoScroll.prototype = {
    dragStarted: function dragStarted(_ref) {
      var originalEvent = _ref.originalEvent;
      if (this.sortable.nativeDraggable) {
        on(document, 'dragover', this._handleAutoScroll);
      } else {
        if (this.options.supportPointer) {
          on(document, 'pointermove', this._handleFallbackAutoScroll);
        } else if (originalEvent.touches) {
          on(document, 'touchmove', this._handleFallbackAutoScroll);
        } else {
          on(document, 'mousemove', this._handleFallbackAutoScroll);
        }
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref2) {
      var originalEvent = _ref2.originalEvent;
      // For when bubbling is canceled and using fallback (fallback 'touchmove' always reached)
      if (!this.options.dragOverBubble && !originalEvent.rootEl) {
        this._handleAutoScroll(originalEvent);
      }
    },
    drop: function drop() {
      if (this.sortable.nativeDraggable) {
        off(document, 'dragover', this._handleAutoScroll);
      } else {
        off(document, 'pointermove', this._handleFallbackAutoScroll);
        off(document, 'touchmove', this._handleFallbackAutoScroll);
        off(document, 'mousemove', this._handleFallbackAutoScroll);
      }
      clearPointerElemChangedInterval();
      clearAutoScrolls();
      cancelThrottle();
    },
    nulling: function nulling() {
      touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
      autoScrolls.length = 0;
    },
    _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
      this._handleAutoScroll(evt, true);
    },
    _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
      var _this = this;
      var x = (evt.touches ? evt.touches[0] : evt).clientX,
        y = (evt.touches ? evt.touches[0] : evt).clientY,
        elem = document.elementFromPoint(x, y);
      touchEvt$1 = evt;

      // IE does not seem to have native autoscroll,
      // Edge's autoscroll seems too conditional,
      // MACOS Safari does not have autoscroll,
      // Firefox and Chrome are good
      if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {
        autoScroll(evt, this.options, elem, fallback);

        // Listener for pointer element change
        var ogElemScroller = getParentAutoScrollElement(elem, true);
        if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y !== lastAutoScrollY)) {
          pointerElemChangedInterval && clearPointerElemChangedInterval();
          // Detect for pointer elem change, emulating native DnD behaviour
          pointerElemChangedInterval = setInterval(function () {
            var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y), true);
            if (newElem !== ogElemScroller) {
              ogElemScroller = newElem;
              clearAutoScrolls();
            }
            autoScroll(evt, _this.options, newElem, fallback);
          }, 10);
          lastAutoScrollX = x;
          lastAutoScrollY = y;
        }
      } else {
        // if DnD is enabled (and browser has good autoscrolling), first autoscroll will already scroll, so get parent autoscroll of first autoscroll
        if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
          clearAutoScrolls();
          return;
        }
        autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
      }
    }
  };
  return _extends(AutoScroll, {
    pluginName: 'scroll',
    initializeByDefault: true
  });
}
function clearAutoScrolls() {
  autoScrolls.forEach(function (autoScroll) {
    clearInterval(autoScroll.pid);
  });
  autoScrolls = [];
}
function clearPointerElemChangedInterval() {
  clearInterval(pointerElemChangedInterval);
}
var autoScroll = throttle(function (evt, options, rootEl, isFallback) {
  // Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=505521
  if (!options.scroll) return;
  var x = (evt.touches ? evt.touches[0] : evt).clientX,
    y = (evt.touches ? evt.touches[0] : evt).clientY,
    sens = options.scrollSensitivity,
    speed = options.scrollSpeed,
    winScroller = getWindowScrollingElement();
  var scrollThisInstance = false,
    scrollCustomFn;

  // New scroll root, set scrollEl
  if (scrollRootEl !== rootEl) {
    scrollRootEl = rootEl;
    clearAutoScrolls();
    scrollEl = options.scroll;
    scrollCustomFn = options.scrollFn;
    if (scrollEl === true) {
      scrollEl = getParentAutoScrollElement(rootEl, true);
    }
  }
  var layersOut = 0;
  var currentParent = scrollEl;
  do {
    var el = currentParent,
      rect = getRect(el),
      top = rect.top,
      bottom = rect.bottom,
      left = rect.left,
      right = rect.right,
      width = rect.width,
      height = rect.height,
      canScrollX = void 0,
      canScrollY = void 0,
      scrollWidth = el.scrollWidth,
      scrollHeight = el.scrollHeight,
      elCSS = css(el),
      scrollPosX = el.scrollLeft,
      scrollPosY = el.scrollTop;
    if (el === winScroller) {
      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll' || elCSS.overflowX === 'visible');
      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll' || elCSS.overflowY === 'visible');
    } else {
      canScrollX = width < scrollWidth && (elCSS.overflowX === 'auto' || elCSS.overflowX === 'scroll');
      canScrollY = height < scrollHeight && (elCSS.overflowY === 'auto' || elCSS.overflowY === 'scroll');
    }
    var vx = canScrollX && (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x) <= sens && !!scrollPosX);
    var vy = canScrollY && (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y) <= sens && !!scrollPosY);
    if (!autoScrolls[layersOut]) {
      for (var i = 0; i <= layersOut; i++) {
        if (!autoScrolls[i]) {
          autoScrolls[i] = {};
        }
      }
    }
    if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
      autoScrolls[layersOut].el = el;
      autoScrolls[layersOut].vx = vx;
      autoScrolls[layersOut].vy = vy;
      clearInterval(autoScrolls[layersOut].pid);
      if (vx != 0 || vy != 0) {
        scrollThisInstance = true;
        /* jshint loopfunc:true */
        autoScrolls[layersOut].pid = setInterval(function () {
          // emulate drag over during autoscroll (fallback), emulating native DnD behaviour
          if (isFallback && this.layer === 0) {
            Sortable.active._onTouchMove(touchEvt$1); // To move ghost if it is positioned absolutely
          }
          var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
          var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;
          if (typeof scrollCustomFn === 'function') {
            if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== 'continue') {
              return;
            }
          }
          scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
        }.bind({
          layer: layersOut
        }), 24);
      }
    }
    layersOut++;
  } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));
  scrolling = scrollThisInstance; // in case another function catches scrolling as false in between when it is not
}, 30);

var drop = function drop(_ref) {
  var originalEvent = _ref.originalEvent,
    putSortable = _ref.putSortable,
    dragEl = _ref.dragEl,
    activeSortable = _ref.activeSortable,
    dispatchSortableEvent = _ref.dispatchSortableEvent,
    hideGhostForTarget = _ref.hideGhostForTarget,
    unhideGhostForTarget = _ref.unhideGhostForTarget;
  if (!originalEvent) return;
  var toSortable = putSortable || activeSortable;
  hideGhostForTarget();
  var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
  var target = document.elementFromPoint(touch.clientX, touch.clientY);
  unhideGhostForTarget();
  if (toSortable && !toSortable.el.contains(target)) {
    dispatchSortableEvent('spill');
    this.onSpill({
      dragEl: dragEl,
      putSortable: putSortable
    });
  }
};
function Revert() {}
Revert.prototype = {
  startIndex: null,
  dragStart: function dragStart(_ref2) {
    var oldDraggableIndex = _ref2.oldDraggableIndex;
    this.startIndex = oldDraggableIndex;
  },
  onSpill: function onSpill(_ref3) {
    var dragEl = _ref3.dragEl,
      putSortable = _ref3.putSortable;
    this.sortable.captureAnimationState();
    if (putSortable) {
      putSortable.captureAnimationState();
    }
    var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);
    if (nextSibling) {
      this.sortable.el.insertBefore(dragEl, nextSibling);
    } else {
      this.sortable.el.appendChild(dragEl);
    }
    this.sortable.animateAll();
    if (putSortable) {
      putSortable.animateAll();
    }
  },
  drop: drop
};
_extends(Revert, {
  pluginName: 'revertOnSpill'
});
function Remove() {}
Remove.prototype = {
  onSpill: function onSpill(_ref4) {
    var dragEl = _ref4.dragEl,
      putSortable = _ref4.putSortable;
    var parentSortable = putSortable || this.sortable;
    parentSortable.captureAnimationState();
    dragEl.parentNode && dragEl.parentNode.removeChild(dragEl);
    parentSortable.animateAll();
  },
  drop: drop
};
_extends(Remove, {
  pluginName: 'removeOnSpill'
});

var lastSwapEl;
function SwapPlugin() {
  function Swap() {
    this.defaults = {
      swapClass: 'sortable-swap-highlight'
    };
  }
  Swap.prototype = {
    dragStart: function dragStart(_ref) {
      var dragEl = _ref.dragEl;
      lastSwapEl = dragEl;
    },
    dragOverValid: function dragOverValid(_ref2) {
      var completed = _ref2.completed,
        target = _ref2.target,
        onMove = _ref2.onMove,
        activeSortable = _ref2.activeSortable,
        changed = _ref2.changed,
        cancel = _ref2.cancel;
      if (!activeSortable.options.swap) return;
      var el = this.sortable.el,
        options = this.options;
      if (target && target !== el) {
        var prevSwapEl = lastSwapEl;
        if (onMove(target) !== false) {
          toggleClass(target, options.swapClass, true);
          lastSwapEl = target;
        } else {
          lastSwapEl = null;
        }
        if (prevSwapEl && prevSwapEl !== lastSwapEl) {
          toggleClass(prevSwapEl, options.swapClass, false);
        }
      }
      changed();
      completed(true);
      cancel();
    },
    drop: function drop(_ref3) {
      var activeSortable = _ref3.activeSortable,
        putSortable = _ref3.putSortable,
        dragEl = _ref3.dragEl;
      var toSortable = putSortable || this.sortable;
      var options = this.options;
      lastSwapEl && toggleClass(lastSwapEl, options.swapClass, false);
      if (lastSwapEl && (options.swap || putSortable && putSortable.options.swap)) {
        if (dragEl !== lastSwapEl) {
          toSortable.captureAnimationState();
          if (toSortable !== activeSortable) activeSortable.captureAnimationState();
          swapNodes(dragEl, lastSwapEl);
          toSortable.animateAll();
          if (toSortable !== activeSortable) activeSortable.animateAll();
        }
      }
    },
    nulling: function nulling() {
      lastSwapEl = null;
    }
  };
  return _extends(Swap, {
    pluginName: 'swap',
    eventProperties: function eventProperties() {
      return {
        swapItem: lastSwapEl
      };
    }
  });
}
function swapNodes(n1, n2) {
  var p1 = n1.parentNode,
    p2 = n2.parentNode,
    i1,
    i2;
  if (!p1 || !p2 || p1.isEqualNode(n2) || p2.isEqualNode(n1)) return;
  i1 = index(n1);
  i2 = index(n2);
  if (p1.isEqualNode(p2) && i1 < i2) {
    i2++;
  }
  p1.insertBefore(n2, p1.children[i1]);
  p2.insertBefore(n1, p2.children[i2]);
}

var multiDragElements = [],
  multiDragClones = [],
  lastMultiDragSelect,
  // for selection with modifier key down (SHIFT)
  multiDragSortable,
  initialFolding = false,
  // Initial multi-drag fold when drag started
  folding = false,
  // Folding any other time
  dragStarted = false,
  dragEl$1,
  clonesFromRect,
  clonesHidden;
function MultiDragPlugin() {
  function MultiDrag(sortable) {
    // Bind all private methods
    for (var fn in this) {
      if (fn.charAt(0) === '_' && typeof this[fn] === 'function') {
        this[fn] = this[fn].bind(this);
      }
    }
    if (!sortable.options.avoidImplicitDeselect) {
      if (sortable.options.supportPointer) {
        on(document, 'pointerup', this._deselectMultiDrag);
      } else {
        on(document, 'mouseup', this._deselectMultiDrag);
        on(document, 'touchend', this._deselectMultiDrag);
      }
    }
    on(document, 'keydown', this._checkKeyDown);
    on(document, 'keyup', this._checkKeyUp);
    this.defaults = {
      selectedClass: 'sortable-selected',
      multiDragKey: null,
      avoidImplicitDeselect: false,
      setData: function setData(dataTransfer, dragEl) {
        var data = '';
        if (multiDragElements.length && multiDragSortable === sortable) {
          multiDragElements.forEach(function (multiDragElement, i) {
            data += (!i ? '' : ', ') + multiDragElement.textContent;
          });
        } else {
          data = dragEl.textContent;
        }
        dataTransfer.setData('Text', data);
      }
    };
  }
  MultiDrag.prototype = {
    multiDragKeyDown: false,
    isMultiDrag: false,
    delayStartGlobal: function delayStartGlobal(_ref) {
      var dragged = _ref.dragEl;
      dragEl$1 = dragged;
    },
    delayEnded: function delayEnded() {
      this.isMultiDrag = ~multiDragElements.indexOf(dragEl$1);
    },
    setupClone: function setupClone(_ref2) {
      var sortable = _ref2.sortable,
        cancel = _ref2.cancel;
      if (!this.isMultiDrag) return;
      for (var i = 0; i < multiDragElements.length; i++) {
        multiDragClones.push(clone(multiDragElements[i]));
        multiDragClones[i].sortableIndex = multiDragElements[i].sortableIndex;
        multiDragClones[i].draggable = false;
        multiDragClones[i].style['will-change'] = '';
        toggleClass(multiDragClones[i], this.options.selectedClass, false);
        multiDragElements[i] === dragEl$1 && toggleClass(multiDragClones[i], this.options.chosenClass, false);
      }
      sortable._hideClone();
      cancel();
    },
    clone: function clone(_ref3) {
      var sortable = _ref3.sortable,
        rootEl = _ref3.rootEl,
        dispatchSortableEvent = _ref3.dispatchSortableEvent,
        cancel = _ref3.cancel;
      if (!this.isMultiDrag) return;
      if (!this.options.removeCloneOnHide) {
        if (multiDragElements.length && multiDragSortable === sortable) {
          insertMultiDragClones(true, rootEl);
          dispatchSortableEvent('clone');
          cancel();
        }
      }
    },
    showClone: function showClone(_ref4) {
      var cloneNowShown = _ref4.cloneNowShown,
        rootEl = _ref4.rootEl,
        cancel = _ref4.cancel;
      if (!this.isMultiDrag) return;
      insertMultiDragClones(false, rootEl);
      multiDragClones.forEach(function (clone) {
        css(clone, 'display', '');
      });
      cloneNowShown();
      clonesHidden = false;
      cancel();
    },
    hideClone: function hideClone(_ref5) {
      var _this = this;
      var sortable = _ref5.sortable,
        cloneNowHidden = _ref5.cloneNowHidden,
        cancel = _ref5.cancel;
      if (!this.isMultiDrag) return;
      multiDragClones.forEach(function (clone) {
        css(clone, 'display', 'none');
        if (_this.options.removeCloneOnHide && clone.parentNode) {
          clone.parentNode.removeChild(clone);
        }
      });
      cloneNowHidden();
      clonesHidden = true;
      cancel();
    },
    dragStartGlobal: function dragStartGlobal(_ref6) {
      var sortable = _ref6.sortable;
      if (!this.isMultiDrag && multiDragSortable) {
        multiDragSortable.multiDrag._deselectMultiDrag();
      }
      multiDragElements.forEach(function (multiDragElement) {
        multiDragElement.sortableIndex = index(multiDragElement);
      });

      // Sort multi-drag elements
      multiDragElements = multiDragElements.sort(function (a, b) {
        return a.sortableIndex - b.sortableIndex;
      });
      dragStarted = true;
    },
    dragStarted: function dragStarted(_ref7) {
      var _this2 = this;
      var sortable = _ref7.sortable;
      if (!this.isMultiDrag) return;
      if (this.options.sort) {
        // Capture rects,
        // hide multi drag elements (by positioning them absolute),
        // set multi drag elements rects to dragRect,
        // show multi drag elements,
        // animate to rects,
        // unset rects & remove from DOM

        sortable.captureAnimationState();
        if (this.options.animation) {
          multiDragElements.forEach(function (multiDragElement) {
            if (multiDragElement === dragEl$1) return;
            css(multiDragElement, 'position', 'absolute');
          });
          var dragRect = getRect(dragEl$1, false, true, true);
          multiDragElements.forEach(function (multiDragElement) {
            if (multiDragElement === dragEl$1) return;
            setRect(multiDragElement, dragRect);
          });
          folding = true;
          initialFolding = true;
        }
      }
      sortable.animateAll(function () {
        folding = false;
        initialFolding = false;
        if (_this2.options.animation) {
          multiDragElements.forEach(function (multiDragElement) {
            unsetRect(multiDragElement);
          });
        }

        // Remove all auxiliary multidrag items from el, if sorting enabled
        if (_this2.options.sort) {
          removeMultiDragElements();
        }
      });
    },
    dragOver: function dragOver(_ref8) {
      var target = _ref8.target,
        completed = _ref8.completed,
        cancel = _ref8.cancel;
      if (folding && ~multiDragElements.indexOf(target)) {
        completed(false);
        cancel();
      }
    },
    revert: function revert(_ref9) {
      var fromSortable = _ref9.fromSortable,
        rootEl = _ref9.rootEl,
        sortable = _ref9.sortable,
        dragRect = _ref9.dragRect;
      if (multiDragElements.length > 1) {
        // Setup unfold animation
        multiDragElements.forEach(function (multiDragElement) {
          sortable.addAnimationState({
            target: multiDragElement,
            rect: folding ? getRect(multiDragElement) : dragRect
          });
          unsetRect(multiDragElement);
          multiDragElement.fromRect = dragRect;
          fromSortable.removeAnimationState(multiDragElement);
        });
        folding = false;
        insertMultiDragElements(!this.options.removeCloneOnHide, rootEl);
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref10) {
      var sortable = _ref10.sortable,
        isOwner = _ref10.isOwner,
        insertion = _ref10.insertion,
        activeSortable = _ref10.activeSortable,
        parentEl = _ref10.parentEl,
        putSortable = _ref10.putSortable;
      var options = this.options;
      if (insertion) {
        // Clones must be hidden before folding animation to capture dragRectAbsolute properly
        if (isOwner) {
          activeSortable._hideClone();
        }
        initialFolding = false;
        // If leaving sort:false root, or already folding - Fold to new location
        if (options.animation && multiDragElements.length > 1 && (folding || !isOwner && !activeSortable.options.sort && !putSortable)) {
          // Fold: Set all multi drag elements's rects to dragEl's rect when multi-drag elements are invisible
          var dragRectAbsolute = getRect(dragEl$1, false, true, true);
          multiDragElements.forEach(function (multiDragElement) {
            if (multiDragElement === dragEl$1) return;
            setRect(multiDragElement, dragRectAbsolute);

            // Move element(s) to end of parentEl so that it does not interfere with multi-drag clones insertion if they are inserted
            // while folding, and so that we can capture them again because old sortable will no longer be fromSortable
            parentEl.appendChild(multiDragElement);
          });
          folding = true;
        }

        // Clones must be shown (and check to remove multi drags) after folding when interfering multiDragElements are moved out
        if (!isOwner) {
          // Only remove if not folding (folding will remove them anyways)
          if (!folding) {
            removeMultiDragElements();
          }
          if (multiDragElements.length > 1) {
            var clonesHiddenBefore = clonesHidden;
            activeSortable._showClone(sortable);

            // Unfold animation for clones if showing from hidden
            if (activeSortable.options.animation && !clonesHidden && clonesHiddenBefore) {
              multiDragClones.forEach(function (clone) {
                activeSortable.addAnimationState({
                  target: clone,
                  rect: clonesFromRect
                });
                clone.fromRect = clonesFromRect;
                clone.thisAnimationDuration = null;
              });
            }
          } else {
            activeSortable._showClone(sortable);
          }
        }
      }
    },
    dragOverAnimationCapture: function dragOverAnimationCapture(_ref11) {
      var dragRect = _ref11.dragRect,
        isOwner = _ref11.isOwner,
        activeSortable = _ref11.activeSortable;
      multiDragElements.forEach(function (multiDragElement) {
        multiDragElement.thisAnimationDuration = null;
      });
      if (activeSortable.options.animation && !isOwner && activeSortable.multiDrag.isMultiDrag) {
        clonesFromRect = _extends({}, dragRect);
        var dragMatrix = matrix(dragEl$1, true);
        clonesFromRect.top -= dragMatrix.f;
        clonesFromRect.left -= dragMatrix.e;
      }
    },
    dragOverAnimationComplete: function dragOverAnimationComplete() {
      if (folding) {
        folding = false;
        removeMultiDragElements();
      }
    },
    drop: function drop(_ref12) {
      var evt = _ref12.originalEvent,
        rootEl = _ref12.rootEl,
        parentEl = _ref12.parentEl,
        sortable = _ref12.sortable,
        dispatchSortableEvent = _ref12.dispatchSortableEvent,
        oldIndex = _ref12.oldIndex,
        putSortable = _ref12.putSortable;
      var toSortable = putSortable || this.sortable;
      if (!evt) return;
      var options = this.options,
        children = parentEl.children;

      // Multi-drag selection
      if (!dragStarted) {
        if (options.multiDragKey && !this.multiDragKeyDown) {
          this._deselectMultiDrag();
        }
        toggleClass(dragEl$1, options.selectedClass, !~multiDragElements.indexOf(dragEl$1));
        if (!~multiDragElements.indexOf(dragEl$1)) {
          multiDragElements.push(dragEl$1);
          dispatchEvent({
            sortable: sortable,
            rootEl: rootEl,
            name: 'select',
            targetEl: dragEl$1,
            originalEvent: evt
          });

          // Modifier activated, select from last to dragEl
          if (evt.shiftKey && lastMultiDragSelect && sortable.el.contains(lastMultiDragSelect)) {
            var lastIndex = index(lastMultiDragSelect),
              currentIndex = index(dragEl$1);
            if (~lastIndex && ~currentIndex && lastIndex !== currentIndex) {
              (function () {
                // Must include lastMultiDragSelect (select it), in case modified selection from no selection
                // (but previous selection existed)
                var n, i;
                if (currentIndex > lastIndex) {
                  i = lastIndex;
                  n = currentIndex;
                } else {
                  i = currentIndex;
                  n = lastIndex + 1;
                }
                var filter = options.filter;
                for (; i < n; i++) {
                  if (~multiDragElements.indexOf(children[i])) continue;
                  // Check if element is draggable
                  if (!closest(children[i], options.draggable, parentEl, false)) continue;
                  // Check if element is filtered
                  var filtered = filter && (typeof filter === 'function' ? filter.call(sortable, evt, children[i], sortable) : filter.split(',').some(function (criteria) {
                    return closest(children[i], criteria.trim(), parentEl, false);
                  }));
                  if (filtered) continue;
                  toggleClass(children[i], options.selectedClass, true);
                  multiDragElements.push(children[i]);
                  dispatchEvent({
                    sortable: sortable,
                    rootEl: rootEl,
                    name: 'select',
                    targetEl: children[i],
                    originalEvent: evt
                  });
                }
              })();
            }
          } else {
            lastMultiDragSelect = dragEl$1;
          }
          multiDragSortable = toSortable;
        } else {
          multiDragElements.splice(multiDragElements.indexOf(dragEl$1), 1);
          lastMultiDragSelect = null;
          dispatchEvent({
            sortable: sortable,
            rootEl: rootEl,
            name: 'deselect',
            targetEl: dragEl$1,
            originalEvent: evt
          });
        }
      }

      // Multi-drag drop
      if (dragStarted && this.isMultiDrag) {
        folding = false;
        // Do not "unfold" after around dragEl if reverted
        if ((parentEl[expando].options.sort || parentEl !== rootEl) && multiDragElements.length > 1) {
          var dragRect = getRect(dragEl$1),
            multiDragIndex = index(dragEl$1, ':not(.' + this.options.selectedClass + ')');
          if (!initialFolding && options.animation) dragEl$1.thisAnimationDuration = null;
          toSortable.captureAnimationState();
          if (!initialFolding) {
            if (options.animation) {
              dragEl$1.fromRect = dragRect;
              multiDragElements.forEach(function (multiDragElement) {
                multiDragElement.thisAnimationDuration = null;
                if (multiDragElement !== dragEl$1) {
                  var rect = folding ? getRect(multiDragElement) : dragRect;
                  multiDragElement.fromRect = rect;

                  // Prepare unfold animation
                  toSortable.addAnimationState({
                    target: multiDragElement,
                    rect: rect
                  });
                }
              });
            }

            // Multi drag elements are not necessarily removed from the DOM on drop, so to reinsert
            // properly they must all be removed
            removeMultiDragElements();
            multiDragElements.forEach(function (multiDragElement) {
              if (children[multiDragIndex]) {
                parentEl.insertBefore(multiDragElement, children[multiDragIndex]);
              } else {
                parentEl.appendChild(multiDragElement);
              }
              multiDragIndex++;
            });

            // If initial folding is done, the elements may have changed position because they are now
            // unfolding around dragEl, even though dragEl may not have his index changed, so update event
            // must be fired here as Sortable will not.
            if (oldIndex === index(dragEl$1)) {
              var update = false;
              multiDragElements.forEach(function (multiDragElement) {
                if (multiDragElement.sortableIndex !== index(multiDragElement)) {
                  update = true;
                  return;
                }
              });
              if (update) {
                dispatchSortableEvent('update');
                dispatchSortableEvent('sort');
              }
            }
          }

          // Must be done after capturing individual rects (scroll bar)
          multiDragElements.forEach(function (multiDragElement) {
            unsetRect(multiDragElement);
          });
          toSortable.animateAll();
        }
        multiDragSortable = toSortable;
      }

      // Remove clones if necessary
      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== 'clone') {
        multiDragClones.forEach(function (clone) {
          clone.parentNode && clone.parentNode.removeChild(clone);
        });
      }
    },
    nullingGlobal: function nullingGlobal() {
      this.isMultiDrag = dragStarted = false;
      multiDragClones.length = 0;
    },
    destroyGlobal: function destroyGlobal() {
      this._deselectMultiDrag();
      off(document, 'pointerup', this._deselectMultiDrag);
      off(document, 'mouseup', this._deselectMultiDrag);
      off(document, 'touchend', this._deselectMultiDrag);
      off(document, 'keydown', this._checkKeyDown);
      off(document, 'keyup', this._checkKeyUp);
    },
    _deselectMultiDrag: function _deselectMultiDrag(evt) {
      if (typeof dragStarted !== "undefined" && dragStarted) return;

      // Only deselect if selection is in this sortable
      if (multiDragSortable !== this.sortable) return;

      // Only deselect if target is not item in this sortable
      if (evt && closest(evt.target, this.options.draggable, this.sortable.el, false)) return;

      // Only deselect if left click
      if (evt && evt.button !== 0) return;
      while (multiDragElements.length) {
        var el = multiDragElements[0];
        toggleClass(el, this.options.selectedClass, false);
        multiDragElements.shift();
        dispatchEvent({
          sortable: this.sortable,
          rootEl: this.sortable.el,
          name: 'deselect',
          targetEl: el,
          originalEvent: evt
        });
      }
    },
    _checkKeyDown: function _checkKeyDown(evt) {
      if (evt.key === this.options.multiDragKey) {
        this.multiDragKeyDown = true;
      }
    },
    _checkKeyUp: function _checkKeyUp(evt) {
      if (evt.key === this.options.multiDragKey) {
        this.multiDragKeyDown = false;
      }
    }
  };
  return _extends(MultiDrag, {
    // Static methods & properties
    pluginName: 'multiDrag',
    utils: {
      /**
       * Selects the provided multi-drag item
       * @param  {HTMLElement} el    The element to be selected
       */
      select: function select(el) {
        var sortable = el.parentNode[expando];
        if (!sortable || !sortable.options.multiDrag || ~multiDragElements.indexOf(el)) return;
        if (multiDragSortable && multiDragSortable !== sortable) {
          multiDragSortable.multiDrag._deselectMultiDrag();
          multiDragSortable = sortable;
        }
        toggleClass(el, sortable.options.selectedClass, true);
        multiDragElements.push(el);
      },
      /**
       * Deselects the provided multi-drag item
       * @param  {HTMLElement} el    The element to be deselected
       */
      deselect: function deselect(el) {
        var sortable = el.parentNode[expando],
          index = multiDragElements.indexOf(el);
        if (!sortable || !sortable.options.multiDrag || !~index) return;
        toggleClass(el, sortable.options.selectedClass, false);
        multiDragElements.splice(index, 1);
      }
    },
    eventProperties: function eventProperties() {
      var _this3 = this;
      var oldIndicies = [],
        newIndicies = [];
      multiDragElements.forEach(function (multiDragElement) {
        oldIndicies.push({
          multiDragElement: multiDragElement,
          index: multiDragElement.sortableIndex
        });

        // multiDragElements will already be sorted if folding
        var newIndex;
        if (folding && multiDragElement !== dragEl$1) {
          newIndex = -1;
        } else if (folding) {
          newIndex = index(multiDragElement, ':not(.' + _this3.options.selectedClass + ')');
        } else {
          newIndex = index(multiDragElement);
        }
        newIndicies.push({
          multiDragElement: multiDragElement,
          index: newIndex
        });
      });
      return {
        items: _toConsumableArray(multiDragElements),
        clones: [].concat(multiDragClones),
        oldIndicies: oldIndicies,
        newIndicies: newIndicies
      };
    },
    optionListeners: {
      multiDragKey: function multiDragKey(key) {
        key = key.toLowerCase();
        if (key === 'ctrl') {
          key = 'Control';
        } else if (key.length > 1) {
          key = key.charAt(0).toUpperCase() + key.substr(1);
        }
        return key;
      }
    }
  });
}
function insertMultiDragElements(clonesInserted, rootEl) {
  multiDragElements.forEach(function (multiDragElement, i) {
    var target = rootEl.children[multiDragElement.sortableIndex + (clonesInserted ? Number(i) : 0)];
    if (target) {
      rootEl.insertBefore(multiDragElement, target);
    } else {
      rootEl.appendChild(multiDragElement);
    }
  });
}

/**
 * Insert multi-drag clones
 * @param  {[Boolean]} elementsInserted  Whether the multi-drag elements are inserted
 * @param  {HTMLElement} rootEl
 */
function insertMultiDragClones(elementsInserted, rootEl) {
  multiDragClones.forEach(function (clone, i) {
    var target = rootEl.children[clone.sortableIndex + (elementsInserted ? Number(i) : 0)];
    if (target) {
      rootEl.insertBefore(clone, target);
    } else {
      rootEl.appendChild(clone);
    }
  });
}
function removeMultiDragElements() {
  multiDragElements.forEach(function (multiDragElement) {
    if (multiDragElement === dragEl$1) return;
    multiDragElement.parentNode && multiDragElement.parentNode.removeChild(multiDragElement);
  });
}

Sortable.mount(new AutoScrollPlugin());
Sortable.mount(Remove, Revert);

/* harmony default export */ __webpack_exports__["default"] = (Sortable);



/***/ }),

/***/ "./node_modules/tabbable/dist/index.esm.js":
/*!*************************************************!*\
  !*** ./node_modules/tabbable/dist/index.esm.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   focusable: function() { return /* binding */ focusable; },
/* harmony export */   getTabIndex: function() { return /* binding */ getTabIndex; },
/* harmony export */   isFocusable: function() { return /* binding */ isFocusable; },
/* harmony export */   isTabbable: function() { return /* binding */ isTabbable; },
/* harmony export */   tabbable: function() { return /* binding */ tabbable; }
/* harmony export */ });
/*!
* tabbable 6.2.0
* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
*/
// NOTE: separate `:not()` selectors has broader browser support than the newer
//  `:not([inert], [inert] *)` (Feb 2023)
// CAREFUL: JSDom does not support `:not([inert] *)` as a selector; using it causes
//  the entire query to fail, resulting in no nodes found, which will break a lot
//  of things... so we have to rely on JS to identify nodes inside an inert container
var candidateSelectors = ['input:not([inert])', 'select:not([inert])', 'textarea:not([inert])', 'a[href]:not([inert])', 'button:not([inert])', '[tabindex]:not(slot):not([inert])', 'audio[controls]:not([inert])', 'video[controls]:not([inert])', '[contenteditable]:not([contenteditable="false"]):not([inert])', 'details>summary:first-of-type:not([inert])', 'details:not([inert])'];
var candidateSelector = /* #__PURE__ */candidateSelectors.join(',');
var NoElement = typeof Element === 'undefined';
var matches = NoElement ? function () {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
var getRootNode = !NoElement && Element.prototype.getRootNode ? function (element) {
  var _element$getRootNode;
  return element === null || element === void 0 ? void 0 : (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element);
} : function (element) {
  return element === null || element === void 0 ? void 0 : element.ownerDocument;
};

/**
 * Determines if a node is inert or in an inert ancestor.
 * @param {Element} [node]
 * @param {boolean} [lookUp] If true and `node` is not inert, looks up at ancestors to
 *  see if any of them are inert. If false, only `node` itself is considered.
 * @returns {boolean} True if inert itself or by way of being in an inert ancestor.
 *  False if `node` is falsy.
 */
var isInert = function isInert(node, lookUp) {
  var _node$getAttribute;
  if (lookUp === void 0) {
    lookUp = true;
  }
  // CAREFUL: JSDom does not support inert at all, so we can't use the `HTMLElement.inert`
  //  JS API property; we have to check the attribute, which can either be empty or 'true';
  //  if it's `null` (not specified) or 'false', it's an active element
  var inertAtt = node === null || node === void 0 ? void 0 : (_node$getAttribute = node.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node, 'inert');
  var inert = inertAtt === '' || inertAtt === 'true';

  // NOTE: this could also be handled with `node.matches('[inert], :is([inert] *)')`
  //  if it weren't for `matches()` not being a function on shadow roots; the following
  //  code works for any kind of node
  // CAREFUL: JSDom does not appear to support certain selectors like `:not([inert] *)`
  //  so it likely would not support `:is([inert] *)` either...
  var result = inert || lookUp && node && isInert(node.parentNode); // recursive

  return result;
};

/**
 * Determines if a node's content is editable.
 * @param {Element} [node]
 * @returns True if it's content-editable; false if it's not or `node` is falsy.
 */
var isContentEditable = function isContentEditable(node) {
  var _node$getAttribute2;
  // CAREFUL: JSDom does not support the `HTMLElement.isContentEditable` API so we have
  //  to use the attribute directly to check for this, which can either be empty or 'true';
  //  if it's `null` (not specified) or 'false', it's a non-editable element
  var attValue = node === null || node === void 0 ? void 0 : (_node$getAttribute2 = node.getAttribute) === null || _node$getAttribute2 === void 0 ? void 0 : _node$getAttribute2.call(node, 'contenteditable');
  return attValue === '' || attValue === 'true';
};

/**
 * @param {Element} el container to check in
 * @param {boolean} includeContainer add container to check
 * @param {(node: Element) => boolean} filter filter candidates
 * @returns {Element[]}
 */
var getCandidates = function getCandidates(el, includeContainer, filter) {
  // even if `includeContainer=false`, we still have to check it for inertness because
  //  if it's inert, all its children are inert
  if (isInert(el)) {
    return [];
  }
  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
  if (includeContainer && matches.call(el, candidateSelector)) {
    candidates.unshift(el);
  }
  candidates = candidates.filter(filter);
  return candidates;
};

/**
 * @callback GetShadowRoot
 * @param {Element} element to check for shadow root
 * @returns {ShadowRoot|boolean} ShadowRoot if available or boolean indicating if a shadowRoot is attached but not available.
 */

/**
 * @callback ShadowRootFilter
 * @param {Element} shadowHostNode the element which contains shadow content
 * @returns {boolean} true if a shadow root could potentially contain valid candidates.
 */

/**
 * @typedef {Object} CandidateScope
 * @property {Element} scopeParent contains inner candidates
 * @property {Element[]} candidates list of candidates found in the scope parent
 */

/**
 * @typedef {Object} IterativeOptions
 * @property {GetShadowRoot|boolean} getShadowRoot true if shadow support is enabled; falsy if not;
 *  if a function, implies shadow support is enabled and either returns the shadow root of an element
 *  or a boolean stating if it has an undisclosed shadow root
 * @property {(node: Element) => boolean} filter filter candidates
 * @property {boolean} flatten if true then result will flatten any CandidateScope into the returned list
 * @property {ShadowRootFilter} shadowRootFilter filter shadow roots;
 */

/**
 * @param {Element[]} elements list of element containers to match candidates from
 * @param {boolean} includeContainer add container list to check
 * @param {IterativeOptions} options
 * @returns {Array.<Element|CandidateScope>}
 */
var getCandidatesIteratively = function getCandidatesIteratively(elements, includeContainer, options) {
  var candidates = [];
  var elementsToCheck = Array.from(elements);
  while (elementsToCheck.length) {
    var element = elementsToCheck.shift();
    if (isInert(element, false)) {
      // no need to look up since we're drilling down
      // anything inside this container will also be inert
      continue;
    }
    if (element.tagName === 'SLOT') {
      // add shadow dom slot scope (slot itself cannot be focusable)
      var assigned = element.assignedElements();
      var content = assigned.length ? assigned : element.children;
      var nestedCandidates = getCandidatesIteratively(content, true, options);
      if (options.flatten) {
        candidates.push.apply(candidates, nestedCandidates);
      } else {
        candidates.push({
          scopeParent: element,
          candidates: nestedCandidates
        });
      }
    } else {
      // check candidate element
      var validCandidate = matches.call(element, candidateSelector);
      if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {
        candidates.push(element);
      }

      // iterate over shadow content if possible
      var shadowRoot = element.shadowRoot ||
      // check for an undisclosed shadow
      typeof options.getShadowRoot === 'function' && options.getShadowRoot(element);

      // no inert look up because we're already drilling down and checking for inertness
      //  on the way down, so all containers to this root node should have already been
      //  vetted as non-inert
      var validShadowRoot = !isInert(shadowRoot, false) && (!options.shadowRootFilter || options.shadowRootFilter(element));
      if (shadowRoot && validShadowRoot) {
        // add shadow dom scope IIF a shadow root node was given; otherwise, an undisclosed
        //  shadow exists, so look at light dom children as fallback BUT create a scope for any
        //  child candidates found because they're likely slotted elements (elements that are
        //  children of the web component element (which has the shadow), in the light dom, but
        //  slotted somewhere _inside_ the undisclosed shadow) -- the scope is created below,
        //  _after_ we return from this recursive call
        var _nestedCandidates = getCandidatesIteratively(shadowRoot === true ? element.children : shadowRoot.children, true, options);
        if (options.flatten) {
          candidates.push.apply(candidates, _nestedCandidates);
        } else {
          candidates.push({
            scopeParent: element,
            candidates: _nestedCandidates
          });
        }
      } else {
        // there's not shadow so just dig into the element's (light dom) children
        //  __without__ giving the element special scope treatment
        elementsToCheck.unshift.apply(elementsToCheck, element.children);
      }
    }
  }
  return candidates;
};

/**
 * @private
 * Determines if the node has an explicitly specified `tabindex` attribute.
 * @param {HTMLElement} node
 * @returns {boolean} True if so; false if not.
 */
var hasTabIndex = function hasTabIndex(node) {
  return !isNaN(parseInt(node.getAttribute('tabindex'), 10));
};

/**
 * Determine the tab index of a given node.
 * @param {HTMLElement} node
 * @returns {number} Tab order (negative, 0, or positive number).
 * @throws {Error} If `node` is falsy.
 */
var getTabIndex = function getTabIndex(node) {
  if (!node) {
    throw new Error('No node provided');
  }
  if (node.tabIndex < 0) {
    // in Chrome, <details/>, <audio controls/> and <video controls/> elements get a default
    // `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,
    // yet they are still part of the regular tab order; in FF, they get a default
    // `tabIndex` of 0; since Chrome still puts those elements in the regular tab
    // order, consider their tab index to be 0.
    // Also browsers do not return `tabIndex` correctly for contentEditable nodes;
    // so if they don't have a tabindex attribute specifically set, assume it's 0.
    if ((/^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || isContentEditable(node)) && !hasTabIndex(node)) {
      return 0;
    }
  }
  return node.tabIndex;
};

/**
 * Determine the tab index of a given node __for sort order purposes__.
 * @param {HTMLElement} node
 * @param {boolean} [isScope] True for a custom element with shadow root or slot that, by default,
 *  has tabIndex -1, but needs to be sorted by document order in order for its content to be
 *  inserted into the correct sort position.
 * @returns {number} Tab order (negative, 0, or positive number).
 */
var getSortOrderTabIndex = function getSortOrderTabIndex(node, isScope) {
  var tabIndex = getTabIndex(node);
  if (tabIndex < 0 && isScope && !hasTabIndex(node)) {
    return 0;
  }
  return tabIndex;
};
var sortOrderedTabbables = function sortOrderedTabbables(a, b) {
  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;
};
var isInput = function isInput(node) {
  return node.tagName === 'INPUT';
};
var isHiddenInput = function isHiddenInput(node) {
  return isInput(node) && node.type === 'hidden';
};
var isDetailsWithSummary = function isDetailsWithSummary(node) {
  var r = node.tagName === 'DETAILS' && Array.prototype.slice.apply(node.children).some(function (child) {
    return child.tagName === 'SUMMARY';
  });
  return r;
};
var getCheckedRadio = function getCheckedRadio(nodes, form) {
  for (var i = 0; i < nodes.length; i++) {
    if (nodes[i].checked && nodes[i].form === form) {
      return nodes[i];
    }
  }
};
var isTabbableRadio = function isTabbableRadio(node) {
  if (!node.name) {
    return true;
  }
  var radioScope = node.form || getRootNode(node);
  var queryRadios = function queryRadios(name) {
    return radioScope.querySelectorAll('input[type="radio"][name="' + name + '"]');
  };
  var radioSet;
  if (typeof window !== 'undefined' && typeof window.CSS !== 'undefined' && typeof window.CSS.escape === 'function') {
    radioSet = queryRadios(window.CSS.escape(node.name));
  } else {
    try {
      radioSet = queryRadios(node.name);
    } catch (err) {
      // eslint-disable-next-line no-console
      console.error('Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s', err.message);
      return false;
    }
  }
  var checked = getCheckedRadio(radioSet, node.form);
  return !checked || checked === node;
};
var isRadio = function isRadio(node) {
  return isInput(node) && node.type === 'radio';
};
var isNonTabbableRadio = function isNonTabbableRadio(node) {
  return isRadio(node) && !isTabbableRadio(node);
};

// determines if a node is ultimately attached to the window's document
var isNodeAttached = function isNodeAttached(node) {
  var _nodeRoot;
  // The root node is the shadow root if the node is in a shadow DOM; some document otherwise
  //  (but NOT _the_ document; see second 'If' comment below for more).
  // If rootNode is shadow root, it'll have a host, which is the element to which the shadow
  //  is attached, and the one we need to check if it's in the document or not (because the
  //  shadow, and all nodes it contains, is never considered in the document since shadows
  //  behave like self-contained DOMs; but if the shadow's HOST, which is part of the document,
  //  is hidden, or is not in the document itself but is detached, it will affect the shadow's
  //  visibility, including all the nodes it contains). The host could be any normal node,
  //  or a custom element (i.e. web component). Either way, that's the one that is considered
  //  part of the document, not the shadow root, nor any of its children (i.e. the node being
  //  tested).
  // To further complicate things, we have to look all the way up until we find a shadow HOST
  //  that is attached (or find none) because the node might be in nested shadows...
  // If rootNode is not a shadow root, it won't have a host, and so rootNode should be the
  //  document (per the docs) and while it's a Document-type object, that document does not
  //  appear to be the same as the node's `ownerDocument` for some reason, so it's safer
  //  to ignore the rootNode at this point, and use `node.ownerDocument`. Otherwise,
  //  using `rootNode.contains(node)` will _always_ be true we'll get false-positives when
  //  node is actually detached.
  // NOTE: If `nodeRootHost` or `node` happens to be the `document` itself (which is possible
  //  if a tabbable/focusable node was quickly added to the DOM, focused, and then removed
  //  from the DOM as in https://github.com/focus-trap/focus-trap-react/issues/905), then
  //  `ownerDocument` will be `null`, hence the optional chaining on it.
  var nodeRoot = node && getRootNode(node);
  var nodeRootHost = (_nodeRoot = nodeRoot) === null || _nodeRoot === void 0 ? void 0 : _nodeRoot.host;

  // in some cases, a detached node will return itself as the root instead of a document or
  //  shadow root object, in which case, we shouldn't try to look further up the host chain
  var attached = false;
  if (nodeRoot && nodeRoot !== node) {
    var _nodeRootHost, _nodeRootHost$ownerDo, _node$ownerDocument;
    attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && (_nodeRootHost$ownerDo = _nodeRootHost.ownerDocument) !== null && _nodeRootHost$ownerDo !== void 0 && _nodeRootHost$ownerDo.contains(nodeRootHost) || node !== null && node !== void 0 && (_node$ownerDocument = node.ownerDocument) !== null && _node$ownerDocument !== void 0 && _node$ownerDocument.contains(node));
    while (!attached && nodeRootHost) {
      var _nodeRoot2, _nodeRootHost2, _nodeRootHost2$ownerD;
      // since it's not attached and we have a root host, the node MUST be in a nested shadow DOM,
      //  which means we need to get the host's host and check if that parent host is contained
      //  in (i.e. attached to) the document
      nodeRoot = getRootNode(nodeRootHost);
      nodeRootHost = (_nodeRoot2 = nodeRoot) === null || _nodeRoot2 === void 0 ? void 0 : _nodeRoot2.host;
      attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && (_nodeRootHost2$ownerD = _nodeRootHost2.ownerDocument) !== null && _nodeRootHost2$ownerD !== void 0 && _nodeRootHost2$ownerD.contains(nodeRootHost));
    }
  }
  return attached;
};
var isZeroArea = function isZeroArea(node) {
  var _node$getBoundingClie = node.getBoundingClientRect(),
    width = _node$getBoundingClie.width,
    height = _node$getBoundingClie.height;
  return width === 0 && height === 0;
};
var isHidden = function isHidden(node, _ref) {
  var displayCheck = _ref.displayCheck,
    getShadowRoot = _ref.getShadowRoot;
  // NOTE: visibility will be `undefined` if node is detached from the document
  //  (see notes about this further down), which means we will consider it visible
  //  (this is legacy behavior from a very long way back)
  // NOTE: we check this regardless of `displayCheck="none"` because this is a
  //  _visibility_ check, not a _display_ check
  if (getComputedStyle(node).visibility === 'hidden') {
    return true;
  }
  var isDirectSummary = matches.call(node, 'details>summary:first-of-type');
  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
  if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {
    return true;
  }
  if (!displayCheck || displayCheck === 'full' || displayCheck === 'legacy-full') {
    if (typeof getShadowRoot === 'function') {
      // figure out if we should consider the node to be in an undisclosed shadow and use the
      //  'non-zero-area' fallback
      var originalNode = node;
      while (node) {
        var parentElement = node.parentElement;
        var rootNode = getRootNode(node);
        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true // check if there's an undisclosed shadow
        ) {
          // node has an undisclosed shadow which means we can only treat it as a black box, so we
          //  fall back to a non-zero-area test
          return isZeroArea(node);
        } else if (node.assignedSlot) {
          // iterate up slot
          node = node.assignedSlot;
        } else if (!parentElement && rootNode !== node.ownerDocument) {
          // cross shadow boundary
          node = rootNode.host;
        } else {
          // iterate up normal dom
          node = parentElement;
        }
      }
      node = originalNode;
    }
    // else, `getShadowRoot` might be true, but all that does is enable shadow DOM support
    //  (i.e. it does not also presume that all nodes might have undisclosed shadows); or
    //  it might be a falsy value, which means shadow DOM support is disabled

    // Since we didn't find it sitting in an undisclosed shadow (or shadows are disabled)
    //  now we can just test to see if it would normally be visible or not, provided it's
    //  attached to the main document.
    // NOTE: We must consider case where node is inside a shadow DOM and given directly to
    //  `isTabbable()` or `isFocusable()` -- regardless of `getShadowRoot` option setting.

    if (isNodeAttached(node)) {
      // this works wherever the node is: if there's at least one client rect, it's
      //  somehow displayed; it also covers the CSS 'display: contents' case where the
      //  node itself is hidden in place of its contents; and there's no need to search
      //  up the hierarchy either
      return !node.getClientRects().length;
    }

    // Else, the node isn't attached to the document, which means the `getClientRects()`
    //  API will __always__ return zero rects (this can happen, for example, if React
    //  is used to render nodes onto a detached tree, as confirmed in this thread:
    //  https://github.com/facebook/react/issues/9117#issuecomment-284228870)
    //
    // It also means that even window.getComputedStyle(node).display will return `undefined`
    //  because styles are only computed for nodes that are in the document.
    //
    // NOTE: THIS HAS BEEN THE CASE FOR YEARS. It is not new, nor is it caused by tabbable
    //  somehow. Though it was never stated officially, anyone who has ever used tabbable
    //  APIs on nodes in detached containers has actually implicitly used tabbable in what
    //  was later (as of v5.2.0 on Apr 9, 2021) called `displayCheck="none"` mode -- essentially
    //  considering __everything__ to be visible because of the innability to determine styles.
    //
    // v6.0.0: As of this major release, the default 'full' option __no longer treats detached
    //  nodes as visible with the 'none' fallback.__
    if (displayCheck !== 'legacy-full') {
      return true; // hidden
    }
    // else, fallback to 'none' mode and consider the node visible
  } else if (displayCheck === 'non-zero-area') {
    // NOTE: Even though this tests that the node's client rect is non-zero to determine
    //  whether it's displayed, and that a detached node will __always__ have a zero-area
    //  client rect, we don't special-case for whether the node is attached or not. In
    //  this mode, we do want to consider nodes that have a zero area to be hidden at all
    //  times, and that includes attached or not.
    return isZeroArea(node);
  }

  // visible, as far as we can tell, or per current `displayCheck=none` mode, we assume
  //  it's visible
  return false;
};

// form fields (nested) inside a disabled fieldset are not focusable/tabbable
//  unless they are in the _first_ <legend> element of the top-most disabled
//  fieldset
var isDisabledFromFieldset = function isDisabledFromFieldset(node) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
    var parentNode = node.parentElement;
    // check if `node` is contained in a disabled <fieldset>
    while (parentNode) {
      if (parentNode.tagName === 'FIELDSET' && parentNode.disabled) {
        // look for the first <legend> among the children of the disabled <fieldset>
        for (var i = 0; i < parentNode.children.length; i++) {
          var child = parentNode.children.item(i);
          // when the first <legend> (in document order) is found
          if (child.tagName === 'LEGEND') {
            // if its parent <fieldset> is not nested in another disabled <fieldset>,
            // return whether `node` is a descendant of its first <legend>
            return matches.call(parentNode, 'fieldset[disabled] *') ? true : !child.contains(node);
          }
        }
        // the disabled <fieldset> containing `node` has no <legend>
        return true;
      }
      parentNode = parentNode.parentElement;
    }
  }

  // else, node's tabbable/focusable state should not be affected by a fieldset's
  //  enabled/disabled state
  return false;
};
var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable(options, node) {
  if (node.disabled ||
  // we must do an inert look up to filter out any elements inside an inert ancestor
  //  because we're limited in the type of selectors we can use in JSDom (see related
  //  note related to `candidateSelectors`)
  isInert(node) || isHiddenInput(node) || isHidden(node, options) ||
  // For a details element with a summary, the summary element gets the focus
  isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
    return false;
  }
  return true;
};
var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable(options, node) {
  if (isNonTabbableRadio(node) || getTabIndex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {
    return false;
  }
  return true;
};
var isValidShadowRootTabbable = function isValidShadowRootTabbable(shadowHostNode) {
  var tabIndex = parseInt(shadowHostNode.getAttribute('tabindex'), 10);
  if (isNaN(tabIndex) || tabIndex >= 0) {
    return true;
  }
  // If a custom element has an explicit negative tabindex,
  // browsers will not allow tab targeting said element's children.
  return false;
};

/**
 * @param {Array.<Element|CandidateScope>} candidates
 * @returns Element[]
 */
var sortByOrder = function sortByOrder(candidates) {
  var regularTabbables = [];
  var orderedTabbables = [];
  candidates.forEach(function (item, i) {
    var isScope = !!item.scopeParent;
    var element = isScope ? item.scopeParent : item;
    var candidateTabindex = getSortOrderTabIndex(element, isScope);
    var elements = isScope ? sortByOrder(item.candidates) : element;
    if (candidateTabindex === 0) {
      isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);
    } else {
      orderedTabbables.push({
        documentOrder: i,
        tabIndex: candidateTabindex,
        item: item,
        isScope: isScope,
        content: elements
      });
    }
  });
  return orderedTabbables.sort(sortOrderedTabbables).reduce(function (acc, sortable) {
    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
    return acc;
  }, []).concat(regularTabbables);
};
var tabbable = function tabbable(container, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([container], options.includeContainer, {
      filter: isNodeMatchingSelectorTabbable.bind(null, options),
      flatten: false,
      getShadowRoot: options.getShadowRoot,
      shadowRootFilter: isValidShadowRootTabbable
    });
  } else {
    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));
  }
  return sortByOrder(candidates);
};
var focusable = function focusable(container, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([container], options.includeContainer, {
      filter: isNodeMatchingSelectorFocusable.bind(null, options),
      flatten: true,
      getShadowRoot: options.getShadowRoot
    });
  } else {
    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));
  }
  return candidates;
};
var isTabbable = function isTabbable(node, options) {
  options = options || {};
  if (!node) {
    throw new Error('No node provided');
  }
  if (matches.call(node, candidateSelector) === false) {
    return false;
  }
  return isNodeMatchingSelectorTabbable(options, node);
};
var focusableCandidateSelector = /* #__PURE__ */candidateSelectors.concat('iframe').join(',');
var isFocusable = function isFocusable(node, options) {
  options = options || {};
  if (!node) {
    throw new Error('No node provided');
  }
  if (matches.call(node, focusableCandidateSelector) === false) {
    return false;
  }
  return isNodeMatchingSelectorFocusable(options, node);
};


//# sourceMappingURL=index.esm.js.map


/***/ }),

/***/ "./vendor/web-auth/webauthn-stimulus/assets/dist/controller.js":
/*!*********************************************************************!*\
  !*** ./vendor/web-auth/webauthn-stimulus/assets/dist/controller.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ default_1; }
/* harmony export */ });
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");
/* harmony import */ var _simplewebauthn_browser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @simplewebauthn/browser */ "./node_modules/@simplewebauthn/browser/esm/index.js");


class default_1 extends _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Controller {
  constructor() {
    super(...arguments);
    this.connect = async () => {
      var _a, _b, _c, _d;
      const options = {
        requestResultUrl: this.requestResultUrlValue,
        requestOptionsUrl: this.requestOptionsUrlValue,
        requestResultField: (_a = this.requestResultFieldValue) !== null && _a !== undefined ? _a : null,
        creationResultField: (_b = this.creationResultFieldValue) !== null && _b !== undefined ? _b : null,
        requestSuccessRedirectUri: (_c = this.requestSuccessRedirectUriValue) !== null && _c !== undefined ? _c : null,
        creationResultUrl: this.creationResultUrlValue,
        creationOptionsUrl: this.creationOptionsUrlValue,
        creationSuccessRedirectUri: (_d = this.creationSuccessRedirectUriValue) !== null && _d !== undefined ? _d : null
      };
      this._dispatchEvent('webauthn:connect', {
        options
      });
      const supportAutofill = await (0,_simplewebauthn_browser__WEBPACK_IMPORTED_MODULE_1__.browserSupportsWebAuthnAutofill)();
      if (supportAutofill && this.useBrowserAutofillValue) {
        const optionsResponseJson = await this._getPublicKeyCredentialRequestOptions({});
        if (!optionsResponseJson) {
          return;
        }
        this._processSignin(optionsResponseJson, true);
      }
    };
  }
  async signin(event) {
    if (!(0,_simplewebauthn_browser__WEBPACK_IMPORTED_MODULE_1__.browserSupportsWebAuthn)()) {
      this._dispatchEvent('webauthn:unsupported', {});
      return;
    }
    event.preventDefault();
    const optionsResponseJson = await this._getPublicKeyCredentialRequestOptions(null);
    if (!optionsResponseJson) {
      return;
    }
    this._processSignin(optionsResponseJson, false);
  }
  async _processSignin(optionsResponseJson, useBrowserAutofill) {
    var _a;
    try {
      optionsResponseJson = this._processExtensionsInput(optionsResponseJson);
      let authenticatorResponse = await (0,_simplewebauthn_browser__WEBPACK_IMPORTED_MODULE_1__.startAuthentication)({
        optionsJSON: optionsResponseJson,
        useBrowserAutofill
      });
      authenticatorResponse = this._processExtensionsOutput(authenticatorResponse);
      this._dispatchEvent('webauthn:authenticator:response', {
        response: authenticatorResponse
      });
      if (this.requestResultFieldValue && this.element instanceof HTMLFormElement) {
        (_a = this.element.querySelector(this.requestResultFieldValue)) === null || _a === void 0 ? void 0 : _a.setAttribute('value', JSON.stringify(authenticatorResponse));
        this.element.submit();
        return;
      }
      const assertionResponse = await this._getAssertionResponse(authenticatorResponse);
      if (assertionResponse !== false && this.requestSuccessRedirectUriValue) {
        window.location.replace(this.requestSuccessRedirectUriValue);
      }
    } catch (e) {
      this._dispatchEvent('webauthn:assertion:failure', {
        exception: e,
        assertionResponse: null
      });
      return;
    }
  }
  async signup(event) {
    var _a;
    try {
      if (!(0,_simplewebauthn_browser__WEBPACK_IMPORTED_MODULE_1__.browserSupportsWebAuthn)()) {
        this._dispatchEvent('webauthn:unsupported', {});
        return;
      }
      event.preventDefault();
      let optionsResponseJson = await this._getPublicKeyCredentialCreationOptions(null);
      if (!optionsResponseJson) {
        return;
      }
      optionsResponseJson = this._processExtensionsInput(optionsResponseJson);
      let authenticatorResponse = await (0,_simplewebauthn_browser__WEBPACK_IMPORTED_MODULE_1__.startRegistration)({
        optionsJSON: optionsResponseJson
      });
      authenticatorResponse = this._processExtensionsOutput(authenticatorResponse);
      this._dispatchEvent('webauthn:authenticator:response', {
        response: authenticatorResponse
      });
      if (this.creationResultFieldValue && this.element instanceof HTMLFormElement) {
        (_a = this.element.querySelector(this.creationResultFieldValue)) === null || _a === void 0 ? void 0 : _a.setAttribute('value', JSON.stringify(authenticatorResponse));
        this.element.submit();
        return;
      }
      const attestationResponseJSON = await this._getAttestationResponse(authenticatorResponse);
      if (attestationResponseJSON !== false && this.creationSuccessRedirectUriValue) {
        window.location.replace(this.creationSuccessRedirectUriValue);
      }
    } catch (e) {
      this._dispatchEvent('webauthn:attestation:failure', {
        exception: e,
        assertionResponse: null
      });
      return;
    }
  }
  _dispatchEvent(name, payload) {
    this.element.dispatchEvent(new CustomEvent(name, {
      detail: payload,
      bubbles: true
    }));
  }
  _getData() {
    let data = new FormData();
    try {
      this.element.reportValidity();
      if (!this.element.checkValidity()) {
        return;
      }
      data = new FormData(this.element);
    } catch (e) {}
    function removeEmpty(obj) {
      return Object.entries(obj).filter(([, v]) => v !== null && v !== '').reduce((acc, [k, v]) => Object.assign(Object.assign({}, acc), {
        [k]: v === Object(v) ? removeEmpty(v) : v
      }), {});
    }
    return removeEmpty({
      username: data.get(this.usernameFieldValue),
      displayName: data.get(this.displayNameFieldValue),
      attestation: data.get(this.attestationFieldValue),
      userVerification: data.get(this.userVerificationFieldValue),
      residentKey: data.get(this.residentKeyFieldValue),
      authenticatorAttachment: data.get(this.authenticatorAttachmentFieldValue)
    });
  }
  async _getPublicKeyCredentialRequestOptions(formData) {
    return this._getOptions(this.requestOptionsUrlValue, formData);
  }
  async _getPublicKeyCredentialCreationOptions(formData) {
    return this._getOptions(this.creationOptionsUrlValue, formData);
  }
  async _getOptions(url, formData) {
    const data = formData || this._getData();
    if (!data) {
      return false;
    }
    this._dispatchEvent('webauthn:options:request', {
      data
    });
    const optionsResponse = await fetch(url, {
      headers: Object.assign({}, this.requestHeadersValue),
      method: 'POST',
      body: JSON.stringify(data)
    });
    if (!optionsResponse.ok) {
      this._dispatchEvent('webauthn:options:failure', {
        exception: null,
        optionsResponse
      });
      return false;
    }
    const options = await optionsResponse.json();
    this._dispatchEvent('webauthn:options:success', {
      data: options
    });
    return options;
  }
  async _getAttestationResponse(authenticatorResponse) {
    return this._getResult(this.creationResultUrlValue, 'webauthn:attestation:', authenticatorResponse);
  }
  async _getAssertionResponse(authenticatorResponse) {
    return this._getResult(this.requestResultUrlValue, 'webauthn:assertion:', authenticatorResponse);
  }
  async _getResult(url, eventPrefix, authenticatorResponse) {
    const attestationResponse = await fetch(url, {
      headers: Object.assign({}, this.requestHeadersValue),
      method: 'POST',
      body: JSON.stringify(authenticatorResponse)
    });
    if (!attestationResponse.ok) {
      this._dispatchEvent(eventPrefix + 'failure', {});
      return false;
    }
    const attestationResponseJSON = await attestationResponse.json();
    this._dispatchEvent(eventPrefix + 'success', {
      data: attestationResponseJSON
    });
    return attestationResponseJSON;
  }
  _processExtensionsInput(options) {
    if (!options || !options.extensions) {
      return options;
    }
    if (options.extensions.prf) {
      options.extensions.prf = this._processPrfInput(options.extensions.prf);
    }
    return options;
  }
  _processPrfInput(prf) {
    if (prf.eval) {
      prf.eval = this._importPrfValues(eval);
    }
    if (prf.evalByCredential) {
      Object.keys(prf.evalByCredential).forEach(key => {
        prf.evalByCredential[key] = this._importPrfValues(prf.evalByCredential[key]);
      });
    }
    return prf;
  }
  _importPrfValues(values) {
    values.first = (0,_simplewebauthn_browser__WEBPACK_IMPORTED_MODULE_1__.base64URLStringToBuffer)(values.first);
    if (values.second) {
      values.second = (0,_simplewebauthn_browser__WEBPACK_IMPORTED_MODULE_1__.base64URLStringToBuffer)(values.second);
    }
    return values;
  }
  _processExtensionsOutput(options) {
    if (!options || !options.extensions) {
      return options;
    }
    if (options.extensions.prf) {
      options.extensions.prf = this._processPrfOutput(options.extensions.prf);
    }
    return options;
  }
  _processPrfOutput(prf) {
    if (!prf.result) {
      return prf;
    }
    prf.result = this._exportPrfValues(prf.result);
    return prf;
  }
  _exportPrfValues(values) {
    values.first = (0,_simplewebauthn_browser__WEBPACK_IMPORTED_MODULE_1__.bufferToBase64URLString)(values.first);
    if (values.second) {
      values.second = (0,_simplewebauthn_browser__WEBPACK_IMPORTED_MODULE_1__.bufferToBase64URLString)(values.second);
    }
    return values;
  }
}
default_1.values = {
  requestResultUrl: {
    type: String,
    default: '/request'
  },
  requestOptionsUrl: {
    type: String,
    default: '/request/options'
  },
  requestResultField: {
    type: String,
    default: null
  },
  requestSuccessRedirectUri: String,
  creationResultUrl: {
    type: String,
    default: '/creation'
  },
  creationOptionsUrl: {
    type: String,
    default: '/creation/options'
  },
  creationResultField: {
    type: String,
    default: null
  },
  creationSuccessRedirectUri: String,
  usernameField: {
    type: String,
    default: 'username'
  },
  displayNameField: {
    type: String,
    default: 'displayName'
  },
  attestationField: {
    type: String,
    default: 'attestation'
  },
  userVerificationField: {
    type: String,
    default: 'userVerification'
  },
  residentKeyField: {
    type: String,
    default: 'residentKey'
  },
  authenticatorAttachmentField: {
    type: String,
    default: 'authenticatorAttachment'
  },
  useBrowserAutofill: {
    type: Boolean,
    default: false
  },
  requestHeaders: {
    type: Object,
    default: {
      'Content-Type': 'application/json',
      'Accept': 'application/json',
      'mode': 'no-cors',
      'credentials': 'include'
    }
  }
};


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be in strict mode.
!function() {
"use strict";
/*!***************************************!*\
  !*** ./core-bundle/assets/backend.js ***!
  \***************************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hotwired/stimulus */ "./node_modules/@hotwired/stimulus/dist/stimulus.js");
/* harmony import */ var _hotwired_stimulus_webpack_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @hotwired/stimulus-webpack-helpers */ "./node_modules/@hotwired/stimulus-webpack-helpers/dist/stimulus-webpack-helpers.js");
/* harmony import */ var _hotwired_turbo__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @hotwired/turbo */ "./node_modules/@hotwired/turbo/dist/turbo.es2017-esm.js");
/* harmony import */ var _web_auth_webauthn_stimulus__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @web-auth/webauthn-stimulus */ "./vendor/web-auth/webauthn-stimulus/assets/dist/controller.js");
/* harmony import */ var _scripts_mootao_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./scripts/mootao.js */ "./core-bundle/assets/scripts/mootao.js");
/* harmony import */ var _scripts_mootao_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_scripts_mootao_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _scripts_core_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./scripts/core.js */ "./core-bundle/assets/scripts/core.js");
/* harmony import */ var _scripts_limit_height_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./scripts/limit-height.js */ "./core-bundle/assets/scripts/limit-height.js");
/* harmony import */ var _scripts_limit_height_js__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_scripts_limit_height_js__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _styles_backend_pcss__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./styles/backend.pcss */ "./core-bundle/assets/styles/backend.pcss");









// Start the Stimulus application
const application = _hotwired_stimulus__WEBPACK_IMPORTED_MODULE_0__.Application.start();
application.debug = "development" === 'development';

// Register all controllers with `contao--` prefix
const context = __webpack_require__("./core-bundle/assets/controllers sync recursive \\.js$");
application.load(context.keys().map(key => {
  const identifier = (0,_hotwired_stimulus_webpack_helpers__WEBPACK_IMPORTED_MODULE_1__.identifierForContextKey)(key);
  if (identifier) {
    return (0,_hotwired_stimulus_webpack_helpers__WEBPACK_IMPORTED_MODULE_1__.definitionForModuleAndIdentifier)(context(key), `contao--${identifier}`);
  }
}).filter(value => value));
application.register('contao--webauthn', _web_auth_webauthn_stimulus__WEBPACK_IMPORTED_MODULE_3__["default"]);
document.documentElement.addEventListener('turbo:before-prefetch', e => {
  if (
  // Do not prefetch if the user wants to save data or is on a slow
  // connection
  navigator.connection?.saveData || ['slow-2g', '2g'].includes(navigator.connection?.effectiveType) ||
  // Do not prefetch if the URL contains a request token or the element
  // is part of the Symfony toolbar
  e.target.search && new URLSearchParams(e.target.search).has('rt') || e.target.classList.contains('header_back') || e.target.matches('[onclick^="Backend.openModalIframe("]') || e.target.closest('.sf-toolbar') !== null) {
    e.preventDefault();
  }
});

// Make the MooTools scripts reinitialize themselves
const mooDomready = () => {
  if (!document.body.mooDomreadyFired) {
    document.body.mooDomreadyFired = true;
    window.fireEvent('domready');
  }
};
document.documentElement.addEventListener('turbo:render', mooDomready);
document.documentElement.addEventListener('turbo:frame-render', mooDomready);

// Always break out of a missing frame (#7501)
document.documentElement.addEventListener('turbo:frame-missing', e => {
  if (window.console) {
    console.warn(`Turbo frame #${e.target.id} is missing.`);
  }

  // Do not break out of frames that load their content via src
  if (e.target.hasAttribute('src')) {
    return;
  }
  e.preventDefault();
  e.detail.visit(e.detail.response);
});

// Call the beforeCache() function on all controllers implementing it. This
// allows controllers to tear down things before the page gets put into cache.
// Note that Stimulus' disconnect() function will not fire at this point and
// thus cannot be used for this task.
document.documentElement.addEventListener('turbo:before-cache', e => {
  for (const controller of application.controllers) {
    if ('function' === typeof controller.beforeCache) {
      controller.beforeCache(e);
    }
  }

  // Remove the Symfony toolbar
  e.target.querySelector('.sf-toolbar')?.remove();
});

// If the previously fetched resource got redirected and a full page reload
// occurs, Turbo currently uses the wrong URL (the originally fetched one, not
// the effective URL after the redirect).
// TODO: Remove again once hotwired/turbo#1391 is fixed.
let targetURLAfterRedirectedFetch = null;
document.documentElement.addEventListener('turbo:reload', event => {
  if (event.detail.reason !== 'request_failed' && targetURLAfterRedirectedFetch) {
    Turbo.session.adapter.location = new URL(targetURLAfterRedirectedFetch);
  }
});
document.documentElement.addEventListener('turbo:before-fetch-response', event => {
  const response = event.detail.fetchResponse;
  targetURLAfterRedirectedFetch = response.redirected ? response.response.url : null;
});
}();
/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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OztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCwyQ0FBMkM7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx3Q0FBd0M7QUFDNUU7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrQ0FBa0M7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLEtBQUs7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsd0JBQXdCLEdBQUcsZ0JBQWdCLE1BQU0sY0FBYztBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDRCQUE0QjtBQUNoRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHdCQUF3QjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsd0JBQXdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsWUFBWTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFlBQVk7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxZQUFZO0FBQ2hEO0FBQ0E7QUFDQSx3REFBd0QsZ0NBQWdDLElBQUksV0FBVztBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLFlBQVk7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQkFBK0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLFdBQVc7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7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Szs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1RUFBdUU7QUFDdkU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxnREFBZ0Q7QUFDaEQsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHdCQUF3QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsWUFBWSwwQkFBMEI7QUFDdEM7O0FBRUE7QUFD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QUFFQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1FQUFtRSxtQkFBbUI7QUFDdEY7O0FBRUEsNkNBQTZDLFlBQVk7QUFDekQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHFFQUFxRSxZQUFZO0FBQ2pGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLGlCQUFpQjtBQUNsRzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLFNBQVM7QUFDeEIsZUFBZSxTQUFTO0FBQ3hCLGVBQWUsUUFBUTtBQUN2QixlQUFlLGNBQWM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFNBQVM7QUFDeEIsZUFBZSxxQkFBcUI7QUFDcEMsZUFBZSxjQUFjO0FBQzdCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLE1BQU07QUFDckIsZUFBZSxjQUFjO0FBQzdCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsY0FBYztBQUMzQixh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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0QyxxQkFBcUI7QUFDakUsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxZQUFZO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsTUFBTTtBQUN2QixjQUFjLHFCQUFxQjtBQUNuQzs7QUFFQTtBQUNBO0FBQ0EsY0FBYywwQkFBMEI7QUFDeEM7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLDZCQUE2QjtBQUNyRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxtREFBbUQsS0FBSztBQUN4RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxRUFBcUU7QUFDckU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhO0FBQzNCO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsMkJBQTJCO0FBQ3pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLHlCQUF5QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQSw0QkFBNEIsa0RBQWtEO0FBQzlFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVkseUJBQXlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTiw0QkFBNEIsa0RBQWtEO0FBQzlFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCLGdCQUFnQjs7QUFFL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLHlCQUF5QixzRUFBc0UsZUFBZTtBQUM3SDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsR0FBRztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSx3QkFBd0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0EsZ0JBQWdCLDBDQUEwQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDRFQUE0RSxZQUFZO0FBQ3hGLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9EQUFvRCxnQ0FBZ0M7QUFDcEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IseUJBQXlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLHlCQUF5QjtBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLGFBQWE7QUFDekI7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQkFBMEIsOENBQThDO0FBQ3hFOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEtBQUs7O0FBRWpCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0RBQWdELE9BQU87QUFDdkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLHdCQUF3Qjs7QUFFcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksd0JBQXdCO0FBQ3BDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksa0JBQWtCO0FBQzlCLFlBQVksT0FBTzs7QUFFbkI7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEIsVUFBVSw4QkFBOEI7QUFDdEU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGlDQUFpQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDhCQUE4QjtBQUM5Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLCtDQUErQztBQUN2RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtB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QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFD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QUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsV0FBVztBQUM5RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixpQkFBaUIsSUFBSSxRQUFRO0FBQ3BEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFN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QUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsRUFBRTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDLGFBQWEsb0JBQW9CO0FBQ2pDLGFBQWEsb0JBQW9CO0FBQ2pDLGFBQWEsb0JBQW9CO0FBQ2pDLGFBQWEsb0JBQW9CO0FBQ2pDLGFBQWEsb0JBQW9CO0FBQ2pDLGFBQWEsb0JBQW9CO0FBQ2pDLGFBQWEsb0JBQW9CO0FBQ2pDLGFBQWEsb0JBQW9CO0FBQ2pDLGFBQWEsb0JBQW9CO0FBQ2pDLGFBQWEsb0JBQW9CO0FBQ2pDLGFBQWEsb0JBQW9CO0FBQ2pDLGFBQWEsb0JBQW9CO0FBQ2pDLGFBQWEsb0JBQW9CO0FBQ2pDLGFBQWEsb0JBQW9CO0FBQ2pDLGFBQWEsb0JBQW9CO0FBQ2pDLGFBQWEsb0JBQW9CO0FBQ2pDLGFBQWEsb0JBQW9CO0FBQ2pDLGFBQWEsb0JBQW9CO0FBQ2pDLGFBQWEsb0JBQW9CO0FBQ2pDLGFBQWEsb0JBQW9CO0FBQ2pDLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGtCQUFrQixlQUFlO0FBQ2pDLGtCQUFrQixlQUFlO0FBQ2pDLGtCQUFrQixlQUFlO0FBQ2pDLGtCQUFrQixlQUFlO0FBQ2pDLGtCQUFrQixlQUFlO0FBQ2pDLGtCQUFrQixlQUFlO0FBQ2pDLGtCQUFrQixlQUFlO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUIsa0JBQWtCLFFBQVE7QUFDMUIsa0JBQWtCLFFBQVE7QUFDMUIsa0JBQWtCLFFBQVE7QUFDMUIsa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEMsa0JBQWtCLGtCQUFrQjtBQUNwQyxrQkFBa0Isa0JBQWtCO0FBQ3BDLGtCQUFrQixrQkFBa0I7QUFDcEMsa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWTtBQUN2QixTQUFTLHdCQUF3QjtBQUNqQztBQUNBLFdBQVcsWUFBWTtBQUN2QixTQUFTLGtCQUFrQjtBQUMzQjtBQUNBLFdBQVcsWUFBWTtBQUN2QixTQUFTLG1CQUFtQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx1QkFBdUI7QUFDcEMsYUFBYSx1QkFBdUI7QUFDcEMsYUFBYSx1QkFBdUI7QUFDcEMsYUFBYSx1QkFBdUI7QUFDcEMsYUFBYSx1QkFBdUI7QUFDcEMsYUFBYSx1QkFBdUI7QUFDcEMsYUFBYSx1QkFBdUI7QUFDcEMsYUFBYSx1QkFBdUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCLGFBQWEsaUJBQWlCO0FBQzlCLGFBQWEsaUJBQWlCO0FBQzlCLGFBQWEsaUJBQWlCO0FBQzlCLGFBQWEsaUJBQWlCO0FBQzlCLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHlCQUF5QjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9CQUFvQjtBQUNqQyxhQUFhLG9CQUFvQjtBQUNqQyxhQUFhLG9CQUFvQjtBQUNqQyxhQUFhLG9CQUFvQjtBQUNqQyxhQUFhLG9CQUFvQjtBQUNqQyxhQUFhLG9CQUFvQjtBQUNqQyxhQUFhLG9CQUFvQjtBQUNqQyxhQUFhLG9CQUFvQjtBQUNqQyxhQUFhLG9CQUFvQjtBQUNqQyxhQUFhLG9CQUFvQjtBQUNqQyxhQUFhLG9CQUFvQjtBQUNqQyxhQUFhLG9CQUFvQjtBQUNqQyxhQUFhLG9CQUFvQjtBQUNqQyxhQUFhLG9CQUFvQjtBQUNqQyxhQUFhLG9CQUFvQjtBQUNqQyxhQUFhLG9CQUFvQjtBQUNqQyxhQUFhLG9CQUFvQjtBQUNqQyxhQUFhLG9CQUFvQjtBQUNqQyxhQUFhLG9CQUFvQjtBQUNqQyxhQUFhLG9CQUFvQjtBQUNqQyxhQUFhLG9CQUFvQjtBQUNqQyxhQUFhLG9CQUFvQjtBQUNqQyxhQUFhLG9CQUFvQjtBQUNqQyxhQUFhLG9CQUFvQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHVCQUF1QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0JBQWdCO0FBQzdCLGFBQWEsZ0JBQWdCO0FBQzdCLGFBQWEsZ0JBQWdCO0FBQzdCLGFBQWEsZ0JBQWdCO0FBQzdCLGFBQWEsZ0JBQWdCO0FBQzdCLGFBQWEsZ0JBQWdCO0FBQzdCLGFBQWEsZ0JBQWdCO0FBQzdCLGFBQWEsZ0JBQWdCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixhQUFhLGFBQWE7QUFDMUIsYUFBYSxhQUFhO0FBQzFCLGFBQWEsYUFBYTtBQUMxQixhQUFhLGFBQWE7QUFDMUIsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxvQkFBb0I7QUFDakMsYUFBYSxvQkFBb0I7QUFDakMsYUFBYSxvQkFBb0I7QUFDakMsYUFBYSxvQkFBb0I7QUFDakMsYUFBYSxvQkFBb0I7QUFDakMsYUFBYSxvQkFBb0I7QUFDakMsYUFBYSxvQkFBb0I7QUFDakMsYUFBYSxvQkFBb0I7QUFDakMsYUFBYSxvQkFBb0I7QUFDakMsYUFBYSxvQkFBb0I7QUFDakMsYUFBYSxvQkFBb0I7QUFDakMsYUFBYSxvQkFBb0I7QUFDakMsYUFBYSxvQkFBb0I7QUFDakMsYUFBYSxvQkFBb0I7QUFDakMsYUFBYSxvQkFBb0I7QUFDakMsYUFBYSxvQkFBb0I7QUFDakMsYUFBYSxvQkFBb0I7QUFDakMsYUFBYSxvQkFBb0I7QUFDakMsYUFBYSxvQkFBb0I7QUFDakMsYUFBYSxvQkFBb0I7QUFDakMsYUFBYSxvQkFBb0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0lBQXNJO0FBQ3RJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0NBQW9DO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywwQ0FBMEM7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw4QkFBOEI7QUFDM0MsYUFBYSw4QkFBOEI7QUFDM0MsYUFBYSw4QkFBOEI7QUFDM0MsYUFBYSw4QkFBOEI7QUFDM0MsYUFBYSw4QkFBOEI7QUFDM0MsYUFBYSw4QkFBOEI7QUFDM0MsYUFBYSw4QkFBOEI7QUFDM0MsYUFBYSw4QkFBOEI7QUFDM0MsYUFBYSw4QkFBOEI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix5Q0FBeUM7QUFDM0Qsa0JBQWtCLHlDQUF5QztBQUMzRCxrQkFBa0IseUNBQXlDO0FBQzNELGtCQUFrQix5Q0FBeUM7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSx3QkFBd0I7QUFDckMsYUFBYSx3QkFBd0I7QUFDckMsYUFBYSx3QkFBd0I7QUFDckMsYUFBYSx3QkFBd0I7QUFDckMsYUFBYSx3QkFBd0I7QUFDckMsYUFBYSx3QkFBd0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMseUJBQXlCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsd0JBQXdCO0FBQ3JDLGFBQWEsd0JBQXdCO0FBQ3JDLGFBQWEsd0JBQXdCO0FBQ3JDLGFBQWEsd0JBQXdCO0FBQ3JDLGFBQWEsd0JBQXdCO0FBQ3JDLGFBQWEsd0JBQXdCO0FBQ3JDLGFBQWEsd0JBQXdCO0FBQ3JDLGFBQWEsd0JBQXdCO0FBQ3JDLGFBQWEsd0JBQXdCO0FBQ3JDLGFBQWEsd0JBQXdCO0FBQ3JDLGFBQWEsd0JBQXdCO0FBQ3JDLGFBQWEsd0JBQXdCO0FBQ3JDLGFBQWEsd0JBQXdCO0FBQ3JDLGFBQWEsd0JBQXdCO0FBQ3JDLGFBQWEsd0JBQXdCO0FBQ3JDLGFBQWEsd0JBQXdCO0FBQ3JDLGFBQWEsd0JBQXdCO0FBQ3JDLGFBQWEsd0JBQXdCO0FBQ3JDLGFBQWEsd0JBQXdCO0FBQ3JDLGFBQWEsd0JBQXdCO0FBQ3JDLGFBQWEsd0JBQXdCO0FBQ3JDLGFBQWEsd0JBQXdCO0FBQ3JDLGFBQWEsd0JBQXdCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQixrQkFBa0IsUUFBUTtBQUMxQixrQkFBa0IsUUFBUTtBQUMxQixrQkFBa0IsUUFBUTtBQUMxQixrQkFBa0IsUUFBUTtBQUMxQixrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHVCQUF1QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DLDRDQUE0QztBQUM1Qyx3QkFBd0I7QUFDeEIsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QixhQUFhLGlCQUFpQjtBQUM5QixhQUFhLGlCQUFpQjtBQUM5QixhQUFhLGlCQUFpQjtBQUM5QixhQUFhLGlCQUFpQjtBQUM5QixhQUFhLGlCQUFpQjtBQUM5QixhQUFhLGlCQUFpQjtBQUM5QixhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGFBQWE7QUFDMUIsYUFBYSxhQUFhO0FBQzFCLGFBQWEsYUFBYTtBQUMxQixhQUFhLGFBQWE7QUFDMUIsYUFBYSxhQUFhO0FBQzFCLGFBQWEsYUFBYTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDLGFBQWEsb0JBQW9CO0FBQ2pDLGFBQWEsb0JBQW9CO0FBQ2pDLGFBQWEsb0JBQW9CO0FBQ2pDLGFBQWEsb0JBQW9CO0FBQ2pDLGFBQWEsb0JBQW9CO0FBQ2pDLGFBQWEsb0JBQW9CO0FBQ2pDLGFBQWEsb0JBQW9CO0FBQ2pDLGFBQWEsb0JBQW9CO0FBQ2pDLGFBQWEsb0JBQW9CO0FBQ2pDLGFBQWEsb0JBQW9CO0FBQ2pDLGFBQWEsb0JBQW9CO0FBQ2pDLGFBQWEsb0JBQW9CO0FBQ2pDLGFBQWEsb0JBQW9CO0FBQ2pDLGFBQWEsb0JBQW9CO0FBQ2pDLGFBQWEsb0JBQW9CO0FBQ2pDLGFBQWEsb0JBQW9CO0FBQ2pDLGFBQWEsb0JBQW9CO0FBQ2pDLGFBQWEsb0JBQW9CO0FBQ2pDLGFBQWEsb0JBQW9CO0FBQ2pDLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxrREFBa0Q7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FB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UCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7O0FBRXhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGNBQWMsV0FBVztBQUN6QjtB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QUFFQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsYUFBYTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGtDQUFrQztBQUNsQyxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDhCQUE4QjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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LE1BQU0sQ0FBQ3FxQyxhQUFhO0VBQzNDRiw2QkFBNkIsR0FBR3hrQixRQUFRLENBQUNzRyxVQUFVLEdBQUd0RyxRQUFRLENBQUNBLFFBQVEsQ0FBQ2hsQixHQUFHLEdBQUcsSUFBSTtBQUN0RixDQUFDLENBQUMsQyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL2NvcmUtYnVuZGxlL2Fzc2V0cy9jb250cm9sbGVycy8gc3luYyBcXC5qcyQiLCJ3ZWJwYWNrOi8vLy4vY29yZS1idW5kbGUvYXNzZXRzL2NvbnRyb2xsZXJzL2FjZS1jb250cm9sbGVyLmpzIiwid2VicGFjazovLy8uL2NvcmUtYnVuZGxlL2Fzc2V0cy9jb250cm9sbGVycy9iYWNrZW5kLXNlYXJjaC1jb250cm9sbGVyLmpzIiwid2VicGFjazovLy8uL2NvcmUtYnVuZGxlL2Fzc2V0cy9jb250cm9sbGVycy9jaGVjay1hbGwtY29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly8vLi9jb3JlLWJ1bmRsZS9hc3NldHMvY29udHJvbGxlcnMvY2hvaWNlcy1jb250cm9sbGVyLmpzIiwid2VicGFjazovLy8uL2NvcmUtYnVuZGxlL2Fzc2V0cy9jb250cm9sbGVycy9jbGlwYm9hcmQtY29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly8vLi9jb3JlLWJ1bmRsZS9hc3NldHMvY29udHJvbGxlcnMvY29sb3ItcGlja2VyLWNvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vY29yZS1idW5kbGUvYXNzZXRzL2NvbnRyb2xsZXJzL2NvbG9yLXNjaGVtZS1jb250cm9sbGVyLmpzIiwid2VicGFjazovLy8uL2NvcmUtYnVuZGxlL2Fzc2V0cy9jb250cm9sbGVycy9kZWVwbGluay1jb250cm9sbGVyLmpzIiwid2VicGFjazovLy8uL2NvcmUtYnVuZGxlL2Fzc2V0cy9jb250cm9sbGVycy9kaWFsb2ctY29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly8vLi9jb3JlLWJ1bmRsZS9hc3NldHMvY29udHJvbGxlcnMvaW1hZ2Utc2l6ZS1jb250cm9sbGVyLmpzIiwid2VicGFjazovLy8uL2NvcmUtYnVuZGxlL2Fzc2V0cy9jb250cm9sbGVycy9pbnB1dC1tYXAtY29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly8vLi9jb3JlLWJ1bmRsZS9hc3NldHMvY29udHJvbGxlcnMvam9icy1jb250cm9sbGVyLmpzIiwid2VicGFjazovLy8uL2NvcmUtYnVuZGxlL2Fzc2V0cy9jb250cm9sbGVycy9qdW1wLXRhcmdldHMtY29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly8vLi9jb3JlLWJ1bmRsZS9hc3NldHMvY29udHJvbGxlcnMvbGltaXQtaGVpZ2h0LWNvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vY29yZS1idW5kbGUvYXNzZXRzL2NvbnRyb2xsZXJzL21lc3NhZ2Utb3V0bGV0LWNvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vY29yZS1idW5kbGUvYXNzZXRzL2NvbnRyb2xsZXJzL21ldGF3aXphcmQtY29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly8vLi9jb3JlLWJ1bmRsZS9hc3NldHMvY29udHJvbGxlcnMvb3BlcmF0aW9ucy1tZW51LWNvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vY29yZS1idW5kbGUvYXNzZXRzL2NvbnRyb2xsZXJzL3Bhc3NrZXlzLWNvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vY29yZS1idW5kbGUvYXNzZXRzL2NvbnRyb2xsZXJzL3Byb2ZpbGUtY29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly8vLi9jb3JlLWJ1bmRsZS9hc3NldHMvY29udHJvbGxlcnMvcm93LXdpemFyZC1jb250cm9sbGVyLmpzIiwid2VicGFjazovLy8uL2NvcmUtYnVuZGxlL2Fzc2V0cy9jb250cm9sbGVycy9zY3JvbGwtb2Zmc2V0LWNvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vY29yZS1idW5kbGUvYXNzZXRzL2NvbnRyb2xsZXJzL3NlcnAtcHJldmlldy1jb250cm9sbGVyLmpzIiwid2VicGFjazovLy8uL2NvcmUtYnVuZGxlL2Fzc2V0cy9jb250cm9sbGVycy9zb3J0YWJsZS1jb250cm9sbGVyLmpzIiwid2VicGFjazovLy8uL2NvcmUtYnVuZGxlL2Fzc2V0cy9jb250cm9sbGVycy90YWJzLWNvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vY29yZS1idW5kbGUvYXNzZXRzL2NvbnRyb2xsZXJzL3RlbXBsYXRlLXN0dWRpby1jb250cm9sbGVyLmpzIiwid2VicGFjazovLy8uL2NvcmUtYnVuZGxlL2Fzc2V0cy9jb250cm9sbGVycy90aW55bWNlLWNvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vY29yZS1idW5kbGUvYXNzZXRzL2NvbnRyb2xsZXJzL3RvZ2dsZS1maWVsZHNldC1jb250cm9sbGVyLmpzIiwid2VicGFjazovLy8uL2NvcmUtYnVuZGxlL2Fzc2V0cy9jb250cm9sbGVycy90b2dnbGUtbmF2aWdhdGlvbi1jb250cm9sbGVyLmpzIiwid2VicGFjazovLy8uL2NvcmUtYnVuZGxlL2Fzc2V0cy9jb250cm9sbGVycy90b2dnbGUtbm9kZXMtY29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly8vLi9jb3JlLWJ1bmRsZS9hc3NldHMvY29udHJvbGxlcnMvdG9vbHRpcHMtY29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly8vLi9jb3JlLWJ1bmRsZS9hc3NldHMvY29udHJvbGxlcnMvd2ViYXV0aG4tZXJyb3ItY29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly8vLi9jb3JlLWJ1bmRsZS9hc3NldHMvbW9kdWxlcy9pY29uLmpzIiwid2VicGFjazovLy8uL2NvcmUtYnVuZGxlL2Fzc2V0cy9tb2R1bGVzL21lc3NhZ2UuanMiLCJ3ZWJwYWNrOi8vLy4vY29yZS1idW5kbGUvYXNzZXRzL21vZHVsZXMvdHVyYm8tc3RyZWFtLWNvbm5lY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vY29yZS1idW5kbGUvYXNzZXRzL21vZHVsZXMvdHdpZy1lZGl0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vY29yZS1idW5kbGUvYXNzZXRzL3NjcmlwdHMvY29yZS5qcyIsIndlYnBhY2s6Ly8vLi9jb3JlLWJ1bmRsZS9hc3NldHMvc2NyaXB0cy9saW1pdC1oZWlnaHQuanMiLCJ3ZWJwYWNrOi8vLy4vY29yZS1idW5kbGUvYXNzZXRzL3NjcmlwdHMvbW9vdGFvLmpzIiwid2VicGFjazovLy8uL2NvcmUtYnVuZGxlL2Fzc2V0cy9zdHlsZXMvYmFja2VuZC5wY3NzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaG90d2lyZWQvc3RpbXVsdXMtd2VicGFjay1oZWxwZXJzL2Rpc3Qvc3RpbXVsdXMtd2VicGFjay1oZWxwZXJzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AaG90d2lyZWQvc3RpbXVsdXMvZGlzdC9zdGltdWx1cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGhvdHdpcmVkL3R1cmJvL2Rpc3QvdHVyYm8uZXMyMDE3LWVzbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHNpbW9ud2VwL3BpY2tyL2Rpc3QvcGlja3IubWluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ac2ltcGxld2ViYXV0aG4vYnJvd3Nlci9lc20vaGVscGVycy9iYXNlNjRVUkxTdHJpbmdUb0J1ZmZlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHNpbXBsZXdlYmF1dGhuL2Jyb3dzZXIvZXNtL2hlbHBlcnMvYnJvd3NlclN1cHBvcnRzV2ViQXV0aG4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BzaW1wbGV3ZWJhdXRobi9icm93c2VyL2VzbS9oZWxwZXJzL2Jyb3dzZXJTdXBwb3J0c1dlYkF1dGhuQXV0b2ZpbGwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BzaW1wbGV3ZWJhdXRobi9icm93c2VyL2VzbS9oZWxwZXJzL2J1ZmZlclRvQmFzZTY0VVJMU3RyaW5nLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ac2ltcGxld2ViYXV0aG4vYnJvd3Nlci9lc20vaGVscGVycy9pZGVudGlmeUF1dGhlbnRpY2F0aW9uRXJyb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BzaW1wbGV3ZWJhdXRobi9icm93c2VyL2VzbS9oZWxwZXJzL2lkZW50aWZ5UmVnaXN0cmF0aW9uRXJyb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BzaW1wbGV3ZWJhdXRobi9icm93c2VyL2VzbS9oZWxwZXJzL2lzVmFsaWREb21haW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BzaW1wbGV3ZWJhdXRobi9icm93c2VyL2VzbS9oZWxwZXJzL3BsYXRmb3JtQXV0aGVudGljYXRvcklzQXZhaWxhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ac2ltcGxld2ViYXV0aG4vYnJvd3Nlci9lc20vaGVscGVycy90b0F1dGhlbnRpY2F0b3JBdHRhY2htZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ac2ltcGxld2ViYXV0aG4vYnJvd3Nlci9lc20vaGVscGVycy90b1B1YmxpY0tleUNyZWRlbnRpYWxEZXNjcmlwdG9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ac2ltcGxld2ViYXV0aG4vYnJvd3Nlci9lc20vaGVscGVycy93ZWJBdXRobkFib3J0U2VydmljZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHNpbXBsZXdlYmF1dGhuL2Jyb3dzZXIvZXNtL2hlbHBlcnMvd2ViQXV0aG5FcnJvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHNpbXBsZXdlYmF1dGhuL2Jyb3dzZXIvZXNtL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ac2ltcGxld2ViYXV0aG4vYnJvd3Nlci9lc20vbWV0aG9kcy9zdGFydEF1dGhlbnRpY2F0aW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ac2ltcGxld2ViYXV0aG4vYnJvd3Nlci9lc20vbWV0aG9kcy9zdGFydFJlZ2lzdHJhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHNpbXBsZXdlYmF1dGhuL2Jyb3dzZXIvZXNtL3R5cGVzL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ac3RpbXVsdXMtY29tcG9uZW50cy9jb2xvci1waWNrZXIvZGlzdC9zdGltdWx1cy1jb2xvci1waWNrZXIubWpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9hY2Nlc3NpYmxlLW1lbnUvZGlzdC9hY2Nlc3NpYmxlLW1lbnUuZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZvY3VzLXRyYXAvZGlzdC9mb2N1cy10cmFwLmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc29ydGFibGVqcy9tb2R1bGFyL3NvcnRhYmxlLmVzbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGFiYmFibGUvZGlzdC9pbmRleC5lc20uanMiLCJ3ZWJwYWNrOi8vLy4vdmVuZG9yL3dlYi1hdXRoL3dlYmF1dGhuLXN0aW11bHVzL2Fzc2V0cy9kaXN0L2NvbnRyb2xsZXIuanMiLCJ3ZWJwYWNrOi8vL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovLy93ZWJwYWNrL3J1bnRpbWUvY29tcGF0IGdldCBkZWZhdWx0IGV4cG9ydCIsIndlYnBhY2s6Ly8vd2VicGFjay9ydW50aW1lL2RlZmluZSBwcm9wZXJ0eSBnZXR0ZXJzIiwid2VicGFjazovLy93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovLy93ZWJwYWNrL3J1bnRpbWUvbWFrZSBuYW1lc3BhY2Ugb2JqZWN0Iiwid2VicGFjazovLy8uL2NvcmUtYnVuZGxlL2Fzc2V0cy9iYWNrZW5kLmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBtYXAgPSB7XG5cdFwiLi9hY2UtY29udHJvbGxlci5qc1wiOiBcIi4vY29yZS1idW5kbGUvYXNzZXRzL2NvbnRyb2xsZXJzL2FjZS1jb250cm9sbGVyLmpzXCIsXG5cdFwiLi9iYWNrZW5kLXNlYXJjaC1jb250cm9sbGVyLmpzXCI6IFwiLi9jb3JlLWJ1bmRsZS9hc3NldHMvY29udHJvbGxlcnMvYmFja2VuZC1zZWFyY2gtY29udHJvbGxlci5qc1wiLFxuXHRcIi4vY2hlY2stYWxsLWNvbnRyb2xsZXIuanNcIjogXCIuL2NvcmUtYnVuZGxlL2Fzc2V0cy9jb250cm9sbGVycy9jaGVjay1hbGwtY29udHJvbGxlci5qc1wiLFxuXHRcIi4vY2hvaWNlcy1jb250cm9sbGVyLmpzXCI6IFwiLi9jb3JlLWJ1bmRsZS9hc3NldHMvY29udHJvbGxlcnMvY2hvaWNlcy1jb250cm9sbGVyLmpzXCIsXG5cdFwiLi9jbGlwYm9hcmQtY29udHJvbGxlci5qc1wiOiBcIi4vY29yZS1idW5kbGUvYXNzZXRzL2NvbnRyb2xsZXJzL2NsaXBib2FyZC1jb250cm9sbGVyLmpzXCIsXG5cdFwiLi9jb2xvci1waWNrZXItY29udHJvbGxlci5qc1wiOiBcIi4vY29yZS1idW5kbGUvYXNzZXRzL2NvbnRyb2xsZXJzL2NvbG9yLXBpY2tlci1jb250cm9sbGVyLmpzXCIsXG5cdFwiLi9jb2xvci1zY2hlbWUtY29udHJvbGxlci5qc1wiOiBcIi4vY29yZS1idW5kbGUvYXNzZXRzL2NvbnRyb2xsZXJzL2NvbG9yLXNjaGVtZS1jb250cm9sbGVyLmpzXCIsXG5cdFwiLi9kZWVwbGluay1jb250cm9sbGVyLmpzXCI6IFwiLi9jb3JlLWJ1bmRsZS9hc3NldHMvY29udHJvbGxlcnMvZGVlcGxpbmstY29udHJvbGxlci5qc1wiLFxuXHRcIi4vZGlhbG9nLWNvbnRyb2xsZXIuanNcIjogXCIuL2NvcmUtYnVuZGxlL2Fzc2V0cy9jb250cm9sbGVycy9kaWFsb2ctY29udHJvbGxlci5qc1wiLFxuXHRcIi4vaW1hZ2Utc2l6ZS1jb250cm9sbGVyLmpzXCI6IFwiLi9jb3JlLWJ1bmRsZS9hc3NldHMvY29udHJvbGxlcnMvaW1hZ2Utc2l6ZS1jb250cm9sbGVyLmpzXCIsXG5cdFwiLi9pbnB1dC1tYXAtY29udHJvbGxlci5qc1wiOiBcIi4vY29yZS1idW5kbGUvYXNzZXRzL2NvbnRyb2xsZXJzL2lucHV0LW1hcC1jb250cm9sbGVyLmpzXCIsXG5cdFwiLi9qb2JzLWNvbnRyb2xsZXIuanNcIjogXCIuL2NvcmUtYnVuZGxlL2Fzc2V0cy9jb250cm9sbGVycy9qb2JzLWNvbnRyb2xsZXIuanNcIixcblx0XCIuL2p1bXAtdGFyZ2V0cy1jb250cm9sbGVyLmpzXCI6IFwiLi9jb3JlLWJ1bmRsZS9hc3NldHMvY29udHJvbGxlcnMvanVtcC10YXJnZXRzLWNvbnRyb2xsZXIuanNcIixcblx0XCIuL2xpbWl0LWhlaWdodC1jb250cm9sbGVyLmpzXCI6IFwiLi9jb3JlLWJ1bmRsZS9hc3NldHMvY29udHJvbGxlcnMvbGltaXQtaGVpZ2h0LWNvbnRyb2xsZXIuanNcIixcblx0XCIuL21lc3NhZ2Utb3V0bGV0LWNvbnRyb2xsZXIuanNcIjogXCIuL2NvcmUtYnVuZGxlL2Fzc2V0cy9jb250cm9sbGVycy9tZXNzYWdlLW91dGxldC1jb250cm9sbGVyLmpzXCIsXG5cdFwiLi9tZXRhd2l6YXJkLWNvbnRyb2xsZXIuanNcIjogXCIuL2NvcmUtYnVuZGxlL2Fzc2V0cy9jb250cm9sbGVycy9tZXRhd2l6YXJkLWNvbnRyb2xsZXIuanNcIixcblx0XCIuL29wZXJhdGlvbnMtbWVudS1jb250cm9sbGVyLmpzXCI6IFwiLi9jb3JlLWJ1bmRsZS9hc3NldHMvY29udHJvbGxlcnMvb3BlcmF0aW9ucy1tZW51LWNvbnRyb2xsZXIuanNcIixcblx0XCIuL3Bhc3NrZXlzLWNvbnRyb2xsZXIuanNcIjogXCIuL2NvcmUtYnVuZGxlL2Fzc2V0cy9jb250cm9sbGVycy9wYXNza2V5cy1jb250cm9sbGVyLmpzXCIsXG5cdFwiLi9wcm9maWxlLWNvbnRyb2xsZXIuanNcIjogXCIuL2NvcmUtYnVuZGxlL2Fzc2V0cy9jb250cm9sbGVycy9wcm9maWxlLWNvbnRyb2xsZXIuanNcIixcblx0XCIuL3Jvdy13aXphcmQtY29udHJvbGxlci5qc1wiOiBcIi4vY29yZS1idW5kbGUvYXNzZXRzL2NvbnRyb2xsZXJzL3Jvdy13aXphcmQtY29udHJvbGxlci5qc1wiLFxuXHRcIi4vc2Nyb2xsLW9mZnNldC1jb250cm9sbGVyLmpzXCI6IFwiLi9jb3JlLWJ1bmRsZS9hc3NldHMvY29udHJvbGxlcnMvc2Nyb2xsLW9mZnNldC1jb250cm9sbGVyLmpzXCIsXG5cdFwiLi9zZXJwLXByZXZpZXctY29udHJvbGxlci5qc1wiOiBcIi4vY29yZS1idW5kbGUvYXNzZXRzL2NvbnRyb2xsZXJzL3NlcnAtcHJldmlldy1jb250cm9sbGVyLmpzXCIsXG5cdFwiLi9zb3J0YWJsZS1jb250cm9sbGVyLmpzXCI6IFwiLi9jb3JlLWJ1bmRsZS9hc3NldHMvY29udHJvbGxlcnMvc29ydGFibGUtY29udHJvbGxlci5qc1wiLFxuXHRcIi4vdGFicy1jb250cm9sbGVyLmpzXCI6IFwiLi9jb3JlLWJ1bmRsZS9hc3NldHMvY29udHJvbGxlcnMvdGFicy1jb250cm9sbGVyLmpzXCIsXG5cdFwiLi90ZW1wbGF0ZS1zdHVkaW8tY29udHJvbGxlci5qc1wiOiBcIi4vY29yZS1idW5kbGUvYXNzZXRzL2NvbnRyb2xsZXJzL3RlbXBsYXRlLXN0dWRpby1jb250cm9sbGVyLmpzXCIsXG5cdFwiLi90aW55bWNlLWNvbnRyb2xsZXIuanNcIjogXCIuL2NvcmUtYnVuZGxlL2Fzc2V0cy9jb250cm9sbGVycy90aW55bWNlLWNvbnRyb2xsZXIuanNcIixcblx0XCIuL3RvZ2dsZS1maWVsZHNldC1jb250cm9sbGVyLmpzXCI6IFwiLi9jb3JlLWJ1bmRsZS9hc3NldHMvY29udHJvbGxlcnMvdG9nZ2xlLWZpZWxkc2V0LWNvbnRyb2xsZXIuanNcIixcblx0XCIuL3RvZ2dsZS1uYXZpZ2F0aW9uLWNvbnRyb2xsZXIuanNcIjogXCIuL2NvcmUtYnVuZGxlL2Fzc2V0cy9jb250cm9sbGVycy90b2dnbGUtbmF2aWdhdGlvbi1jb250cm9sbGVyLmpzXCIsXG5cdFwiLi90b2dnbGUtbm9kZXMtY29udHJvbGxlci5qc1wiOiBcIi4vY29yZS1idW5kbGUvYXNzZXRzL2NvbnRyb2xsZXJzL3RvZ2dsZS1ub2Rlcy1jb250cm9sbGVyLmpzXCIsXG5cdFwiLi90b29sdGlwcy1jb250cm9sbGVyLmpzXCI6IFwiLi9jb3JlLWJ1bmRsZS9hc3NldHMvY29udHJvbGxlcnMvdG9vbHRpcHMtY29udHJvbGxlci5qc1wiLFxuXHRcIi4vd2ViYXV0aG4tZXJyb3ItY29udHJvbGxlci5qc1wiOiBcIi4vY29yZS1idW5kbGUvYXNzZXRzL2NvbnRyb2xsZXJzL3dlYmF1dGhuLWVycm9yLWNvbnRyb2xsZXIuanNcIlxufTtcblxuXG5mdW5jdGlvbiB3ZWJwYWNrQ29udGV4dChyZXEpIHtcblx0dmFyIGlkID0gd2VicGFja0NvbnRleHRSZXNvbHZlKHJlcSk7XG5cdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKGlkKTtcbn1cbmZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0UmVzb2x2ZShyZXEpIHtcblx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhtYXAsIHJlcSkpIHtcblx0XHR2YXIgZSA9IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIgKyByZXEgKyBcIidcIik7XG5cdFx0ZS5jb2RlID0gJ01PRFVMRV9OT1RfRk9VTkQnO1xuXHRcdHRocm93IGU7XG5cdH1cblx0cmV0dXJuIG1hcFtyZXFdO1xufVxud2VicGFja0NvbnRleHQua2V5cyA9IGZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0S2V5cygpIHtcblx0cmV0dXJuIE9iamVjdC5rZXlzKG1hcCk7XG59O1xud2VicGFja0NvbnRleHQucmVzb2x2ZSA9IHdlYnBhY2tDb250ZXh0UmVzb2x2ZTtcbm1vZHVsZS5leHBvcnRzID0gd2VicGFja0NvbnRleHQ7XG53ZWJwYWNrQ29udGV4dC5pZCA9IFwiLi9jb3JlLWJ1bmRsZS9hc3NldHMvY29udHJvbGxlcnMgc3luYyByZWN1cnNpdmUgXFxcXC5qcyRcIjsiLCJpbXBvcnQgeyBDb250cm9sbGVyIH0gZnJvbSAnQGhvdHdpcmVkL3N0aW11bHVzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgZXh0ZW5kcyBDb250cm9sbGVyIHtcbiAgICBzdGF0aWMgdmFsdWVzID0ge1xuICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgIHJlYWRPbmx5OiBCb29sZWFuLFxuICAgIH07XG5cbiAgICBjb25uZWN0KCkge1xuICAgICAgICAvLyBDcmVhdGUgYSBkaXYgdG8gYXBwbHkgdGhlIGVkaXRvciB0b1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5pZCA9IGAke3RoaXMuZWxlbWVudC5pZH1fZGl2YDtcbiAgICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NOYW1lID0gdGhpcy5lbGVtZW50LmNsYXNzTmFtZTtcbiAgICAgICAgdGhpcy5lbGVtZW50LnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRoaXMuY29udGFpbmVyLCB0aGlzLmVsZW1lbnQubmV4dFNpYmxpbmcpO1xuXG4gICAgICAgIC8vIEhpZGUgdGhlIHRleHRhcmVhXG4gICAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXG4gICAgICAgIC8vIEluc3RhbnRpYXRlIHRoZSBlZGl0b3JcbiAgICAgICAgdGhpcy5lZGl0b3IgPSBhY2UuZWRpdCh0aGlzLmNvbnRhaW5lcik7XG4gICAgICAgIHRoaXMuZWRpdG9yLmdldFNlc3Npb24oKS5zZXRWYWx1ZSh0aGlzLmVsZW1lbnQudmFsdWUpO1xuXG4gICAgICAgIHRoaXMuZWRpdG9yLm9uKCdmb2N1cycsICgpID0+IHtcbiAgICAgICAgICAgIHdpbmRvdy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnc3RvcmUtc2Nyb2xsLW9mZnNldCcpKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5lZGl0b3IuZ2V0U2Vzc2lvbigpLm9uKCdjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQudmFsdWUgPSB0aGlzLmVkaXRvci5nZXRWYWx1ZSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBEaXNhYmxlIGNvbW1hbmQgY29uZmxpY3RzIHdpdGggQWx0R3IgKHNlZSAjNTc5MilcbiAgICAgICAgdGhpcy5lZGl0b3IuY29tbWFuZHMuYmluZEtleSgnQ3RybC1hbHQtYXxDdHJsLWFsdC1lfEN0cmwtYWx0LWh8Q3RybC1hbHQtbHxDdHJsLWFsdC1zJywgbnVsbCk7XG5cbiAgICAgICAgLy8gRXhlY3V0ZSB0aGUgY29uZmlnIGNhbGxiYWNrXG4gICAgICAgIHRoaXMuZWxlbWVudD8uY29uZmlnQ2FsbGJhY2sodGhpcy5lZGl0b3IpO1xuXG4gICAgICAgIHRoaXMuc2V0TWF4TGluZXMoKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuc2V0TWF4TGluZXMuYmluZCh0aGlzKSk7XG4gICAgfVxuXG4gICAgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5lZGl0b3I/LmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5jb250YWluZXI/LnJlbW92ZSgpO1xuICAgIH1cblxuICAgIGJlZm9yZUNhY2hlKCkge1xuICAgICAgICAvLyBSZW1vdmUgdGhlIGVsZW1lbnQgY29udGFpbmVyIGJlZm9yZSBUdXJibyBjYWNoZXMgdGhlIHBhZ2UuIEl0IHdpbGxcbiAgICAgICAgLy8gYmUgcmVjcmVhdGVkIHdoZW4gdGhlIGNvbm5lY3QoKSBjYWxsIGhhcHBlbnMgb24gdGhlIHJlc3RvcmVkIHBhZ2UuXG4gICAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgIH1cblxuICAgIGNvbG9yQ2hhbmdlKGV2ZW50KSB7XG4gICAgICAgIHRoaXMuZWRpdG9yLnNldFRoZW1lKGBhY2UvdGhlbWUvJHtldmVudC5kZXRhaWwubW9kZSA9PT0gJ2RhcmsnID8gJ3R3aWxpZ2h0JyA6ICdjbG91ZHMnfWApO1xuICAgIH1cblxuICAgIHNldE1heExpbmVzKCkge1xuICAgICAgICB0aGlzLmVkaXRvci5zZXRPcHRpb24oXG4gICAgICAgICAgICAnbWF4TGluZXMnLFxuICAgICAgICAgICAgTWF0aC5mbG9vcigod2luZG93LmlubmVySGVpZ2h0IC0gMzIwKSAvIE1hdGguZmxvb3IoMTIgKiB0aGlzLmVkaXRvci5jb250YWluZXIuc3R5bGUubGluZUhlaWdodCkpLFxuICAgICAgICApO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IENvbnRyb2xsZXIgfSBmcm9tICdAaG90d2lyZWQvc3RpbXVsdXMnO1xuaW1wb3J0ICogYXMgZm9jdXNUcmFwIGZyb20gJ2ZvY3VzLXRyYXAnO1xuaW1wb3J0IHsgVHVyYm9TdHJlYW1Db25uZWN0aW9uIH0gZnJvbSAnLi4vbW9kdWxlcy90dXJiby1zdHJlYW0tY29ubmVjdGlvbic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEJhY2tlbmRTZWFyY2hDb250cm9sbGVyIGV4dGVuZHMgQ29udHJvbGxlciB7XG4gICAgc3RhdGljIHRhcmdldHMgPSBbJ2lucHV0JywgJ3Jlc3VsdHMnXTtcblxuICAgIHN0YXRpYyB2YWx1ZXMgPSB7XG4gICAgICAgIHVybDogU3RyaW5nLFxuICAgICAgICBtaW5DaGFyYWN0ZXJzOiBOdW1iZXIsXG4gICAgICAgIGRlYm91bmNlRGVsYXk6IE51bWJlcixcbiAgICB9O1xuXG4gICAgc3RhdGljIGNsYXNzZXMgPSBbJ2hpZGRlbicsICdpbml0aWFsJywgJ2xvYWRpbmcnLCAnaW52YWxpZCcsICdyZXN1bHRzJywgJ2Vycm9yJ107XG5cbiAgICBjb25uZWN0KCkge1xuICAgICAgICB0aGlzLmRlYm91bmNlVGltZW91dCA9IG51bGw7XG4gICAgICAgIHRoaXMuc2VhcmNoUmVzdWx0Q29ubmVjdGlvbiA9IG5ldyBUdXJib1N0cmVhbUNvbm5lY3Rpb24oKTtcblxuICAgICAgICB0aGlzLmZvY3VzVHJhcCA9IGZvY3VzVHJhcC5jcmVhdGVGb2N1c1RyYXAodGhpcy5lbGVtZW50LCB7XG4gICAgICAgICAgICBlc2NhcGVEZWFjdGl2YXRlczogZmFsc2UsXG4gICAgICAgICAgICBhbGxvd091dHNpZGVDbGljazogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5fc3RvcFBlbmRpbmdTZWFyY2goKTtcbiAgICB9XG5cbiAgICBhc3luYyBzZWFyY2goKSB7XG4gICAgICAgIHRoaXMuX3N0b3BQZW5kaW5nU2VhcmNoKCk7XG5cbiAgICAgICAgLy8gUmVxdWlyZSBhIG1pbmltdW0gbnVtYmVyIG9mIGNoYXJhY3RlcnNcbiAgICAgICAgaWYgKHRoaXMuaW5wdXRUYXJnZXQudmFsdWUubGVuZ3RoIDwgdGhpcy5taW5DaGFyYWN0ZXJzVmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZXRTdGF0ZSgnaW52YWxpZCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc2V0U3RhdGUoJ2xvYWRpbmcnKTtcblxuICAgICAgICAvLyBEZWJvdW5jZSB0byBhdm9pZCB0b28gbWFueSByZXF1ZXN0c1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gKHRoaXMuZGVib3VuY2VUaW1lb3V0ID0gc2V0VGltZW91dChyZXNvbHZlLCB0aGlzLmRlYm91bmNlRGVsYXlWYWx1ZSkpKTtcblxuICAgICAgICAvLyBHZXQgdGhlIHNlYXJjaCByZXN1bHRzXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuc2VhcmNoUmVzdWx0Q29ubmVjdGlvbi5nZXQodGhpcy51cmxWYWx1ZSwgeyBrZXl3b3JkczogdGhpcy5pbnB1dFRhcmdldC52YWx1ZSB9KTtcblxuICAgICAgICBpZiAocmVzdWx0Lm9rKSB7XG4gICAgICAgICAgICB0aGlzLl9zZXRTdGF0ZSgncmVzdWx0cycpO1xuICAgICAgICAgICAgdGhpcy5mb2N1c1RyYXAuYWN0aXZhdGUoKTtcbiAgICAgICAgfSBlbHNlIGlmIChyZXN1bHQuZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuX3NldFN0YXRlKCdlcnJvcicpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb3BlbigpIHtcbiAgICAgICAgLy8gSWdub3JlIGZvY3VzIG9uIGlucHV0IGlmIHRhYmJpbmcgdGhyb3VnaCByZXN1bHRzXG4gICAgICAgIGlmICh0aGlzLmZvY3VzVHJhcC5hY3RpdmUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3NldFN0YXRlKCdpbml0aWFsJyk7XG4gICAgfVxuXG4gICAgY2xvc2UoZXZlbnQpIHtcbiAgICAgICAgLy8gT25seSBjbG9zZSB3aGVuIGNsaWNraW5nIGF3YXlcbiAgICAgICAgaWYgKGV2ZW50IGluc3RhbmNlb2YgUG9pbnRlckV2ZW50ICYmIHRoaXMuZWxlbWVudC5jb250YWlucyhldmVudC50YXJnZXQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZ25vcmUgbG9zdCBmb2N1cyBvbiBpbnB1dCB3aGVuIHRhYmJpbmcgdGhyb3VnaCByZXN1bHRzXG4gICAgICAgIGlmIChldmVudC50eXBlID09PSAnYmx1cicgJiYgdGhpcy5mb2N1c1RyYXAuYWN0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zdG9wUGVuZGluZ1NlYXJjaCgpO1xuICAgICAgICB0aGlzLnJlc3VsdHNUYXJnZXQuaW5uZXJUZXh0ID0gJyc7XG5cbiAgICAgICAgdGhpcy5pbnB1dFRhcmdldC5ibHVyKCk7XG4gICAgICAgIHRoaXMuaW5wdXRUYXJnZXQudmFsdWUgPSAnJztcblxuICAgICAgICB0aGlzLl9zZXRTdGF0ZSgnaGlkZGVuJyk7XG4gICAgfVxuXG4gICAgX3N0b3BQZW5kaW5nU2VhcmNoKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5kZWJvdW5jZVRpbWVvdXQpO1xuICAgICAgICB0aGlzLnNlYXJjaFJlc3VsdENvbm5lY3Rpb24uYWJvcnRQZW5kaW5nKCk7XG4gICAgICAgIHRoaXMuZm9jdXNUcmFwLmRlYWN0aXZhdGUoKTtcbiAgICB9XG5cbiAgICBfc2V0U3RhdGUoc3RhdGUpIHtcbiAgICAgICAgZm9yIChjb25zdCBjbGFzc05hbWUgb2YgQmFja2VuZFNlYXJjaENvbnRyb2xsZXIuY2xhc3Nlcykge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC50b2dnbGUodGhpc1tgJHtjbGFzc05hbWV9Q2xhc3NgXSwgY2xhc3NOYW1lID09PSBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJpbXBvcnQgeyBDb250cm9sbGVyIH0gZnJvbSAnQGhvdHdpcmVkL3N0aW11bHVzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgZXh0ZW5kcyBDb250cm9sbGVyIHtcbiAgICBzdGF0aWMgdGFyZ2V0cyA9IFsnc291cmNlJywgJ2lucHV0J107XG5cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIGNvbnN0IGNoZWNrZWQgPSB0aGlzLnNvdXJjZVRhcmdldC5jaGVja2VkO1xuXG4gICAgICAgIGZvciAoY29uc3QgZWwgb2YgdGhpcy5pbnB1dFRhcmdldHMpIHtcbiAgICAgICAgICAgIGVsLmNoZWNrZWQgPSBjaGVja2VkO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgQ29udHJvbGxlciB9IGZyb20gJ0Bob3R3aXJlZC9zdGltdWx1cyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENob2ljZXNDb250cm9sbGVyIGV4dGVuZHMgQ29udHJvbGxlciB7XG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0ID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ3NlbGVjdCcpO1xuXG4gICAgICAgIHRoaXMuY2hvaWNlcyA9IG5ldyBDaG9pY2VzKHNlbGVjdCwge1xuICAgICAgICAgICAgc2hvdWxkU29ydDogZmFsc2UsXG4gICAgICAgICAgICBkdXBsaWNhdGVJdGVtc0FsbG93ZWQ6IGZhbHNlLFxuICAgICAgICAgICAgYWxsb3dIVE1MOiBmYWxzZSxcbiAgICAgICAgICAgIHJlbW92ZUl0ZW1CdXR0b246IHRydWUsXG4gICAgICAgICAgICBzZWFyY2hFbmFibGVkOiBzZWxlY3Qub3B0aW9ucy5sZW5ndGggPiA3LFxuICAgICAgICAgICAgc2VhcmNoUmVzdWx0TGltaXQ6IC0xLFxuICAgICAgICAgICAgYXBwZW5kR3JvdXBJblNlYXJjaDogdHJ1ZSxcbiAgICAgICAgICAgIGNsYXNzTmFtZXM6IHtcbiAgICAgICAgICAgICAgICBjb250YWluZXJPdXRlcjogWydjaG9pY2VzJywgLi4uQXJyYXkuZnJvbShzZWxlY3QuY2xhc3NMaXN0KV0sXG4gICAgICAgICAgICAgICAgZmxpcHBlZFN0YXRlOiAnJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmdXNlT3B0aW9uczoge1xuICAgICAgICAgICAgICAgIGluY2x1ZGVTY29yZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB0aHJlc2hvbGQ6IDAuNCxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYWxsYmFja09uSW5pdDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNob2ljZXMgPSBzZWxlY3QuY2xvc2VzdCgnLmNob2ljZXMnKT8ucXVlcnlTZWxlY3RvcignLmNob2ljZXNfX2xpc3QtLWRyb3Bkb3duID4gLmNob2ljZXNfX2xpc3QnKTtcblxuICAgICAgICAgICAgICAgIGlmIChjaG9pY2VzICYmIHNlbGVjdC5kYXRhc2V0LnBsYWNlaG9sZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNob2ljZXMuZGF0YXNldC5wbGFjZWhvbGRlciA9IHNlbGVjdC5kYXRhc2V0LnBsYWNlaG9sZGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsb2FkaW5nVGV4dDogQ29udGFvLmxhbmcubG9hZGluZyxcbiAgICAgICAgICAgIG5vUmVzdWx0c1RleHQ6IENvbnRhby5sYW5nLm5vUmVzdWx0cyxcbiAgICAgICAgICAgIG5vQ2hvaWNlc1RleHQ6IENvbnRhby5sYW5nLm5vT3B0aW9ucyxcbiAgICAgICAgICAgIHJlbW92ZUl0ZW1MYWJlbFRleHQ6ICh2YWx1ZSkgPT4gQ29udGFvLmxhbmcucmVtb3ZlSXRlbS5jb25jYXQoJyAnKS5jb25jYXQodmFsdWUpLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICB0aGlzLl9yZW1vdmVDaG9pY2VzKCk7XG4gICAgfVxuXG4gICAgYmVmb3JlQ2FjaGUoKSB7XG4gICAgICAgIC8vIExldCBjaG9pY2VzIHVud3JhcCB0aGUgZWxlbWVudCBjb250YWluZXIgYmVmb3JlIFR1cmJvIGNhY2hlcyB0aGVcbiAgICAgICAgLy8gcGFnZS4gSXQgd2lsbCBiZSByZWNyZWF0ZWQsIHdoZW4gdGhlIGNvbm5lY3QoKSBjYWxsIGhhcHBlbnMgb24gdGhlXG4gICAgICAgIC8vIHJlc3RvcmVkIHBhZ2UuXG4gICAgICAgIHRoaXMuX3JlbW92ZUNob2ljZXMoKTtcbiAgICB9XG5cbiAgICBfcmVtb3ZlQ2hvaWNlcygpIHtcbiAgICAgICAgdGhpcy5jaG9pY2VzPy5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuY2hvaWNlcyA9IG51bGw7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgQ29udHJvbGxlciB9IGZyb20gJ0Bob3R3aXJlZC9zdGltdWx1cyc7XG5pbXBvcnQgKiBhcyBNZXNzYWdlIGZyb20gJy4uL21vZHVsZXMvbWVzc2FnZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIGV4dGVuZHMgQ29udHJvbGxlciB7XG4gICAgc3RhdGljIHZhbHVlcyA9IHtcbiAgICAgICAgY29udGVudDogU3RyaW5nLFxuICAgICAgICBtZXNzYWdlOiB7XG4gICAgICAgICAgICB0eXBlOiBTdHJpbmcsXG4gICAgICAgICAgICBkZWZhdWx0OiAnQ29waWVkIHRvIGNsaXBib2FyZC4nLFxuICAgICAgICB9LFxuICAgIH07XG5cbiAgICBhc3luYyB3cml0ZSgpIHtcbiAgICAgICAgaWYgKCFuYXZpZ2F0b3IuY2xpcGJvYXJkKSB7XG4gICAgICAgICAgICBpZiAod2luZG93LmNvbnNvbGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdUaGUgY2xpcGJvYXJkIEFQSSBpcyBub3QgYXZhaWxhYmxlLiBNYWtlIHN1cmUgeW91IHVzZSBhIHNlY3VyZSBjb250ZXh0IChodHRwcykuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGF3YWl0IG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KHRoaXMuY29udGVudFZhbHVlKTtcblxuICAgICAgICBNZXNzYWdlLmluZm8odGhpcy5tZXNzYWdlVmFsdWUpO1xuICAgIH1cbn1cbiIsImltcG9ydCBDb2xvclBpY2tlciBmcm9tICdAc3RpbXVsdXMtY29tcG9uZW50cy9jb2xvci1waWNrZXInO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBleHRlbmRzIENvbG9yUGlja2VyIHtcbiAgICBjb25uZWN0KCkge1xuICAgICAgICBsZXQgaGV4VmFsdWVMb2FkZWQgPSBmYWxzZTtcblxuICAgICAgICBpZiAodGhpcy5pbnB1dFRhcmdldC52YWx1ZSAmJiAvXlswLTlhLWZdezMsNn0kL2kudGVzdCh0aGlzLmlucHV0VGFyZ2V0LnZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5pbnB1dFRhcmdldC52YWx1ZSA9IGAjJHt0aGlzLmlucHV0VGFyZ2V0LnZhbHVlfWA7XG4gICAgICAgICAgICBoZXhWYWx1ZUxvYWRlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBzdXBlci5jb25uZWN0KCk7XG5cbiAgICAgICAgaWYgKGhleFZhbHVlTG9hZGVkKSB7XG4gICAgICAgICAgICB0aGlzLmlucHV0VGFyZ2V0LnZhbHVlID0gdGhpcy5pbnB1dFRhcmdldC52YWx1ZS5zdWJzdHJpbmcoMSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBPdmVycmlkZSB0aGUgb25TYXZlIGZ1bmN0aW9uIHRvIHN0cmlwIHRoZSBsZWFkaW5nIGAjYFxuICAgIG9uU2F2ZShjb2xvcikge1xuICAgICAgICB0aGlzLmlucHV0VGFyZ2V0LnZhbHVlID0gbnVsbDtcblxuICAgICAgICBpZiAoY29sb3IpIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IGNvbG9yLnRvSEVYQSgpLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgICAgIGlmICgnIycgPT09IHZhbHVlLmNoYXJBdCgwKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmlucHV0VGFyZ2V0LnZhbHVlID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMucGlja2VyLmhpZGUoKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBDb250cm9sbGVyIH0gZnJvbSAnQGhvdHdpcmVkL3N0aW11bHVzJztcblxuY29uc3QgcHJlZmVyc0RhcmsgPSAoKSA9PiB7XG4gICAgY29uc3QgcHJlZmVyc0RhcmsgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnY29udGFvLS1wcmVmZXJzLWRhcmsnKTtcblxuICAgIGlmIChudWxsID09PSBwcmVmZXJzRGFyaykge1xuICAgICAgICByZXR1cm4gISF3aW5kb3cubWF0Y2hNZWRpYSgnKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKScpLm1hdGNoZXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByZWZlcnNEYXJrID09PSAndHJ1ZSc7XG59O1xuXG5jb25zdCBzZXRDb2xvclNjaGVtZSA9ICgpID0+IHtcbiAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZGF0YXNldC5jb2xvclNjaGVtZSA9IHByZWZlcnNEYXJrKCkgPyAnZGFyaycgOiAnbGlnaHQnO1xufTtcblxud2luZG93Lm1hdGNoTWVkaWEoJyhwcmVmZXJzLWNvbG9yLXNjaGVtZTogZGFyayknKS5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBzZXRDb2xvclNjaGVtZSk7XG5zZXRDb2xvclNjaGVtZSgpO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBleHRlbmRzIENvbnRyb2xsZXIge1xuICAgIHN0YXRpYyB0YXJnZXRzID0gWydsYWJlbCddO1xuXG4gICAgc3RhdGljIHZhbHVlcyA9IHtcbiAgICAgICAgaTE4bjoge1xuICAgICAgICAgICAgdHlwZTogT2JqZWN0LFxuICAgICAgICAgICAgZGVmYXVsdDogeyBsaWdodDogJ0Rpc2FibGUgZGFyayBtb2RlJywgZGFyazogJ0VuYWJsZSBkYXJrIG1vZGUnIH0sXG4gICAgICAgIH0sXG4gICAgfTtcblxuICAgIGluaXRpYWxpemUoKSB7XG4gICAgICAgIHRoaXMuc2V0TGFiZWwgPSB0aGlzLnNldExhYmVsLmJpbmQodGhpcyk7XG4gICAgfVxuXG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5tYXRjaE1lZGlhID0gd2luZG93Lm1hdGNoTWVkaWEoJyhwcmVmZXJzLWNvbG9yLXNjaGVtZTogZGFyayknKTtcbiAgICAgICAgdGhpcy5tYXRjaE1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuc2V0TGFiZWwpO1xuICAgICAgICB0aGlzLnNldExhYmVsKCk7XG4gICAgfVxuXG4gICAgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5tYXRjaE1lZGlhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHRoaXMuc2V0TGFiZWwpO1xuICAgIH1cblxuICAgIHRvZ2dsZShlKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICBjb25zdCBpc0RhcmsgPSAhcHJlZmVyc0RhcmsoKTtcblxuICAgICAgICBpZiAoaXNEYXJrID09PSB0aGlzLm1hdGNoTWVkaWEubWF0Y2hlcykge1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oJ2NvbnRhby0tcHJlZmVycy1kYXJrJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnY29udGFvLS1wcmVmZXJzLWRhcmsnLCBTdHJpbmcoaXNEYXJrKSk7XG4gICAgICAgIH1cblxuICAgICAgICBzZXRDb2xvclNjaGVtZSgpO1xuXG4gICAgICAgIHRoaXMuZGlzcGF0Y2goJ2NoYW5nZScsIHtcbiAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgIG1vZGU6IGlzRGFyayA/ICdkYXJrJyA6ICdsaWdodCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBDaGFuZ2UgdGhlIGxhYmVsIGFmdGVyIHRoZSBkcm9wZG93biBpcyBoaWRkZW5cbiAgICAgICAgc2V0VGltZW91dCh0aGlzLnNldExhYmVsLCAzMDApO1xuICAgIH1cblxuICAgIHNldExhYmVsKCkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzTGFiZWxUYXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxhYmVsID0gdGhpcy5pMThuVmFsdWVbcHJlZmVyc0RhcmsoKSA/ICdsaWdodCcgOiAnZGFyayddO1xuXG4gICAgICAgIHRoaXMubGFiZWxUYXJnZXQudGl0bGUgPSBsYWJlbDtcbiAgICAgICAgdGhpcy5sYWJlbFRhcmdldC5pbm5lclRleHQgPSBsYWJlbDtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBDb250cm9sbGVyIH0gZnJvbSAnQGhvdHdpcmVkL3N0aW11bHVzJztcbmltcG9ydCAqIGFzIFR1cmJvIGZyb20gJ0Bob3R3aXJlZC90dXJibyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIGV4dGVuZHMgQ29udHJvbGxlciB7XG4gICAgc3RhdGljIHRhcmdldHMgPSBbJ3ByaW1hcnknLCAnc2Vjb25kYXJ5J107XG5cbiAgICBzdGF0aWMgYWZ0ZXJMb2FkKGlkZW50aWZpZXIpIHtcbiAgICAgICAgY29uc3Qgc2V0dXBDb250cm9sbGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbCBvZiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuY2xpY2syZWRpdCcpKSB7XG4gICAgICAgICAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSgnY2xpY2syZWRpdCcpO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgcHJpbWFyeSA9IGVsLnF1ZXJ5U2VsZWN0b3IoJ2EuZWRpdCcpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlY29uZGFyeSA9IGVsLnF1ZXJ5U2VsZWN0b3IoJ2EuY2hpbGRyZW4nKTtcblxuICAgICAgICAgICAgICAgIGlmIChwcmltYXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIHByaW1hcnkuc2V0QXR0cmlidXRlKGBkYXRhLSR7aWRlbnRpZmllcn0tdGFyZ2V0YCwgJ3ByaW1hcnknKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoc2Vjb25kYXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlY29uZGFyeS5zZXRBdHRyaWJ1dGUoYGRhdGEtJHtpZGVudGlmaWVyfS10YXJnZXRgLCAnc2Vjb25kYXJ5Jyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZWwuZGF0YXNldC5jb250cm9sbGVyID0gZWwuZGF0YXNldC5jb250cm9sbGVyXG4gICAgICAgICAgICAgICAgICAgID8gYCR7ZWwuZGF0YXNldC5jb250cm9sbGVyfSAke2lkZW50aWZpZXJ9YFxuICAgICAgICAgICAgICAgICAgICA6IGAke2lkZW50aWZpZXJ9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgc2V0dXBDb250cm9sbGVyKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignYWpheF9jaGFuZ2UnLCBzZXR1cENvbnRyb2xsZXIpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0dXJibzpyZW5kZXInLCBzZXR1cENvbnRyb2xsZXIpO1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0dXJibzpmcmFtZS1yZW5kZXInLCBzZXR1cENvbnRyb2xsZXIpO1xuICAgICAgICBzZXR1cENvbnRyb2xsZXIoKTtcblxuICAgICAgICBUaGVtZS5zZXR1cEN0cmxDbGljayA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICh3aW5kb3cuY29uc29sZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICAgICAgJ1VzaW5nIFRoZW1lLnNldHVwQ3RybENsaWNrKCkgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIENvbnRhbyA2LiBBcHBseSB0aGUgU3RpbXVsdXMgYWN0aW9ucyBpbnN0ZWFkLicsXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc2V0dXBDb250cm9sbGVyKCk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgdGhpcy5oYW5kbGUgPSB0aGlzLmhhbmRsZS5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIGNvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuaGFuZGxlKTtcbiAgICB9XG5cbiAgICBoYW5kbGUoZXZlbnQpIHtcbiAgICAgICAgLy8gSWdub3JlIGNsaWNrcyBvbiBhbmNob3IgZWxlbWVudHNcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcHJpbWFyeUtleSA9IHdpbmRvdy5uYXZpZ2F0b3IucGxhdGZvcm0/LnN0YXJ0c1dpdGgoJ01hYycpID8gJ21ldGFLZXknIDogJ2N0cmxLZXknO1xuXG4gICAgICAgIGlmIChldmVudFtwcmltYXJ5S2V5XSAmJiAhZXZlbnQuc2hpZnRLZXkgJiYgdGhpcy5oYXNQcmltYXJ5VGFyZ2V0ICYmIHRoaXMucHJpbWFyeVRhcmdldC5ocmVmKSB7XG4gICAgICAgICAgICBUdXJiby52aXNpdCh0aGlzLnByaW1hcnlUYXJnZXQuaHJlZik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnRbcHJpbWFyeUtleV0gJiYgZXZlbnQuc2hpZnRLZXkgJiYgdGhpcy5oYXNTZWNvbmRhcnlUYXJnZXQgJiYgdGhpcy5zZWNvbmRhcnlUYXJnZXQuaHJlZikge1xuICAgICAgICAgICAgVHVyYm8udmlzaXQodGhpcy5zZWNvbmRhcnlUYXJnZXQuaHJlZik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnQucG9pbnRlclR5cGUgPT09ICdtb3VzZScgfHwgIXRoaXMuaGFzUHJpbWFyeVRhcmdldCB8fCAhdGhpcy5wcmltYXJ5VGFyZ2V0LmhyZWYpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLiR0aW1lcik7XG5cbiAgICAgICAgaWYgKCF0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLXZpc2l0ZWQnKSkge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS12aXNpdGVkJywgJzEnKTtcblxuICAgICAgICAgICAgdGhpcy4kdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdkYXRhLXZpc2l0ZWQnKTtcbiAgICAgICAgICAgIH0sIDIwMDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnZGF0YS12aXNpdGVkJyk7XG4gICAgICAgICAgICBUdXJiby52aXNpdCh0aGlzLnByaW1hcnlUYXJnZXQuaHJlZik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2aXNpdFByaW1hcnkoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzUHJpbWFyeVRhcmdldCAmJiB0aGlzLnByaW1hcnlUYXJnZXQuaHJlZiAmJiB0aGlzLmlzVmFsaWQoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgICAgICAgVHVyYm8udmlzaXQodGhpcy5wcmltYXJ5VGFyZ2V0LmhyZWYpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmlzaXRTZWNvbmRhcnkoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzU2Vjb25kYXJ5VGFyZ2V0ICYmIHRoaXMuc2Vjb25kYXJ5VGFyZ2V0LmhyZWYgJiYgdGhpcy5pc1ZhbGlkKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgICAgIFR1cmJvLnZpc2l0KHRoaXMuc2Vjb25kYXJ5VGFyZ2V0LmhyZWYpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaXNWYWxpZChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiAnYScgIT09IGVsZW1lbnQudGFnTmFtZSAmJiAhZWxlbWVudC5jbG9zZXN0KCdhLCBidXR0b24nKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBDb250cm9sbGVyIH0gZnJvbSAnQGhvdHdpcmVkL3N0aW11bHVzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgZXh0ZW5kcyBDb250cm9sbGVyIHtcbiAgICBjb25uZWN0KCkge1xuICAgICAgICBpZiAodGhpcy5lbGVtZW50Lm9wZW4pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZWxlbWVudC5zaG93TW9kYWwoKTtcbiAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgIH1cblxuICAgIGZvY3VzKCkge1xuICAgICAgICAvLyBGb2N1cyB0aGUgZmlyc3QgaW5wdXQgZWxlbWVudCBpZiBwcmVzZW50XG4gICAgICAgIHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpPy5mb2N1cygpO1xuXG4gICAgICAgIC8vIFNlbGVjdCB0aGUgdGV4dCBvZiB0aGUgZmlyc3QgdGV4dCBpbnB1dCBlbGVtZW50IGlmIHByZXNlbnRcbiAgICAgICAgdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJ2lucHV0W3R5cGU9XCJ0ZXh0XCJdJyk/LnNlbGVjdCgpO1xuICAgIH1cblxuICAgIGNsb3NlKCkge1xuICAgICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgc3VzcGVuZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudC5vcGVuKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlc3VtZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVsZW1lbnQub3Blbikge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LnNob3dNb2RhbCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgQ29udHJvbGxlciB9IGZyb20gJ0Bob3R3aXJlZC9zdGltdWx1cyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIGV4dGVuZHMgQ29udHJvbGxlciB7XG4gICAgc3RhdGljIHRhcmdldHMgPSBbJ3NlbGVjdCcsICdidXR0b24nLCAnaW1hZ2UnLCAnd2lkdGgnLCAnaGVpZ2h0J107XG5cbiAgICBzdGF0aWMgdmFsdWVzID0ge1xuICAgICAgICBjb25maWc6IE9iamVjdCxcbiAgICB9O1xuXG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlV2l6YXJkKCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUlucHV0cygpO1xuICAgIH1cblxuICAgIHdpZHRoVGFyZ2V0RGlzY29ubmVjdGVkKGlucHV0KSB7XG4gICAgICAgIHRoaXMuX3Jlc2V0SW5wdXQoaW5wdXQpO1xuICAgIH1cblxuICAgIGhlaWdodFRhcmdldERpc2Nvbm5lY3RlZChpbnB1dCkge1xuICAgICAgICB0aGlzLl9yZXNldElucHV0KGlucHV0KTtcbiAgICB9XG5cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVdpemFyZCgpO1xuICAgICAgICB0aGlzLl91cGRhdGVJbnB1dHMoKTtcbiAgICB9XG5cbiAgICBfdXBkYXRlV2l6YXJkKCkge1xuICAgICAgICBpZiAodGhpcy5jYW5FZGl0KCkpIHtcbiAgICAgICAgICAgIHRoaXMuYnV0dG9uVGFyZ2V0LnRpdGxlID0gdGhpcy5jb25maWdWYWx1ZS50aXRsZTtcbiAgICAgICAgICAgIHRoaXMuYnV0dG9uVGFyZ2V0LmRpc2FibGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgaW1nIG9mIHRoaXMuaW1hZ2VUYXJnZXRzKSB7XG4gICAgICAgICAgICAgICAgaW1nLnNyYyA9IHRoaXMuY29uZmlnVmFsdWUuaWNvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYnV0dG9uVGFyZ2V0LnRpdGxlID0gJyc7XG4gICAgICAgICAgICB0aGlzLmJ1dHRvblRhcmdldC5kaXNhYmxlZCA9IHRydWU7XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgaW1nIG9mIHRoaXMuaW1hZ2VUYXJnZXRzKSB7XG4gICAgICAgICAgICAgICAgaW1nLnNyYyA9IHRoaXMuY29uZmlnVmFsdWUuaWNvbkRpc2FibGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3VwZGF0ZUlucHV0cygpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0ID0gdGhpcy5zZWxlY3RUYXJnZXQ7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gc2VsZWN0LnZhbHVlO1xuXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gJycgfHwgdmFsdWUuaW5kZXhPZignXycpID09PSAwIHx8IHZhbHVlLnRvSW50KCkudG9TdHJpbmcoKSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIGxldCBkaW1lbnNpb25zID0gc2VsZWN0Lm9wdGlvbnNbc2VsZWN0LnNlbGVjdGVkSW5kZXhdLnRleHQ7XG4gICAgICAgICAgICBkaW1lbnNpb25zID0gZGltZW5zaW9ucy5zcGxpdCgnKCcpO1xuICAgICAgICAgICAgZGltZW5zaW9ucyA9IGRpbWVuc2lvbnMubGVuZ3RoID4gMSA/IGRpbWVuc2lvbnMuZ2V0TGFzdCgpLnNwbGl0KCcpJylbMF0uc3BsaXQoJ3gnKSA6IFsnJywgJyddO1xuXG4gICAgICAgICAgICB0aGlzLndpZHRoVGFyZ2V0LnJlYWRPbmx5ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0VGFyZ2V0LnJlYWRPbmx5ID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMud2lkdGhUYXJnZXQudmFsdWUgPSAnJztcbiAgICAgICAgICAgIHRoaXMuaGVpZ2h0VGFyZ2V0LnZhbHVlID0gJyc7XG4gICAgICAgICAgICB0aGlzLndpZHRoVGFyZ2V0LnNldEF0dHJpYnV0ZSgncGxhY2Vob2xkZXInLCBkaW1lbnNpb25zWzBdICogMSB8fCAnJyk7XG4gICAgICAgICAgICB0aGlzLmhlaWdodFRhcmdldC5zZXRBdHRyaWJ1dGUoJ3BsYWNlaG9sZGVyJywgZGltZW5zaW9uc1sxXSAqIDEgfHwgJycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy53aWR0aFRhcmdldC5yZWFkT25seSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5oZWlnaHRUYXJnZXQucmVhZE9ubHkgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMud2lkdGhUYXJnZXQucmVtb3ZlQXR0cmlidXRlKCdwbGFjZWhvbGRlcicpO1xuICAgICAgICAgICAgdGhpcy5oZWlnaHRUYXJnZXQucmVtb3ZlQXR0cmlidXRlKCdwbGFjZWhvbGRlcicpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3Jlc2V0SW5wdXQoaW5wdXQpIHtcbiAgICAgICAgaW5wdXQudmFsdWUgPSAnJztcbiAgICAgICAgaW5wdXQucmVtb3ZlQXR0cmlidXRlKCdwbGFjZWhvbGRlcicpO1xuICAgICAgICBpbnB1dC5yZWFkT25seSA9IGZhbHNlO1xuICAgIH1cblxuICAgIG9wZW5Nb2RhbCgpIHtcbiAgICAgICAgQmFja2VuZC5vcGVuTW9kYWxJZnJhbWUoe1xuICAgICAgICAgICAgdGl0bGU6IHRoaXMuY29uZmlnVmFsdWUudGl0bGUsXG4gICAgICAgICAgICB1cmw6IGAke3RoaXMuY29uZmlnVmFsdWUuaHJlZn0maWQ9JHt0aGlzLnNlbGVjdFRhcmdldC52YWx1ZX1gLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBjYW5FZGl0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWdWYWx1ZS5pZHMuaW5jbHVkZXMoTnVtYmVyKHRoaXMuc2VsZWN0VGFyZ2V0LnZhbHVlKSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgQ29udHJvbGxlciB9IGZyb20gJ0Bob3R3aXJlZC9zdGltdWx1cyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIGV4dGVuZHMgQ29udHJvbGxlciB7XG4gICAgc3RhdGljIHRhcmdldHMgPSBbJ2lucHV0JywgJ3NvdXJjZSddO1xuXG4gICAgc3RhdGljIHZhbHVlcyA9IHtcbiAgICAgICAgYXR0cmlidXRlOiBTdHJpbmcsXG4gICAgfTtcblxuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBbXTtcblxuICAgICAgICBmb3IgKGNvbnN0IGVsIG9mIHRoaXMuc291cmNlVGFyZ2V0cykge1xuICAgICAgICAgICAgdmFsdWUucHVzaChlbC5nZXRBdHRyaWJ1dGUodGhpcy5hdHRyaWJ1dGVWYWx1ZSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5pbnB1dFRhcmdldC52YWx1ZSA9IHZhbHVlLmpvaW4oJywnKTtcbiAgICB9XG5cbiAgICByZW1vdmVFbGVtZW50KGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGVsID0gdGhpcy5fZ2V0RWxlbWVudChldmVudCk7XG5cbiAgICAgICAgaWYgKCFlbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZWwucmVtb3ZlKCk7XG5cbiAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICB9XG5cbiAgICBfZ2V0RWxlbWVudChldmVudCkge1xuICAgICAgICBpZiAoZXZlbnQucGFyYW1zLmNsb3Nlc3QpIHtcbiAgICAgICAgICAgIHJldHVybiBldmVudC50YXJnZXQuY2xvc2VzdChldmVudC5wYXJhbXMuY2xvc2VzdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXZlbnQucGFyYW1zLnF1ZXJ5U2VsZWN0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiBldmVudC50YXJnZXQucXVlcnlTZWxlY3RvcihldmVudC5wYXJhbXMucXVlcnlTZWxlY3Rvcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXZlbnQudGFyZ2V0O1xuICAgIH1cbn1cbiIsImltcG9ydCB7IENvbnRyb2xsZXIgfSBmcm9tICdAaG90d2lyZWQvc3RpbXVsdXMnO1xuaW1wb3J0ICogYXMgTWVzc2FnZSBmcm9tICcuLi9tb2R1bGVzL21lc3NhZ2UnO1xuaW1wb3J0IHsgVHVyYm9TdHJlYW1Db25uZWN0aW9uIH0gZnJvbSAnLi4vbW9kdWxlcy90dXJiby1zdHJlYW0tY29ubmVjdGlvbic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIGV4dGVuZHMgQ29udHJvbGxlciB7XG4gICAgX3R1cmJvU3RyZWFtQ29ubmVjdGlvbiA9IG5ldyBUdXJib1N0cmVhbUNvbm5lY3Rpb24oKTtcbiAgICBfcnVubmluZ0pvYnMgPSBmYWxzZTtcblxuICAgIHN0YXRpYyB2YWx1ZXMgPSB7XG4gICAgICAgIHBlbmRpbmdKb2JzVXJsOiBTdHJpbmcsXG4gICAgICAgIGRlZmF1bHRJbnRlcnZhbDogTnVtYmVyLFxuICAgICAgICBtYXhpbXVtSW50ZXJ2YWw6IE51bWJlcixcbiAgICAgICAgZW5hYmxlZDogQm9vbGVhbixcbiAgICAgICAgYWxsSm9ic1Byb2Nlc3NlZE1lc3NhZ2U6IFN0cmluZyxcbiAgICB9O1xuXG4gICAgc3RhdGljIHRhcmdldHMgPSBbJ2NvdW50JywgJ2xpc3QnXTtcblxuICAgIGNvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMuX3BvbGxJbnRlcnZhbCA9IHRoaXMuZGVmYXVsdEludGVydmFsVmFsdWU7XG4gICAgICAgIHRoaXMuX3RpbWVyID0gbnVsbDtcblxuICAgICAgICBpZiAodGhpcy5lbmFibGVkVmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXMuZW5hYmxlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBlbmFibGUoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG4gICAgICAgIHRoaXMuX3BvbGwoKTtcbiAgICB9XG5cbiAgICBsaXN0VGFyZ2V0Q29ubmVjdGVkKGVsKSB7XG4gICAgICAgIC8vIENsZWFyIHRpbWVyIGluIGNhc2UgdGhlIHRhcmdldCB3YXMgYWRkZWQgbWFudWFsbHlcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcblxuICAgICAgICBpZiAoJzAnID09PSBlbC5kYXRhc2V0LmpvYnMpIHtcbiAgICAgICAgICAgIHRoaXMuY291bnRUYXJnZXQuaW5uZXJUZXh0ID0gJyc7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9ydW5uaW5nSm9icykge1xuICAgICAgICAgICAgICAgIC8vIEFMbCBwZW5kaW5nIGpvYnMgaGF2ZSBiZWVuIHByb2Nlc3NlZFxuICAgICAgICAgICAgICAgIHRoaXMuX3J1bm5pbmdKb2JzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgTWVzc2FnZS5pbmZvKHRoaXMuYWxsSm9ic1Byb2Nlc3NlZE1lc3NhZ2VWYWx1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENvbnRpbnVvdXNseSBpbmNyZWFzZSBpbnRlcnZhbCBpZiB0aGVyZSBhcmUgbm8gcmVzdWx0c1xuICAgICAgICAgICAgdGhpcy5fcG9sbEludGVydmFsID0gTWF0aC5taW4odGhpcy5tYXhpbXVtSW50ZXJ2YWxWYWx1ZSwgdGhpcy5fcG9sbEludGVydmFsICogMik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvdW50VGFyZ2V0LmlubmVyVGV4dCA9IGVsLmRhdGFzZXQuam9icztcbiAgICAgICAgICAgIHRoaXMuX3J1bm5pbmdKb2JzID0gdHJ1ZTtcblxuICAgICAgICAgICAgdGhpcy5fcG9sbEludGVydmFsID0gdGhpcy5kZWZhdWx0SW50ZXJ2YWxWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3dhaXRBbmRQb2xsKCk7XG4gICAgfVxuXG4gICAgX3dhaXRBbmRQb2xsKCkge1xuICAgICAgICB0aGlzLl90aW1lciA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5fcG9sbCgpLCB0aGlzLl9wb2xsSW50ZXJ2YWwpO1xuICAgIH1cblxuICAgIF9wb2xsKCkge1xuICAgICAgICB0aGlzLl90dXJib1N0cmVhbUNvbm5lY3Rpb24uZ2V0KHRoaXMucGVuZGluZ0pvYnNVcmxWYWx1ZSwgbnVsbCwgdHJ1ZSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgQ29udHJvbGxlciB9IGZyb20gJ0Bob3R3aXJlZC9zdGltdWx1cyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIGV4dGVuZHMgQ29udHJvbGxlciB7XG4gICAgc3RhdGljIHRhcmdldHMgPSBbJ25hdmlnYXRpb24nLCAnc2VjdGlvbiddO1xuXG4gICAgc2VjdGlvblRhcmdldENvbm5lY3RlZCgpIHtcbiAgICAgICAgdGhpcy5yZWJ1aWxkTmF2aWdhdGlvbigpO1xuICAgIH1cblxuICAgIHNlY3Rpb25UYXJnZXREaXNjb25uZWN0ZWQoKSB7XG4gICAgICAgIHRoaXMucmVidWlsZE5hdmlnYXRpb24oKTtcbiAgICB9XG5cbiAgICByZWJ1aWxkTmF2aWdhdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc05hdmlnYXRpb25UYXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGxpbmtzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndWwnKTtcblxuICAgICAgICBmb3IgKGNvbnN0IGVsIG9mIHRoaXMuc2VjdGlvblRhcmdldHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGFjdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICAgICAgYWN0aW9uLmlubmVyVGV4dCA9IGVsLmdldEF0dHJpYnV0ZShgZGF0YS0ke3RoaXMuaWRlbnRpZmllcn0tbGFiZWwtdmFsdWVgKTtcblxuICAgICAgICAgICAgYWN0aW9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoKCdzY3JvbGx0bycsIHsgdGFyZ2V0OiBlbCB9KTtcbiAgICAgICAgICAgICAgICBlbC5zY3JvbGxJbnRvVmlldygpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGxpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcbiAgICAgICAgICAgIGxpLmFwcGVuZChhY3Rpb24pO1xuXG4gICAgICAgICAgICBsaW5rcy5hcHBlbmQobGkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uVGFyZ2V0LnJlcGxhY2VDaGlsZHJlbihsaW5rcyk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgQ29udHJvbGxlciB9IGZyb20gJ0Bob3R3aXJlZC9zdGltdWx1cyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIGV4dGVuZHMgQ29udHJvbGxlciB7XG4gICAgc3RhdGljIHZhbHVlcyA9IHtcbiAgICAgICAgbWF4OiBOdW1iZXIsXG4gICAgICAgIGV4cGFuZDogU3RyaW5nLFxuICAgICAgICBjb2xsYXBzZTogU3RyaW5nLFxuICAgICAgICBleHBhbmRBbGw6IFN0cmluZyxcbiAgICAgICAgZXhwYW5kQWxsVGl0bGU6IFN0cmluZyxcbiAgICAgICAgY29sbGFwc2VBbGw6IFN0cmluZyxcbiAgICAgICAgY29sbGFwc2VBbGxUaXRsZTogU3RyaW5nLFxuICAgIH07XG5cbiAgICBzdGF0aWMgdGFyZ2V0cyA9IFsnb3BlcmF0aW9uJywgJ25vZGUnXTtcblxuICAgIGluaXRpYWxpemUoKSB7XG4gICAgICAgIHN1cGVyLmluaXRpYWxpemUoKTtcbiAgICAgICAgdGhpcy50b2dnbGVyTWFwID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgdGhpcy5uZXh0SWQgPSAxO1xuICAgIH1cblxuICAgIG9wZXJhdGlvblRhcmdldENvbm5lY3RlZCgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVPcGVyYXRpb24oKTtcbiAgICB9XG5cbiAgICBub2RlVGFyZ2V0Q29ubmVjdGVkKG5vZGUpIHtcbiAgICAgICAgY29uc3Qgc3R5bGUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShub2RlLCBudWxsKTtcbiAgICAgICAgY29uc3QgcGFkZGluZyA9IE51bWJlci5wYXJzZUZsb2F0KHN0eWxlLnBhZGRpbmdUb3ApICsgTnVtYmVyLnBhcnNlRmxvYXQoc3R5bGUucGFkZGluZ0JvdHRvbSk7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IG5vZGUuY2xpZW50SGVpZ2h0IC0gcGFkZGluZztcblxuICAgICAgICAvLyBSZXNpemUgdGhlIGVsZW1lbnQgaWYgaXQgaXMgaGlnaGVyIHRoYW4gdGhlIG1heGltdW0gaGVpZ2h0XG4gICAgICAgIGlmICh0aGlzLm1heFZhbHVlID4gaGVpZ2h0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW5vZGUuaWQpIHtcbiAgICAgICAgICAgIG5vZGUuaWQgPSBgbGltaXQtaGVpZ2h0LSR7dGhpcy5uZXh0SWQrK31gO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZS5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgICAgICBub2RlLnN0eWxlLm1heEhlaWdodCA9IGAke3RoaXMubWF4VmFsdWV9cHhgO1xuXG4gICAgICAgIGNvbnN0IGJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICBidXR0b24uc2V0QXR0cmlidXRlKCd0eXBlJywgJ2J1dHRvbicpO1xuICAgICAgICBidXR0b24udGl0bGUgPSB0aGlzLmV4cGFuZFZhbHVlO1xuICAgICAgICBidXR0b24uaW5uZXJIVE1MID0gJzxzcGFuPi4uLjwvc3Bhbj4nO1xuICAgICAgICBidXR0b24uY2xhc3NMaXN0LmFkZCgndW5zZWxlY3RhYmxlJyk7XG4gICAgICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCAnZmFsc2UnKTtcbiAgICAgICAgYnV0dG9uLnNldEF0dHJpYnV0ZSgnYXJpYS1jb250cm9scycsIG5vZGUuaWQpO1xuXG4gICAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlKG5vZGUpO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVPcGVyYXRpb24oZXZlbnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCB0b2dnbGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRvZ2dsZXIuY2xhc3NMaXN0LmFkZCgnbGltaXRfdG9nZ2xlcicpO1xuICAgICAgICB0b2dnbGVyLmFwcGVuZChidXR0b24pO1xuXG4gICAgICAgIHRoaXMudG9nZ2xlck1hcC5zZXQobm9kZSwgdG9nZ2xlcik7XG5cbiAgICAgICAgbm9kZS5hcHBlbmQodG9nZ2xlcik7XG4gICAgICAgIHRoaXMudXBkYXRlT3BlcmF0aW9uKCk7XG4gICAgfVxuXG4gICAgbm9kZVRhcmdldERpc2Nvbm5lY3RlZChub2RlKSB7XG4gICAgICAgIGlmICghdGhpcy50b2dnbGVyTWFwLmhhcyhub2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50b2dnbGVyTWFwLmdldChub2RlKS5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy50b2dnbGVyTWFwLmRlbGV0ZShub2RlKTtcbiAgICAgICAgbm9kZS5zdHlsZS5vdmVyZmxvdyA9ICcnO1xuICAgICAgICBub2RlLnN0eWxlLm1heEhlaWdodCA9ICcnO1xuICAgIH1cblxuICAgIHRvZ2dsZShub2RlKSB7XG4gICAgICAgIGlmIChub2RlLnN0eWxlLm1heEhlaWdodCA9PT0gJycpIHtcbiAgICAgICAgICAgIHRoaXMuY29sbGFwc2Uobm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmV4cGFuZChub2RlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGV4cGFuZChub2RlKSB7XG4gICAgICAgIGlmICghdGhpcy50b2dnbGVyTWFwLmhhcyhub2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZS5zdHlsZS5tYXhIZWlnaHQgPSAnJztcbiAgICAgICAgY29uc3QgYnV0dG9uID0gdGhpcy50b2dnbGVyTWFwLmdldChub2RlKS5xdWVyeVNlbGVjdG9yKCdidXR0b24nKTtcbiAgICAgICAgYnV0dG9uLnRpdGxlID0gdGhpcy5jb2xsYXBzZVZhbHVlO1xuICAgICAgICBidXR0b24uc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgJ3RydWUnKTtcbiAgICB9XG5cbiAgICBjb2xsYXBzZShub2RlKSB7XG4gICAgICAgIGlmICghdGhpcy50b2dnbGVyTWFwLmhhcyhub2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZS5zdHlsZS5tYXhIZWlnaHQgPSBgJHt0aGlzLm1heFZhbHVlfXB4YDtcbiAgICAgICAgY29uc3QgYnV0dG9uID0gdGhpcy50b2dnbGVyTWFwLmdldChub2RlKS5xdWVyeVNlbGVjdG9yKCdidXR0b24nKTtcbiAgICAgICAgYnV0dG9uLnRpdGxlID0gdGhpcy5leHBhbmRWYWx1ZTtcbiAgICAgICAgYnV0dG9uLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICdmYWxzZScpO1xuICAgIH1cblxuICAgIHRvZ2dsZUFsbChldmVudCkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBjb25zdCBpc0V4cGFuZGVkID0gdGhpcy5oYXNFeHBhbmRlZCgpIF4gZXZlbnQuYWx0S2V5O1xuXG4gICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiB0aGlzLm5vZGVUYXJnZXRzKSB7XG4gICAgICAgICAgICBpZiAoaXNFeHBhbmRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29sbGFwc2Uobm9kZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZXhwYW5kKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51cGRhdGVPcGVyYXRpb24oZXZlbnQpO1xuICAgIH1cblxuICAgIGtleXByZXNzKGV2ZW50KSB7XG4gICAgICAgIHRoaXMudXBkYXRlT3BlcmF0aW9uKGV2ZW50KTtcbiAgICB9XG5cbiAgICB1cGRhdGVPcGVyYXRpb24oZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc09wZXJhdGlvblRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaGFzVG9nZ2xlcnMgPSAhIXRoaXMubm9kZVRhcmdldHMuZmluZCgoZWwpID0+IHRoaXMudG9nZ2xlck1hcC5oYXMoZWwpKTtcbiAgICAgICAgY29uc3QgZXhwYW5kZWQgPSB0aGlzLmhhc0V4cGFuZGVkKCk7XG5cbiAgICAgICAgZm9yIChjb25zdCBvcGVyYXRpb25UYXJnZXQgb2YgdGhpcy5vcGVyYXRpb25UYXJnZXRzKSB7XG4gICAgICAgICAgICBvcGVyYXRpb25UYXJnZXQuc3R5bGUuZGlzcGxheSA9IGhhc1RvZ2dsZXJzID8gJycgOiAnbm9uZSc7XG4gICAgICAgICAgICBvcGVyYXRpb25UYXJnZXQuc2V0QXR0cmlidXRlKCdhcmlhLWNvbnRyb2xzJywgdGhpcy5ub2RlVGFyZ2V0cy5tYXAoKGVsKSA9PiBlbC5pZCkuam9pbignICcpKTtcbiAgICAgICAgICAgIG9wZXJhdGlvblRhcmdldC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCBleHBhbmRlZCA/ICd0cnVlJyA6ICdmYWxzZScpO1xuXG4gICAgICAgICAgICBpZiAob3BlcmF0aW9uVGFyZ2V0LmNsb3Nlc3QoJyN0bF9idXR0b25zJykpIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb25UYXJnZXQucGFyZW50Tm9kZS5zdHlsZS5kaXNwbGF5ID0gaGFzVG9nZ2xlcnMgPyAnJyA6ICdub25lJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGV4cGFuZGVkIF4gKGV2ZW50ID8gZXZlbnQuYWx0S2V5IDogZmFsc2UpKSB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uVGFyZ2V0LmlubmVyVGV4dCA9IHRoaXMuY29sbGFwc2VBbGxWYWx1ZTtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb25UYXJnZXQudGl0bGUgPSB0aGlzLmNvbGxhcHNlQWxsVGl0bGVWYWx1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uVGFyZ2V0LmlubmVyVGV4dCA9IHRoaXMuZXhwYW5kQWxsVmFsdWU7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uVGFyZ2V0LnRpdGxlID0gdGhpcy5leHBhbmRBbGxUaXRsZVZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgaGFzRXhwYW5kZWQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMubm9kZVRhcmdldHMuZmluZCgoZWwpID0+IHRoaXMudG9nZ2xlck1hcC5oYXMoZWwpICYmIGVsLnN0eWxlLm1heEhlaWdodCA9PT0gJycpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IENvbnRyb2xsZXIgfSBmcm9tICdAaG90d2lyZWQvc3RpbXVsdXMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBleHRlbmRzIENvbnRyb2xsZXIge1xuICAgIHN0YXRpYyB0YXJnZXRzID0gWydtZXNzYWdlJywgJ21lc3NhZ2VQcm90b3R5cGUnXTtcblxuICAgIG1lc3NhZ2VUYXJnZXRDb25uZWN0ZWQoZWwpIHtcbiAgICAgICAgaWYgKGVsLmhhc0F0dHJpYnV0ZShgZGF0YS0ke3RoaXMuaWRlbnRpZmllcn0tYXV0b2Nsb3NlYCkpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5faGlkZShlbCksIGVsLmdldEF0dHJpYnV0ZShgZGF0YS0ke3RoaXMuaWRlbnRpZmllcn0tYXV0b2Nsb3NlYCkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xvc2UoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5faGlkZShldmVudC50YXJnZXQuY2xvc2VzdCgnKltkYXRhLWNvbnRhby0tbWVzc2FnZS1vdXRsZXQtdGFyZ2V0XScpKTtcbiAgICB9XG5cbiAgICByZW5kZXJNZXNzYWdlKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHsgdHlwZSwgbWVzc2FnZSB9ID0gZXZlbnQuZGV0YWlsO1xuXG4gICAgICAgIGZvciAoY29uc3QgdGFyZ2V0IG9mIHRoaXMubWVzc2FnZVByb3RvdHlwZVRhcmdldHMpIHtcbiAgICAgICAgICAgIGlmICh0YXJnZXQuZGF0YXNldC50eXBlID09PSB0eXBlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaHRtbCA9IHRhcmdldC5nZXRIVE1MKCkucmVwbGFjZSgne3ttZXNzYWdlfX0nLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kKGRvY3VtZW50LmNyZWF0ZVJhbmdlKCkuY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50KGh0bWwpKTtcblxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3aW5kb3cuY29uc29sZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgQ291bGQgbm90IGZpbmQgYW55IG1lc3NhZ2UgcHJvdG90eXBlcyBmb3IgdHlwZSBcIiR7dHlwZX1cIi5gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9oaWRlKGVsKSB7XG4gICAgICAgIGVsLmhpZGRlbiA9IHRydWU7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgQ29udHJvbGxlciB9IGZyb20gJ0Bob3R3aXJlZC9zdGltdWx1cyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIGV4dGVuZHMgQ29udHJvbGxlciB7XG4gICAgc3RhdGljIHRhcmdldHMgPSBbJ2lucHV0J107XG5cbiAgICBkZWxldGUoKSB7XG4gICAgICAgIGZvciAoY29uc3QgaW5wdXQgb2YgdGhpcy5pbnB1dFRhcmdldHMpIHtcbiAgICAgICAgICAgIGlucHV0LnZhbHVlID0gJyc7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJpbXBvcnQgeyBDb250cm9sbGVyIH0gZnJvbSAnQGhvdHdpcmVkL3N0aW11bHVzJztcbmltcG9ydCBBY2Nlc3NpYmxlTWVudSBmcm9tICdhY2Nlc3NpYmxlLW1lbnUnO1xuXG5sZXQgbWVudXMgPSBbXTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgT3BlcmF0aW9uc01lbnVDb250cm9sbGVyIGV4dGVuZHMgQ29udHJvbGxlciB7XG4gICAgc3RhdGljIHRhcmdldHMgPSBbJ21lbnUnLCAnc3VibWVudScsICdjb250cm9sbGVyJywgJ3RpdGxlJ107XG5cbiAgICBjb25uZWN0KCkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzQ29udHJvbGxlclRhcmdldCB8fCAhdGhpcy5oYXNNZW51VGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLiRtZW51ID0gbmV3IEFjY2Vzc2libGVNZW51LkRpc2Nsb3N1cmVNZW51KHtcbiAgICAgICAgICAgIG1lbnVFbGVtZW50OiB0aGlzLm1lbnVUYXJnZXQsXG4gICAgICAgICAgICBtZW51TGlua1NlbGVjdG9yOiAnYSxidXR0b24saW1nJyxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgbWVudXMucHVzaCh0aGlzLiRtZW51KTtcblxuICAgICAgICB0aGlzLmNvbnRyb2xsZXJUYXJnZXQ/LmFkZEV2ZW50TGlzdGVuZXIoJ2FjY2Vzc2libGVNZW51RXhwYW5kJywgKCkgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBtZW51IG9mIG1lbnVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1lbnUgIT09IHRoaXMuJG1lbnUgJiYgbWVudS5lbGVtZW50cy5zdWJtZW51VG9nZ2xlc1swXS5pc09wZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgbWVudS5lbGVtZW50cy5zdWJtZW51VG9nZ2xlc1swXS5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5zZXRQb3NpdGlvbigpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICAvLyBDbGVhbnVwIG1lbnUgaW5zdGFuY2UsIG90aGVyd2lzZSB3ZSB3b3VsZCBsZWFrIG1lbW9yeVxuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh3aW5kb3cuQWNjZXNzaWJsZU1lbnU/Lm1lbnVzID8/IHt9KSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB0aGlzLiRtZW51KSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHdpbmRvdy5BY2Nlc3NpYmxlTWVudS5tZW51c1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbWVudXMgPSBtZW51cy5maWx0ZXIoKG1lbnUpID0+IG1lbnUgIT09IHRoaXMuJG1lbnUpO1xuICAgIH1cblxuICAgIHRpdGxlVGFyZ2V0Q29ubmVjdGVkKGVsKSB7XG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShgZGF0YS0ke3RoaXMuaWRlbnRpZmllcn0tdGFyZ2V0YCk7XG5cbiAgICAgICAgY29uc3QgbGluayA9IGVsLnF1ZXJ5U2VsZWN0b3IoJ2FbdGl0bGVdJyk7XG4gICAgICAgIGlmIChsaW5rICYmICcnICE9PSBsaW5rLmdldEF0dHJpYnV0ZSgndGl0bGUnKSkge1xuICAgICAgICAgICAgbGluay5hcHBlbmQobGluay5nZXRBdHRyaWJ1dGUoJ3RpdGxlJykpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgaW1nID0gZWwucXVlcnlTZWxlY3RvcignaW1nW2FsdF0nKTtcbiAgICAgICAgaWYgKGltZyAmJiAnJyAhPT0gaW1nLmdldEF0dHJpYnV0ZSgnYWx0JykpIHtcbiAgICAgICAgICAgIGltZy5wYXJlbnROb2RlLmFwcGVuZChpbWcuZ2V0QXR0cmlidXRlKCdhbHQnKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvcGVuKGV2ZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNDb250cm9sbGVyVGFyZ2V0IHx8ICF0aGlzLmhhc01lbnVUYXJnZXQgfHwgdGhpcy5pc0ludGVyYWN0aXZlKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLiRtZW51LmVsZW1lbnRzLnN1Ym1lbnVUb2dnbGVzWzBdLmlzT3Blbikge1xuICAgICAgICAgICAgdGhpcy4kbWVudS5lbGVtZW50cy5zdWJtZW51VG9nZ2xlc1swXS5jbG9zZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAvLyBQcmV2ZW50IGFjY2Vzc2libGUtbWVudSBmcm9tIGhhbmRsaW5nIHBvaW50ZXJ1cCBhbmQgY2xvc2luZyB0aGUgbWVudSBhZ2FpbiAoc2VlICM4MDY1LCAjODU2NylcbiAgICAgICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJ1cCcsIChlKSA9PiBlLnN0b3BQcm9wYWdhdGlvbigpLCB7IG9uY2U6IHRydWUgfSk7XG5cbiAgICAgICAgdGhpcy4kbWVudS5lbGVtZW50cy5zdWJtZW51VG9nZ2xlc1swXS5vcGVuKCk7XG4gICAgICAgIHRoaXMuc2V0UG9zaXRpb24oZXZlbnQpO1xuICAgIH1cblxuICAgIHNldFBvc2l0aW9uKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IDI7IC8vIGJvcmRlci13aWR0aCB0aGF0IGlzIGV4Y2x1ZGVkIGZyb20gZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG5cbiAgICAgICAgY29uc3Qgc3VibWVudVJlY3QgPSB0aGlzLnN1Ym1lbnVUYXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGNvbnN0IHBhcmVudFJlY3QgPSB0aGlzLm1lbnVUYXJnZXQucXVlcnlTZWxlY3RvcignLm9wZXJhdGlvbnMtbWVudS1jb250YWluZXInKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICBjb25zdCByZWN0ID0gdGhpcy5jb250cm9sbGVyVGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBsZXQgY2xpZW50WDtcbiAgICAgICAgbGV0IGNsaWVudFk7XG5cbiAgICAgICAgaWYgKGV2ZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNsaWVudFggPSByZWN0LnJpZ2h0O1xuICAgICAgICAgICAgY2xpZW50WSA9IHJlY3QuYm90dG9tO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2xpZW50WCA9IGV2ZW50LmNsaWVudFg7XG4gICAgICAgICAgICBjbGllbnRZID0gZXZlbnQuY2xpZW50WTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgaW5uZXJXaWR0aCwgaW5uZXJIZWlnaHQgfSA9IHdpbmRvdztcbiAgICAgICAgY29uc3Qgcm93UmVjdCA9IHRoaXMuZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICBjb25zdCBvdmVyZmxvd1JpZ2h0ID0gaW5uZXJXaWR0aCA8IGNsaWVudFggKyBzdWJtZW51UmVjdC53aWR0aCArIHBhcmVudFJlY3Qud2lkdGg7XG4gICAgICAgIGNvbnN0IG92ZXJmbG93Qm90dG9tID0gaW5uZXJIZWlnaHQgPCBjbGllbnRZICsgc3VibWVudVJlY3QuaGVpZ2h0O1xuXG4gICAgICAgIGNvbnN0IHggPSBpbm5lcldpZHRoIC0gY2xpZW50WCAtIChpbm5lcldpZHRoIC0gcGFyZW50UmVjdC5sZWZ0KTtcbiAgICAgICAgbGV0IHkgPSBjbGllbnRZIC0gcm93UmVjdC50b3AgLSAocGFyZW50UmVjdC50b3AgLSByb3dSZWN0LnRvcCk7XG5cbiAgICAgICAgLy8gSWYgbm90IGEgY29udGV4dCBtZW51IGFuZCBib3R0b20gb3ZlcmZsb3csIHBvc2l0aW9uIGF0IHRoZSB0b3Agb2YgdGhlIFwibW9yZVwiIGhhbmRsZS5cbiAgICAgICAgaWYgKGV2ZW50ID09PSB1bmRlZmluZWQgJiYgb3ZlcmZsb3dCb3R0b20pIHtcbiAgICAgICAgICAgIHkgPSB5IC0gY2xpZW50WSArIHJlY3QudG9wIC0gb2Zmc2V0O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdWJtZW51VGFyZ2V0LnN0eWxlLmxlZnQgPSBvdmVyZmxvd1JpZ2h0ID8gYC0ke3ggKyBzdWJtZW51UmVjdC53aWR0aCAtIG9mZnNldH1weGAgOiBgLSR7eH1weGA7XG4gICAgICAgIHRoaXMuc3VibWVudVRhcmdldC5zdHlsZS50b3AgPSBvdmVyZmxvd0JvdHRvbSA/IGAke3kgLSBzdWJtZW51UmVjdC5oZWlnaHQgKyBvZmZzZXR9cHhgIDogYCR7eX1weGA7XG4gICAgICAgIHRoaXMuc3VibWVudVRhcmdldC5zdHlsZS5yaWdodCA9ICdhdXRvJztcbiAgICB9XG5cbiAgICBpc0ludGVyYWN0aXZlKGVsKSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICBlbCBpbnN0YW5jZW9mIEhUTUxBbmNob3JFbGVtZW50IHx8XG4gICAgICAgICAgICBlbCBpbnN0YW5jZW9mIEhUTUxCdXR0b25FbGVtZW50IHx8XG4gICAgICAgICAgICBlbCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQgfHxcbiAgICAgICAgICAgIGVsPy5jbG9zZXN0KCdhLCBidXR0b24sIGlucHV0JylcbiAgICAgICAgKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBDb250cm9sbGVyIH0gZnJvbSAnQGhvdHdpcmVkL3N0aW11bHVzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgZXh0ZW5kcyBDb250cm9sbGVyIHtcbiAgICBzdGF0aWMgdGFyZ2V0cyA9IFsnZm9ybScsICduYW1lSW5wdXQnXTtcblxuICAgIG5hbWVJbnB1dFRhcmdldENvbm5lY3RlZChlbCkge1xuICAgICAgICBlbC5mb2N1cygpO1xuICAgICAgICBlbC5zZWxlY3QoKTtcbiAgICB9XG5cbiAgICBjYW5jZWxFZGl0KGUpIHtcbiAgICAgICAgdGhpcy5uYW1lSW5wdXRUYXJnZXQudmFsdWUgPSB0aGlzLm5hbWVJbnB1dFRhcmdldC5nZXRBdHRyaWJ1dGUoJ3ZhbHVlJyk7XG4gICAgICAgIHRoaXMuZm9ybVRhcmdldC5yZXF1ZXN0U3VibWl0KCk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgQ29udHJvbGxlciB9IGZyb20gJ0Bob3R3aXJlZC9zdGltdWx1cyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIGV4dGVuZHMgQ29udHJvbGxlciB7XG4gICAgc3RhdGljIHRhcmdldHMgPSBbJ2J1dHRvbicsICdtZW51J107XG5cbiAgICBzdGF0aWMgdmFsdWVzID0ge1xuICAgICAgICBuYW1lOiB7IHR5cGU6IFN0cmluZywgZGVmYXVsdDogJ3RtZW51X19wcm9maWxlJyB9LFxuICAgIH07XG5cbiAgICBidXR0b25UYXJnZXRDb25uZWN0ZWQoYnV0dG9uKSB7XG4gICAgICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ2FyaWEtY29udHJvbHMnLCB0aGlzLm5hbWVWYWx1ZSk7XG4gICAgICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCAnZmFsc2UnKTtcbiAgICB9XG5cbiAgICBtZW51VGFyZ2V0Q29ubmVjdGVkKG1lbnUpIHtcbiAgICAgICAgbWVudS5zZXRBdHRyaWJ1dGUoJ2lkJywgdGhpcy5uYW1lVmFsdWUpO1xuICAgIH1cblxuICAgIHRvZ2dsZShldmVudCkge1xuICAgICAgICB0aGlzLm1lbnVUYXJnZXQuY2xhc3NMaXN0LnRvZ2dsZSgnYWN0aXZlJyk7XG5cbiAgICAgICAgaWYgKHRoaXMubWVudVRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoJ2FjdGl2ZScpKSB7XG4gICAgICAgICAgICB0aGlzLmJ1dHRvblRhcmdldC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCAndHJ1ZScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5idXR0b25UYXJnZXQuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgJ2ZhbHNlJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgdGhpcy5tZW51VGFyZ2V0LmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xuICAgICAgICB0aGlzLmJ1dHRvblRhcmdldC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCAnZmFsc2UnKTtcbiAgICB9XG5cbiAgICBkb2N1bWVudENsaWNrKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmJ1dHRvblRhcmdldC5jb250YWlucyhldmVudC50YXJnZXQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgQ29udHJvbGxlciB9IGZyb20gJ0Bob3R3aXJlZC9zdGltdWx1cyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIGV4dGVuZHMgQ29udHJvbGxlciB7XG4gICAgc3RhdGljIHRhcmdldHMgPSBbJ2JvZHknLCAncm93J107XG5cbiAgICByb3dUYXJnZXRDb25uZWN0ZWQoKSB7XG4gICAgICAgIHRoaXMudXBkYXRlU29ydGluZygpO1xuICAgIH1cblxuICAgIHJvd1RhcmdldERpc2Nvbm5lY3RlZCgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVTb3J0aW5nKCk7XG4gICAgfVxuXG4gICAgY29weShldmVudCkge1xuICAgICAgICBjb25zdCByb3cgPSB0aGlzLl9nZXRSb3coZXZlbnQpO1xuICAgICAgICBjb25zdCBwcmV2aW91cyA9IHJvdy5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuXG4gICAgICAgIC8vIENhdXNlIENob2ljZXMgYW5kIHNpbWlsYXIgY29udHJvbGxlcnMgdG8gYmUgZGlzY29ubmVjdGVkXG4gICAgICAgIHJvdy5yZW1vdmUoKTtcblxuICAgICAgICAvLyBXYWl0IHVudGlsIFN0aW11bHVzIGNvbnRyb2xsZXJzIGFyZSBkaXNjb25uZWN0ZWRcbiAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV3Um93ID0gcm93LmNsb25lTm9kZSh0cnVlKTtcblxuICAgICAgICAgICAgLy8gUmUtaW5zZXJ0IHRoZSBwcmV2aW91cyBhbmQgbmV3IHJvd1xuICAgICAgICAgICAgaWYgKHByZXZpb3VzKSB7XG4gICAgICAgICAgICAgICAgcHJldmlvdXMuYWZ0ZXIocm93LCBuZXdSb3cpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJvZHlUYXJnZXQucHJlcGVuZChyb3csIG5ld1Jvdyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2ZvY3VzKG5ld1Jvdyk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGRlbGV0ZShldmVudCkge1xuICAgICAgICBjb25zdCByb3cgPSB0aGlzLl9nZXRSb3coZXZlbnQpO1xuXG4gICAgICAgIGlmICh0aGlzLmJvZHlUYXJnZXQuY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGhpcy5fZm9jdXMocm93Lm5leHRFbGVtZW50U2libGluZykgfHxcbiAgICAgICAgICAgICAgICB0aGlzLl9mb2N1cyhyb3cucHJldmlvdXNFbGVtZW50U2libGluZykgfHxcbiAgICAgICAgICAgICAgICB0aGlzLl9mb2N1cyh0aGlzLmJvZHlUYXJnZXQpO1xuXG4gICAgICAgICAgICByb3cucmVtb3ZlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNldElucHV0cyhyb3cpO1xuICAgICAgICAgICAgdGhpcy5fZm9jdXMocm93KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHNwZWNpZmljIHRvIHRoZSByb3cgd2l6YXJkIGJlaW5nIGEgXCJtb2R1bGUgd2l6YXJkXCIuXG4gICAgICovXG4gICAgdXBkYXRlTW9kdWxlV2l6YXJkTGluayhldmVudCkge1xuICAgICAgICBjb25zdCByb3cgPSB0aGlzLl9nZXRSb3coZXZlbnQpO1xuICAgICAgICBjb25zdCBsaW5rID0gcm93LnF1ZXJ5U2VsZWN0b3IoJy5tb2R1bGVfbGluaycpO1xuICAgICAgICBjb25zdCBpbWFnZXMgPSByb3cucXVlcnlTZWxlY3RvckFsbCgnaW1nLm1vZHVsZV9pbWFnZScpO1xuICAgICAgICBjb25zdCBzZWxlY3QgPSBldmVudC50YXJnZXQ7XG5cbiAgICAgICAgY29uc3QgaXNDb250ZW50RWxlbWVudCA9IHNlbGVjdC52YWx1ZS5zdGFydHNXaXRoKCdjb250ZW50LScpO1xuICAgICAgICBjb25zdCBpZCA9IGlzQ29udGVudEVsZW1lbnQgPyBzZWxlY3QudmFsdWUucmVwbGFjZSgnY29udGVudC0nLCAnJykgOiBzZWxlY3QudmFsdWU7XG5cbiAgICAgICAgY29uc3QgaHJlZiA9IG5ldyBVUkwobGluay5ocmVmKTtcbiAgICAgICAgaHJlZi5zZWFyY2hQYXJhbXMuc2V0KCd0YWJsZScsIGlzQ29udGVudEVsZW1lbnQgPyAndGxfY29udGVudCcgOiAndGxfbW9kdWxlJyk7XG4gICAgICAgIGhyZWYuc2VhcmNoUGFyYW1zLnNldCgnaWQnLCBpZCk7XG4gICAgICAgIGxpbmsuaHJlZiA9IGhyZWYudG9TdHJpbmcoKTtcblxuICAgICAgICBpZiAoaWQgPiAwKSB7XG4gICAgICAgICAgICBsaW5rLmNsYXNzTGlzdC5yZW1vdmUoJ2hpZGRlbicpO1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGltYWdlIG9mIGltYWdlcykge1xuICAgICAgICAgICAgICAgIGltYWdlLmNsYXNzTGlzdC5hZGQoJ2hpZGRlbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGluay5jbGFzc0xpc3QuYWRkKCdoaWRkZW4nKTtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBpbWFnZSBvZiBpbWFnZXMpIHtcbiAgICAgICAgICAgICAgICBpbWFnZS5jbGFzc0xpc3QucmVtb3ZlKCdoaWRkZW4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZVNvcnRpbmcoKSB7XG4gICAgICAgIEFycmF5LmZyb20odGhpcy5ib2R5VGFyZ2V0LmNoaWxkcmVuKS5mb3JFYWNoKCh0ciwgaSkgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbCBvZiB0ci5xdWVyeVNlbGVjdG9yQWxsKCdsYWJlbCwgaW5wdXQsIHNlbGVjdCcpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwubmFtZSA9IGVsLm5hbWUucmVwbGFjZSgvXFxbWzAtOV0rXS9nLCBgWyR7aX1dYCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGVsLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLmlkID0gZWwuaWQucmVwbGFjZSgvX1swLTldKyhffCQpL2csIGBfJHtpfSQxYCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGVsLmdldEF0dHJpYnV0ZSgnZm9yJykpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdmb3InLCBlbC5nZXRBdHRyaWJ1dGUoJ2ZvcicpLnJlcGxhY2UoL19bMC05XSsoX3wkKS9nLCBgXyR7aX0kMWApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIF9nZXRSb3coZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50LnRhcmdldC5jbG9zZXN0KCcqW2RhdGEtY29udGFvLS1yb3ctd2l6YXJkLXRhcmdldD1cInJvd1wiXScpO1xuICAgIH1cblxuICAgIF9yZXNldElucHV0cyhyb3cpIHtcbiAgICAgICAgZm9yIChjb25zdCBpbnB1dCBvZiByb3cucXVlcnlTZWxlY3RvckFsbCgnaW5wdXQnKSkge1xuICAgICAgICAgICAgaW5wdXQudmFsdWUgPSAnJztcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3Qgc2VsZWN0IG9mIHJvdy5xdWVyeVNlbGVjdG9yQWxsKCdzZWxlY3QnKSkge1xuICAgICAgICAgICAgc2VsZWN0LnZhbHVlID0gc2VsZWN0LmNoaWxkcmVuWzBdLnZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2ZvY3VzKGVsKSB7XG4gICAgICAgIGlmICghZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsLnF1ZXJ5U2VsZWN0b3IoJ2lucHV0LCBzZWxlY3Q6bm90KC5jaG9pY2VzX19pbnB1dCksIC50bF9zZWxlY3QuY2hvaWNlcycpPy5mb2N1cygpO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IENvbnRyb2xsZXIgfSBmcm9tICdAaG90d2lyZWQvc3RpbXVsdXMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBleHRlbmRzIENvbnRyb2xsZXIge1xuICAgICNhdXRvRm9jdXMgPSBmYWxzZTtcblxuICAgIHN0YXRpYyB0YXJnZXRzID0gWydzY3JvbGxUbycsICdhdXRvRm9jdXMnLCAnd2lkZ2V0RXJyb3InXTtcblxuICAgIHN0YXRpYyB2YWx1ZXMgPSB7XG4gICAgICAgIHNlc3Npb25LZXk6IHtcbiAgICAgICAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgICAgICAgIGRlZmF1bHQ6ICdjb250YW9fYmFja2VuZF9vZmZzZXQnLFxuICAgICAgICB9LFxuICAgICAgICBiZWhhdmlvcjoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJ2luc3RhbnQnLFxuICAgICAgICB9LFxuICAgICAgICBibG9jazoge1xuICAgICAgICAgICAgdHlwZTogU3RyaW5nLFxuICAgICAgICAgICAgZGVmYXVsdDogJ2NlbnRlcicsXG4gICAgICAgIH0sXG4gICAgfTtcblxuICAgIC8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5OiBhdXRvbWF0aWNhbGx5IHJlZ2lzdGVyIHRoZSBTdGltdWx1cyBjb250cm9sbGVyIGlmIHRoZSBsZWdhY3kgbWV0aG9kcyBhcmUgdXNlZFxuICAgIHN0YXRpYyBhZnRlckxvYWQoaWRlbnRpZmllciwgYXBwbGljYXRpb24pIHtcbiAgICAgICAgY29uc3QgbG9hZEZhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb250cm9sbGVyID0gYXBwbGljYXRpb24uZ2V0Q29udHJvbGxlckZvckVsZW1lbnRBbmRJZGVudGlmaWVyKFxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXIsXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIGlmIChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoY29udHJvbGxlcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCB7IGNvbnRyb2xsZXJBdHRyaWJ1dGUgfSA9IGFwcGxpY2F0aW9uLnNjaGVtYTtcblxuICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zZXRBdHRyaWJ1dGUoXG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXJBdHRyaWJ1dGUsXG4gICAgICAgICAgICAgICAgICAgIGAke2RvY3VtZW50LmRvY3VtZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoY29udHJvbGxlckF0dHJpYnV0ZSkgfHwgJyd9ICR7aWRlbnRpZmllcn1gLFxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udHJvbGxlciA9IGFwcGxpY2F0aW9uLmdldENvbnRyb2xsZXJGb3JFbGVtZW50QW5kSWRlbnRpZmllcihcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXIsXG4gICAgICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAgICAgKGNvbnRyb2xsZXIgJiYgcmVzb2x2ZShjb250cm9sbGVyKSkgfHwgcmVqZWN0KGNvbnRyb2xsZXIpO1xuICAgICAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAod2luZG93LkJhY2tlbmQgJiYgIXdpbmRvdy5CYWNrZW5kLmluaXRTY3JvbGxPZmZzZXQpIHtcbiAgICAgICAgICAgIHdpbmRvdy5CYWNrZW5kLmluaXRTY3JvbGxPZmZzZXQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5jb25zb2xlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICAgICAgICAgICdCYWNrZW5kLmluaXRTY3JvbGxPZmZzZXQoKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIHRoZSBTdGltdWx1cyBjb250cm9sbGVyIGluc3RlYWQuJyxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsb2FkRmFsbGJhY2soKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAod2luZG93LkJhY2tlbmQgJiYgIXdpbmRvdy5CYWNrZW5kLmdldFNjcm9sbE9mZnNldCkge1xuICAgICAgICAgICAgd2luZG93LkJhY2tlbmQuZ2V0U2Nyb2xsT2Zmc2V0ID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh3aW5kb3cuY29uc29sZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgICAgICAgICAgICAnQmFja2VuZC5nZXRTY3JvbGxPZmZzZXQoKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIHRoZSBTdGltdWx1cyBjb250cm9sbGVyIGluc3RlYWQuJyxcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBsb2FkRmFsbGJhY2soKS50aGVuKChjb250cm9sbGVyKSA9PiBjb250cm9sbGVyLmRpc2NhcmQoKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaW5pdGlhbGl6ZSgpIHtcbiAgICAgICAgdGhpcy5zdG9yZSA9IHRoaXMuc3RvcmUuYmluZCh0aGlzKTtcbiAgICB9XG5cbiAgICBjb25uZWN0KCkge1xuICAgICAgICB0aGlzLnJlc3RvcmUoKTtcbiAgICB9XG5cbiAgICBhc3luYyByZXN0b3JlKCkge1xuICAgICAgICBpZiAoIXRoaXMub2Zmc2V0KSByZXR1cm47XG5cbiAgICAgICAgLy8gRXhlY3V0ZSBzY3JvbGwgcmVzdG9yZSBhZnRlciBUdXJibyBzY3JvbGxlZCB0byB0b3BcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVxdWVzdEFuaW1hdGlvbkZyYW1lKTtcblxuICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oe1xuICAgICAgICAgICAgdG9wOiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgIGJlaGF2aW9yOiB0aGlzLmJlaGF2aW9yVmFsdWUsXG4gICAgICAgICAgICBibG9jazogdGhpcy5ibG9ja1ZhbHVlLFxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLm9mZnNldCA9IG51bGw7XG4gICAgfVxuXG4gICAgc2Nyb2xsVG9UYXJnZXRDb25uZWN0ZWQoKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsVG9UYXJnZXQuc2Nyb2xsSW50b1ZpZXcoe1xuICAgICAgICAgICAgYmVoYXZpb3I6IHRoaXMuYmVoYXZpb3JWYWx1ZSxcbiAgICAgICAgICAgIGJsb2NrOiB0aGlzLmJsb2NrVmFsdWUsXG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGF1dG9Gb2N1c1RhcmdldENvbm5lY3RlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMub2Zmc2V0IHx8IHRoaXMuI2F1dG9Gb2N1cykgcmV0dXJuO1xuXG4gICAgICAgIGNvbnN0IGlucHV0ID0gdGhpcy5hdXRvRm9jdXNUYXJnZXQ7XG5cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgaW5wdXQuZGlzYWJsZWQgfHxcbiAgICAgICAgICAgIGlucHV0LnJlYWRvbmx5IHx8XG4gICAgICAgICAgICAhaW5wdXQub2Zmc2V0V2lkdGggfHxcbiAgICAgICAgICAgICFpbnB1dC5vZmZzZXRIZWlnaHQgfHxcbiAgICAgICAgICAgIGlucHV0LmNsb3Nlc3QoJy5jaHpuLXNlYXJjaCcpIHx8XG4gICAgICAgICAgICAoaW5wdXQuYXV0b2NvbXBsZXRlICYmIGlucHV0LmF1dG9jb21wbGV0ZSAhPT0gJ29mZicpXG4gICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy4jYXV0b0ZvY3VzID0gdHJ1ZTtcbiAgICAgICAgaW5wdXQuZm9jdXMoKTtcbiAgICB9XG5cbiAgICBhdXRvRm9jdXNUYXJnZXREaXNjb25uZWN0ZWQoKSB7XG4gICAgICAgIHRoaXMuI2F1dG9Gb2N1cyA9IGZhbHNlO1xuICAgIH1cblxuICAgIHdpZGdldEVycm9yVGFyZ2V0Q29ubmVjdGVkKCkge1xuICAgICAgICB0aGlzLndpZGdldEVycm9yVGFyZ2V0LnNjcm9sbEludG9WaWV3KHtcbiAgICAgICAgICAgIGJlaGF2aW9yOiAnc21vb3RoJyxcbiAgICAgICAgICAgIGJsb2NrOiAnc3RhcnQnLFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzdG9yZSgpIHtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSB0aGlzLmVsZW1lbnQuc2Nyb2xsVG9wO1xuICAgIH1cblxuICAgIGRpc2NhcmQoKSB7XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gbnVsbDtcbiAgICB9XG5cbiAgICBzY3JvbGxUb1dpZGdldEVycm9yKCkge1xuICAgICAgICBpZiAodGhpcy5oYXNXaWRnZXRFcnJvclRhcmdldCkge1xuICAgICAgICAgICAgdGhpcy53aWRnZXRFcnJvclRhcmdldENvbm5lY3RlZCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0IG9mZnNldCgpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB3aW5kb3cuc2Vzc2lvblN0b3JhZ2UuZ2V0SXRlbSh0aGlzLnNlc3Npb25LZXlWYWx1ZSk7XG5cbiAgICAgICAgcmV0dXJuIHZhbHVlID8gTnVtYmVyLnBhcnNlSW50KHZhbHVlKSA6IG51bGw7XG4gICAgfVxuXG4gICAgc2V0IG9mZnNldCh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgd2luZG93LnNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0odGhpcy5zZXNzaW9uS2V5VmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2luZG93LnNlc3Npb25TdG9yYWdlLnNldEl0ZW0odGhpcy5zZXNzaW9uS2V5VmFsdWUsIFN0cmluZyh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgQ29udHJvbGxlciB9IGZyb20gJ0Bob3R3aXJlZC9zdGltdWx1cyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIGV4dGVuZHMgQ29udHJvbGxlciB7XG4gICAgc3RhdGljIHZhbHVlcyA9IHtcbiAgICAgICAgaWQ6IFN0cmluZyxcbiAgICAgICAgdHJhaWw6IFN0cmluZyxcbiAgICAgICAgdGl0bGVUYWc6IFN0cmluZyxcbiAgICAgICAgZmllbGRzOiBPYmplY3QsXG4gICAgfTtcblxuICAgIHN0YXRpYyB0YXJnZXRzID0gWyd1cmwnLCAndGl0bGUnLCAnZGVzY3JpcHRpb24nXTtcblxuICAgIHNvdXJjZUVsZW1lbnRzID0gbmV3IE1hcCgpO1xuXG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgLy8gSW5zdGFsbCBldmVudCBsaXN0ZW5lcnMgb24gdGhlIHNvdXJjZSBmaWVsZHNcbiAgICAgICAgZm9yIChjb25zdCBbc291cmNlVHlwZSwgaWRzXSBvZiBPYmplY3QuZW50cmllcyh0aGlzLmZpZWxkc1ZhbHVlKSkge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudHMgPSBbXTtcblxuICAgICAgICAgICAgZm9yIChjb25zdCBpZCBvZiBpZHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcblxuICAgICAgICAgICAgICAgIGlmICghZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChlbCk7XG4gICAgICAgICAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCB0aGlzLl91cGRhdGUuYmluZCh0aGlzLCBzb3VyY2VUeXBlKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuc291cmNlRWxlbWVudHMuc2V0KHNvdXJjZVR5cGUsIGVsZW1lbnRzKTtcblxuICAgICAgICAgICAgLy8gSW5pdGlhbGx5IGdhdGhlciBjb250ZW50XG4gICAgICAgICAgICB0aGlzLl91cGRhdGUoc291cmNlVHlwZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnRzIG9mIHRoaXMuc291cmNlRWxlbWVudHMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZWwgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgICAgICAgICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdpbnB1dCcsIHRoaXMuX3VwZGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNvdXJjZUVsZW1lbnRzLmNsZWFyKCk7XG4gICAgfVxuXG4gICAgX3VwZGF0ZShzb3VyY2VUeXBlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5fZ2V0VmFsdWUoc291cmNlVHlwZSk7XG5cbiAgICAgICAgaWYgKHNvdXJjZVR5cGUgPT09ICd0aXRsZScpIHtcbiAgICAgICAgICAgIHRoaXMudGl0bGVUYXJnZXQudGV4dENvbnRlbnQgPSB0aGlzLl9zaG9ydGVuKFxuICAgICAgICAgICAgICAgIHRoaXMuX2h0bWwyc3RyaW5nKHRoaXMudGl0bGVUYWdWYWx1ZS5yZXBsYWNlKC8lcy8sIHZhbHVlKSkucmVwbGFjZSgvJSUvZywgJyUnKSxcbiAgICAgICAgICAgICAgICA2NCxcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAoc291cmNlVHlwZSA9PT0gJ2FsaWFzJykge1xuICAgICAgICAgICAgdGhpcy51cmxUYXJnZXQudGV4dENvbnRlbnQgPVxuICAgICAgICAgICAgICAgIHZhbHVlID09PSAnaW5kZXgnXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy50cmFpbFZhbHVlXG4gICAgICAgICAgICAgICAgICAgIDogYCR7dGhpcy50cmFpbFZhbHVlfSDigLogJHsodmFsdWUgfHwgdGhpcy5pZFZhbHVlKS5yZXBsYWNlKC9cXC8vZywgJyDigLogJyl9YDtcbiAgICAgICAgfSBlbHNlIGlmIChzb3VyY2VUeXBlID09PSAnZGVzY3JpcHRpb24nKSB7XG4gICAgICAgICAgICB0aGlzLmRlc2NyaXB0aW9uVGFyZ2V0LnRleHRDb250ZW50ID0gdGhpcy5fc2hvcnRlbih2YWx1ZSwgMTYwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9nZXRWYWx1ZShzb3VyY2VUeXBlKSB7XG4gICAgICAgIGZvciAoY29uc3QgZWwgb2YgdGhpcy5zb3VyY2VFbGVtZW50cy5nZXQoc291cmNlVHlwZSkpIHtcbiAgICAgICAgICAgIGlmICghZWwpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPVxuICAgICAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5jb250YWlucygndGxfdGV4dGFyZWEnKSAmJiBlbC5jbGFzc0xpc3QuY29udGFpbnMoJ25vcmVzaXplJylcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLl9odG1sMnN0cmluZyhlbC52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgOiBlbC52YWx1ZTtcblxuICAgICAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIF9zaG9ydGVuKHN0ciwgbWF4KSB7XG4gICAgICAgIGlmIChzdHIubGVuZ3RoIDw9IG1heCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBgJHtzdHIuc3Vic3RyKDAsIHN0ci5sYXN0SW5kZXhPZignICcsIG1heCkpfSDigKZgO1xuICAgIH1cblxuICAgIF9odG1sMnN0cmluZyhodG1sKSB7XG4gICAgICAgIHJldHVybiBuZXcgRE9NUGFyc2VyKClcbiAgICAgICAgICAgIC5wYXJzZUZyb21TdHJpbmcoaHRtbCwgJ3RleHQvaHRtbCcpXG4gICAgICAgICAgICAuYm9keS50ZXh0Q29udGVudC5yZXBsYWNlKC9cXFstXS9nLCAnXFx4QUQnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcW25ic3BdL2csICdcXHhBMCcpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IENvbnRyb2xsZXIgfSBmcm9tICdAaG90d2lyZWQvc3RpbXVsdXMnO1xuaW1wb3J0IFNvcnRhYmxlIGZyb20gJ3NvcnRhYmxlanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBleHRlbmRzIENvbnRyb2xsZXIge1xuICAgIHN0YXRpYyB2YWx1ZXMgPSB7XG4gICAgICAgIHBhcmVudE1vZGU6IHtcbiAgICAgICAgICAgIHR5cGU6IEJvb2xlYW4sXG4gICAgICAgICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICAgICAgcmVxdWVzdFRva2VuOiBTdHJpbmcsXG4gICAgICAgIGhhbmRsZTogU3RyaW5nLFxuICAgICAgICBkcmFnZ2FibGU6IFN0cmluZyxcbiAgICB9O1xuXG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGFuaW1hdGlvbjogMTAwLFxuICAgICAgICAgICAgb25Tb3J0OiAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vblNvcnRlZChldmVudC5pdGVtKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHRoaXMuaGFzSGFuZGxlVmFsdWUpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuaGFuZGxlID0gdGhpcy5oYW5kbGVWYWx1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmhhc0RyYWdnYWJsZVZhbHVlKSB7XG4gICAgICAgICAgICBvcHRpb25zLmRyYWdnYWJsZSA9IHRoaXMuZHJhZ2dhYmxlVmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNvcnRhYmxlID0gbmV3IFNvcnRhYmxlKHRoaXMuZWxlbWVudCwgb3B0aW9ucyk7XG5cbiAgICAgICAgLy8gQmFja3dhcmRzIGNvbXBhdGliaWxpdHkgZm9yIHBhcmVudCBtb2RlLCB3aWxsIHVuaGlkZSB0aGUgb3BlcmF0aW9uIGlmIG5vIG90aGVyIGRyYWcgaGFuZGxlIGlzIGZvdW5kXG4gICAgICAgIGZvciAoY29uc3QgZWwgb2YgWy4uLnRoaXMuZWxlbWVudC5jaGlsZHJlbl0pIHtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZXMgPSBlbC5xdWVyeVNlbGVjdG9yQWxsKCcuZHJhZy1oYW5kbGUnKTtcblxuICAgICAgICAgICAgLy8gVGhlcmUgd2lsbCBhbHdheXMgYmUgYXQgbGVhc3QgMiBoYW5kbGVzOiBvbmUgZm9yIHRoZSBvcGVyYXRpb25zIGxpc3QgYW5kIG9uZSBmb3IgdGhlIG9wZXJhdGlvbnMgbWVudSAod2hpY2ggaXMgaGlkZGVuKVxuICAgICAgICAgICAgaWYgKGhhbmRsZXMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlc1swXS5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgaGFuZGxlIG9mIGhhbmRsZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJyAmJiBoYW5kbGUucGFyZW50Tm9kZS5sb2NhbE5hbWUgPT09ICdsaScpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlLnBhcmVudE5vZGUuc3R5bGUgPSAnZGlzcGxheTogbm9uZSAhaW1wb3J0YW50JztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICB0aGlzLnNvcnRhYmxlPy5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuc29ydGFibGUgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgbW92ZShldmVudCkge1xuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5fZ2V0SXRlbShldmVudC50YXJnZXQpO1xuXG4gICAgICAgIGlmIChldmVudC5jb2RlID09PSAnQXJyb3dVcCcgfHwgZXZlbnQua2V5Q29kZSA9PT0gMzgpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICAgIGlmIChpdGVtLnByZXZpb3VzRWxlbWVudFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICBpdGVtLnByZXZpb3VzRWxlbWVudFNpYmxpbmcuYmVmb3JlKGl0ZW0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kKGl0ZW0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9vblNvcnRlZChpdGVtKTtcbiAgICAgICAgICAgIGV2ZW50LnRhcmdldC5mb2N1cygpO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmNvZGUgPT09ICdBcnJvd0Rvd24nIHx8IGV2ZW50LmtleUNvZGUgPT09IDQwKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgICBpZiAoaXRlbS5uZXh0RWxlbWVudFNpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICBpdGVtLm5leHRFbGVtZW50U2libGluZy5hZnRlcihpdGVtKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnByZXBlbmQoaXRlbSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX29uU29ydGVkKGl0ZW0pO1xuICAgICAgICAgICAgZXZlbnQudGFyZ2V0LmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfdXBkYXRlV3JhcHBlckxldmVsKCkge1xuICAgICAgICBjb25zdCBkaXZzID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2xpID4gZGl2OmZpcnN0LWNoaWxkJyk7XG5cbiAgICAgICAgaWYgKCFkaXZzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgd3JhcExldmVsID0gMDtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRpdnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChkaXZzW2ldLmNsYXNzTGlzdC5jb250YWlucygnd3JhcHBlcl9zdG9wJykgJiYgd3JhcExldmVsID4gMCkge1xuICAgICAgICAgICAgICAgIHdyYXBMZXZlbC0tO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkaXZzW2ldLmNsYXNzTmFtZSA9IGRpdnNbaV0uY2xhc3NOYW1lLnJlcGxhY2UoLyhefFxccylpbmRlbnRbXlxcc10qL2csICcnKTtcblxuICAgICAgICAgICAgaWYgKHdyYXBMZXZlbCA+IDApIHtcbiAgICAgICAgICAgICAgICBkaXZzW2ldLmNsYXNzTGlzdC5hZGQoJ2luZGVudCcpO1xuICAgICAgICAgICAgICAgIGRpdnNbaV0uY2xhc3NMaXN0LmFkZChgaW5kZW50XyR7d3JhcExldmVsfWApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGl2c1tpXS5jbGFzc0xpc3QuY29udGFpbnMoJ3dyYXBwZXJfc3RhcnQnKSkge1xuICAgICAgICAgICAgICAgIHdyYXBMZXZlbCsrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkaXZzW2ldLmNsYXNzTGlzdC5yZW1vdmUoJ2luZGVudF9maXJzdCcpO1xuICAgICAgICAgICAgZGl2c1tpXS5jbGFzc0xpc3QucmVtb3ZlKCdpbmRlbnRfbGFzdCcpO1xuXG4gICAgICAgICAgICBpZiAoZGl2c1tpIC0gMV0gJiYgZGl2c1tpIC0gMV0uY2xhc3NMaXN0LmNvbnRhaW5zKCd3cmFwcGVyX3N0YXJ0JykpIHtcbiAgICAgICAgICAgICAgICBkaXZzW2ldLmNsYXNzTGlzdC5hZGQoJ2luZGVudF9maXJzdCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGl2c1tpICsgMV0gJiYgZGl2c1tpICsgMV0uY2xhc3NMaXN0LmNvbnRhaW5zKCd3cmFwcGVyX3N0b3AnKSkge1xuICAgICAgICAgICAgICAgIGRpdnNbaV0uY2xhc3NMaXN0LmFkZCgnaW5kZW50X2xhc3QnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIF91cGRhdGVQYXJlbnRTb3J0aW5nKGVsKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuXG4gICAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdydCcsIHRoaXMucmVxdWVzdFRva2VuVmFsdWUpO1xuICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgnYWN0JywgJ2N1dCcpO1xuICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgnaWQnLCBlbC5kYXRhc2V0LmlkKTtcblxuICAgICAgICBpZiAoZWwucHJldmlvdXNFbGVtZW50U2libGluZykge1xuICAgICAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ3BpZCcsIGVsLnByZXZpb3VzRWxlbWVudFNpYmxpbmcuZGF0YXNldC5pZCk7XG4gICAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLnNldCgnbW9kZScsIDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ3BpZCcsIHRoaXMuZWxlbWVudC5kYXRhc2V0LmlkKTtcbiAgICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdtb2RlJywgMik7XG4gICAgICAgIH1cblxuICAgICAgICBmZXRjaCh1cmwsIHtcbiAgICAgICAgICAgIHJlZGlyZWN0OiAnbWFudWFsJyxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgX2dldEl0ZW0oZWwpIHtcbiAgICAgICAgaWYgKCFlbC5wYXJlbnROb2RlIHx8IGVsLnBhcmVudE5vZGUgPT09IHRoaXMuZWxlbWVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldEl0ZW0oZWwucGFyZW50Tm9kZSk7XG4gICAgfVxuXG4gICAgX29uU29ydGVkKGl0ZW0pIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaCgndXBkYXRlJywgeyB0YXJnZXQ6IGl0ZW0gfSk7XG5cbiAgICAgICAgaWYgKHRoaXMucGFyZW50TW9kZVZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVXcmFwcGVyTGV2ZWwoaXRlbSk7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVQYXJlbnRTb3J0aW5nKGl0ZW0pO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgQ29udHJvbGxlciB9IGZyb20gJ0Bob3R3aXJlZC9zdGltdWx1cyc7XG5pbXBvcnQgKiBhcyBJY29uIGZyb20gJy4uL21vZHVsZXMvaWNvbic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRhYnNDb250cm9sbGVyIGV4dGVuZHMgQ29udHJvbGxlciB7XG4gICAgc3RhdGljIHZhbHVlcyA9IHtcbiAgICAgICAgY2xvc2VMYWJlbDogU3RyaW5nLFxuICAgIH07XG5cbiAgICBzdGF0aWMgdGFyZ2V0cyA9IFsnbmF2aWdhdGlvbicsICdwYW5lbCddO1xuXG4gICAgYWN0aXZlVGFiID0gbnVsbDtcblxuICAgIHBhbmVsVGFyZ2V0Q29ubmVjdGVkKHBhbmVsKSB7XG4gICAgICAgIC8vIFdoZW4gdGhlIERPTSBpcyBhbHJlYWR5IHNldCB1cCwganVzdCBzZXQgdGhlIHBhbmVsIElEIGFuZFxuICAgICAgICAvLyBpbnN0YWxsIHRoZSBldmVudCBsaXN0ZW5lcnMsIG90aGVyd2lzZSBjcmVhdGUgdGhlIGVsZW1lbnRzIGZpcnN0LlxuICAgICAgICBjb25zdCBpc1Jlc3RvcmUgPSAndGFicGFuZWwnID09PSBwYW5lbC5nZXRBdHRyaWJ1dGUoJ3JvbGUnKTtcblxuICAgICAgICBjb25zdCB0YWJJZCA9IGlzUmVzdG9yZSA/IHBhbmVsLmRhdGFzZXQudGFiSWQgOiAoTWF0aC5yYW5kb20oKSArIDEpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoNyk7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lcklkID0gdGhpcy5lbGVtZW50LmlkO1xuICAgICAgICBjb25zdCBwYW5lbFJlZmVyZW5jZSA9IHBhbmVsLmlkIHx8IGB0YWItcGFuZWxfJHtjb250YWluZXJJZH1fJHt0YWJJZH1gO1xuICAgICAgICBjb25zdCBjb250cm9sUmVmZXJlbmNlID0gYHRhYi1jb250cm9sXyR7Y29udGFpbmVySWR9XyR7dGFiSWR9YDtcblxuICAgICAgICAvLyBDcmVhdGUgbmF2aWdhdGlvbiBlbGVtZW50c1xuICAgICAgICBjb25zdCBzZWxlY3RCdXR0b24gPSBpc1Jlc3RvcmVcbiAgICAgICAgICAgID8gdGhpcy5uYXZpZ2F0aW9uVGFyZ2V0LnF1ZXJ5U2VsZWN0b3IoYGJ1dHRvbi5zZWxlY3RbYXJpYS1jb250cm9scz1cIiR7cGFuZWxSZWZlcmVuY2V9XCJdYClcbiAgICAgICAgICAgIDogKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICAgICAgICAgICAgYnV0dG9uLmlkID0gY29udHJvbFJlZmVyZW5jZTtcbiAgICAgICAgICAgICAgICAgIGJ1dHRvbi5jbGFzc05hbWUgPSAnc2VsZWN0JztcbiAgICAgICAgICAgICAgICAgIGJ1dHRvbi5pbm5lclRleHQgPSBwYW5lbC5kYXRhc2V0LmxhYmVsO1xuICAgICAgICAgICAgICAgICAgYnV0dG9uLnNldEF0dHJpYnV0ZSgndHlwZScsICdidXR0b24nKTtcbiAgICAgICAgICAgICAgICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAndGFiJyk7XG4gICAgICAgICAgICAgICAgICBidXR0b24uc2V0QXR0cmlidXRlKCdhcmlhLWNvbnRyb2xzJywgcGFuZWxSZWZlcmVuY2UpO1xuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gYnV0dG9uO1xuICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICBzZWxlY3RCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdFRhYihwYW5lbCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IGNsb3NlQnV0dG9uID0gaXNSZXN0b3JlXG4gICAgICAgICAgICA/IHRoaXMubmF2aWdhdGlvblRhcmdldC5xdWVyeVNlbGVjdG9yKGBidXR0b24uY2xvc2VbYXJpYS1jb250cm9scz1cIiR7cGFuZWxSZWZlcmVuY2V9XCJdYClcbiAgICAgICAgICAgIDogKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IGJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICAgICAgICAgICAgYnV0dG9uLmNsYXNzTmFtZSA9ICdjbG9zZSc7XG4gICAgICAgICAgICAgICAgICBidXR0b24uYXBwZW5kKEljb24uZ2V0VGVtcGxhdGUoJ2Nsb3NlJywgeyAnYXJpYS1oaWRkZW4nOiB0cnVlLCB3aWR0aDogMTIsIGhlaWdodDogMTIgfSkuY29udGVudCk7XG4gICAgICAgICAgICAgICAgICBidXR0b24uc2V0QXR0cmlidXRlKCd0eXBlJywgJ2J1dHRvbicpO1xuICAgICAgICAgICAgICAgICAgYnV0dG9uLnNldEF0dHJpYnV0ZSgnYXJpYS1jb250cm9scycsIHBhbmVsUmVmZXJlbmNlKTtcbiAgICAgICAgICAgICAgICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCB0aGlzLmNsb3NlTGFiZWxWYWx1ZSk7XG5cbiAgICAgICAgICAgICAgICAgIHJldHVybiBidXR0b247XG4gICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIGNsb3NlQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBwYW5lbCBhbmQgbGV0IHRoZSBkaXNjb25uZWN0IGhhbmRsZXIgZG8gdGhlIHJlc3RcbiAgICAgICAgICAgIHBhbmVsLnJlbW92ZSgpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIWlzUmVzdG9yZSkge1xuICAgICAgICAgICAgLy8gRW5oYW5jZSBwYW5lbCBjb250YWluZXJcbiAgICAgICAgICAgIHBhbmVsLmRhdGFzZXQudGFiSWQgPSB0YWJJZDtcbiAgICAgICAgICAgIHBhbmVsLmlkID0gcGFuZWxSZWZlcmVuY2U7XG4gICAgICAgICAgICBwYW5lbC5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAndGFicGFuZWwnKTtcbiAgICAgICAgICAgIHBhbmVsLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbGxlZGJ5JywgY29udHJvbFJlZmVyZW5jZSk7XG5cbiAgICAgICAgICAgIC8vIEFkZCBuYXZpZ2F0aW9uIGVsZW1lbnRcbiAgICAgICAgICAgIGNvbnN0IGxpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcbiAgICAgICAgICAgIGxpLnNldEF0dHJpYnV0ZSgncm9sZScsICdwcmVzZW50YXRpb24nKTtcbiAgICAgICAgICAgIGxpLmFwcGVuZChzZWxlY3RCdXR0b24pO1xuICAgICAgICAgICAgbGkuYXBwZW5kKGNsb3NlQnV0dG9uKTtcblxuICAgICAgICAgICAgdGhpcy5uYXZpZ2F0aW9uVGFyZ2V0LmFwcGVuZChsaSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBY3RpdmF0ZSB0YWJcbiAgICAgICAgdGhpcy5zZWxlY3RUYWIocGFuZWwpO1xuICAgIH1cblxuICAgIHBhbmVsVGFyZ2V0RGlzY29ubmVjdGVkKHBhbmVsKSB7XG4gICAgICAgIC8vIFJlbW92ZSBjb250cm9sc1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChwYW5lbC5nZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWxsZWRieScpKT8ucGFyZW50RWxlbWVudD8ucmVtb3ZlKCk7XG5cbiAgICAgICAgLy8gU2VsZWN0IHRoZSBmaXJzdCB0YWIvbm8gdGFiIGlmIHRoZSBjdXJyZW50IHRhYiB3YXMgYWN0aXZlIGJlZm9yZSBjbG9zaW5nLlxuICAgICAgICBpZiAocGFuZWwgPT09IHRoaXMuYWN0aXZlVGFiKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNQYW5lbFRhcmdldCkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0VGFiKHRoaXMucGFuZWxUYXJnZXQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZVRhYiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZWxlY3RUYWIocGFuZWwpIHtcbiAgICAgICAgZm9yIChjb25zdCBlbCBvZiB0aGlzLnBhbmVsVGFyZ2V0cykge1xuICAgICAgICAgICAgY29uc3QgaXNUYXJnZXQgPSBlbCA9PT0gcGFuZWw7XG5cbiAgICAgICAgICAgIGVsLnRvZ2dsZUF0dHJpYnV0ZSgnYXJpYS1zZWxlY3RlZCcsIGlzVGFyZ2V0KTtcbiAgICAgICAgICAgIGVsLnRvZ2dsZUF0dHJpYnV0ZSgnZGF0YS1hY3RpdmUnLCBpc1RhcmdldCk7XG4gICAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gaXNUYXJnZXQgPyAncmV2ZXJ0JyA6ICdub25lJztcblxuICAgICAgICAgICAgLy8gUmUtZW5hYmxlL2Rpc2FibGUgdGhlIGJ1dHRvbiBhY2Nlc3Mga2V5c1xuICAgICAgICAgICAgaWYgKGlzVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBidXR0b24gb2YgZWwucXVlcnlTZWxlY3RvckFsbCgnYnV0dG9uW2RhdGEtZGlzYWJsZWQtYWNjZXNza2V5XScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ2FjY2Vzc2tleScsIGJ1dHRvbi5nZXRBdHRyaWJ1dGUoJ2RhdGEtZGlzYWJsZWQtYWNjZXNza2V5JykpO1xuICAgICAgICAgICAgICAgICAgICBidXR0b24ucmVtb3ZlQXR0cmlidXRlKCdkYXRhLWRpc2FibGVkLWFjY2Vzc2tleScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBidXR0b24gb2YgZWwucXVlcnlTZWxlY3RvckFsbCgnYnV0dG9uW2FjY2Vzc2tleV0nKSkge1xuICAgICAgICAgICAgICAgICAgICBidXR0b24uc2V0QXR0cmlidXRlKCdkYXRhLWRpc2FibGVkLWFjY2Vzc2tleScsIGJ1dHRvbi5nZXRBdHRyaWJ1dGUoJ2FjY2Vzc2tleScpKTtcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uLnJlbW92ZUF0dHJpYnV0ZSgnYWNjZXNza2V5Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBzZWxlY3RCdXR0b24gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbC5nZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWxsZWRieScpKTtcbiAgICAgICAgICAgIHNlbGVjdEJ1dHRvbj8udG9nZ2xlQXR0cmlidXRlKCdhcmlhLXNlbGVjdGVkJywgaXNUYXJnZXQpO1xuICAgICAgICAgICAgc2VsZWN0QnV0dG9uPy5wYXJlbnRFbGVtZW50LnRvZ2dsZUF0dHJpYnV0ZSgnZGF0YS1hY3RpdmUnLCBpc1RhcmdldCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmFjdGl2ZVRhYiA9IHBhbmVsO1xuICAgIH1cblxuICAgIGdldEFjdGl2ZVRhYigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlVGFiO1xuICAgIH1cblxuICAgIGdldFRhYnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhbmVsVGFyZ2V0cy5yZWR1Y2UoKHJlc3VsdCwgcGFuZWwpID0+IHtcbiAgICAgICAgICAgIHJlc3VsdFtwYW5lbC5pZF0gPSBwYW5lbDtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sIHt9KTtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBDb250cm9sbGVyIH0gZnJvbSAnQGhvdHdpcmVkL3N0aW11bHVzJztcbmltcG9ydCB7IFR1cmJvU3RyZWFtQ29ubmVjdGlvbiB9IGZyb20gJy4uL21vZHVsZXMvdHVyYm8tc3RyZWFtLWNvbm5lY3Rpb24nO1xuaW1wb3J0IHsgVHdpZ0VkaXRvciB9IGZyb20gJy4uL21vZHVsZXMvdHdpZy1lZGl0b3InO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBleHRlbmRzIENvbnRyb2xsZXIge1xuICAgIGVkaXRvcnMgPSBuZXcgTWFwKCk7XG4gICAgdHVyYm9TdHJlYW1Db25uZWN0aW9uID0gbmV3IFR1cmJvU3RyZWFtQ29ubmVjdGlvbigpO1xuXG4gICAgc3RhdGljIHZhbHVlcyA9IHtcbiAgICAgICAgZm9sbG93VXJsOiBTdHJpbmcsXG4gICAgICAgIGJsb2NrSW5mb1VybDogU3RyaW5nLFxuICAgIH07XG5cbiAgICBzdGF0aWMgdGFyZ2V0cyA9IFsndGhlbWVTZWxlY3RvcicsICd0YWJzJywgJ2VkaXRvcicsICdlZGl0b3JBbm5vdGF0aW9ucyddO1xuXG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgLy8gU3Vic2NyaWJlIHRvIGV2ZW50cyBkaXNwYXRjaGVkIGJ5IHRoZSBlZGl0b3JzXG4gICAgICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0d2lnLWVkaXRvcjpsZW5zOmZvbGxvdycsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy50dXJib1N0cmVhbUNvbm5lY3Rpb24uZ2V0KHRoaXMuZm9sbG93VXJsVmFsdWUsIHsgbmFtZTogZXZlbnQuZGV0YWlsLm5hbWUgfSwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0d2lnLWVkaXRvcjpsZW5zOmJsb2NrLWluZm8nLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMudHVyYm9TdHJlYW1Db25uZWN0aW9uLmdldCh0aGlzLmJsb2NrSW5mb1VybFZhbHVlLCBldmVudC5kZXRhaWwsIHRydWUpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndHVyYm86c3VibWl0LXN0YXJ0JywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAvLyBBZGQgdGhlIGN1cnJlbnRseSBvcGVuIGVkaXRvciB0YWJzIHRvIHRoZSByZXF1ZXN0IHdoZW4gc2VsZWN0aW5nIGEgdGhlbWVcbiAgICAgICAgICAgIGlmICh0aGlzLmhhc1RoZW1lU2VsZWN0b3JUYXJnZXQgJiYgZXZlbnQudGFyZ2V0ID09PSB0aGlzLnRoZW1lU2VsZWN0b3JUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRPcGVuRWRpdG9yVGFic1RvUmVxdWVzdChldmVudCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEluY2x1ZGUgdGhlIGFjdGl2ZSBlZGl0b3IncyBjb250ZW50IHdoZW4gdGhlIHNhdmUgb3BlcmF0aW9uIHdhcyB0cmlnZ2VyZWRcbiAgICAgICAgICAgIGlmIChldmVudC5kZXRhaWwuZm9ybVN1Ym1pc3Npb24uc3VibWl0dGVyPy5kYXRhc2V0Py5vcGVyYXRpb24gPT09ICdzYXZlJykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZEVkaXRvckNvbnRlbnRUb1JlcXVlc3QoZXZlbnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2dldEFjdGl2ZU11dGFibGVFZGl0b3IoKT8uZm9jdXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYmVmb3JlQ2FjaGUoKSB7XG4gICAgICAgIC8vIERlc3Ryb3kgZWRpdG9yIGluc3RhbmNlcyBiZWZvcmUgVHVyYm8gY2FjaGVzIHRoZSBwYWdlLiBUaGV5IHdpbGwgYmVcbiAgICAgICAgLy8gcmVjcmVhdGVkIHdoZW4gdGhlIGVkaXRvclRhcmdldENvbm5lY3RlZCgpIGNhbGxzIGhhcHBlbnMgb24gdGhlXG4gICAgICAgIC8vIHJlc3RvcmVkIHBhZ2UuXG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgZWRpdG9yXSBvZiB0aGlzLmVkaXRvcnMpIHtcbiAgICAgICAgICAgIGVkaXRvci5kZXN0cm95KCk7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5lZGl0b3JzW2tleV07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBjbG9zZShldmVudCkge1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChldmVudC50YXJnZXQuZ2V0QXR0cmlidXRlKCdhcmlhLWNvbnRyb2xzJykpLmlubmVyVGV4dCA9ICcnO1xuICAgIH1cblxuICAgIGVkaXRvclRhcmdldENvbm5lY3RlZChlbCkge1xuICAgICAgICB0aGlzLmVkaXRvcnMuc2V0KGVsLCBuZXcgVHdpZ0VkaXRvcihlbC5xdWVyeVNlbGVjdG9yKCd0ZXh0YXJlYScpKSk7XG4gICAgfVxuXG4gICAgZWRpdG9yVGFyZ2V0RGlzY29ubmVjdGVkKGVsKSB7XG4gICAgICAgIHRoaXMuZWRpdG9ycy5nZXQoZWwpLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5lZGl0b3JzLmRlbGV0ZShlbCk7XG4gICAgfVxuXG4gICAgZWRpdG9yQW5ub3RhdGlvbnNUYXJnZXRDb25uZWN0ZWQoZWwpIHtcbiAgICAgICAgdGhpcy5lZGl0b3JzXG4gICAgICAgICAgICAuZ2V0KGVsLmNsb3Nlc3QoJypbZGF0YS1jb250YW8tLXRlbXBsYXRlLXN0dWRpby10YXJnZXQ9XCJlZGl0b3JcIl0nKSlcbiAgICAgICAgICAgID8uc2V0QW5ub3RhdGlvbnNEYXRhKEpTT04ucGFyc2UoZWwuaW5uZXJUZXh0KSk7XG4gICAgfVxuXG4gICAgY29sb3JDaGFuZ2UoZXZlbnQpIHtcbiAgICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy5lZGl0b3JzKSB7XG4gICAgICAgICAgICBlZGl0b3Iuc2V0Q29sb3JTY2hlbWUoZXZlbnQuZGV0YWlsLm1vZGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2FkZE9wZW5FZGl0b3JUYWJzVG9SZXF1ZXN0KGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHNlYXJjaFBhcmFtcyA9IGV2ZW50LmRldGFpbC5mb3JtU3VibWlzc2lvbi5sb2NhdGlvbi5zZWFyY2hQYXJhbXM7XG4gICAgICAgIGNvbnN0IHRhYnMgPSB0aGlzLmFwcGxpY2F0aW9uLmdldENvbnRyb2xsZXJGb3JFbGVtZW50QW5kSWRlbnRpZmllcih0aGlzLnRhYnNUYXJnZXQsICdjb250YW8tLXRhYnMnKS5nZXRUYWJzKCk7XG5cbiAgICAgICAgZm9yIChjb25zdCB0YWJJZCBvZiBPYmplY3Qua2V5cyh0YWJzKSkge1xuICAgICAgICAgICAgLy8gRXh0cmFjdCBpZGVudGlmaWVyIGZyb20gdGFiSWQgXCJ0ZW1wbGF0ZS1zdHVkaW8tLXRhYl88aWRlbnRpZmllcj5cIlxuICAgICAgICAgICAgc2VhcmNoUGFyYW1zLmFwcGVuZCgnb3Blbl90YWJbXScsIHRhYklkLnN1YnN0cmluZygyMSkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2FkZEVkaXRvckNvbnRlbnRUb1JlcXVlc3QoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQuZGV0YWlsLmZvcm1TdWJtaXNzaW9uLmZldGNoUmVxdWVzdC5ib2R5LmFwcGVuZChcbiAgICAgICAgICAgICdjb2RlJyxcbiAgICAgICAgICAgIHRoaXMuX2dldEFjdGl2ZU11dGFibGVFZGl0b3IoKT8uZ2V0Q29udGVudCgpID8/ICcnLFxuICAgICAgICApO1xuICAgIH1cblxuICAgIF9nZXRBY3RpdmVNdXRhYmxlRWRpdG9yKCkge1xuICAgICAgICBjb25zdCBlZGl0b3JFbGVtZW50c09uQWN0aXZlVGFiID0gdGhpcy5hcHBsaWNhdGlvblxuICAgICAgICAgICAgLmdldENvbnRyb2xsZXJGb3JFbGVtZW50QW5kSWRlbnRpZmllcih0aGlzLnRhYnNUYXJnZXQsICdjb250YW8tLXRhYnMnKVxuICAgICAgICAgICAgLmdldEFjdGl2ZVRhYigpXG4gICAgICAgICAgICA/LnF1ZXJ5U2VsZWN0b3JBbGwoJypbZGF0YS1jb250YW8tLXRlbXBsYXRlLXN0dWRpby10YXJnZXQ9XCJlZGl0b3JcIl0nKTtcblxuICAgICAgICBmb3IgKGNvbnN0IGVsIG9mIGVkaXRvckVsZW1lbnRzT25BY3RpdmVUYWIgPz8gW10pIHtcbiAgICAgICAgICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuZWRpdG9ycy5nZXQoZWwpO1xuXG4gICAgICAgICAgICBpZiAoZWRpdG9yPy5pc0VkaXRhYmxlKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWRpdG9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgQ29udHJvbGxlciB9IGZyb20gJ0Bob3R3aXJlZC9zdGltdWx1cyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIGV4dGVuZHMgQ29udHJvbGxlciB7XG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgLy8gV29yayBhcm91bmQgYSBidWcgaW4gU2FmYXJpIHdoZXJlIHRoZSB0cmFuc2l0aW9uIHRvIGEgbmV3IGNvbnRleHRcbiAgICAgICAgLy8gY2F1c2VzIGRpc2Nvbm5lY3QoKSB0byBiZSBjYWxsZWQgYmVmb3JlIGNvbm5lY3QoKS4gSWYgdGhlIGVsZW1lbnQgSURcbiAgICAgICAgLy8gaXMgaWRlbnRpY2FsIC0gd2hpY2ggaXMgdGhlIGNhc2Ugd2hlbiBzYXZpbmcgYSByZWNvcmQgLSB0aGlzIG1lc3Nlc1xuICAgICAgICAvLyB1cCB0aGUgaW5pdGlhbGl6YXRpb24gb2YgdGhlIGVkaXRvci4gVG8gcHJldmVudCB0aGlzLCB3ZSBkZWxheSB0aGVcbiAgICAgICAgLy8gZXhlY3V0aW9uIHVudGlsIHRoZSBjYWxsIHN0YWNrIGhhcyBiZWVuIGNsZWFyZWQgYW5kIGFsbCBtaWNyb3Rhc2tzLFxuICAgICAgICAvLyBpLmUuIGRpc2Nvbm5lY3QoKSBjYWxscywgaGF2ZSBiZWVuIGV4ZWN1dGVkLlxuICAgICAgICBxdWV1ZU1pY3JvdGFzaygoKSA9PiB0aGlzLl9jb25uZWN0KCkpO1xuICAgIH1cblxuICAgIF9jb25uZWN0KCkge1xuICAgICAgICBpZiAoIXRoaXMuZWxlbWVudC50aW55bWNlQ29uZmlnKSB7XG4gICAgICAgICAgICBpZiAod2luZG93LmNvbnNvbGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgICAgICAnTm8gVGlueU1DRSBjb25maWcgd2FzIGF0dGFjaGVkIHRvIHRoZSBET00gZWxlbWVudCwgZXhwZWN0ZWQgYW4gZXhwYW5kbyBwcm9wZXJ0eSBjYWxsZWQgXCJ0aW55bWNlQ29uZmlnXCIuJyxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHRoaXMuZWxlbWVudC50aW55bWNlQ29uZmlnO1xuICAgICAgICBjb25maWcudGFyZ2V0ID0gdGhpcy5lbGVtZW50O1xuXG4gICAgICAgIHRpbnltY2U/LmluaXQoY29uZmlnKS50aGVuKChlZGl0b3JzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlZGl0b3IgPSBlZGl0b3JzWzBdID8/IG51bGw7XG4gICAgICAgICAgICB0aGlzLmVkaXRvcklkID0gZWRpdG9yPy5pZDtcblxuICAgICAgICAgICAgLy8gQWxsb3cgb3RoZXJzIHRvIGxpc3RlbiBvbiB0aGUgaW5wdXQgZXZlbnQgb2YgdGhlIHVuZGVybHlpbmcgdGV4dGFyZWFcbiAgICAgICAgICAgIGVkaXRvcj8ub24oJ2tleXVwJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJlZm9yZSA9IHRoaXMuZWxlbWVudC5pbm5lclRleHQ7XG4gICAgICAgICAgICAgICAgY29uc3QgYWZ0ZXIgPSBlZGl0b3IuZ2V0Q29udGVudCgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGJlZm9yZSAhPT0gYWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LmlubmVyVGV4dCA9IGVkaXRvci5nZXRDb250ZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnaW5wdXQnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIEZpcmUgYSBjdXN0b20gZXZlbnQgd2hlbiB0aGUgZWRpdG9yIGZpbmlzaGVkIGluaXRpYWxpemluZy5cbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2goJ2VkaXRvci1sb2FkZWQnLCB7IGRldGFpbDogeyBjb250ZW50OiBlZGl0b3IgfSB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgdGlueW1jZT8uZ2V0KHRoaXMuZWRpdG9ySWQpPy5yZW1vdmUoKTtcbiAgICB9XG5cbiAgICBiZWZvcmVDYWNoZSgpIHtcbiAgICAgICAgLy8gRGVzdHJveSBUaW55TUNFIGJlZm9yZSBUdXJibyBjYWNoZXMgdGhlIHBhZ2UuIEl0IHdpbGwgYmUgcmVjcmVhdGVkXG4gICAgICAgIC8vIHdoZW4gdGhlIGNvbm5lY3QoKSBjYWxsIGhhcHBlbnMgb24gdGhlIHJlc3RvcmVkIHBhZ2UuXG4gICAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgY29udHJvbGxlciBhdHRyaWJ1dGUuIFRoZXkgd2lsbCBiZSByZS1hZGRlZCBpbiB0aGUgaW5pdFxuICAgICAgICAvLyBzY3JpcHQgb2YgdGhlIGJlX3RpbnlNQ0UuaHRtbDUgdGVtcGxhdGUuXG4gICAgICAgIHRoaXMuZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtY29udHJvbGxlcicpO1xuICAgIH1cblxuICAgIGxlYXZlKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGVkaXRvciA9IHRpbnltY2U/LmdldCh0aGlzLmVkaXRvcklkKTtcblxuICAgICAgICBpZiAoIWVkaXRvciB8fCAhT2JqZWN0Lmhhc093bihlZGl0b3IucGx1Z2lucywgJ2F1dG9zYXZlJykgfHwgZWRpdG9yLmlzTm90RGlydHkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRyaWdnZXIgYSBiZWZvcmV1bmxvYWQgZXZlbnQgbGlrZSB3aGVuIG5hdmlnYXRpbmcgYXdheSB0byBjYXB0dXJlIHRoZSBUaW55TUNFIGF1dG9zYXZlIG1lc3NhZ2VcbiAgICAgICAgY29uc3QgZGVsZWdhdGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnQmVmb3JlVW5sb2FkRXZlbnQnKTtcbiAgICAgICAgZGVsZWdhdGUuaW5pdEV2ZW50KCdiZWZvcmV1bmxvYWQnLCBmYWxzZSwgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKCF3aW5kb3cuZGlzcGF0Y2hFdmVudChkZWxlZ2F0ZSkgJiYgIWNvbmZpcm0oZGVsZWdhdGUucmV0dXJuVmFsdWUpKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgQ29udHJvbGxlciB9IGZyb20gJ0Bob3R3aXJlZC9zdGltdWx1cyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIGV4dGVuZHMgQ29udHJvbGxlciB7XG4gICAgc3RhdGljIHZhbHVlcyA9IHtcbiAgICAgICAgaWQ6IFN0cmluZyxcbiAgICAgICAgdGFibGU6IFN0cmluZyxcbiAgICB9O1xuXG4gICAgc3RhdGljIGNsYXNzZXMgPSBbJ2NvbGxhcHNlZCddO1xuXG4gICAgc3RhdGljIGFmdGVyTG9hZChpZGVudGlmaWVyLCBhcHBsaWNhdGlvbikge1xuICAgICAgICBjb25zdCBhZGRDb250cm9sbGVyID0gKGVsLCBpZCwgdGFibGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZzID0gZWwucGFyZW50Tm9kZTtcblxuICAgICAgICAgICAgZnMuZGF0YXNldC5jb250cm9sbGVyID0gYCR7ZnMuZGF0YXNldC5jb250cm9sbGVyIHx8ICcnfSAke2lkZW50aWZpZXJ9YDtcbiAgICAgICAgICAgIGZzLnNldEF0dHJpYnV0ZShgZGF0YS0ke2lkZW50aWZpZXJ9LWlkLXZhbHVlYCwgaWQpO1xuICAgICAgICAgICAgZnMuc2V0QXR0cmlidXRlKGBkYXRhLSR7aWRlbnRpZmllcn0tdGFibGUtdmFsdWVgLCB0YWJsZSk7XG4gICAgICAgICAgICBmcy5zZXRBdHRyaWJ1dGUoYGRhdGEtJHtpZGVudGlmaWVyfS1jb2xsYXBzZWQtY2xhc3NgLCAnY29sbGFwc2VkJyk7XG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgMCk7XG5cbiAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZShcbiAgICAgICAgICAgICAgICAnZGF0YS1hY3Rpb24nLFxuICAgICAgICAgICAgICAgIGBjbGljay0+JHtpZGVudGlmaWVyfSN0b2dnbGUga2V5ZG93bi5lbnRlci0+JHtpZGVudGlmaWVyfSN0b2dnbGUga2V5ZG93bi5zcGFjZS0+JHtpZGVudGlmaWVyfSNwcmV2ZW50OnByZXZlbnQga2V5dXAuc3BhY2UtPiR7aWRlbnRpZmllcn0jdG9nZ2xlOnByZXZlbnRgLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBtaWdyYXRlTGVnYWN5ID0gKCkgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbCBvZiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdsZWdlbmRbZGF0YS10b2dnbGUtZmllbGRzZXRdJykpIHtcbiAgICAgICAgICAgICAgICBpZiAod2luZG93LmNvbnNvbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICAgICAgICAgYFVzaW5nIHRoZSBcImRhdGEtdG9nZ2xlLWZpZWxkc2V0XCIgYXR0cmlidXRlIG9uIGZpZWxkc2V0IGxlZ2VuZHMgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIENvbnRhbyA2LiBBcHBseSB0aGUgXCIke2lkZW50aWZpZXJ9XCIgU3RpbXVsdXMgY29udHJvbGxlciBpbnN0ZWFkLmAsXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgY29uc3QgeyBpZCwgdGFibGUgfSA9IEpTT04ucGFyc2UoZWwuZ2V0QXR0cmlidXRlKCdkYXRhLXRvZ2dsZS1maWVsZHNldCcpKTtcbiAgICAgICAgICAgICAgICBhZGRDb250cm9sbGVyKGVsLCBpZCwgdGFibGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBBamF4UmVxdWVzdC50b2dnbGVGaWVsZHNldCA9IChlbCwgaWQsIHRhYmxlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZnMgPSBlbC5wYXJlbnROb2RlO1xuXG4gICAgICAgICAgICAgICAgLy8gQWxyZWFkeSBjbGlja2VkLCBTdGltdWx1cyBjb250cm9sbGVyIHdhcyBhZGRlZCBkeW5hbWljYWxseVxuICAgICAgICAgICAgICAgIGlmIChhcHBsaWNhdGlvbi5nZXRDb250cm9sbGVyRm9yRWxlbWVudEFuZElkZW50aWZpZXIoZnMsIGlkZW50aWZpZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAod2luZG93LmNvbnNvbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICAgICAgICAgJ1VzaW5nIEFqYXhSZXF1ZXN0LnRvZ2dsZUZpZWxkc2V0KCkgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIENvbnRhbyA2LiBBcHBseSB0aGUgU3RpbXVsdXMgYWN0aW9ucyBpbnN0ZWFkLicsXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYWRkQ29udHJvbGxlcihlbCwgaWQsIHRhYmxlKTtcblxuICAgICAgICAgICAgICAgIC8vIE9wdGltaXN0aWNhbGx5IHdhaXQgdW50aWwgU3RpbXVsdXMgaGFzIHJlZ2lzdGVyZWQgdGhlIG5ldyBjb250cm9sbGVyXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGFwcGxpY2F0aW9uLmdldENvbnRyb2xsZXJGb3JFbGVtZW50QW5kSWRlbnRpZmllcihmcywgaWRlbnRpZmllcikudG9nZ2xlKCk7XG4gICAgICAgICAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQ2FsbGVkIGFzIHNvb24gYXMgcmVnaXN0ZXJlZCwgc28gRE9NIG1heSBub3QgaGF2ZSBiZWVuIGxvYWRlZCB5ZXRcbiAgICAgICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdsb2FkaW5nJykge1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIG1pZ3JhdGVMZWdhY3kpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWlncmF0ZUxlZ2FjeSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdsYWJlbC5lcnJvciwgbGFiZWwubWFuZGF0b3J5JykubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZSh0aGlzLmNvbGxhcHNlZENsYXNzKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdoaWRlJykpIHtcbiAgICAgICAgICAgIGlmICh3aW5kb3cuY29uc29sZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgICAgICAgYFVzaW5nIGNsYXNzIFwiaGlkZVwiIG9uIGEgZmllbGRzZXQgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIENvbnRhbyA2LiBVc2UgY2xhc3MgXCIke3RoaXMuY29sbGFwc2VkQ2xhc3N9XCIgaW5zdGVhZC5gLFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuYWRkKHRoaXMuY29sbGFwc2VkQ2xhc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnModGhpcy5jb2xsYXBzZWRDbGFzcykpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QXJpYUV4cGFuZGVkKGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QXJpYUV4cGFuZGVkKHRydWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdG9nZ2xlKCkge1xuICAgICAgICBpZiAodGhpcy5lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyh0aGlzLmNvbGxhcHNlZENsYXNzKSkge1xuICAgICAgICAgICAgdGhpcy5vcGVuKCk7XG4gICAgICAgICAgICB0aGlzLnNldEFyaWFFeHBhbmRlZCh0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgIHRoaXMuc2V0QXJpYUV4cGFuZGVkKGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9wZW4oKSB7XG4gICAgICAgIGlmICghdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyh0aGlzLmNvbGxhcHNlZENsYXNzKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUodGhpcy5jb2xsYXBzZWRDbGFzcyk7XG4gICAgICAgIHRoaXMuc3RvcmVTdGF0ZSgxKTtcbiAgICB9XG5cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnModGhpcy5jb2xsYXBzZWRDbGFzcykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGZvcm0gPSB0aGlzLmVsZW1lbnQuY2xvc2VzdCgnZm9ybScpO1xuICAgICAgICBjb25zdCBpbnB1dCA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbcmVxdWlyZWRdJyk7XG5cbiAgICAgICAgbGV0IGNvbGxhcHNlID0gdHJ1ZTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCFpbnB1dFtpXS52YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNvbGxhcHNlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWNvbGxhcHNlKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZvcm0uY2hlY2tWYWxpZGl0eSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGZvcm0ucXVlcnlTZWxlY3RvcignYnV0dG9uW3R5cGU9XCJzdWJtaXRcIl0nKS5jbGljaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50LmNsYXNzTGlzdC5hZGQodGhpcy5jb2xsYXBzZWRDbGFzcyk7XG4gICAgICAgICAgICB0aGlzLnN0b3JlU3RhdGUoMCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdG9yZVN0YXRlKHN0YXRlKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNJZFZhbHVlIHx8ICF0aGlzLmhhc1RhYmxlVmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGZldGNoKHdpbmRvdy5sb2NhdGlvbi5ocmVmLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAnWC1SZXF1ZXN0ZWQtV2l0aCc6ICdYTUxIdHRwUmVxdWVzdCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYm9keTogbmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiAndG9nZ2xlRmllbGRzZXQnLFxuICAgICAgICAgICAgICAgIGlkOiB0aGlzLmlkVmFsdWUsXG4gICAgICAgICAgICAgICAgdGFibGU6IHRoaXMudGFibGVWYWx1ZSxcbiAgICAgICAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgc2V0QXJpYUV4cGFuZGVkKHN0YXRlKSB7XG4gICAgICAgIGNvbnN0IGJ1dHRvbiA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKCdidXR0b24nKTtcblxuICAgICAgICBpZiAoYnV0dG9uKSB7XG4gICAgICAgICAgICBidXR0b24uYXJpYUV4cGFuZGVkID0gc3RhdGU7XG4gICAgICAgIH1cbiAgICB9XG59XG4iLCJpbXBvcnQgeyBDb250cm9sbGVyIH0gZnJvbSAnQGhvdHdpcmVkL3N0aW11bHVzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgZXh0ZW5kcyBDb250cm9sbGVyIHtcbiAgICBzdGF0aWMgY2xhc3NlcyA9IFsnY29sbGFwc2VkJ107XG5cbiAgICBzdGF0aWMgdmFsdWVzID0ge1xuICAgICAgICB1cmw6IFN0cmluZyxcbiAgICAgICAgcmVxdWVzdFRva2VuOiBTdHJpbmcsXG4gICAgICAgIGV4cGFuZFRpdGxlOiBTdHJpbmcsXG4gICAgICAgIGNvbGxhcHNlVGl0bGU6IFN0cmluZyxcbiAgICB9O1xuXG4gICAgdG9nZ2xlKHsgY3VycmVudFRhcmdldCwgcGFyYW1zOiB7IGNhdGVnb3J5IH0gfSkge1xuICAgICAgICBjb25zdCBlbCA9IGN1cnJlbnRUYXJnZXQucGFyZW50Tm9kZTtcbiAgICAgICAgY29uc3QgY29sbGFwc2VkID0gZWwuY2xhc3NMaXN0LnRvZ2dsZSh0aGlzLmNvbGxhcHNlZENsYXNzKTtcblxuICAgICAgICBjdXJyZW50VGFyZ2V0LnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIGNvbGxhcHNlZCA/ICdmYWxzZScgOiAndHJ1ZScpO1xuICAgICAgICBjdXJyZW50VGFyZ2V0LnNldEF0dHJpYnV0ZSgndGl0bGUnLCBjb2xsYXBzZWQgPyB0aGlzLmV4cGFuZFRpdGxlVmFsdWUgOiB0aGlzLmNvbGxhcHNlVGl0bGVWYWx1ZSk7XG5cbiAgICAgICAgdGhpcy5zZW5kUmVxdWVzdChjYXRlZ29yeSwgY29sbGFwc2VkKTtcbiAgICB9XG5cbiAgICBzZW5kUmVxdWVzdChjYXRlZ29yeSwgY29sbGFwc2VkKSB7XG4gICAgICAgIGZldGNoKHRoaXMudXJsVmFsdWUsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICdYLVJlcXVlc3RlZC1XaXRoJzogJ1hNTEh0dHBSZXF1ZXN0JyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBib2R5OiBuZXcgVVJMU2VhcmNoUGFyYW1zKHtcbiAgICAgICAgICAgICAgICBhY3Rpb246ICd0b2dnbGVOYXZpZ2F0aW9uJyxcbiAgICAgICAgICAgICAgICBpZDogY2F0ZWdvcnksXG4gICAgICAgICAgICAgICAgc3RhdGU6IGNvbGxhcHNlZCA/IDAgOiAxLFxuICAgICAgICAgICAgICAgIFJFUVVFU1RfVE9LRU46IHRoaXMucmVxdWVzdFRva2VuVmFsdWUsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgQ29udHJvbGxlciB9IGZyb20gJ0Bob3R3aXJlZC9zdGltdWx1cyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIGV4dGVuZHMgQ29udHJvbGxlciB7XG4gICAgc3RhdGljIHZhbHVlcyA9IHtcbiAgICAgICAgbW9kZToge1xuICAgICAgICAgICAgdHlwZTogTnVtYmVyLFxuICAgICAgICAgICAgZGVmYXVsdDogNSxcbiAgICAgICAgfSxcbiAgICAgICAgdG9nZ2xlQWN0aW9uOiBTdHJpbmcsXG4gICAgICAgIGxvYWRBY3Rpb246IFN0cmluZyxcbiAgICAgICAgcmVxdWVzdFRva2VuOiBTdHJpbmcsXG4gICAgICAgIHJlZmVyZXJJZDogU3RyaW5nLFxuICAgICAgICBleHBhbmQ6IFN0cmluZyxcbiAgICAgICAgY29sbGFwc2U6IFN0cmluZyxcbiAgICAgICAgZXhwYW5kQWxsOiBTdHJpbmcsXG4gICAgICAgIGV4cGFuZEFsbFRpdGxlOiBTdHJpbmcsXG4gICAgICAgIGNvbGxhcHNlQWxsOiBTdHJpbmcsXG4gICAgICAgIGNvbGxhcHNlQWxsVGl0bGU6IFN0cmluZyxcbiAgICB9O1xuXG4gICAgc3RhdGljIHRhcmdldHMgPSBbJ29wZXJhdGlvbicsICdub2RlJywgJ3RvZ2dsZScsICdjaGlsZCcsICdyb290Q2hpbGQnXTtcblxuICAgIG9wZXJhdGlvblRhcmdldENvbm5lY3RlZCgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVPcGVyYXRpb24oKTtcbiAgICB9XG5cbiAgICBjaGlsZFRhcmdldENvbm5lY3RlZCgpIHtcbiAgICAgICAgdGhpcy51cGRhdGVPcGVyYXRpb24oKTtcbiAgICB9XG5cbiAgICB0b2dnbGUoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgZWwgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgICAgICB0aGlzLnRvZ2dsZVRvZ2dsZXIoZWwsIGV2ZW50LnBhcmFtcy5pZCwgZXZlbnQucGFyYW1zLmxldmVsLCBldmVudC5wYXJhbXMuZm9sZGVyKTtcbiAgICB9XG5cbiAgICB0b2dnbGVUb2dnbGVyKGVsLCBpZCwgbGV2ZWwsIGZvbGRlcikge1xuICAgICAgICBjb25zdCBpdGVtID0gZG9jdW1lbnQuaWQoaWQpO1xuXG4gICAgICAgIGlmIChpdGVtICYmIGl0ZW0uc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnKSB7XG4gICAgICAgICAgICB0aGlzLnNob3dDaGlsZChpdGVtKTtcbiAgICAgICAgICAgIHRoaXMuZXhwYW5kVG9nZ2xlcihlbCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKGVsLCBpZCwgMSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXRlbSkge1xuICAgICAgICAgICAgdGhpcy5oaWRlQ2hpbGQoaXRlbSk7XG4gICAgICAgICAgICB0aGlzLmNvbGxhcHNlVG9nZ2xlcihlbCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVN0YXRlKGVsLCBpZCwgMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZldGNoQ2hpbGQoZWwsIGlkLCBsZXZlbCwgZm9sZGVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudXBkYXRlT3BlcmF0aW9uKCk7XG4gICAgfVxuXG4gICAgZXhwYW5kVG9nZ2xlcihlbCkge1xuICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKCdmb2xkYWJsZS0tb3BlbicpO1xuXG4gICAgICAgIGlmIChlbC5oYXNBdHRyaWJ1dGUoJ3RpdGxlJykpIHtcbiAgICAgICAgICAgIGVsLnRpdGxlID0gdGhpcy5jb2xsYXBzZVZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBpbWFnZSBvZiBlbC5xdWVyeVNlbGVjdG9yQWxsKCdpbWcnKSkge1xuICAgICAgICAgICAgaW1hZ2UuYWx0ID0gdGhpcy5jb2xsYXBzZVZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29sbGFwc2VUb2dnbGVyKGVsKSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoJ2ZvbGRhYmxlLS1vcGVuJyk7XG5cbiAgICAgICAgaWYgKGVsLmhhc0F0dHJpYnV0ZSgndGl0bGUnKSkge1xuICAgICAgICAgICAgZWwudGl0bGUgPSB0aGlzLmV4cGFuZFZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBpbWFnZSBvZiBlbC5xdWVyeVNlbGVjdG9yQWxsKCdpbWcnKSkge1xuICAgICAgICAgICAgaW1hZ2UuYWx0ID0gdGhpcy5leHBhbmRWYWx1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGxvYWRUb2dnbGVyKGVsLCBlbmFibGVkKSB7XG4gICAgICAgIGVsLmNsYXNzTGlzdFtlbmFibGVkID8gJ2FkZCcgOiAncmVtb3ZlJ10oJ2ZvbGRhYmxlLS1sb2FkaW5nJyk7XG4gICAgfVxuXG4gICAgc2hvd0NoaWxkKGl0ZW0pIHtcbiAgICAgICAgaXRlbS5zdHlsZS5kaXNwbGF5ID0gJyc7XG4gICAgfVxuXG4gICAgaGlkZUNoaWxkKGl0ZW0pIHtcbiAgICAgICAgaXRlbS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIH1cblxuICAgIGFzeW5jIGZldGNoQ2hpbGQoZWwsIGlkLCBsZXZlbCwgZm9sZGVyKSB7XG4gICAgICAgIHRoaXMubG9hZFRvZ2dsZXIoZWwsIHRydWUpO1xuXG4gICAgICAgIGNvbnN0IHVybCA9IG5ldyBVUkwobG9jYXRpb24uaHJlZik7XG4gICAgICAgIGNvbnN0IHNlYXJjaCA9IHVybC5zZWFyY2hQYXJhbXM7XG4gICAgICAgIHNlYXJjaC5zZXQoJ3JlZicsIHRoaXMucmVmZXJlcklkVmFsdWUpO1xuICAgICAgICB1cmwuc2VhcmNoID0gc2VhcmNoLnRvU3RyaW5nKCk7XG5cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJyxcbiAgICAgICAgICAgICAgICAnWC1SZXF1ZXN0ZWQtV2l0aCc6ICdYTUxIdHRwUmVxdWVzdCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYm9keTogbmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiB0aGlzLmxvYWRBY3Rpb25WYWx1ZSxcbiAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgbGV2ZWw6IGxldmVsLFxuICAgICAgICAgICAgICAgIGZvbGRlcjogZm9sZGVyLFxuICAgICAgICAgICAgICAgIHN0YXRlOiAxLFxuICAgICAgICAgICAgICAgIFJFUVVFU1RfVE9LRU46IHRoaXMucmVxdWVzdFRva2VuVmFsdWUsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICBjb25zdCB0eHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG5cbiAgICAgICAgICAgIGNvbnN0IGxpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcbiAgICAgICAgICAgIGxpLmlkID0gaWQ7XG4gICAgICAgICAgICBsaS5jbGFzc0xpc3QuYWRkKCdwYXJlbnQnKTtcbiAgICAgICAgICAgIGxpLnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lJztcbiAgICAgICAgICAgIGxpLnNldEF0dHJpYnV0ZShgZGF0YS0ke3RoaXMuaWRlbnRpZmllcn0tdGFyZ2V0YCwgbGV2ZWwgPT09IDAgPyAnY2hpbGQgcm9vdENoaWxkJyA6ICdjaGlsZCcpO1xuXG4gICAgICAgICAgICBjb25zdCB1bCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3VsJyk7XG4gICAgICAgICAgICB1bC5jbGFzc0xpc3QuYWRkKGBsZXZlbF8ke2xldmVsfWApO1xuICAgICAgICAgICAgdWwuaW5uZXJIVE1MID0gdHh0O1xuICAgICAgICAgICAgbGkuYXBwZW5kKHVsKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMubW9kZVZhbHVlID09PSA1KSB7XG4gICAgICAgICAgICAgICAgZWwuY2xvc2VzdCgnbGknKS5hZnRlcihsaSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBpc0ZvbGRlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGxldCBwYXJlbnQgPSBlbC5jbG9zZXN0KCdsaScpO1xuICAgICAgICAgICAgICAgIGxldCBuZXh0O1xuXG4gICAgICAgICAgICAgICAgd2hpbGUgKHR5cGVPZihwYXJlbnQpID09PSAnZWxlbWVudCcgJiYgcGFyZW50LnRhZ05hbWUgPT09ICdMSScgJiYgKG5leHQgPSBwYXJlbnQubmV4dEVsZW1lbnRTaWJsaW5nKSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQgPSBuZXh0O1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50LmNsYXNzTGlzdC5jb250YWlucygndGxfZm9sZGVyJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzRm9sZGVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGlzRm9sZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5iZWZvcmUobGkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudC5hZnRlcihsaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ3N0cnVjdHVyZScpKTtcbiAgICAgICAgICAgIHRoaXMuZXhwYW5kVG9nZ2xlcihlbCk7XG5cbiAgICAgICAgICAgIC8vIEhPT0sgKHNlZSAjNjc1MilcbiAgICAgICAgICAgIHdpbmRvdy5maXJlRXZlbnQoJ2FqYXhfY2hhbmdlJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxvYWRUb2dnbGVyKGVsLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgYXN5bmMgdG9nZ2xlQWxsKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGhyZWYgPSBldmVudC5jdXJyZW50VGFyZ2V0LmhyZWY7XG5cbiAgICAgICAgaWYgKHRoaXMuaGFzRXhwYW5kZWRSb290KCkgXiAoZXZlbnQgPyBldmVudC5hbHRLZXkgOiBmYWxzZSkpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQWxsU3RhdGUoaHJlZiwgMCk7XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgZWwgb2YgdGhpcy50b2dnbGVUYXJnZXRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2xsYXBzZVRvZ2dsZXIoZWwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy5jaGlsZFRhcmdldHMpIHtcbiAgICAgICAgICAgICAgICBpdGVtLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVsIG9mIHRoaXMuY2hpbGRUYXJnZXRzKSB7XG4gICAgICAgICAgICAgICAgZWwucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgZWwgb2YgdGhpcy50b2dnbGVUYXJnZXRzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2FkVG9nZ2xlcihlbCwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGF3YWl0IHRoaXMudXBkYXRlQWxsU3RhdGUoaHJlZiwgMSk7XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVsIG9mIHRoaXMudG9nZ2xlVGFyZ2V0cykge1xuICAgICAgICAgICAgICAgIHByb21pc2VzLnB1c2goXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmV0Y2hDaGlsZChcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgZWwuZ2V0QXR0cmlidXRlKGBkYXRhLSR7dGhpcy5pZGVudGlmaWVyfS1pZC1wYXJhbWApLFxuICAgICAgICAgICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsLmdldEF0dHJpYnV0ZShgZGF0YS0ke3RoaXMuaWRlbnRpZmllcn0tZm9sZGVyLXBhcmFtYCksXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy51cGRhdGVPcGVyYXRpb24oKTtcbiAgICB9XG5cbiAgICBrZXlwcmVzcyhldmVudCkge1xuICAgICAgICB0aGlzLnVwZGF0ZU9wZXJhdGlvbihldmVudCk7XG4gICAgfVxuXG4gICAgYXN5bmMgdXBkYXRlU3RhdGUoZWwsIGlkLCBzdGF0ZSkge1xuICAgICAgICBhd2FpdCBmZXRjaChsb2NhdGlvbi5ocmVmLCB7XG4gICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICAgICAgICAgICAgICAgJ1gtUmVxdWVzdGVkLVdpdGgnOiAnWE1MSHR0cFJlcXVlc3QnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJvZHk6IG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgICAgICAgICAgICAgIGFjdGlvbjogdGhpcy50b2dnbGVBY3Rpb25WYWx1ZSxcbiAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgICAgICAgICAgIFJFUVVFU1RfVE9LRU46IHRoaXMucmVxdWVzdFRva2VuVmFsdWUsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgdXBkYXRlQWxsU3RhdGUoaHJlZiwgc3RhdGUpIHtcbiAgICAgICAgYXdhaXQgZmV0Y2goYCR7aHJlZn0mc3RhdGU9JHtzdGF0ZX1gKTtcbiAgICB9XG5cbiAgICB1cGRhdGVPcGVyYXRpb24oZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc09wZXJhdGlvblRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBvcGVyYXRpb25UYXJnZXQgb2YgdGhpcy5vcGVyYXRpb25UYXJnZXRzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXNFeHBhbmRlZFJvb3QoKSBeIChldmVudCA/IGV2ZW50LmFsdEtleSA6IGZhbHNlKSkge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvblRhcmdldC5pbm5lclRleHQgPSB0aGlzLmNvbGxhcHNlQWxsVmFsdWU7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uVGFyZ2V0LnRpdGxlID0gdGhpcy5jb2xsYXBzZUFsbFRpdGxlVmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvblRhcmdldC5pbm5lclRleHQgPSB0aGlzLmV4cGFuZEFsbFZhbHVlO1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvblRhcmdldC50aXRsZSA9IHRoaXMuZXhwYW5kQWxsVGl0bGVWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGhhc0V4cGFuZGVkUm9vdCgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5yb290Q2hpbGRUYXJnZXRzLmZpbmQoKGVsKSA9PiBlbC5zdHlsZS5kaXNwbGF5ICE9PSAnbm9uZScpO1xuICAgIH1cbn1cbiIsImltcG9ydCB7IENvbnRyb2xsZXIgfSBmcm9tICdAaG90d2lyZWQvc3RpbXVsdXMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUb29sdGlwc0NvbnRyb2xsZXIgZXh0ZW5kcyBDb250cm9sbGVyIHtcbiAgICBzdGF0aWMgZGVmYXVsdE9wdGlvbnNNYXAgPSB7XG4gICAgICAgICdhIGltZ1thbHRdJzogeyB4OiAtOSwgeTogMzAgfSxcbiAgICAgICAgJy5zZ2FsbGVyeSBpbWdbYWx0XSc6IHsgeDogMCwgeTogNzUgfSxcbiAgICAgICAgJ3AudGxfdGlwJzogeyB4OiAwLCB5OiAyMywgdXNlQ29udGVudDogdHJ1ZSB9LFxuICAgICAgICAnI2hvbWVbdGl0bGVdJzogeyB4OiA2LCB5OiA0MiB9LFxuICAgICAgICAnI3RtZW51IGFbdGl0bGVdJzogeyB4OiAwLCB5OiA0MiB9LFxuICAgICAgICAnYVt0aXRsZV1bY2xhc3NePVwiZ3JvdXAtXCJdJzogeyB4OiAtNiwgeTogMjcgfSxcbiAgICAgICAgJ2FbdGl0bGVdLm5hdmlnYXRpb24nOiB7IHg6IDI1LCB5OiAzMiB9LFxuICAgICAgICAnaW1nW3RpdGxlXS5naW1hZ2UnOiB7IHg6IC05LCB5OiA2MCB9LFxuICAgICAgICAnaW1nW3RpdGxlXTpub3QoLmdpbWFnZSknOiB7IHg6IC05LCB5OiAzMCB9LFxuICAgICAgICAnYVt0aXRsZV0ucGlja2VyLXdpemFyZCc6IHsgeDogLTQsIHk6IDMwIH0sXG4gICAgICAgICdidXR0b24gaW1nW2FsdF0nOiB7IHg6IC05LCB5OiAzMCB9LFxuICAgICAgICAnLnRsX3BhbmVsIGJ1dHRvblt0aXRsZV0nOiB7IHg6IDAsIHk6IDM2IH0sXG4gICAgICAgICdidXR0b25bdGl0bGVdLnVuc2VsZWN0YWJsZSc6IHsgeDogLTQsIHk6IDIwIH0sXG4gICAgICAgICdidXR0b25bdGl0bGVdOm5vdCgudW5zZWxlY3RhYmxlKSc6IHsgeDogLTksIHk6IDMwIH0sXG4gICAgICAgICdhW3RpdGxlXTpub3QoLnBpY2tlci13aXphcmQpJzogeyB4OiAtOSwgeTogMzAgfSxcbiAgICAgICAgJ2lucHV0W3RpdGxlXSc6IHsgeDogLTksIHk6IDMwIH0sXG4gICAgICAgICd0aW1lW3RpdGxlXSc6IHsgeDogLTksIHk6IDI2IH0sXG4gICAgICAgICdzcGFuW3RpdGxlXSc6IHsgeDogLTksIHk6IDI2IH0sXG4gICAgfTtcblxuICAgIGFjdGl2ZVRhcmdldHMgPSBuZXcgU2V0KCk7XG4gICAgcmVtb3ZlQ2xpY2tUYXJnZXRIYW5kbGVyRGVsZWdhdGVzID0gbmV3IE1hcCgpO1xuXG4gICAgLyoqXG4gICAgICogVGhlcmUgaXMgb25lIGNvbnRyb2xsZXIgaGFuZGxpbmcgbXVsdGlwbGUgdG9vbHRpcCB0YXJnZXRzLiBUaGUgdG9vbHRpcFxuICAgICAqIERPTSBlbGVtZW50IGlzIHNoYXJlZCBhY3Jvc3MgdGFyZ2V0cy5cbiAgICAgKi9cbiAgICBjb25uZWN0KCkge1xuICAgICAgICB0aGlzLnRvb2x0aXAgPSBkb2N1bWVudC5ib2R5LnF1ZXJ5U2VsZWN0b3IoJ2JvZHkgPiBkaXZbcm9sZT1cInRvb2x0aXBcIl0nKSA/PyB0aGlzLl9jcmVhdGVUaXBDb250YWluZXIoKTtcbiAgICB9XG5cbiAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICB0aGlzLnRvb2x0aXAucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgdG9vbHRpcFRhcmdldENvbm5lY3RlZChlbCkge1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWVudGVyJywgKGUpID0+IHRoaXMuX3Nob3dUb29sdGlwKGUudGFyZ2V0LCAxMDAwKSk7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgKGUpID0+IHRoaXMuX3Nob3dUb29sdGlwKGUudGFyZ2V0KSk7XG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCAoZSkgPT4gdGhpcy5faGlkZVRvb2x0aXAoZS50YXJnZXQpKTtcblxuICAgICAgICAvLyBJbiBjYXNlIHRoZSB0b29sdGlwIHRhcmdldCBpcyBpbnNpZGUgYSBsaW5rIG9yIGJ1dHRvbiwgYWxzbyBjbG9zZSBpdFxuICAgICAgICAvLyB3aGVuIGEgY2xpY2sgaGFwcGVuZWRcbiAgICAgICAgY29uc3QgY2xpY2tUYXJnZXQgPSBlbC5jbG9zZXN0KCdidXR0b24sIGEnKTtcblxuICAgICAgICBpZiAoY2xpY2tUYXJnZXQpIHtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSAoKSA9PiB0aGlzLl9oaWRlVG9vbHRpcChlbCk7XG5cbiAgICAgICAgICAgIGNsaWNrVGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGFuZGxlcik7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUNsaWNrVGFyZ2V0SGFuZGxlckRlbGVnYXRlcy5zZXQoZWwsICgpID0+IGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGFuZGxlcikpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdG9vbHRpcFRhcmdldERpc2Nvbm5lY3RlZChlbCkge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmVUYXJnZXRzLmhhcyhlbCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2hpZGVUb29sdGlwKGVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLnJlbW92ZUNsaWNrVGFyZ2V0SGFuZGxlckRlbGVnYXRlcy5oYXMoZWwpKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUNsaWNrVGFyZ2V0SGFuZGxlckRlbGVnYXRlcy5nZXQoZWwpKCk7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUNsaWNrVGFyZ2V0SGFuZGxlckRlbGVnYXRlcy5kZWxldGUoZWwpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2NyZWF0ZVRpcENvbnRhaW5lcigpIHtcbiAgICAgICAgY29uc3QgdG9vbHRpcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0b29sdGlwLnNldEF0dHJpYnV0ZSgncm9sZScsICd0b29sdGlwJyk7XG4gICAgICAgIHRvb2x0aXAuY2xhc3NMaXN0LmFkZCgndGlwJyk7XG4gICAgICAgIHRvb2x0aXAuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICB0b29sdGlwLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0b29sdGlwKTtcblxuICAgICAgICByZXR1cm4gdG9vbHRpcDtcbiAgICB9XG5cbiAgICB0b3VjaFN0YXJ0ID0gKGUpID0+IHtcbiAgICAgICAgWy4uLnRoaXMuYWN0aXZlVGFyZ2V0c10uZmlsdGVyKChlbCkgPT4gIWVsLmNvbnRhaW5zKGUudGFyZ2V0KSkuZm9yRWFjaCh0aGlzLl9oaWRlVG9vbHRpcC5iaW5kKHRoaXMpKTtcbiAgICB9O1xuXG4gICAgX3Nob3dUb29sdGlwKGVsLCBkZWxheSA9IDApIHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHRoaXMuX2dldE9wdGlvbnNGb3JFbGVtZW50KGVsKTtcbiAgICAgICAgbGV0IHRleHQ7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMudXNlQ29udGVudCkge1xuICAgICAgICAgICAgdGV4dCA9IGVsLmlubmVySFRNTDtcbiAgICAgICAgfSBlbHNlIGlmIChlbCBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIHRleHQgPSBlbC5nZXRBdHRyaWJ1dGUoJ2FsdCcpO1xuICAgICAgICAgICAgdGV4dCA9IHRleHQ/LnJlcGxhY2UoLyYvZywgJyZhbXA7JykucmVwbGFjZSgvPC9nLCAnJmx0OycpLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKS5yZXBsYWNlKC8nL2csICcmYXBvczsnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRleHQgPSBlbC5nZXRBdHRyaWJ1dGUoJ3RpdGxlJyk7XG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtb3JpZ2luYWwtdGl0bGUnLCB0ZXh0KTtcbiAgICAgICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgndGl0bGUnKTtcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0Py5yZXBsYWNlKC8mL2csICcmYW1wOycpLnJlcGxhY2UoLzwvZywgJyZsdDsnKS5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7JykucmVwbGFjZSgvJy9nLCAnJmFwb3M7Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRleHQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcbiAgICAgICAgdGhpcy50b29sdGlwLnN0eWxlLndpbGxDaGFuZ2UgPSAnZGlzcGxheSxjb250ZW50cyc7XG5cbiAgICAgICAgdGhpcy50aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVUYXJnZXRzLmFkZChlbCk7XG5cbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICBjb25zdCBydGwgPSBnZXRDb21wdXRlZFN0eWxlKGVsKS5kaXJlY3Rpb24gPT09ICdydGwnO1xuICAgICAgICAgICAgY29uc3QgY2xpZW50V2lkdGggPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XG5cbiAgICAgICAgICAgIGlmICgocnRsICYmIHBvc2l0aW9uLnggPCAyMDApIHx8ICghcnRsICYmIHBvc2l0aW9uLnggPCBjbGllbnRXaWR0aCAtIDIwMCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRvb2x0aXAuc3R5bGUubGVmdCA9IGAke3dpbmRvdy5zY3JvbGxYICsgcG9zaXRpb24ubGVmdCArIG9wdGlvbnMueH1weGA7XG4gICAgICAgICAgICAgICAgdGhpcy50b29sdGlwLnN0eWxlLnJpZ2h0ID0gJ2F1dG8nO1xuICAgICAgICAgICAgICAgIHRoaXMudG9vbHRpcC5jbGFzc0xpc3QucmVtb3ZlKCd0aXAtLXJ0bCcpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRvb2x0aXAuc3R5bGUubGVmdCA9ICdhdXRvJztcbiAgICAgICAgICAgICAgICB0aGlzLnRvb2x0aXAuc3R5bGUucmlnaHQgPSBgJHtjbGllbnRXaWR0aCAtIHdpbmRvdy5zY3JvbGxYIC0gcG9zaXRpb24ucmlnaHQgKyBvcHRpb25zLnh9cHhgO1xuICAgICAgICAgICAgICAgIHRoaXMudG9vbHRpcC5jbGFzc0xpc3QuYWRkKCd0aXAtLXJ0bCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnRvb2x0aXAuaW5uZXJIVE1MID0gYDxkaXY+JHt0ZXh0fTwvZGl2PmA7XG4gICAgICAgICAgICB0aGlzLnRvb2x0aXAuc3R5bGUudG9wID0gYCR7d2luZG93LnNjcm9sbFkgKyBwb3NpdGlvbi50b3AgKyBvcHRpb25zLnl9cHhgO1xuICAgICAgICAgICAgdGhpcy50b29sdGlwLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgdGhpcy50b29sdGlwLnN0eWxlLndpbGxDaGFuZ2UgPSAnYXV0byc7XG4gICAgICAgIH0sIGRlbGF5KTtcbiAgICB9XG5cbiAgICBfaGlkZVRvb2x0aXAoZWwsIGRlbGF5ID0gMCkge1xuICAgICAgICBpZiAoZWwuaGFzQXR0cmlidXRlKCdkYXRhLW9yaWdpbmFsLXRpdGxlJykpIHtcbiAgICAgICAgICAgIGlmICghZWwuaGFzQXR0cmlidXRlKCd0aXRsZScpKSB7XG4gICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKCd0aXRsZScsIGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1vcmlnaW5hbC10aXRsZScpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdkYXRhLW9yaWdpbmFsLXRpdGxlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XG4gICAgICAgIHRoaXMudG9vbHRpcC5zdHlsZS53aWxsQ2hhbmdlID0gJ2F1dG8nO1xuXG4gICAgICAgIGlmICh0aGlzLnRvb2x0aXAuc3R5bGUuZGlzcGxheSA9PT0gJ2Jsb2NrJykge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVUYXJnZXRzLmRlbGV0ZShlbCk7XG5cbiAgICAgICAgICAgIHRoaXMudG9vbHRpcC5zdHlsZS53aWxsQ2hhbmdlID0gJ2Rpc3BsYXknO1xuICAgICAgICAgICAgdGhpcy50aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudG9vbHRpcC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgIHRoaXMudG9vbHRpcC5zdHlsZS53aWxsQ2hhbmdlID0gJ2F1dG8nO1xuICAgICAgICAgICAgfSwgZGVsYXkpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2dldE9wdGlvbnNGb3JFbGVtZW50KGVsKSB7XG4gICAgICAgIGZvciAoY29uc3QgW2NyaXRlcmlhLCBkZWZhdWx0T3B0aW9uc10gb2YgT2JqZWN0LmVudHJpZXMoVG9vbHRpcHNDb250cm9sbGVyLmRlZmF1bHRPcHRpb25zTWFwKSkge1xuICAgICAgICAgICAgaWYgKGVsLm1hdGNoKGNyaXRlcmlhKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZWZhdWx0T3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IHg6IC05LCB5OiAzMCB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1pZ3JhdGUgbGVnYWN5IHRhcmdldHMgdG8gcHJvcGVyIGNvbnRyb2xsZXIgdGFyZ2V0cy5cbiAgICAgKi9cbiAgICBzdGF0aWMgYWZ0ZXJMb2FkKGlkZW50aWZpZXIsIGFwcGxpY2F0aW9uKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldFNlbGVjdG9ycyA9IE9iamVjdC5rZXlzKFRvb2x0aXBzQ29udHJvbGxlci5kZWZhdWx0T3B0aW9uc01hcCk7XG5cbiAgICAgICAgY29uc3QgbWlncmF0ZVRhcmdldCA9IChlbCkgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCB0YXJnZXQgb2YgdGFyZ2V0U2VsZWN0b3JzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFlbC5oYXNBdHRyaWJ1dGUoYGRhdGEtJHtpZGVudGlmaWVyfS10YXJnZXRgKSAmJiBlbC5tYXRjaCh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLnNldEF0dHJpYnV0ZShgZGF0YS0ke2lkZW50aWZpZXJ9LXRhcmdldGAsICd0b29sdGlwJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBzZWwgb2YgZWwucXVlcnlTZWxlY3RvckFsbCh0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc2VsLmhhc0F0dHJpYnV0ZShgZGF0YS0ke2lkZW50aWZpZXJ9LXRhcmdldGApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWwuc2V0QXR0cmlidXRlKGBkYXRhLSR7aWRlbnRpZmllcn0tdGFyZ2V0YCwgJ3Rvb2x0aXAnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBuZXcgTXV0YXRpb25PYnNlcnZlcigobXV0YXRpb25zTGlzdCkgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBtdXRhdGlvbiBvZiBtdXRhdGlvbnNMaXN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKG11dGF0aW9uLnR5cGUgIT09ICdjaGlsZExpc3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBtdXRhdGlvbi5hZGRlZE5vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKG5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbWlncmF0ZVRhcmdldChub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLm9ic2VydmUoZG9jdW1lbnQsIHtcbiAgICAgICAgICAgIGNoaWxkTGlzdDogdHJ1ZSxcbiAgICAgICAgICAgIHN1YnRyZWU6IHRydWUsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEluaXRpYWxseSBtaWdyYXRlIGFsbCB0YXJnZXRzIHRoYXQgYXJlIGFscmVhZHkgaW4gdGhlIERPTVxuICAgICAgICBmb3IgKGNvbnN0IGVsIG9mIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwodGFyZ2V0U2VsZWN0b3JzLmpvaW4oJywnKSkpIHtcbiAgICAgICAgICAgIG1pZ3JhdGVUYXJnZXQoZWwpO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiaW1wb3J0IHsgQ29udHJvbGxlciB9IGZyb20gJ0Bob3R3aXJlZC9zdGltdWx1cyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIGV4dGVuZHMgQ29udHJvbGxlciB7XG4gICAgc3RhdGljIHRhcmdldHMgPSBbJ21lc3NhZ2UnXTtcblxuICAgIHN0YXRpYyB2YWx1ZXMgPSB7XG4gICAgICAgIHVuc3VwcG9ydGVkTWVzc2FnZTogU3RyaW5nLFxuICAgICAgICBhc3NlcnRpb25GYWlsdXJlTWVzc2FnZTogU3RyaW5nLFxuICAgICAgICBhdHRlc3RhdGlvbkZhaWx1cmVNZXNzYWdlOiBTdHJpbmcsXG4gICAgICAgIG9wdGlvbnNGYWlsdXJlTWVzc2FnZTogU3RyaW5nLFxuICAgICAgICBjc3JmVXJsOiBTdHJpbmcsXG4gICAgfTtcblxuICAgIGhhbmRsZVVuc3VwcG9ydGVkKCkge1xuICAgICAgICB0aGlzLm1lc3NhZ2VUYXJnZXQuaW5uZXJIVE1MID0gdGhpcy5yZW5kZXJNZXNzYWdlKHRoaXMudW5zdXBwb3J0ZWRNZXNzYWdlVmFsdWUpO1xuICAgIH1cblxuICAgIGhhbmRsZUFzc2VydGlvbkZhaWx1cmUoZSkge1xuICAgICAgICB0aGlzLm1lc3NhZ2VUYXJnZXQuaW5uZXJIVE1MID0gdGhpcy5yZW5kZXJNZXNzYWdlKHRoaXMuYXNzZXJ0aW9uRmFpbHVyZU1lc3NhZ2VWYWx1ZSk7XG4gICAgfVxuXG4gICAgaGFuZGxlQXR0ZXN0YXRpb25GYWlsdXJlKCkge1xuICAgICAgICB0aGlzLm1lc3NhZ2VUYXJnZXQuaW5uZXJIVE1MID0gdGhpcy5yZW5kZXJNZXNzYWdlKHRoaXMuYXR0ZXN0YXRpb25GYWlsdXJlTWVzc2FnZVZhbHVlKTtcbiAgICB9XG5cbiAgICBoYW5kbGVPcHRpb25zRmFpbHVyZSgpIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlVGFyZ2V0LmlubmVySFRNTCA9IHRoaXMucmVuZGVyTWVzc2FnZSh0aGlzLm9wdGlvbnNGYWlsdXJlTWVzc2FnZVZhbHVlKTtcbiAgICB9XG5cbiAgICBsb2FkQ3NyZigpIHtcbiAgICAgICAgaWYgKHRoaXMuY3NyZlNjcmlwdCB8fCAhdGhpcy5jc3JmVXJsVmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBhbHdheXMgaGF2ZSB0aGUgY29ycmVjdCByZXF1ZXN0IHRva2VuIGFuZCBjb29raWVcbiAgICAgICAgdGhpcy5jc3JmU2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgIHRoaXMuY3NyZlNjcmlwdC5zcmMgPSB0aGlzLmNzcmZVcmxWYWx1ZTtcbiAgICAgICAgdGhpcy5jc3JmU2NyaXB0LmFzeW5jID0gdHJ1ZTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmQodGhpcy5jc3JmU2NyaXB0KTtcbiAgICB9XG5cbiAgICByZW5kZXJNZXNzYWdlKG1lc3NhZ2UsIHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGA8cCBjbGFzcz1cInRsXyR7dHlwZSA/PyAnZXJyb3InfVwiPiR7bWVzc2FnZX08L3A+YDtcbiAgICB9XG59XG4iLCJpbXBvcnQgbWFuaWZlc3QgZnJvbSAnLi4vLi4vY29udGFvL3RoZW1lcy9mbGV4aWJsZS9pY29ucy9tYW5pZmVzdC5qc29uJztcblxuLyoqXG4gKiBDcmVhdGUgYW4gaWNvbiB0ZW1wbGF0ZSBmb3IgdGhlIGdpdmVuIG5hbWUuIFlvdSBjYW4gY2FsbCBcImdldEh0bWwoKVwiXG4gKiBvbiB0aGUgcmVzdWx0IHRvIGdldCB0aGUgSFRNTCBvZiB0aGUgaW5jbHVkZWQgaWNvbihzKS4gVGhlIHJlc3VsdCB3aWxsXG4gKiBpbmNsdWRlIGVpdGhlciBvbmUgaW1hZ2UgZWxlbWVudCAobGlnaHQvZGFyayBtb2RlIHNoYXJlIGFuIGljb24pIG9yXG4gKiB0d28gd2l0aCBhIGNvbG9yLXNjaGVtZSBDU1MgY2xhc3MsIGlmIHRoZXJlIGFyZSBkaWZmZXJlbnQgdmFyaWFudHMgZm9yXG4gKiBsaWdodC9kYXJrIG1vZGUuXG4gKlxuICogQHBhcmFtIG5hbWUgVGhlIG5hbWUgb2YgdGhlIGljb24gKGUuZy4gXCJlZGl0XCIgb3IgXCJkZWxldGVcIikuXG4gKiBAcGFyYW0gYXR0cmlidXRlcyBBbiBvYmplY3Qgb2YgYXR0cmlidXRlcyAoZS5nLiB7dGl0bGU6ICdmb28nfSkuXG4gKiBAcmV0dXJucyB7SFRNTFRlbXBsYXRlRWxlbWVudH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFRlbXBsYXRlKG5hbWUsIGF0dHJpYnV0ZXMgPSB7fSkge1xuICAgIC8vIE1ha2Ugc3VyZSB0aGUgYWx0IGF0dHJpYnV0ZSBnZXRzIHNldFxuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGF0dHJpYnV0ZXMsICdhbHQnKSkge1xuICAgICAgICBhdHRyaWJ1dGVzLmFsdCA9ICcnO1xuICAgIH1cblxuICAgIGNvbnN0IHNvdXJjZSA9IGdldFNvdXJjZShuYW1lKTtcblxuICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIHRocm93IEVycm9yKGBUaGUgaWNvbiBcIiR7bmFtZX1cIiBkb2VzIG5vdCBleGlzdC5gKTtcbiAgICB9XG5cbiAgICBjb25zdCBzb3VyY2VEYXJrID0gZ2V0U291cmNlKG5hbWUsIHRydWUpO1xuICAgIGNvbnN0IHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKTtcblxuICAgIGlmIChzb3VyY2VEYXJrKSB7XG4gICAgICAgIHRlbXBsYXRlLmNvbnRlbnQuYXBwZW5kKF9nZXRJbWFnZShzb3VyY2UsIGF0dHJpYnV0ZXMsICdsaWdodCcpKTtcbiAgICAgICAgdGVtcGxhdGUuY29udGVudC5hcHBlbmQoX2dldEltYWdlKHNvdXJjZURhcmssIGF0dHJpYnV0ZXMsICdkYXJrJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRlbXBsYXRlLmNvbnRlbnQuYXBwZW5kKF9nZXRJbWFnZShzb3VyY2UsIGF0dHJpYnV0ZXMpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGVtcGxhdGU7XG59XG5cbmZ1bmN0aW9uIF9nZXRJbWFnZShzb3VyY2UsIGF0dHJpYnV0ZXMsIGNvbG9yU2NoZW1lID0gbnVsbCkge1xuICAgIGNvbnN0IGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICAgIGltZy5zcmMgPSBzb3VyY2U7XG5cbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhhdHRyaWJ1dGVzKSkge1xuICAgICAgICBpbWcuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUpO1xuICAgIH1cblxuICAgIGlmIChjb2xvclNjaGVtZSkge1xuICAgICAgICBpbWcuY2xhc3NMaXN0LmFkZChgY29sb3Itc2NoZW1lLS0ke2NvbG9yU2NoZW1lfWApO1xuICAgIH1cblxuICAgIHJldHVybiBpbWc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTb3VyY2UobmFtZSwgZGFya1NjaGVtZSA9IGZhbHNlKSB7XG4gICAgY29uc3QgZmlsZU5hbWUgPSBgJHtuYW1lfSR7ZGFya1NjaGVtZSA/ICctLWRhcmsnIDogJyd9LnN2Z2A7XG5cbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1hbmlmZXN0LCBmaWxlTmFtZSkgPyBtYW5pZmVzdFtmaWxlTmFtZV0gOiBudWxsO1xufVxuIiwiLyoqXG4gKiBEaXNwbGF5IGFuIGluZm8gbWVzc2FnZS5cbiAqXG4gKiBAcGFyYW0gbWVzc2FnZSBUZXh0IG9yIEhUTUwgdGhhdCB3aWxsIGJlIHB1dCBpbnRvIHRoZSBtZXNzYWdlIGJvZHkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbmZvKG1lc3NhZ2UpIHtcbiAgICBfYWRkTWVzc2FnZShtZXNzYWdlLCAnaW5mbycpO1xufVxuXG4vKipcbiAqIERpc3BsYXkgYW4gZXJyb3IgbWVzc2FnZS5cbiAqXG4gKiBAcGFyYW0gbWVzc2FnZSBUZXh0IG9yIEhUTUwgdGhhdCB3aWxsIGJlIHB1dCBpbnRvIHRoZSBtZXNzYWdlIGJvZHkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlcnJvcihtZXNzYWdlKSB7XG4gICAgX2FkZE1lc3NhZ2UobWVzc2FnZSwgJ2Vycm9yJyk7XG59XG5cbmZ1bmN0aW9uIF9hZGRNZXNzYWdlKG1lc3NhZ2UsIHR5cGUpIHtcbiAgICBjb25zdCBldmVudCA9IG5ldyBDdXN0b21FdmVudCgnY29udGFvLS1tZXNzYWdlJywge1xuICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICB9LFxuICAgIH0pO1xuXG4gICAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XG59XG4iLCJleHBvcnQgY2xhc3MgVHVyYm9TdHJlYW1Db25uZWN0aW9uIHtcbiAgICBfYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIF9hYm9ydFNpZ25hbCA9IHsgcmVhc29uOiAnVGhlIHJlcXVlc3Qgd2FzIHN1YnN0aXR1dGVkLicgfTtcblxuICAgIC8qKlxuICAgICAqIFJlcXVlc3RzIGEgc3RyZWFtIHJlc3BvbnNlIHVzaW5nIEdFVCBhbmQgbGV0cyBUdXJibyBoYW5kbGUgaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdXJsIFRoZSBVUkwgb2YgdGhlIFN5bWZvbnkgY29udHJvbGxlciBhbnN3ZXJpbmcgdGhlIHN0cmVhbSByZXF1ZXN0LlxuICAgICAqIEBwYXJhbSBxdWVyeV9wYXJhbXMgQW4gb2JqZWN0IG9mIHF1ZXJ5IHBhcmFtZXRlcnMuIElmIHRoZSB2YWx1ZSBpcyBhbiBhcnJheSwgYSBrZXkgXCJmb29cIiB3aWxsIGJlIG5hbWVkIFwiZm9vW11cIiBhbmQgYXBwZWFyIG11bHRpcGxlIHRpbWVzLlxuICAgICAqIEBwYXJhbSBhYm9ydFBlbmRpbmcgSWYgc2V0IHRvIHRydWUsIHByZXZpb3VzIHJlcXVlc3RzIHRoYXQgYXJlIHN0aWxsIHBlbmRpbmcgd2lsbCBiZSBhYm9ydGVkLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8VHVyYm9TdHJlYW1SZXN1bHQ+fVxuICAgICAqL1xuICAgIGFzeW5jIGdldCh1cmwsIHF1ZXJ5X3BhcmFtcyA9IG51bGwsIGFib3J0UGVuZGluZyA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChhYm9ydFBlbmRpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuYWJvcnRQZW5kaW5nKCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgICAgICBtZXRob2Q6ICdnZXQnLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgIEFjY2VwdDogJ3RleHQvdm5kLnR1cmJvLXN0cmVhbS5odG1sJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzaWduYWw6IHRoaXMuX2Fib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgICAgIH07XG5cbiAgICAgICAgbGV0IHJlc3BvbnNlO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXNwb25zZSA9IGF3YWl0IGZldGNoKHRoaXMuY29uc3RydWN0b3IuYnVpbGRVUkwodXJsLCBxdWVyeV9wYXJhbXMpLCBwYXJhbXMpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBpZiAoZSAhPT0gdGhpcy5fYWJvcnRTaWduYWwpIHtcbiAgICAgICAgICAgICAgICBpZiAod2luZG93LmNvbnNvbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgVGhlcmUgd2FzIGFuIGVycm9yIGZldGNoaW5nIHRoZSBUdXJibyBzdHJlYW0gcmVzcG9uc2UgZnJvbSBcIiR7dXJsfVwiYCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUdXJib1N0cmVhbVJlc3VsdCgnZXJyb3InLCByZXNwb25zZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBuZXcgVHVyYm9TdHJlYW1SZXN1bHQoJ2Fib3J0ZWQnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZXNwb25zZS5yZWRpcmVjdGVkKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5sb2NhdGlvbiA9IHJlc3BvbnNlLnVybDtcblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBUdXJib1N0cmVhbVJlc3VsdCgnZXJyb3InLCByZXNwb25zZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKS5zdGFydHNXaXRoKCd0ZXh0L3ZuZC50dXJiby1zdHJlYW0uaHRtbCcpIHx8IHJlc3BvbnNlLnN0YXR1cyA+PSAzMDApIHtcbiAgICAgICAgICAgIGlmICh3aW5kb3cuY29uc29sZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFRoZSBUdXJibyBzdHJlYW0gcmVzcG9uc2UgZnJvbSBcIiR7dXJsfVwiIGhhcyBhbiB1bnByb2Nlc3NhYmxlIGZvcm1hdC5gKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBUdXJib1N0cmVhbVJlc3VsdCgnZXJyb3InLCByZXNwb25zZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBodG1sID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICBUdXJiby5yZW5kZXJTdHJlYW1NZXNzYWdlKGh0bWwpO1xuXG4gICAgICAgIHJldHVybiBuZXcgVHVyYm9TdHJlYW1SZXN1bHQoJ29rJywgcmVzcG9uc2UpO1xuICAgIH1cblxuICAgIGFib3J0UGVuZGluZygpIHtcbiAgICAgICAgdGhpcy5fYWJvcnRDb250cm9sbGVyPy5hYm9ydCh0aGlzLl9hYm9ydFNpZ25hbCk7XG4gICAgICAgIHRoaXMuX2Fib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgYnVpbGRVUkwodXJsLCBxdWVyeV9wYXJhbXMpIHtcbiAgICAgICAgaWYgKHF1ZXJ5X3BhcmFtcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHVybDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHBhaXJzID0gW107XG5cbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocXVlcnlfcGFyYW1zKSkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChjb25zdCB2YWx1ZTEgb2YgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBwYWlycy5wdXNoKFtgJHtrZXl9W11gLCB2YWx1ZTFdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBgJHt1cmx9PyR7bmV3IFVSTFNlYXJjaFBhcmFtcyhwYWlycykudG9TdHJpbmcoKX1gO1xuICAgIH1cbn1cblxuZXhwb3J0IGNsYXNzIFR1cmJvU3RyZWFtUmVzdWx0IHtcbiAgICBjb25zdHJ1Y3RvcihyZXN1bHRTdGF0ZSwgcmVzcG9uc2UgPSBudWxsKSB7XG4gICAgICAgIHRoaXMucmVzdWx0U3RhdGUgPSByZXN1bHRTdGF0ZTtcbiAgICAgICAgdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgIH1cblxuICAgIGdldCBvaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzdWx0U3RhdGUgPT09ICdvayc7XG4gICAgfVxuXG4gICAgZ2V0IGFib3J0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3VsdFN0YXRlID09PSAnYWJvcnRlZCc7XG4gICAgfVxuXG4gICAgZ2V0IGVycm9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHRTdGF0ZSA9PT0gJ2Vycm9yJztcbiAgICB9XG59XG4iLCJleHBvcnQgY2xhc3MgVHdpZ0VkaXRvciB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCkge1xuICAgICAgICB0aGlzLmNvbnRhaW5lckJhY2t1cCA9IGVsZW1lbnQuY2xvbmVOb2RlKCk7XG4gICAgICAgIHRoaXMubmFtZSA9IGVsZW1lbnQuZGF0YXNldC5uYW1lO1xuICAgICAgICB0aGlzLnJlc291cmNlVXJsID0gZWxlbWVudC5kYXRhc2V0LnJlc291cmNlVXJsO1xuXG4gICAgICAgIHRoaXMuZWRpdG9yID0gYWNlLmVkaXQoZWxlbWVudCwge1xuICAgICAgICAgICAgbW9kZTogJ2FjZS9tb2RlL3R3aWcnLFxuICAgICAgICAgICAgbWF4TGluZXM6IDEwMCxcbiAgICAgICAgICAgIHdyYXA6IHRydWUsXG4gICAgICAgICAgICB1c2VTb2Z0VGFiczogZmFsc2UsXG4gICAgICAgICAgICBhdXRvU2Nyb2xsRWRpdG9ySW50b1ZpZXc6IHRydWUsXG4gICAgICAgICAgICByZWFkT25seTogZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ3JlYWRvbmx5JyksXG4gICAgICAgICAgICBlbmFibGVMaXZlQXV0b2NvbXBsZXRpb246IHRydWUsXG4gICAgICAgICAgICBlbmFibGVLZXlib2FyZEFjY2Vzc2liaWxpdHk6IHRydWUsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuc2V0Q29sb3JTY2hlbWUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRhdGFzZXQuY29sb3JTY2hlbWUpO1xuICAgICAgICB0aGlzLmVkaXRvci5jb250YWluZXIuc3R5bGUubGluZUhlaWdodCA9ICcxLjQ1JztcblxuICAgICAgICBjb25zdCB3aGl0ZXNwYWNlID0gYWNlLnJlcXVpcmUoJ2FjZS9leHQvd2hpdGVzcGFjZScpO1xuICAgICAgICB3aGl0ZXNwYWNlLmRldGVjdEluZGVudGF0aW9uKHRoaXMuZWRpdG9yLmdldFNlc3Npb24oKSk7XG5cbiAgICAgICAgLy8gUmVnaXN0ZXIgY29tbWFuZHNcbiAgICAgICAgdGhpcy5lZGl0b3IuY29tbWFuZHMuYWRkQ29tbWFuZCh7XG4gICAgICAgICAgICBuYW1lOiAnbGVuczpibG9jay1pbmZvJyxcbiAgICAgICAgICAgIHJlYWRPbmx5OiB0cnVlLFxuICAgICAgICAgICAgZXhlYzogKGVkaXRvciwgYXJncykgPT4ge1xuICAgICAgICAgICAgICAgIGVkaXRvci5jb250YWluZXIuZGlzcGF0Y2hFdmVudChcbiAgICAgICAgICAgICAgICAgICAgbmV3IEN1c3RvbUV2ZW50KCd0d2lnLWVkaXRvcjpsZW5zOmJsb2NrLWluZm8nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrOiBhcmdzWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuZWRpdG9yLmNvbW1hbmRzLmFkZENvbW1hbmQoe1xuICAgICAgICAgICAgbmFtZTogJ2xlbnM6Zm9sbG93JyxcbiAgICAgICAgICAgIHJlYWRPbmx5OiB0cnVlLFxuICAgICAgICAgICAgZXhlYzogKGVkaXRvciwgYXJncykgPT4ge1xuICAgICAgICAgICAgICAgIGVkaXRvci5jb250YWluZXIuZGlzcGF0Y2hFdmVudChcbiAgICAgICAgICAgICAgICAgICAgbmV3IEN1c3RvbUV2ZW50KCd0d2lnLWVkaXRvcjpsZW5zOmZvbGxvdycsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBhcmdzWzBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFNldHVwIGNvZGUgbGVuc2VzXG4gICAgICAgIHRoaXMuZWRpdG9yLmdldFNlc3Npb24oKS5vbmNlKCd0b2tlbml6ZXJVcGRhdGUnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlZ2lzdGVyQ29kZUxlbnNQcm92aWRlcigpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZWdpc3RlckNvZGVMZW5zUHJvdmlkZXIoKSB7XG4gICAgICAgIGNvbnN0IGNvZGVMZW5zID0gYWNlLnJlcXVpcmUoJ2FjZS9leHQvY29kZV9sZW5zJyk7XG5cbiAgICAgICAgY29kZUxlbnMucmVnaXN0ZXJDb2RlTGVuc1Byb3ZpZGVyKHRoaXMuZWRpdG9yLCB7XG4gICAgICAgICAgICBwcm92aWRlQ29kZUxlbnNlczogKHNlc3Npb24sIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHNlc3Npb24uZGVzdHJveWVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gW107XG5cbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJlZmVyZW5jZSBvZiB0aGlzLmFuYWx5emVSZWZlcmVuY2VzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiB7IHJvdzogcmVmZXJlbmNlLnJvdywgY29sdW1uOiByZWZlcmVuY2UuY29sdW1uIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBjb21tYW5kOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6ICdsZW5zOmZvbGxvdycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGl0bGU6IHJlZmVyZW5jZS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3VtZW50czogW3JlZmVyZW5jZS5uYW1lXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYmxvY2sgb2YgdGhpcy5hbmFseXplQmxvY2tzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiB7IHJvdzogYmxvY2sucm93LCBjb2x1bW46IGJsb2NrLmNvbHVtbiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiAnbGVuczpibG9jay1pbmZvJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogYEJsb2NrIFwiJHtibG9jay5uYW1lfVwiYCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IFtibG9jay5uYW1lXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHBheWxvYWQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYW5hbHl6ZVJlZmVyZW5jZXMoKSB7XG4gICAgICAgIGNvbnN0IHJlZmVyZW5jZXMgPSBbXTtcblxuICAgICAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCB0aGlzLmVkaXRvci5nZXRTZXNzaW9uKCkuZ2V0TGVuZ3RoKCk7IHJvdysrKSB7XG4gICAgICAgICAgICBjb25zdCB0b2tlbnMgPSB0aGlzLmVkaXRvci5nZXRTZXNzaW9uKCkuZ2V0VG9rZW5zKHJvdyk7XG5cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICB0b2tlbnNbaV0udHlwZSA9PT0gJ21ldGEudGFnLnR3aWcnICYmXG4gICAgICAgICAgICAgICAgICAgIC9eeyUtPyQvLnRlc3QodG9rZW5zW2ldLnZhbHVlKSAmJlxuICAgICAgICAgICAgICAgICAgICB0b2tlbnNbaSArIDJdPy50eXBlID09PSAna2V5d29yZC5jb250cm9sLnR3aWcnICYmXG4gICAgICAgICAgICAgICAgICAgIFsnZXh0ZW5kcycsICd1c2UnXS5pbmNsdWRlcyh0b2tlbnNbaSArIDJdLnZhbHVlKSAmJlxuICAgICAgICAgICAgICAgICAgICB0b2tlbnNbaSArIDRdPy50eXBlID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuYW1lID0gdG9rZW5zW2kgKyA0XS52YWx1ZS5yZXBsYWNlKC9bXCInXS9nLCAnJyk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKC9eQENvbnRhbyhfLispP1xcLy8udGVzdChuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVmZXJlbmNlcy5wdXNoKHsgbmFtZSwgcm93LCBjb2x1bW46IHRva2Vuc1tpXS5zdGFydCB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZWZlcmVuY2VzO1xuICAgIH1cblxuICAgIGFuYWx5emVCbG9ja3MoKSB7XG4gICAgICAgIGNvbnN0IGJsb2NrcyA9IFtdO1xuXG4gICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHRoaXMuZWRpdG9yLmdldFNlc3Npb24oKS5nZXRMZW5ndGgoKTsgcm93KyspIHtcbiAgICAgICAgICAgIGNvbnN0IHRva2VucyA9IHRoaXMuZWRpdG9yLmdldFNlc3Npb24oKS5nZXRUb2tlbnMocm93KTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgICAgIHRva2Vuc1tpXS50eXBlID09PSAnbWV0YS50YWcudHdpZycgJiZcbiAgICAgICAgICAgICAgICAgICAgL157JS0/JC8udGVzdCh0b2tlbnNbaV0udmFsdWUpICYmXG4gICAgICAgICAgICAgICAgICAgIHRva2Vuc1tpICsgMl0/LnR5cGUgPT09ICdrZXl3b3JkLmNvbnRyb2wudHdpZycgJiZcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zW2kgKyAyXS52YWx1ZSA9PT0gJ2Jsb2NrJyAmJlxuICAgICAgICAgICAgICAgICAgICB0b2tlbnNbaSArIDRdPy50eXBlID09PSAnaWRlbnRpZmllcidcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tzLnB1c2goeyBuYW1lOiB0b2tlbnNbaSArIDRdLnZhbHVlLCByb3csIGNvbHVtbjogdG9rZW5zW2ldLnN0YXJ0IH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBibG9ja3M7XG4gICAgfVxuXG4gICAgc2V0QW5ub3RhdGlvbnNEYXRhKGRhdGEpIHtcbiAgICAgICAgdGhpcy5lZGl0b3IuY29tcGxldGVycyA9IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBnZXRDb21wbGV0aW9uczogKGVkaXRvciwgc2Vzc2lvbiwgcG9zLCBwcmVmaXgsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGRhdGEuYXV0b2NvbXBsZXRlKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXTtcblxuICAgICAgICBpZiAoJ2Vycm9yJyBpbiBkYXRhKSB7XG4gICAgICAgICAgICB0aGlzLmVkaXRvci5nZXRTZXNzaW9uKCkuc2V0QW5ub3RhdGlvbnMoW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcm93OiBkYXRhLmVycm9yLmxpbmUgLSAxLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBkYXRhLmVycm9yLnR5cGUgfHwgJ2Vycm9yJyxcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogYCAke2RhdGEuZXJyb3IubWVzc2FnZX1gLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldENvbG9yU2NoZW1lKG1vZGUpIHtcbiAgICAgICAgdGhpcy5lZGl0b3Iuc2V0VGhlbWUobW9kZSA9PT0gJ2RhcmsnID8gJ2FjZS90aGVtZS90d2lsaWdodCcgOiAnYWNlL3RoZW1lL2Nsb3VkcycpO1xuICAgIH1cblxuICAgIGlzRWRpdGFibGUoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5lZGl0b3IuZ2V0UmVhZE9ubHkoKTtcbiAgICB9XG5cbiAgICBnZXRDb250ZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lZGl0b3IuZ2V0VmFsdWUoKTtcbiAgICB9XG5cbiAgICBmb2N1cygpIHtcbiAgICAgICAgdGhpcy5lZGl0b3IuZm9jdXMoKTtcbiAgICB9XG5cbiAgICBkZXN0cm95KCkge1xuICAgICAgICAvLyBEZXN0cm95aW5nIHRoZSBBQ0UgaW5zdGFuY2UgZG9lcyBub3QgZnVsbHkgcmVzZXQgdGhlIEhUTUwsIHNvIHdlXG4gICAgICAgIC8vIG1hbnVhbGx5IHJlc3RvcmUgdGhlIGNvbnRhaW5lciBieSB1c2luZyB0aGUgY2xvbmVkIGJhY2t1cCB3aXRoXG4gICAgICAgIC8vIHVwZGF0ZWQgY29udGVudC5cbiAgICAgICAgdGhpcy5jb250YWluZXJCYWNrdXAudGV4dENvbnRlbnQgPSB0aGlzLmdldENvbnRlbnQoKTtcbiAgICAgICAgdGhpcy5lZGl0b3IuY29udGFpbmVyLnJlcGxhY2VXaXRoKHRoaXMuY29udGFpbmVyQmFja3VwKTtcblxuICAgICAgICB0aGlzLmVkaXRvci5kZXN0cm95KCk7XG4gICAgfVxufVxuIiwiaW1wb3J0ICogYXMgSWNvbiBmcm9tIFwiLi4vbW9kdWxlcy9pY29uXCI7XG5cbi8qKlxuICogUHJvdmlkZSBtZXRob2RzIHRvIGhhbmRsZSBBamF4IHJlcXVlc3RzLlxuICpcbiAqIEBhdXRob3IgTGVvIEZleWVyIDxodHRwczovL2dpdGh1Yi5jb20vbGVvZmV5ZXI+XG4gKi9cbndpbmRvdy5BamF4UmVxdWVzdCA9XG57XG5cdC8qKlxuXHQgKiBUb2dnbGUgdGhlIG5hdmlnYXRpb24gbWVudVxuXHQgKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gZWwgIFRoZSBET00gZWxlbWVudFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWQgIFRoZSBJRCBvZiB0aGUgbWVudSBpdGVtXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIEFqYXggVVJMXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtib29sZWFufVxuXHQgKi9cblx0dG9nZ2xlTmF2aWdhdGlvbjogZnVuY3Rpb24oZWwsIGlkLCB1cmwpIHtcblx0XHRpZiAod2luZG93LmNvbnNvbGUpIHtcblx0XHRcdGNvbnNvbGUud2FybignQWpheFJlcXVlc3QudG9nZ2xlTmF2aWdhdGlvbigpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgdGhlIHN0aW11bHVzIGNvbnRyb2xsZXIgaW5zdGVhZC4nKTtcblx0XHR9XG5cblx0XHR2YXIgaXRlbSA9ICQoaWQpLFxuXHRcdFx0cGFyZW50ID0gJChlbCkuZ2V0UGFyZW50KCdsaScpO1xuXG5cdFx0aWYgKGl0ZW0pIHtcblx0XHRcdGlmIChwYXJlbnQuaGFzQ2xhc3MoJ2NvbGxhcHNlZCcpKSB7XG5cdFx0XHRcdHBhcmVudC5yZW1vdmVDbGFzcygnY29sbGFwc2VkJyk7XG5cdFx0XHRcdCQoZWwpLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICd0cnVlJyk7XG5cdFx0XHRcdCQoZWwpLnNldEF0dHJpYnV0ZSgndGl0bGUnLCBDb250YW8ubGFuZy5jb2xsYXBzZSk7XG5cdFx0XHRcdG5ldyBSZXF1ZXN0LkNvbnRhbyh7IHVybDogdXJsIH0pLnBvc3QoeydhY3Rpb24nOid0b2dnbGVOYXZpZ2F0aW9uJywgJ2lkJzppZCwgJ3N0YXRlJzoxLCAnUkVRVUVTVF9UT0tFTic6Q29udGFvLnJlcXVlc3RfdG9rZW59KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBhcmVudC5hZGRDbGFzcygnY29sbGFwc2VkJyk7XG5cdFx0XHRcdCQoZWwpLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICdmYWxzZScpO1xuXHRcdFx0XHQkKGVsKS5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgQ29udGFvLmxhbmcuZXhwYW5kKTtcblx0XHRcdFx0bmV3IFJlcXVlc3QuQ29udGFvKHsgdXJsOiB1cmwgfSkucG9zdCh7J2FjdGlvbic6J3RvZ2dsZU5hdmlnYXRpb24nLCAnaWQnOmlkLCAnc3RhdGUnOjAsICdSRVFVRVNUX1RPS0VOJzpDb250YW8ucmVxdWVzdF90b2tlbn0pO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHQvKipcblx0ICogVG9nZ2xlIHRoZSBwYWdlIHRyZWVcblx0ICpcblx0ICogQHBhcmFtIHtvYmplY3R9IGVsICAgIFRoZSBET00gZWxlbWVudFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWQgICAgVGhlIElEIG9mIHRoZSB0YXJnZXQgZWxlbWVudFxuXHQgKiBAcGFyYW0ge2ludH0gICAgbGV2ZWwgVGhlIGluZGVudGF0aW9uIGxldmVsXG5cdCAqIEBwYXJhbSB7aW50fSAgICBtb2RlICBUaGUgaW5zZXJ0IG1vZGVcblx0ICpcblx0ICogQHJldHVybnMge2Jvb2xlYW59XG5cdCAqL1xuXHR0b2dnbGVTdHJ1Y3R1cmU6IGZ1bmN0aW9uKGVsLCBpZCwgbGV2ZWwsIG1vZGUpIHtcblx0XHRpZiAod2luZG93LmNvbnNvbGUpIHtcblx0XHRcdGNvbnNvbGUud2FybignQWpheFJlcXVlc3QudG9nZ2xlU3RydWN0dXJlKCkgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSB0aGUgc3RpbXVsdXMgY29udHJvbGxlciBpbnN0ZWFkLicpO1xuXHRcdH1cblxuXHRcdHZhciBpdGVtID0gJChpZCk7XG5cblx0XHRpZiAoaXRlbSkge1xuXHRcdFx0aWYgKGl0ZW0uZ2V0U3R5bGUoJ2Rpc3BsYXknKSA9PSAnbm9uZScpIHtcblx0XHRcdFx0aXRlbS5zZXRTdHlsZSgnZGlzcGxheScsIG51bGwpO1xuXG5cdFx0XHRcdCQoZWwpLmFkZENsYXNzKCdmb2xkYWJsZS0tb3BlbicpO1xuXHRcdFx0XHQkKGVsKS5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgQ29udGFvLmxhbmcuY29sbGFwc2UpO1xuXG5cdFx0XHRcdG5ldyBSZXF1ZXN0LkNvbnRhbyh7ZmllbGQ6ZWx9KS5wb3N0KHsnYWN0aW9uJzondG9nZ2xlU3RydWN0dXJlJywgJ2lkJzppZCwgJ3N0YXRlJzoxLCAnUkVRVUVTVF9UT0tFTic6Q29udGFvLnJlcXVlc3RfdG9rZW59KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGl0ZW0uc2V0U3R5bGUoJ2Rpc3BsYXknLCAnbm9uZScpO1xuXG5cdFx0XHRcdCQoZWwpLnJlbW92ZUNsYXNzKCdmb2xkYWJsZS0tb3BlbicpO1xuXHRcdFx0XHQkKGVsKS5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgQ29udGFvLmxhbmcuZXhwYW5kKTtcblxuXHRcdFx0XHRuZXcgUmVxdWVzdC5Db250YW8oe2ZpZWxkOmVsfSkucG9zdCh7J2FjdGlvbic6J3RvZ2dsZVN0cnVjdHVyZScsICdpZCc6aWQsICdzdGF0ZSc6MCwgJ1JFUVVFU1RfVE9LRU4nOkNvbnRhby5yZXF1ZXN0X3Rva2VufSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0bmV3IFJlcXVlc3QuQ29udGFvKHtcblx0XHRcdGZpZWxkOiBlbCxcblx0XHRcdGV2YWxTY3JpcHRzOiB0cnVlLFxuXHRcdFx0b25SZXF1ZXN0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0QWpheFJlcXVlc3QuZGlzcGxheUJveChDb250YW8ubGFuZy5sb2FkaW5nICsgJyDigKYnKTtcblx0XHRcdH0sXG5cdFx0XHRvblN1Y2Nlc3M6IGZ1bmN0aW9uKHR4dCkge1xuXHRcdFx0XHR2YXIgbGkgPSBuZXcgRWxlbWVudCgnbGknLCB7XG5cdFx0XHRcdFx0J2lkJzogaWQsXG5cdFx0XHRcdFx0J2NsYXNzJzogJ3BhcmVudCcsXG5cdFx0XHRcdFx0J3N0eWxlcyc6IHtcblx0XHRcdFx0XHRcdCdkaXNwbGF5JzogJ2lubGluZSdcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdG5ldyBFbGVtZW50KCd1bCcsIHtcblx0XHRcdFx0XHQnY2xhc3MnOiAnbGV2ZWxfJyArIGxldmVsLFxuXHRcdFx0XHRcdCdodG1sJzogdHh0XG5cdFx0XHRcdH0pLmluamVjdChsaSwgJ2JvdHRvbScpO1xuXG5cdFx0XHRcdGlmIChtb2RlID09IDUpIHtcblx0XHRcdFx0XHRsaS5pbmplY3QoJChlbCkuZ2V0UGFyZW50KCdsaScpLCAnYWZ0ZXInKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YXIgZm9sZGVyID0gZmFsc2UsXG5cdFx0XHRcdFx0XHRwYXJlbnQgPSAkKGVsKS5nZXRQYXJlbnQoJ2xpJyksXG5cdFx0XHRcdFx0XHRuZXh0O1xuXG5cdFx0XHRcdFx0d2hpbGUgKHR5cGVPZihwYXJlbnQpID09ICdlbGVtZW50JyAmJiAobmV4dCA9IHBhcmVudC5nZXROZXh0KCdsaScpKSkge1xuXHRcdFx0XHRcdFx0cGFyZW50ID0gbmV4dDtcblx0XHRcdFx0XHRcdGlmIChwYXJlbnQuaGFzQ2xhc3MoJ3RsX2ZvbGRlcicpKSB7XG5cdFx0XHRcdFx0XHRcdGZvbGRlciA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGlmIChmb2xkZXIpIHtcblx0XHRcdFx0XHRcdGxpLmluamVjdChwYXJlbnQsICdiZWZvcmUnKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bGkuaW5qZWN0KHBhcmVudCwgJ2FmdGVyJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gVXBkYXRlIHRoZSByZWZlcmVyIElEXG5cdFx0XHRcdGxpLmdldEVsZW1lbnRzKCdhJykuZWFjaChmdW5jdGlvbihlbCkge1xuXHRcdFx0XHRcdGVsLmhyZWYgPSBlbC5ocmVmLnJlcGxhY2UoLyZyZWY9W2EtZjAtOV0rLywgJyZyZWY9JyArIENvbnRhby5yZWZlcmVyX2lkKTtcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0JChlbCkuYWRkQ2xhc3MoJ2ZvbGRhYmxlLS1vcGVuJyk7XG5cdFx0XHRcdCQoZWwpLnNldEF0dHJpYnV0ZSgndGl0bGUnLCBDb250YW8ubGFuZy5jb2xsYXBzZSk7XG5cblx0XHRcdFx0d2luZG93LmZpcmVFdmVudCgnc3RydWN0dXJlJyk7XG5cdFx0XHRcdEFqYXhSZXF1ZXN0LmhpZGVCb3goKTtcblxuXHRcdFx0XHQvLyBIT09LXG5cdFx0XHRcdHdpbmRvdy5maXJlRXZlbnQoJ2FqYXhfY2hhbmdlJyk7XG4gICBcdFx0XHR9XG5cdFx0fSkucG9zdCh7J2FjdGlvbic6J2xvYWRTdHJ1Y3R1cmUnLCAnaWQnOmlkLCAnbGV2ZWwnOmxldmVsLCAnc3RhdGUnOjEsICdSRVFVRVNUX1RPS0VOJzpDb250YW8ucmVxdWVzdF90b2tlbn0pO1xuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBUb2dnbGUgdGhlIGZpbGUgdHJlZVxuXHQgKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gZWwgICAgIFRoZSBET00gZWxlbWVudFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWQgICAgIFRoZSBJRCBvZiB0aGUgdGFyZ2V0IGVsZW1lbnRcblx0ICogQHBhcmFtIHtzdHJpbmd9IGZvbGRlciBUaGUgZm9sZGVyJ3MgcGF0aFxuXHQgKiBAcGFyYW0ge2ludH0gICAgbGV2ZWwgIFRoZSBpbmRlbnRhdGlvbiBsZXZlbFxuXHQgKlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdHRvZ2dsZUZpbGVNYW5hZ2VyOiBmdW5jdGlvbihlbCwgaWQsIGZvbGRlciwgbGV2ZWwpIHtcblx0XHRpZiAod2luZG93LmNvbnNvbGUpIHtcblx0XHRcdGNvbnNvbGUud2FybignQWpheFJlcXVlc3QudG9nZ2xlRmlsZU1hbmFnZXIoKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIHRoZSBzdGltdWx1cyBjb250cm9sbGVyIGluc3RlYWQuJyk7XG5cdFx0fVxuXG5cdFx0dmFyIGl0ZW0gPSAkKGlkKTtcblxuXHRcdGlmIChpdGVtKSB7XG5cdFx0XHRpZiAoaXRlbS5nZXRTdHlsZSgnZGlzcGxheScpID09ICdub25lJykge1xuXHRcdFx0XHRpdGVtLnNldFN0eWxlKCdkaXNwbGF5JywgbnVsbCk7XG5cblx0XHRcdFx0JChlbCkuYWRkQ2xhc3MoJ2ZvbGRhYmxlLS1vcGVuJyk7XG5cdFx0XHRcdCQoZWwpLnNldEF0dHJpYnV0ZSgndGl0bGUnLCBDb250YW8ubGFuZy5jb2xsYXBzZSk7XG5cblx0XHRcdFx0bmV3IFJlcXVlc3QuQ29udGFvKHtmaWVsZDplbH0pLnBvc3QoeydhY3Rpb24nOid0b2dnbGVGaWxlTWFuYWdlcicsICdpZCc6aWQsICdzdGF0ZSc6MSwgJ1JFUVVFU1RfVE9LRU4nOkNvbnRhby5yZXF1ZXN0X3Rva2VufSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpdGVtLnNldFN0eWxlKCdkaXNwbGF5JywgJ25vbmUnKTtcblxuXHRcdFx0XHQkKGVsKS5yZW1vdmVDbGFzcygnZm9sZGFibGUtLW9wZW4nKTtcblx0XHRcdFx0JChlbCkuc2V0QXR0cmlidXRlKCd0aXRsZScsIENvbnRhby5sYW5nLmV4cGFuZCk7XG5cblx0XHRcdFx0bmV3IFJlcXVlc3QuQ29udGFvKHtmaWVsZDplbH0pLnBvc3QoeydhY3Rpb24nOid0b2dnbGVGaWxlTWFuYWdlcicsICdpZCc6aWQsICdzdGF0ZSc6MCwgJ1JFUVVFU1RfVE9LRU4nOkNvbnRhby5yZXF1ZXN0X3Rva2VufSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0bmV3IFJlcXVlc3QuQ29udGFvKHtcblx0XHRcdGZpZWxkOiBlbCxcblx0XHRcdGV2YWxTY3JpcHRzOiB0cnVlLFxuXHRcdFx0b25SZXF1ZXN0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0QWpheFJlcXVlc3QuZGlzcGxheUJveChDb250YW8ubGFuZy5sb2FkaW5nICsgJyDigKYnKTtcblx0XHRcdH0sXG5cdFx0XHRvblN1Y2Nlc3M6IGZ1bmN0aW9uKHR4dCkge1xuXHRcdFx0XHR2YXIgbGkgPSBuZXcgRWxlbWVudCgnbGknLCB7XG5cdFx0XHRcdFx0J2lkJzogaWQsXG5cdFx0XHRcdFx0J2NsYXNzJzogJ3BhcmVudCcsXG5cdFx0XHRcdFx0J3N0eWxlcyc6IHtcblx0XHRcdFx0XHRcdCdkaXNwbGF5JzogJ2lubGluZSdcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdG5ldyBFbGVtZW50KCd1bCcsIHtcblx0XHRcdFx0XHQnY2xhc3MnOiAnbGV2ZWxfJyArIGxldmVsLFxuXHRcdFx0XHRcdCdodG1sJzogdHh0XG5cdFx0XHRcdH0pLmluamVjdChsaSwgJ2JvdHRvbScpO1xuXG5cdFx0XHRcdGxpLmluamVjdCgkKGVsKS5nZXRQYXJlbnQoJ2xpJyksICdhZnRlcicpO1xuXG5cdFx0XHRcdC8vIFVwZGF0ZSB0aGUgcmVmZXJlciBJRFxuXHRcdFx0XHRsaS5nZXRFbGVtZW50cygnYScpLmVhY2goZnVuY3Rpb24oZWwpIHtcblx0XHRcdFx0XHRlbC5ocmVmID0gZWwuaHJlZi5yZXBsYWNlKC8mcmVmPVthLWYwLTldKy8sICcmcmVmPScgKyBDb250YW8ucmVmZXJlcl9pZCk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdCQoZWwpLmFkZENsYXNzKCdmb2xkYWJsZS0tb3BlbicpO1xuXHRcdFx0XHQkKGVsKS5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgQ29udGFvLmxhbmcuY29sbGFwc2UpO1xuXG5cdFx0XHRcdEFqYXhSZXF1ZXN0LmhpZGVCb3goKTtcblxuXHRcdFx0XHQvLyBIT09LXG5cdFx0XHRcdHdpbmRvdy5maXJlRXZlbnQoJ2FqYXhfY2hhbmdlJyk7XG4gICBcdFx0XHR9XG5cdFx0fSkucG9zdCh7J2FjdGlvbic6J2xvYWRGaWxlTWFuYWdlcicsICdpZCc6aWQsICdsZXZlbCc6bGV2ZWwsICdmb2xkZXInOmZvbGRlciwgJ3N0YXRlJzoxLCAnUkVRVUVTVF9UT0tFTic6Q29udGFvLnJlcXVlc3RfdG9rZW59KTtcblxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHQvKipcblx0ICogVG9nZ2xlIHN1Yi1wYWxldHRlcyBpbiBlZGl0IG1vZGVcblx0ICpcblx0ICogQHBhcmFtIHtvYmplY3R9IGVsICAgIFRoZSBET00gZWxlbWVudFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWQgICAgVGhlIElEIG9mIHRoZSB0YXJnZXQgZWxlbWVudFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgVGhlIGZpZWxkIG5hbWVcblx0ICovXG5cdHRvZ2dsZVN1YnBhbGV0dGU6IGZ1bmN0aW9uKGVsLCBpZCwgZmllbGQpIHtcblx0XHR2YXIgaXRlbSA9ICQoaWQpO1xuXG5cdFx0aWYgKGl0ZW0pIHtcblx0XHRcdGlmICghZWwudmFsdWUpIHtcblx0XHRcdFx0ZWwudmFsdWUgPSAxO1xuXHRcdFx0XHRlbC5jaGVja2VkID0gJ2NoZWNrZWQnO1xuXHRcdFx0XHRpdGVtLnNldFN0eWxlKCdkaXNwbGF5JywgbnVsbCk7XG5cdFx0XHRcdGl0ZW0uZ2V0RWxlbWVudHMoJ1tkYXRhLXJlcXVpcmVkXScpLmVhY2goZnVuY3Rpb24oZWwpIHtcblx0XHRcdFx0XHRlbC5zZXQoJ3JlcXVpcmVkJywgJycpLnNldCgnZGF0YS1yZXF1aXJlZCcsIG51bGwpO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0bmV3IFJlcXVlc3QuQ29udGFvKHtmaWVsZDogZWwsIG9uU3VjY2Vzczp1cGRhdGVWZXJzaW9uTnVtYmVyfSkucG9zdCh7J2FjdGlvbic6J3RvZ2dsZVN1YnBhbGV0dGUnLCAnaWQnOmlkLCAnZmllbGQnOmZpZWxkLCAnc3RhdGUnOjEsICdSRVFVRVNUX1RPS0VOJzpDb250YW8ucmVxdWVzdF90b2tlbn0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWwudmFsdWUgPSAnJztcblx0XHRcdFx0ZWwuY2hlY2tlZCA9ICcnO1xuXHRcdFx0XHRpdGVtLnNldFN0eWxlKCdkaXNwbGF5JywgJ25vbmUnKTtcblx0XHRcdFx0aXRlbS5nZXRFbGVtZW50cygnW3JlcXVpcmVkXScpLmVhY2goZnVuY3Rpb24oZWwpIHtcblx0XHRcdFx0XHRlbC5zZXQoJ3JlcXVpcmVkJywgbnVsbCkuc2V0KCdkYXRhLXJlcXVpcmVkJywgJycpO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0bmV3IFJlcXVlc3QuQ29udGFvKHtmaWVsZDogZWwsIG9uU3VjY2Vzczp1cGRhdGVWZXJzaW9uTnVtYmVyfSkucG9zdCh7J2FjdGlvbic6J3RvZ2dsZVN1YnBhbGV0dGUnLCAnaWQnOmlkLCAnZmllbGQnOmZpZWxkLCAnc3RhdGUnOjAsICdSRVFVRVNUX1RPS0VOJzpDb250YW8ucmVxdWVzdF90b2tlbn0pO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdG5ldyBSZXF1ZXN0LkNvbnRhbyh7XG5cdFx0XHRmaWVsZDogZWwsXG5cdFx0XHRldmFsU2NyaXB0czogZmFsc2UsXG5cdFx0XHRvblJlcXVlc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRBamF4UmVxdWVzdC5kaXNwbGF5Qm94KENvbnRhby5sYW5nLmxvYWRpbmcgKyAnIOKApicpO1xuXHRcdFx0fSxcblx0XHRcdG9uU3VjY2VzczogZnVuY3Rpb24odHh0LCBqc29uKSB7XG5cdFx0XHRcdHZhciBkaXYgPSBuZXcgRWxlbWVudCgnZGl2Jywge1xuXHRcdFx0XHRcdCdpZCc6IGlkLFxuXHRcdFx0XHRcdCdjbGFzcyc6ICdzdWJwYWwgd2lkZ2V0LWdyb3VwJyxcblx0XHRcdFx0XHQnaHRtbCc6IHR4dFxuXHRcdFx0XHR9KS5pbmplY3QoJChlbCkuZ2V0UGFyZW50KCdkaXYnKS5nZXRQYXJlbnQoJ2RpdicpLCAnYWZ0ZXInKTtcblxuXHRcdFx0XHQvLyBFeGVjdXRlIHNjcmlwdHMgYWZ0ZXIgdGhlIERPTSBoYXMgYmVlbiB1cGRhdGVkXG5cdFx0XHRcdGlmIChqc29uLmphdmFzY3JpcHQpIHtcblxuXHRcdFx0XHRcdC8vIFVzZSBBc3NldC5qYXZhc2NyaXB0KCkgaW5zdGVhZCBvZiBkb2N1bWVudC53cml0ZSgpIHRvIGxvYWQgYVxuXHRcdFx0XHRcdC8vIEphdmFTY3JpcHQgZmlsZSBhbmQgcmUtZXhlY3V0ZSB0aGUgY29kZSBhZnRlciBpdCBoYXMgYmVlbiBsb2FkZWRcblx0XHRcdFx0XHRkb2N1bWVudC53cml0ZSA9IGZ1bmN0aW9uKHN0cikge1xuXHRcdFx0XHRcdFx0dmFyIHNyYyA9ICcnO1xuXHRcdFx0XHRcdFx0c3RyLnJlcGxhY2UoLzxzY3JpcHQgc3JjPVwiKFteXCJdKylcIi9pLCBmdW5jdGlvbihhbGwsIG1hdGNoKXtcblx0XHRcdFx0XHRcdFx0c3JjID0gbWF0Y2g7XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdHNyYyAmJiBBc3NldC5qYXZhc2NyaXB0KHNyYywge1xuXHRcdFx0XHRcdFx0XHRvbkxvYWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdEJyb3dzZXIuZXhlYyhqc29uLmphdmFzY3JpcHQpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0QnJvd3Nlci5leGVjKGpzb24uamF2YXNjcmlwdCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRlbC52YWx1ZSA9IDE7XG5cdFx0XHRcdGVsLmNoZWNrZWQgPSAnY2hlY2tlZCc7XG5cblx0XHRcdFx0Ly8gVXBkYXRlIHRoZSByZWZlcmVyIElEXG5cdFx0XHRcdGRpdi5nZXRFbGVtZW50cygnYScpLmVhY2goZnVuY3Rpb24oZWwpIHtcblx0XHRcdFx0XHRlbC5ocmVmID0gZWwuaHJlZi5yZXBsYWNlKC8mcmVmPVthLWYwLTldKy8sICcmcmVmPScgKyBDb250YW8ucmVmZXJlcl9pZCk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdHVwZGF0ZVZlcnNpb25OdW1iZXIodHh0KTtcblxuXHRcdFx0XHRBamF4UmVxdWVzdC5oaWRlQm94KCk7XG5cdFx0XHRcdHdpbmRvdy5maXJlRXZlbnQoJ2FqYXhfY2hhbmdlJyk7XG5cdFx0XHR9XG5cdFx0fSkucG9zdCh7J2FjdGlvbic6J3RvZ2dsZVN1YnBhbGV0dGUnLCAnaWQnOmlkLCAnZmllbGQnOmZpZWxkLCAnbG9hZCc6MSwgJ3N0YXRlJzoxLCAnUkVRVUVTVF9UT0tFTic6Q29udGFvLnJlcXVlc3RfdG9rZW59KTtcblxuXHRcdGZ1bmN0aW9uIHVwZGF0ZVZlcnNpb25OdW1iZXIoaHRtbCkge1xuXHRcdFx0dmFyIGZpZWxkcyA9IGVsLmZvcm0uZWxlbWVudHMuVkVSU0lPTl9OVU1CRVIgfHwgW107XG5cdFx0XHRpZiAoIWZpZWxkcy5mb3JFYWNoKSB7XG5cdFx0XHRcdGZpZWxkcyA9IFtmaWVsZHNdO1xuXHRcdFx0fVxuXHRcdFx0ZmllbGRzLmZvckVhY2goZnVuY3Rpb24oZmllbGQpIHtcblx0XHRcdFx0ZmllbGQudmFsdWUgPSAvPGlucHV0XFxzK1tePl0qP25hbWU9XCJWRVJTSU9OX05VTUJFUlwiXFxzK1tePl0qP3ZhbHVlPVwiKFteXCJdKilcIi9pLmV4ZWMoaHRtbClbMV07XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIFRvZ2dsZSB0aGUgc3RhdGUgb2YgYSBjaGVja2JveCBmaWVsZFxuXHQgKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gIGVsICAgICAgIFRoZSBET00gZWxlbWVudFxuXHQgKiBAcGFyYW0ge2Jvb2xlYW59IHJvd0ljb24gIFdoZXRoZXIgdGhlIHJvdyBpY29uIHNob3VsZCBiZSB0b2dnbGVkIGFzIHdlbGxcblx0ICogQHBhcmFtIHtib29sZWFufSBpY29uT25seSBJZiBvbmx5IHRoZSBpY29uIHNob3VsZCBiZSB0b2dnbGVkICh3aXRob3V0IHNlbmRpbmcgYSByZXF1ZXN0KVxuXHQgKlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdHRvZ2dsZUZpZWxkOiBmdW5jdGlvbihlbCwgcm93SWNvbiwgaWNvbk9ubHkgPSBmYWxzZSkge1xuXHRcdHZhciBpbWcgPSBudWxsLFxuXHRcdFx0aW1hZ2VzID0gJChlbCkuZ2V0RWxlbWVudHMoJ2ltZycpLFxuXHRcdFx0cHVibGlzaGVkID0gKGltYWdlc1swXS5nZXQoJ2RhdGEtc3RhdGUnKSA9PSAxKSxcblx0XHRcdGRpdiwgbmV4dCwgcGEsIGxhYmVsO1xuXG5cdFx0aWYgKHJvd0ljb24gJiYgIWljb25Pbmx5KSB7XG5cdFx0XHQvLyBGaW5kIHRoZSBpY29uIGRlcGVuZGluZyBvbiB0aGUgdmlldyAodHJlZSB2aWV3LCBsaXN0IHZpZXcsIHBhcmVudCB2aWV3KVxuXHRcdFx0aWYgKChkaXYgPSBlbC5jbG9zZXN0KCcudGxfcmlnaHQnKSkpIHtcblx0XHRcdFx0aW1nID0gZGl2LmdldFByZXZpb3VzKCdkaXYnKS5nZXRFbGVtZW50cygnaW1nJyk7XG5cdFx0XHR9IGVsc2UgaWYgKChkaXYgPSBlbC5jbG9zZXN0KCcudGxfY29udGVudF9yaWdodCcpKSAmJiAobmV4dCA9IGRpdi5nZXROZXh0KCdkaXYnKSkpIHtcblx0XHRcdFx0aWYgKG5leHQuaGFzQ2xhc3MoJ2N0ZV90eXBlJykpIHtcblx0XHRcdFx0XHRpbWcgPSBuZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChpbWcgPT09IG51bGwpIHsgLy8gbmV3c2xldHRlciByZWNpcGllbnRzXG5cdFx0XHRcdFx0aW1nID0gbmV4dC5nZXRGaXJzdCgnZGl2Lmxpc3RfaWNvbicpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKGVsLmNsb3Nlc3QoJy50bF9saXN0aW5nX2NvbnRhaW5lcicpICYmIGVsLmdldFBhcmVudCgndHInKSkge1xuXHRcdFx0XHRpbWcgPSBlbC5nZXRQYXJlbnQoJ3RkJykuZ2V0UHJldmlvdXMoJ3RkJykuZ2V0Rmlyc3QoJ2Rpdi5saXN0X2ljb24nKTtcblx0XHRcdFx0aWYgKGltZyA9PT0gbnVsbCkgeyAvLyBjb21tZW50c1xuXHRcdFx0XHRcdGltZyA9IGVsLmdldFBhcmVudCgndGQnKS5nZXRQcmV2aW91cygndGQnKS5nZXRFbGVtZW50KCdkaXYuY3RlX3R5cGUnKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoaW1nID09PSBudWxsKSB7IC8vIHNob3dDb2x1bW5zXG5cdFx0XHRcdFx0aW1nID0gZWwuZ2V0UGFyZW50KCd0cicpLmdldEZpcnN0KCd0ZCcpLmdldEVsZW1lbnQoJ2Rpdi5saXN0X2ljb25fbmV3Jyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2hhbmdlIHRoZSByb3cgaWNvblxuXHRcdFx0aWYgKGltZyAhPT0gbnVsbCkge1xuXHRcdFx0XHQvLyBUcmVlIHZpZXdcblx0XHRcdFx0aWYgKCEoaW1nIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpICYmIGltZy5mb3JFYWNoKSB7XG5cdFx0XHRcdFx0aW1nLmZvckVhY2goKGltZykgPT4ge1xuXHRcdFx0XHRcdFx0aWYgKGltZyBpbnN0YW5jZW9mIEhUTUxJbWFnZUVsZW1lbnQpIHtcblx0XHRcdFx0XHRcdFx0aWYgKCFpbWcuZ2V0UGFyZW50KCd1bC50bF9saXN0aW5nJykuaGFzQ2xhc3MoJ3RsX3RyZWVfeHRuZCcpKSB7XG5cdFx0XHRcdFx0XHRcdFx0cGEgPSBpbWcuZ2V0UGFyZW50KCdhJyk7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAocGEgJiYgcGEuaHJlZi5pbmRleE9mKCdjb250YW8vcHJldmlldycpID09IC0xKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAobmV4dCA9IHBhLmdldE5leHQoJ2EnKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpbWcgPSBuZXh0LmdldEVsZW1lbnQoJ2ltZycpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0aW1nID0gbmV3IEVsZW1lbnQoJ2ltZycpOyAvLyBubyBpY29ucyB1c2VkIChzZWUgIzIyODYpXG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Y29uc3QgbmV3U3JjID0gIXB1Ymxpc2hlZCA/IGltZy5nZXQoJ2RhdGEtaWNvbicpIDogaW1nLmdldCgnZGF0YS1pY29uLWRpc2FibGVkJyk7XG5cdFx0XHRcdFx0XHRcdGltZy5zcmMgPSAoaW1nLnNyYy5pbmNsdWRlcygnLycpICYmICFuZXdTcmMuaW5jbHVkZXMoJy8nKSkgPyBpbWcuc3JjLnNsaWNlKDAsIGltZy5zcmMubGFzdEluZGV4T2YoJy8nKSArIDEpICsgbmV3U3JjIDogbmV3U3JjO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gUGFyZW50IHZpZXdcblx0XHRcdFx0ZWxzZSBpZiAoaW1nLmhhc0NsYXNzKCdjdGVfdHlwZScpKSB7XG5cdFx0XHRcdFx0aWYgKCFwdWJsaXNoZWQpIHtcblx0XHRcdFx0XHRcdGltZy5hZGRDbGFzcygncHVibGlzaGVkJyk7XG5cdFx0XHRcdFx0XHRpbWcucmVtb3ZlQ2xhc3MoJ3VucHVibGlzaGVkJyk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGltZy5hZGRDbGFzcygndW5wdWJsaXNoZWQnKTtcblx0XHRcdFx0XHRcdGltZy5yZW1vdmVDbGFzcygncHVibGlzaGVkJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdC8vIExpc3Qgdmlld1xuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRpbWcuc2V0U3R5bGUoJ2JhY2tncm91bmQtaW1hZ2UnLCAndXJsKCcgKyAoIXB1Ymxpc2hlZCA/IGltZy5nZXQoJ2RhdGEtaWNvbicpIDogaW1nLmdldCgnZGF0YS1pY29uLWRpc2FibGVkJykpICsgJyknKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNlbmQgcmVxdWVzdFxuXHRcdGltYWdlcy5mb3JFYWNoKGZ1bmN0aW9uKGltYWdlKSB7XG5cdFx0XHRjb25zdCBuZXdTcmMgPSAhcHVibGlzaGVkID8gaW1hZ2UuZ2V0KCdkYXRhLWljb24nKSA6IGltYWdlLmdldCgnZGF0YS1pY29uLWRpc2FibGVkJyk7XG5cdFx0XHRpbWFnZS5zcmMgPSAoaW1hZ2Uuc3JjLmluY2x1ZGVzKCcvJykgJiYgIW5ld1NyYy5pbmNsdWRlcygnLycpKSA/IGltYWdlLnNyYy5zbGljZSgwLCBpbWFnZS5zcmMubGFzdEluZGV4T2YoJy8nKSArIDEpICsgbmV3U3JjIDogbmV3U3JjO1xuXHRcdFx0aW1hZ2UuYWx0ID0gbGFiZWwgPSAhcHVibGlzaGVkID8gaW1hZ2UuZ2V0KCdkYXRhLWFsdCcpIDogaW1hZ2UuZ2V0KCdkYXRhLWFsdC1kaXNhYmxlZCcpO1xuXHRcdFx0aW1hZ2Uuc2V0KCdkYXRhLXN0YXRlJywgIXB1Ymxpc2hlZCA/IDEgOiAwKTtcblx0XHR9KTtcblxuXHRcdGlmICghcHVibGlzaGVkICYmICQoZWwpLmdldCgnZGF0YS10aXRsZScpKSB7XG5cdFx0XHRlbC50aXRsZSA9IGxhYmVsID0gJChlbCkuZ2V0KCdkYXRhLXRpdGxlJyk7XG5cdFx0fSBlbHNlIGlmIChwdWJsaXNoZWQgJiYgJChlbCkuZ2V0KCdkYXRhLXRpdGxlLWRpc2FibGVkJykpIHtcblx0XHRcdGVsLnRpdGxlID0gbGFiZWwgPSAkKGVsKS5nZXQoJ2RhdGEtdGl0bGUtZGlzYWJsZWQnKTtcblx0XHR9XG5cblx0XHRpZiAoIXB1Ymxpc2hlZCAmJiAkKGVsKS5nZXQoJ2RhdGEtbGFiZWwnKSkge1xuXHRcdFx0bGFiZWwgPSAkKGVsKS5nZXQoJ2RhdGEtbGFiZWwnKTtcblx0XHR9IGVsc2UgaWYgKHB1Ymxpc2hlZCAmJiAkKGVsKS5nZXQoJ2RhdGEtbGFiZWwtZGlzYWJsZWQnKSkge1xuXHRcdFx0bGFiZWwgPSAkKGVsKS5nZXQoJ2RhdGEtbGFiZWwtZGlzYWJsZWQnKTtcblx0XHR9XG5cblx0XHRpZiAobGFiZWwpIHtcblx0XHRcdGVsLmNoaWxkTm9kZXMuZm9yRWFjaCgoY2hpbGQpID0+IHtcblx0XHRcdFx0aWYgKGNoaWxkIGluc3RhbmNlb2YgVGV4dCAmJiBjaGlsZC5ub2RlVmFsdWUudHJpbSgpKSB7XG5cdFx0XHRcdFx0Y2hpbGQucmVwbGFjZVdpdGgobmV3IFRleHQobGFiZWwpKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0aWYgKCFpY29uT25seSkge1xuXHRcdFx0ZG9jdW1lbnQuYm9keS5xdWVyeVNlbGVjdG9yQWxsKGBhW2hyZWY9XCIke2VsLmdldEF0dHJpYnV0ZSgnaHJlZicpfVwiXWApLmZvckVhY2goKGNsb25lKSA9PiB7XG5cdFx0XHRcdGlmIChlbCAhPT0gY2xvbmUpIHtcblx0XHRcdFx0XHRBamF4UmVxdWVzdC50b2dnbGVGaWVsZChjbG9uZSwgcm93SWNvbiwgdHJ1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRuZXcgUmVxdWVzdC5Db250YW8oeyd1cmwnOmVsLmhyZWYsICdmb2xsb3dSZWRpcmVjdHMnOmZhbHNlfSkuZ2V0KCk7XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIGZhbHNlIHRvIHN0b3AgdGhlIGNsaWNrIGV2ZW50IG9uIGxpbmtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFRvZ2dsZSBhIGdyb3VwIG9mIGEgbXVsdGktY2hlY2tib3ggZmllbGRcblx0ICpcblx0ICogQHBhcmFtIHtvYmplY3R9IGVsIFRoZSBET00gZWxlbWVudFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIElEIG9mIHRoZSB0YXJnZXQgZWxlbWVudFxuXHQgKlxuXHQgKiBAcmV0dXJucyB7Ym9vbGVhbn1cblx0ICovXG5cdHRvZ2dsZUNoZWNrYm94R3JvdXA6IGZ1bmN0aW9uKGVsLCBpZCkge1xuXHRcdHZhciBpdGVtID0gJChpZCk7XG5cblx0XHRpZiAoaXRlbSkge1xuXHRcdFx0aWYgKGl0ZW0uZ2V0U3R5bGUoJ2Rpc3BsYXknKSA9PSAnbm9uZScpIHtcblx0XHRcdFx0aXRlbS5zZXRTdHlsZSgnZGlzcGxheScsIG51bGwpO1xuXHRcdFx0XHQkKGVsKS5hZGRDbGFzcygnZm9sZGFibGUtLW9wZW4nKTtcblxuXHRcdFx0XHRuZXcgUmVxdWVzdC5Db250YW8oKS5wb3N0KHsnYWN0aW9uJzondG9nZ2xlQ2hlY2tib3hHcm91cCcsICdpZCc6aWQsICdzdGF0ZSc6MSwgJ1JFUVVFU1RfVE9LRU4nOkNvbnRhby5yZXF1ZXN0X3Rva2VufSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpdGVtLnNldFN0eWxlKCdkaXNwbGF5JywgJ25vbmUnKTtcblx0XHRcdFx0JChlbCkucmVtb3ZlQ2xhc3MoJ2ZvbGRhYmxlLS1vcGVuJyk7XG5cblx0XHRcdFx0bmV3IFJlcXVlc3QuQ29udGFvKCkucG9zdCh7J2FjdGlvbic6J3RvZ2dsZUNoZWNrYm94R3JvdXAnLCAnaWQnOmlkLCAnc3RhdGUnOjAsICdSRVFVRVNUX1RPS0VOJzpDb250YW8ucmVxdWVzdF90b2tlbn0pO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBEaXNwbGF5IHRoZSBcImxvYWRpbmcgZGF0YVwiIG1lc3NhZ2Vcblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdGV4dFxuXHQgKi9cblx0ZGlzcGxheUJveDogZnVuY3Rpb24obWVzc2FnZSkge1xuXHRcdHZhciBib3ggPSAkKCd0bF9hamF4Qm94JyksXG5cdFx0XHRvdmVybGF5ID0gJCgndGxfYWpheE92ZXJsYXknKSxcblx0XHRcdHNjcm9sbCA9IHdpbmRvdy5nZXRTY3JvbGwoKTtcblxuXHRcdGlmIChvdmVybGF5ID09PSBudWxsKSB7XG5cdFx0XHRvdmVybGF5ID0gbmV3IEVsZW1lbnQoJ2RpdicsIHtcblx0XHRcdFx0J2lkJzogJ3RsX2FqYXhPdmVybGF5J1xuXHRcdFx0fSkuaW5qZWN0KCQoZG9jdW1lbnQuYm9keSksICdib3R0b20nKTtcblx0XHR9XG5cblx0XHRvdmVybGF5LnNldCh7XG5cdFx0XHQnc3R5bGVzJzoge1xuXHRcdFx0XHQnZGlzcGxheSc6ICdibG9jaycsXG5cdFx0XHRcdCd0b3AnOiBzY3JvbGwueSArICdweCdcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGlmIChib3ggPT09IG51bGwpIHtcblx0XHRcdGJveCA9IG5ldyBFbGVtZW50KCdkaXYnLCB7XG5cdFx0XHRcdCdpZCc6ICd0bF9hamF4Qm94J1xuXHRcdFx0fSkuaW5qZWN0KCQoZG9jdW1lbnQuYm9keSksICdib3R0b20nKTtcblx0XHR9XG5cblx0XHRib3guc2V0KHtcblx0XHRcdCdodG1sJzogbWVzc2FnZSxcblx0XHRcdCdzdHlsZXMnOiB7XG5cdFx0XHRcdCdkaXNwbGF5JzogJ2Jsb2NrJyxcblx0XHRcdFx0J3RvcCc6IChzY3JvbGwueSArIDEwMCkgKyAncHgnXG5cdFx0XHR9XG5cdFx0fSlcblx0fSxcblxuXHQvKipcblx0ICogSGlkZSB0aGUgXCJsb2FkaW5nIGRhdGFcIiBtZXNzYWdlXG5cdCAqL1xuXHRoaWRlQm94OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgYm94ID0gJCgndGxfYWpheEJveCcpLFxuXHRcdFx0b3ZlcmxheSA9ICQoJ3RsX2FqYXhPdmVybGF5Jyk7XG5cblx0XHRpZiAob3ZlcmxheSkge1xuXHRcdFx0b3ZlcmxheS5zZXRTdHlsZSgnZGlzcGxheScsICdub25lJyk7XG5cdFx0fVxuXG5cdFx0aWYgKGJveCkge1xuXHRcdFx0Ym94LnNldFN0eWxlKCdkaXNwbGF5JywgJ25vbmUnKTtcblx0XHR9XG5cdH1cbn07XG5cbi8qKlxuICogUHJvdmlkZSBtZXRob2RzIHRvIGhhbmRsZSBiYWNrIGVuZCB0YXNrcy5cbiAqXG4gKiBAYXV0aG9yIExlbyBGZXllciA8aHR0cHM6Ly9naXRodWIuY29tL2xlb2ZleWVyPlxuICovXG53aW5kb3cuQmFja2VuZCA9XG57XG5cdC8qKlxuXHQgKiBUaGUgY3VycmVudCBJRFxuXHQgKiBAbWVtYmVyIHsoc3RyaW5nfG51bGwpfVxuXHQgKi9cblx0Y3VycmVudElkOiBudWxsLFxuXG5cdC8qKlxuXHQgKiBUaGUgcG9wdXAgd2luZG93XG5cdCAqIEBtZW1iZXIge29iamVjdH1cblx0ICovXG5cdHBvcHVwV2luZG93OiBudWxsLFxuXG5cdC8qKlxuXHQgKiBUaGUgdGhlbWUgcGF0aFxuXHQgKiBAbWVtYmVyIHtzdHJpbmd9XG5cdCAqL1xuXHR0aGVtZVBhdGg6IENvbnRhby5zY3JpcHRfdXJsICsgJ3N5c3RlbS90aGVtZXMvJyArIENvbnRhby50aGVtZSArICcvJyxcblxuXHQvKipcblx0ICogT3BlbiBhIG1vZGFsIHdpbmRvd1xuXHQgKlxuXHQgKiBAcGFyYW0ge2ludH0gICAgd2lkdGggICBUaGUgd2lkdGggaW4gcGl4ZWxzXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZSAgIFRoZSB3aW5kb3cncyB0aXRsZVxuXHQgKiBAcGFyYW0ge3N0cmluZ30gY29udGVudCBUaGUgd2luZG93J3MgY29udGVudFxuXHQgKi9cblx0b3Blbk1vZGFsV2luZG93OiBmdW5jdGlvbih3aWR0aCwgdGl0bGUsIGNvbnRlbnQpIHtcblx0XHRuZXcgU2ltcGxlTW9kYWwoe1xuXHRcdFx0J3dpZHRoJzogd2lkdGgsXG5cdFx0XHQnaGlkZUZvb3Rlcic6IHRydWUsXG5cdFx0XHQnZHJhZ2dhYmxlJzogZmFsc2UsXG5cdFx0XHQnb3ZlcmxheU9wYWNpdHknOiAuNyxcblx0XHRcdCdvdmVybGF5Q2xpY2snOiBmYWxzZSxcblx0XHRcdCdvblNob3cnOiBmdW5jdGlvbigpIHsgZG9jdW1lbnQuYm9keS5zZXRTdHlsZSgnb3ZlcmZsb3cnLCAnaGlkZGVuJyk7IH0sXG5cdFx0XHQnb25IaWRlJzogZnVuY3Rpb24oKSB7IGRvY3VtZW50LmJvZHkuc2V0U3R5bGUoJ292ZXJmbG93JywgJ2F1dG8nKTsgfVxuXHRcdH0pLnNob3coe1xuXHRcdFx0J3RpdGxlJzogdGl0bGUsXG5cdFx0XHQnY29udGVudHMnOiBjb250ZW50XG5cdFx0fSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIE9wZW4gYW4gaW1hZ2UgaW4gYSBtb2RhbCB3aW5kb3dcblx0ICpcblx0ICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgQW4gb3B0aW9uYWwgb3B0aW9ucyBvYmplY3Rcblx0ICovXG5cdG9wZW5Nb2RhbEltYWdlOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0dmFyIG9wdCA9IG9wdGlvbnMgfHwge30sXG5cdFx0XHRtYXhXaWR0aCA9ICh3aW5kb3cuZ2V0U2l6ZSgpLnggLSAyMCkudG9JbnQoKTtcblx0XHRpZiAoIW9wdC53aWR0aCB8fCBvcHQud2lkdGggPiBtYXhXaWR0aCkgb3B0LndpZHRoID0gTWF0aC5taW4obWF4V2lkdGgsIDkwMCk7XG5cdFx0dmFyIE0gPSBuZXcgU2ltcGxlTW9kYWwoe1xuXHRcdFx0J3dpZHRoJzogb3B0LndpZHRoLFxuXHRcdFx0J2hpZGVGb290ZXInOiB0cnVlLFxuXHRcdFx0J2RyYWdnYWJsZSc6IGZhbHNlLFxuXHRcdFx0J292ZXJsYXlPcGFjaXR5JzogLjcsXG5cdFx0XHQnb25TaG93JzogZnVuY3Rpb24oKSB7IGRvY3VtZW50LmJvZHkuc2V0U3R5bGUoJ292ZXJmbG93JywgJ2hpZGRlbicpOyB9LFxuXHRcdFx0J29uSGlkZSc6IGZ1bmN0aW9uKCkgeyBkb2N1bWVudC5ib2R5LnNldFN0eWxlKCdvdmVyZmxvdycsICdhdXRvJyk7IH1cblx0XHR9KTtcblx0XHRNLnNob3coe1xuXHRcdFx0J3RpdGxlJzogb3B0LnRpdGxlPy5yZXBsYWNlKC8mL2csICcmYW1wOycpLnJlcGxhY2UoLzwvZywgJyZsdDsnKS5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7JykucmVwbGFjZSgvJy9nLCAnJmFwb3M7JyksXG5cdFx0XHQnY29udGVudHMnOiAnPGltZyBzcmM9XCInICsgb3B0LnVybCArICdcIiBhbHQ9XCJcIj4nXG5cdFx0fSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIE9wZW4gYW4gaWZyYW1lIGluIGEgbW9kYWwgd2luZG93XG5cdCAqXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIEFuIG9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0XG5cdCAqL1xuXHRvcGVuTW9kYWxJZnJhbWU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHR2YXIgb3B0ID0gb3B0aW9ucyB8fCB7fSxcblx0XHRcdG1heFdpZHRoID0gKHdpbmRvdy5nZXRTaXplKCkueCAtIDIwKS50b0ludCgpLFxuXHRcdFx0bWF4SGVpZ2h0ID0gKHdpbmRvdy5nZXRTaXplKCkueSAtIDEzNykudG9JbnQoKTtcblx0XHRpZiAoIW9wdC53aWR0aCB8fCBvcHQud2lkdGggPiBtYXhXaWR0aCkgb3B0LndpZHRoID0gTWF0aC5taW4obWF4V2lkdGgsIDkwMCk7XG5cdFx0aWYgKCFvcHQuaGVpZ2h0IHx8IG9wdC5oZWlnaHQgPiBtYXhIZWlnaHQpIG9wdC5oZWlnaHQgPSBtYXhIZWlnaHQ7XG5cdFx0dmFyIE0gPSBuZXcgU2ltcGxlTW9kYWwoe1xuXHRcdFx0J3dpZHRoJzogb3B0LndpZHRoLFxuXHRcdFx0J2hpZGVGb290ZXInOiB0cnVlLFxuXHRcdFx0J2RyYWdnYWJsZSc6IGZhbHNlLFxuXHRcdFx0J292ZXJsYXlPcGFjaXR5JzogLjcsXG5cdFx0XHQnb3ZlcmxheUNsaWNrJzogZmFsc2UsXG5cdFx0XHQnb25TaG93JzogZnVuY3Rpb24oKSB7IGRvY3VtZW50LmJvZHkuc2V0U3R5bGUoJ292ZXJmbG93JywgJ2hpZGRlbicpOyB9LFxuXHRcdFx0J29uSGlkZSc6IGZ1bmN0aW9uKCkgeyBkb2N1bWVudC5ib2R5LnNldFN0eWxlKCdvdmVyZmxvdycsICdhdXRvJyk7IH1cblx0XHR9KTtcblx0XHRNLnNob3coe1xuXHRcdFx0J3RpdGxlJzogb3B0LnRpdGxlPy5yZXBsYWNlKC8mL2csICcmYW1wOycpLnJlcGxhY2UoLzwvZywgJyZsdDsnKS5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7JykucmVwbGFjZSgvJy9nLCAnJmFwb3M7JyksXG5cdFx0XHQnY29udGVudHMnOiAnPGlmcmFtZSBzcmM9XCInICsgb3B0LnVybCArICdcIiB3aWR0aD1cIjEwMCVcIiBoZWlnaHQ9XCInICsgb3B0LmhlaWdodCArICdcIiBmcmFtZWJvcmRlcj1cIjBcIj48L2lmcmFtZT4nLFxuXHRcdFx0J21vZGVsJzogJ21vZGFsJ1xuXHRcdH0pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBPcGVuIGEgc2VsZWN0b3IgcGFnZSBpbiBhIG1vZGFsIHdpbmRvd1xuXHQgKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyBBbiBvcHRpb25hbCBvcHRpb25zIG9iamVjdFxuXHQgKi9cblx0b3Blbk1vZGFsU2VsZWN0b3I6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHR2YXIgb3B0ID0gb3B0aW9ucyB8fCB7fSxcblx0XHRcdG1heFdpZHRoID0gKHdpbmRvdy5nZXRTaXplKCkueCAtIDIwKS50b0ludCgpLFxuXHRcdFx0bWF4SGVpZ2h0ID0gKHdpbmRvdy5nZXRTaXplKCkueSAtIDE5MikudG9JbnQoKTtcblx0XHRpZiAoIW9wdC5pZCkgb3B0LmlkID0gJ3RsX3NlbGVjdCc7XG5cdFx0aWYgKCFvcHQud2lkdGggfHwgb3B0LndpZHRoID4gbWF4V2lkdGgpIG9wdC53aWR0aCA9IE1hdGgubWluKG1heFdpZHRoLCA5MDApO1xuXHRcdGlmICghb3B0LmhlaWdodCB8fCBvcHQuaGVpZ2h0ID4gbWF4SGVpZ2h0KSBvcHQuaGVpZ2h0ID0gbWF4SGVpZ2h0O1xuXHRcdHZhciBNID0gbmV3IFNpbXBsZU1vZGFsKHtcblx0XHRcdCd3aWR0aCc6IG9wdC53aWR0aCxcblx0XHRcdCdkcmFnZ2FibGUnOiBmYWxzZSxcblx0XHRcdCdvdmVybGF5T3BhY2l0eSc6IC43LFxuXHRcdFx0J292ZXJsYXlDbGljayc6IGZhbHNlLFxuXHRcdFx0J29uU2hvdyc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkb2N1bWVudC5ib2R5LnNldFN0eWxlKCdvdmVyZmxvdycsICdoaWRkZW4nKTtcblx0XHRcdFx0ZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoJ2NvbnRhby0tc2ltcGxlLW1vZGFsOnNob3cnKSk7XG5cdFx0XHR9LFxuXHRcdFx0J29uSGlkZSc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkb2N1bWVudC5ib2R5LnNldFN0eWxlKCdvdmVyZmxvdycsICdhdXRvJyk7XG5cdFx0XHRcdGRvY3VtZW50LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KCdjb250YW8tLXNpbXBsZS1tb2RhbDpoaWRlJykpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdE0uYWRkQnV0dG9uKENvbnRhby5sYW5nLmNhbmNlbCwgJ2J0bicsIGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKHRoaXMuYnV0dG9uc1swXS5oYXNDbGFzcygnYnRuLWRpc2FibGVkJykpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5oaWRlKCk7XG5cdFx0fSk7XG5cdFx0TS5hZGRCdXR0b24oQ29udGFvLmxhbmcuYXBwbHksICdidG4gcHJpbWFyeScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKHRoaXMuYnV0dG9uc1sxXS5oYXNDbGFzcygnYnRuLWRpc2FibGVkJykpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGZybSA9IHdpbmRvdy5mcmFtZXNbJ3NpbXBsZS1tb2RhbC1pZnJhbWUnXSxcblx0XHRcdFx0dmFsID0gW10sIHVsLCBpbnAsIGksIHBpY2tlclZhbHVlLCBzSW5kZXg7XG5cdFx0XHRpZiAoZnJtID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0YWxlcnQoJ0NvdWxkIG5vdCBmaW5kIHRoZSBTaW1wbGVNb2RhbCBmcmFtZScpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR1bCA9IGZybS5kb2N1bWVudC5nZXRFbGVtZW50QnlJZChvcHQuaWQpO1xuXHRcdFx0Ly8gTG9hZCB0aGUgcHJldmlvdXMgdmFsdWVzICgjMTgxNilcblx0XHRcdGlmIChwaWNrZXJWYWx1ZSA9IHVsLmdldCgnZGF0YS1waWNrZXItdmFsdWUnKSkge1xuXHRcdFx0XHR2YWwgPSBKU09OLnBhcnNlKHBpY2tlclZhbHVlKTtcblx0XHRcdH1cblx0XHRcdGlucCA9IHVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdpbnB1dCcpO1xuXHRcdFx0Zm9yIChpPTA7IGk8aW5wLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChpbnBbaV0uaWQubWF0Y2goL14oY2hlY2tfYWxsX3xyZXNldF8pLykpIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyBBZGQgY3VycmVudGx5IHNlbGVjdGVkIHZhbHVlLCBvdGhlcndpc2UgcmVtb3ZlICgjMTgxNilcblx0XHRcdFx0c0luZGV4ID0gdmFsLmluZGV4T2YoaW5wW2ldLmdldCgndmFsdWUnKSk7XG5cdFx0XHRcdGlmIChpbnBbaV0uY2hlY2tlZCkge1xuXHRcdFx0XHRcdGlmIChzSW5kZXggPT0gLTEpIHtcblx0XHRcdFx0XHRcdHZhbC5wdXNoKGlucFtpXS5nZXQoJ3ZhbHVlJykpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmIChzSW5kZXggIT0gLTEpIHtcblx0XHRcdFx0XHR2YWwuc3BsaWNlKHNJbmRleCwgMSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdG9wdC5jYWxsYmFjayh1bC5nZXQoJ2RhdGEtdGFibGUnKSwgdmFsKTtcblx0XHRcdHRoaXMuaGlkZSgpO1xuXHRcdH0pO1xuXHRcdE0uc2hvdyh7XG5cdFx0XHQndGl0bGUnOiBvcHQudGl0bGU/LnJlcGxhY2UoLyYvZywgJyZhbXA7JykucmVwbGFjZSgvPC9nLCAnJmx0OycpLnJlcGxhY2UoL1wiL2csICcmcXVvdDsnKS5yZXBsYWNlKC8nL2csICcmYXBvczsnKSxcblx0XHRcdCdjb250ZW50cyc6ICc8aWZyYW1lIHNyYz1cIicgKyBvcHQudXJsICsgJ1wiIG5hbWU9XCJzaW1wbGUtbW9kYWwtaWZyYW1lXCIgd2lkdGg9XCIxMDAlXCIgaGVpZ2h0PVwiJyArIG9wdC5oZWlnaHQgKyAnXCIgZnJhbWVib3JkZXI9XCIwXCI+PC9pZnJhbWU+Jyxcblx0XHRcdCdtb2RlbCc6ICdtb2RhbCdcblx0XHR9KTtcblx0fSxcblxuXHQvKipcblx0ICogT3BlbiBhIFRpbnlNQ0UgZmlsZSBicm93c2VyIGluIGEgbW9kYWwgd2luZG93XG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBmaWVsZF9uYW1lIFRoZSBmaWVsZCBuYW1lXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgICAgICAgIFRoZSBVUkxcblx0ICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgICAgICAgVGhlIHBpY2tlciB0eXBlXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSB3aW4gICAgICAgIFRoZSB3aW5kb3cgb2JqZWN0XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgICAgIFRoZSBzb3VyY2UgcmVjb3JkXG5cdCAqL1xuXHRvcGVuTW9kYWxCcm93c2VyOiBmdW5jdGlvbihmaWVsZF9uYW1lLCB1cmwsIHR5cGUsIHdpbiwgc291cmNlKSB7XG5cdFx0QmFja2VuZC5vcGVuTW9kYWxTZWxlY3Rvcih7XG5cdFx0XHQnaWQnOiAndGxfbGlzdGluZycsXG5cdFx0XHQndGl0bGUnOiB3aW4uZG9jdW1lbnQuZ2V0RWxlbWVudCgnZGl2Lm1jZS10aXRsZScpLmdldCgndGV4dCcpLFxuXHRcdFx0J3VybCc6IENvbnRhby5yb3V0ZXMuYmFja2VuZF9waWNrZXIgKyAnP2NvbnRleHQ9JyArICh0eXBlID09ICdmaWxlJyA/ICdsaW5rJyA6ICdmaWxlJykgKyAnJmFtcDtleHRyYXNbZmllbGRUeXBlXT1yYWRpbyZhbXA7ZXh0cmFzW2ZpbGVzT25seV09dHJ1ZSZhbXA7ZXh0cmFzW3NvdXJjZV09JyArIHNvdXJjZSArICcmYW1wO3ZhbHVlPScgKyB1cmwgKyAnJmFtcDtwb3B1cD0xJyxcblx0XHRcdCdjYWxsYmFjayc6IGZ1bmN0aW9uKHRhYmxlLCB2YWx1ZSkge1xuXHRcdFx0XHR3aW4uZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZmllbGRfbmFtZSkudmFsdWUgPSB2YWx1ZS5qb2luKCcsJyk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEF1dG9tYXRpY2FsbHkgc3VibWl0IGEgZm9ybVxuXHQgKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gZWwgVGhlIERPTSBlbGVtZW50XG5cdCAqL1xuXHRhdXRvU3VibWl0OiBmdW5jdGlvbihlbCkge1xuXHRcdHdpbmRvdy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnc3RvcmUtc2Nyb2xsLW9mZnNldCcpKTtcblxuXHRcdHZhciBoaWRkZW4gPSBuZXcgRWxlbWVudCgnaW5wdXQnLCB7XG5cdFx0XHQndHlwZSc6ICdoaWRkZW4nLFxuXHRcdFx0J25hbWUnOiAnU1VCTUlUX1RZUEUnLFxuXHRcdFx0J3ZhbHVlJzogJ2F1dG8nXG5cdFx0fSk7XG5cblx0XHR2YXIgZm9ybSA9ICQoZWwpIHx8IGVsO1xuXHRcdGhpZGRlbi5pbmplY3QoZm9ybSwgJ2JvdHRvbScpO1xuXHRcdGZvcm0ubm9WYWxpZGF0ZSA9IHRydWU7XG5cdFx0Zm9ybS5yZXF1ZXN0U3VibWl0KCk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFNjcm9sbCB0aGUgd2luZG93IHRvIGEgY2VydGFpbiB2ZXJ0aWNhbCBwb3NpdGlvblxuXHQgKlxuXHQgKiBAcGFyYW0ge2ludH0gb2Zmc2V0IFRoZSBvZmZzZXQgdG8gc2Nyb2xsIHRvXG5cdCAqL1xuXHR2U2Nyb2xsVG86IGZ1bmN0aW9uKG9mZnNldCkge1xuXHRcdGlmICh3aW5kb3cuY29uc29sZSkge1xuXHRcdFx0Y29uc29sZS53YXJuKCdCYWNrZW5kLnZTY3JvbGxUbygpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgdGhlIFN0aW11bHVzIGNvbnRyb2xsZXIgaW5zdGVhZC4nKTtcblx0XHR9XG5cblx0XHR3aW5kb3cuYWRkRXZlbnQoJ2xvYWQnLCBmdW5jdGlvbigpIHtcblx0XHRcdHdpbmRvdy5zY3JvbGxUbyhudWxsLCBwYXJzZUludChvZmZzZXQpKTtcblx0XHR9KTtcblx0fSxcblxuXHQvKipcblx0ICogVG9nZ2xlIGNoZWNrYm94ZXNcblx0ICpcblx0ICogQHBhcmFtIHtvYmplY3R9IGVsICAgVGhlIERPTSBlbGVtZW50XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBbaWRdIFRoZSBJRCBvZiB0aGUgdGFyZ2V0IGVsZW1lbnRcblx0ICovXG5cdHRvZ2dsZUNoZWNrYm94ZXM6IGZ1bmN0aW9uKGVsLCBpZCkge1xuXHRcdHZhciBpdGVtcyA9ICQkKCdpbnB1dCcpLFxuXHRcdFx0c3RhdHVzID0gJChlbCkuY2hlY2tlZCA/ICdjaGVja2VkJyA6ICcnO1xuXG5cdFx0Zm9yICh2YXIgaT0wOyBpPGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAoaXRlbXNbaV0udHlwZS50b0xvd2VyQ2FzZSgpICE9ICdjaGVja2JveCcpIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoaWQgIT09IHVuZGVmaW5lZCAmJiBpZCAhPSBpdGVtc1tpXS5pZC5zdWJzdHIoMCwgaWQubGVuZ3RoKSkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdGl0ZW1zW2ldLmNoZWNrZWQgPSBzdGF0dXM7XG5cdFx0fVxuXHR9LFxuXG5cdC8qKlxuXHQgKiBUb2dnbGUgYSBjaGVja2JveCBncm91cFxuXHQgKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gZWwgVGhlIERPTSBlbGVtZW50XG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgSUQgb2YgdGhlIHRhcmdldCBlbGVtZW50XG5cdCAqL1xuXHR0b2dnbGVDaGVja2JveEdyb3VwOiBmdW5jdGlvbihlbCwgaWQpIHtcblx0XHR2YXIgY2xzID0gJChlbCkuY2xhc3NOYW1lLFxuXHRcdFx0c3RhdHVzID0gJChlbCkuY2hlY2tlZCA/ICdjaGVja2VkJyA6ICcnO1xuXG5cdFx0aWYgKGNscyA9PSAndGxfY2hlY2tib3gnKSB7XG5cdFx0XHR2YXIgY2J4ID0gJChpZCkgPyAkJCgnIycgKyBpZCArICcgLnRsX2NoZWNrYm94JykgOiAkKGVsKS5nZXRQYXJlbnQoJ2ZpZWxkc2V0JykuZ2V0RWxlbWVudHMoJy50bF9jaGVja2JveCcpO1xuXHRcdFx0Y2J4LmVhY2goZnVuY3Rpb24oY2hlY2tib3gpIHtcblx0XHRcdFx0Y2hlY2tib3guY2hlY2tlZCA9IHN0YXR1cztcblx0XHRcdH0pO1xuXHRcdH0gZWxzZSBpZiAoY2xzID09ICd0bF90cmVlX2NoZWNrYm94Jykge1xuXHRcdFx0JCQoJyMnICsgaWQgKyAnIC5wYXJlbnQgLnRsX3RyZWVfY2hlY2tib3gnKS5lYWNoKGZ1bmN0aW9uKGNoZWNrYm94KSB7XG5cdFx0XHRcdGNoZWNrYm94LmNoZWNrZWQgPSBzdGF0dXM7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHR3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ3N0b3JlLXNjcm9sbC1vZmZzZXQnKSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFRvZ2dsZSBjaGVja2JveCBlbGVtZW50c1xuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gZWwgIFRoZSBET00gZWxlbWVudFxuXHQgKiBAcGFyYW0ge3N0cmluZ30gY2xzIFRoZSBDU1MgY2xhc3MgbmFtZVxuXHQgKi9cblx0dG9nZ2xlQ2hlY2tib3hFbGVtZW50czogZnVuY3Rpb24oZWwsIGNscykge1xuXHRcdHZhciBzdGF0dXMgPSAkKGVsKS5jaGVja2VkID8gJ2NoZWNrZWQnIDogJyc7XG5cblx0XHQkJCgnLicgKyBjbHMpLmVhY2goZnVuY3Rpb24oY2hlY2tib3gpIHtcblx0XHRcdGlmIChjaGVja2JveC5oYXNDbGFzcygndGxfY2hlY2tib3gnKSkge1xuXHRcdFx0XHRjaGVja2JveC5jaGVja2VkID0gc3RhdHVzO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0d2luZG93LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdzdG9yZS1zY3JvbGwtb2Zmc2V0JykpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBNYWtlIHBhcmVudCB2aWV3IGl0ZW1zIHNvcnRhYmxlXG5cdCAqXG5cdCAqIEBwYXJhbSB7b2JqZWN0fSB1bCBUaGUgRE9NIGVsZW1lbnRcblx0ICpcblx0ICogQGF1dGhvciBKb2UgUmF5IEdyZWdvcnlcblx0ICogQGF1dGhvciBNYXJ0aW4gQXVzd8O2Z2VyXG5cdCAqL1xuXHRtYWtlUGFyZW50Vmlld1NvcnRhYmxlOiBmdW5jdGlvbih1bCkge1xuXHRcdGNvbnNvbGUud2FybignQmFja2VuZC5tYWtlUGFyZW50Vmlld1NvcnRhYmxlKCkgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSB0aGUgc3RpbXVsdXMgY29udHJvbGxlcnMgaW5zdGVhZC4nKTtcblxuXHRcdHZhciBkcyA9IG5ldyBTY3JvbGxlcihkb2N1bWVudC5nZXRFbGVtZW50KCdib2R5JyksIHtcblx0XHRcdG9uQ2hhbmdlOiBmdW5jdGlvbih4LCB5KSB7XG5cdFx0XHRcdHRoaXMuZWxlbWVudC5zY3JvbGxUbyh0aGlzLmVsZW1lbnQuZ2V0U2Nyb2xsKCkueCwgeSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHR2YXIgbGlzdCA9IG5ldyBTb3J0YWJsZXModWwsIHtcblx0XHRcdGNvbnN0cmFpbjogdHJ1ZSxcblx0XHRcdG9wYWNpdHk6IDAuNixcblx0XHRcdG9uU3RhcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkcy5zdGFydCgpO1xuXHRcdFx0fSxcblx0XHRcdG9uQ29tcGxldGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkcy5zdG9wKCk7XG5cdFx0XHR9LFxuXHRcdFx0b25Tb3J0OiBmdW5jdGlvbihlbCkge1xuXHRcdFx0XHR2YXIgdWwgPSBlbC5nZXRQYXJlbnQoJ3VsJyksXG5cdFx0XHRcdFx0d3JhcExldmVsID0gMCwgZGl2cywgaTtcblxuXHRcdFx0XHRpZiAoIXVsKSByZXR1cm47XG5cblx0XHRcdFx0ZGl2cyA9IHVsLmdldENoaWxkcmVuKCdsaSA+IGRpdjpmaXJzdC1jaGlsZCcpO1xuXG5cdFx0XHRcdGlmICghZGl2cykgcmV0dXJuO1xuXG5cdFx0XHRcdGZvciAoaT0wOyBpPGRpdnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRpZiAoZGl2c1tpXS5oYXNDbGFzcygnd3JhcHBlcl9zdG9wJykgJiYgd3JhcExldmVsID4gMCkge1xuXHRcdFx0XHRcdFx0d3JhcExldmVsLS07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZGl2c1tpXS5jbGFzc05hbWUgPSBkaXZzW2ldLmNsYXNzTmFtZS5yZXBsYWNlKC8oXnxcXHMpaW5kZW50W15cXHNdKi9nLCAnJyk7XG5cblx0XHRcdFx0XHRpZiAod3JhcExldmVsID4gMCkge1xuXHRcdFx0XHRcdFx0ZGl2c1tpXS5hZGRDbGFzcygnaW5kZW50JykuYWRkQ2xhc3MoJ2luZGVudF8nICsgd3JhcExldmVsKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoZGl2c1tpXS5oYXNDbGFzcygnd3JhcHBlcl9zdGFydCcpKSB7XG5cdFx0XHRcdFx0XHR3cmFwTGV2ZWwrKztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRkaXZzW2ldLnJlbW92ZUNsYXNzKCdpbmRlbnRfZmlyc3QnKTtcblx0XHRcdFx0XHRkaXZzW2ldLnJlbW92ZUNsYXNzKCdpbmRlbnRfbGFzdCcpO1xuXG5cdFx0XHRcdFx0aWYgKGRpdnNbaS0xXSAmJiBkaXZzW2ktMV0uaGFzQ2xhc3MoJ3dyYXBwZXJfc3RhcnQnKSkge1xuXHRcdFx0XHRcdFx0ZGl2c1tpXS5hZGRDbGFzcygnaW5kZW50X2ZpcnN0Jyk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0aWYgKGRpdnNbaSsxXSAmJiBkaXZzW2krMV0uaGFzQ2xhc3MoJ3dyYXBwZXJfc3RvcCcpKSB7XG5cdFx0XHRcdFx0XHRkaXZzW2ldLmFkZENsYXNzKCdpbmRlbnRfbGFzdCcpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGhhbmRsZTogJy5kcmFnLWhhbmRsZSdcblx0XHR9KTtcblxuXHRcdGxpc3QuYWN0aXZlID0gZmFsc2U7XG5cblx0XHRsaXN0LmFkZEV2ZW50KCdzdGFydCcsIGZ1bmN0aW9uKCkge1xuXHRcdFx0bGlzdC5hY3RpdmUgPSB0cnVlO1xuXHRcdH0pO1xuXG5cdFx0bGlzdC5hZGRFdmVudCgnY29tcGxldGUnLCBmdW5jdGlvbihlbCkge1xuXHRcdFx0aWYgKCFsaXN0LmFjdGl2ZSkgcmV0dXJuO1xuXHRcdFx0dmFyIGlkLCBwaWQsIHVybCA9IG5ldyBVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuXG5cdFx0XHR1cmwuc2VhcmNoUGFyYW1zLnNldCgncnQnLCBDb250YW8ucmVxdWVzdF90b2tlbik7XG5cdFx0XHR1cmwuc2VhcmNoUGFyYW1zLnNldCgnYWN0JywgJ2N1dCcpO1xuXG5cdFx0XHRpZiAoZWwuZ2V0UHJldmlvdXMoJ2xpJykpIHtcblx0XHRcdFx0aWQgPSBlbC5nZXQoJ2lkJykucmVwbGFjZSgvbGlfLywgJycpO1xuXHRcdFx0XHRwaWQgPSBlbC5nZXRQcmV2aW91cygnbGknKS5nZXQoJ2lkJykucmVwbGFjZSgvbGlfLywgJycpO1xuXHRcdFx0XHR1cmwuc2VhcmNoUGFyYW1zLnNldCgnaWQnLCBpZCk7XG5cdFx0XHRcdHVybC5zZWFyY2hQYXJhbXMuc2V0KCdwaWQnLCBwaWQpO1xuXHRcdFx0XHR1cmwuc2VhcmNoUGFyYW1zLnNldCgnbW9kZScsIDEpO1xuXHRcdFx0XHRuZXcgUmVxdWVzdC5Db250YW8oeyd1cmwnOnVybC50b1N0cmluZygpLCAnZm9sbG93UmVkaXJlY3RzJzpmYWxzZX0pLmdldCgpO1xuXHRcdFx0fSBlbHNlIGlmIChlbC5nZXRQYXJlbnQoJ3VsJykpIHtcblx0XHRcdFx0aWQgPSBlbC5nZXQoJ2lkJykucmVwbGFjZSgvbGlfLywgJycpO1xuXHRcdFx0XHRwaWQgPSBlbC5nZXRQYXJlbnQoJ3VsJykuZ2V0KCdpZCcpLnJlcGxhY2UoL3VsXy8sICcnKTtcblx0XHRcdFx0dXJsLnNlYXJjaFBhcmFtcy5zZXQoJ2lkJywgaWQpO1xuXHRcdFx0XHR1cmwuc2VhcmNoUGFyYW1zLnNldCgncGlkJywgcGlkKTtcblx0XHRcdFx0dXJsLnNlYXJjaFBhcmFtcy5zZXQoJ21vZGUnLCAyKTtcblx0XHRcdFx0bmV3IFJlcXVlc3QuQ29udGFvKHsndXJsJzp1cmwudG9TdHJpbmcoKSwgJ2ZvbGxvd1JlZGlyZWN0cyc6ZmFsc2V9KS5nZXQoKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHQvKipcblx0ICogTWFrZSBtdWx0aVNSQyBpdGVtcyBzb3J0YWJsZVxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWQgIFRoZSBJRCBvZiB0aGUgdGFyZ2V0IGVsZW1lbnRcblx0ICogQHBhcmFtIHtzdHJpbmd9IG9pZCBUaGUgb3JkZXIgZmllbGRcblx0ICogQHBhcmFtIHtzdHJpbmd9IHZhbCBUaGUgdmFsdWUgZmllbGRcblx0ICovXG5cdG1ha2VNdWx0aVNyY1NvcnRhYmxlOiBmdW5jdGlvbihpZCwgb2lkLCB2YWwpIHtcblx0XHRjb25zb2xlLndhcm4oJ0JhY2tlbmQubWFrZU11bHRpU3JjU29ydGFibGUoKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIHRoZSBzdGltdWx1cyBjb250cm9sbGVycyBpbnN0ZWFkLicpO1xuXG5cdFx0dmFyIGxpc3QgPSBuZXcgU29ydGFibGVzKCQoaWQpLCB7XG5cdFx0XHRjb25zdHJhaW46IHRydWUsXG5cdFx0XHRvcGFjaXR5OiAwLjZcblx0XHR9KS5hZGRFdmVudCgnY29tcGxldGUnLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBlbHMgPSBbXSxcblx0XHRcdFx0bGlzID0gJChpZCkuZ2V0Q2hpbGRyZW4oJ1tkYXRhLWlkXScpLFxuXHRcdFx0XHRpO1xuXHRcdFx0Zm9yIChpPTA7IGk8bGlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGVscy5wdXNoKGxpc1tpXS5nZXQoJ2RhdGEtaWQnKSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAob2lkID09PSB2YWwpIHtcblx0XHRcdFx0JCh2YWwpLnZhbHVlLnNwbGl0KCcsJykuZm9yRWFjaChmdW5jdGlvbihqKSB7XG5cdFx0XHRcdFx0aWYgKGVscy5pbmRleE9mKGopID09PSAtMSkge1xuXHRcdFx0XHRcdFx0ZWxzLnB1c2goaik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdCQob2lkKS52YWx1ZSA9IGVscy5qb2luKCcsJyk7XG5cdFx0fSk7XG5cdFx0JChpZCkuZ2V0RWxlbWVudHMoJy5naW1hZ2UnKS5lYWNoKGZ1bmN0aW9uKGVsKSB7XG5cdFx0XHRpZiAoZWwuaGFzQ2xhc3MoJ3JlbW92YWJsZScpKSB7XG5cdFx0XHRcdG5ldyBFbGVtZW50KCdidXR0b24nLCB7XG5cdFx0XHRcdFx0dHlwZTogJ2J1dHRvbicsXG5cdFx0XHRcdFx0aHRtbDogSWNvbi5nZXRUZW1wbGF0ZSgnZGVsZXRlJywgeydhcmlhLWhpZGRlbic6IHRydWV9KS5nZXRIVE1MKCksXG5cdFx0XHRcdFx0J2NsYXNzJzogJ3RsX3JlZCdcblx0XHRcdFx0fSkuYWRkRXZlbnQoJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmFyIGxpID0gZWwuZ2V0UGFyZW50KCdsaScpLFxuXHRcdFx0XHRcdFx0ZGlkID0gbGkuZ2V0KCdkYXRhLWlkJyk7XG5cdFx0XHRcdFx0JCh2YWwpLnZhbHVlID0gJCh2YWwpLnZhbHVlLnNwbGl0KCcsJykuZmlsdGVyKGZ1bmN0aW9uKGopIHsgcmV0dXJuIGogIT0gZGlkOyB9KS5qb2luKCcsJyk7XG5cdFx0XHRcdFx0JChvaWQpLnZhbHVlID0gJChvaWQpLnZhbHVlLnNwbGl0KCcsJykuZmlsdGVyKGZ1bmN0aW9uKGopIHsgcmV0dXJuIGogIT0gZGlkOyB9KS5qb2luKCcsJyk7XG5cdFx0XHRcdFx0bGkuZGlzcG9zZSgpO1xuXHRcdFx0XHR9KS5pbmplY3QoZWwsICdhZnRlcicpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bmV3IEVsZW1lbnQoJ2J1dHRvbicsIHtcblx0XHRcdFx0XHR0eXBlOiAnYnV0dG9uJyxcblx0XHRcdFx0XHRodG1sOiBJY29uLmdldFRlbXBsYXRlKCdkZWxldGUnLCB7J2FyaWEtaGlkZGVuJzogdHJ1ZX0pLmdldEhUTUwoKSxcblx0XHRcdFx0XHRkaXNhYmxlZDogdHJ1ZVxuXHRcdFx0XHR9KS5pbmplY3QoZWwsICdhZnRlcicpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdGxpc3QuZmlyZUV2ZW50KFwiY29tcGxldGVcIik7IC8vIEluaXRpYWwgc29ydGluZ1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBFbmFibGUgZHJhZyBhbmQgZHJvcCBmb3IgdGhlIGZpbGUgdHJlZVxuXHQgKlxuXHQgKiBAcGFyYW0ge29iamVjdH0gdWwgICAgICBUaGUgRE9NIGVsZW1lbnRcblx0ICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgQW4gb3B0aW9uYWwgb3B0aW9ucyBvYmplY3Rcblx0ICovXG5cdGVuYWJsZUZpbGVUcmVlRHJhZ0FuZERyb3A6IGZ1bmN0aW9uKHVsLCBvcHRpb25zKSB7XG5cdFx0dmFyIGRzID0gbmV3IFNjcm9sbGVyKGRvY3VtZW50LmdldEVsZW1lbnQoJ2JvZHknKSwge1xuXHRcdFx0b25DaGFuZ2U6IGZ1bmN0aW9uKHgsIHkpIHtcblx0XHRcdFx0dGhpcy5lbGVtZW50LnNjcm9sbFRvKHRoaXMuZWxlbWVudC5nZXRTY3JvbGwoKS54LCB5KTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdHVsLmFkZEV2ZW50KCdtb3VzZWRvd24nLCBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0dmFyIGRyYWdIYW5kbGUgPSBldmVudC50YXJnZXQuaGFzQ2xhc3MoJ2RyYWctaGFuZGxlJykgPyBldmVudC50YXJnZXQgOiBldmVudC50YXJnZXQuZ2V0UGFyZW50KCcuZHJhZy1oYW5kbGUnKTtcblx0XHRcdHZhciBkcmFnRWxlbWVudCA9IGV2ZW50LnRhcmdldC5nZXRQYXJlbnQoJy50bF9maWxlLC50bF9mb2xkZXInKTtcblxuXHRcdFx0aWYgKCFkcmFnSGFuZGxlIHx8ICFkcmFnRWxlbWVudCB8fCBldmVudC5yaWdodENsaWNrKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0ZHMuc3RhcnQoKTtcblx0XHRcdHVsLmFkZENsYXNzKCd0bF9saXN0aW5nX2RyYWdnaW5nJyk7XG5cblx0XHRcdHZhciBjbG9uZUJhc2UgPSAoZHJhZ0VsZW1lbnQuZ2V0RWxlbWVudHMoJy50bF9sZWZ0JylbMF0gfHwgZHJhZ0VsZW1lbnQpLFxuXHRcdFx0XHRjbG9uZSA9IGNsb25lQmFzZS5jbG9uZSh0cnVlKVxuXHRcdFx0XHRcdC5pbmplY3QodWwpXG5cdFx0XHRcdFx0LmFkZENsYXNzKCd0bF9sZWZ0X2RyYWdnaW5nJyksXG5cdFx0XHRcdGN1cnJlbnRIb3ZlciwgY3VycmVudEhvdmVyVGltZSwgZXhwYW5kTGluaztcblxuXHRcdFx0Y2xvbmUuc2V0UG9zaXRpb24oe1xuXHRcdFx0XHR4OiBldmVudC5wYWdlLnggLSBjbG9uZUJhc2UuZ2V0T2Zmc2V0UGFyZW50KCkuZ2V0UG9zaXRpb24oKS54IC0gY2xvbmUuZ2V0U2l6ZSgpLngsXG5cdFx0XHRcdHk6IGNsb25lQmFzZS5nZXRQb3NpdGlvbihjbG9uZUJhc2UuZ2V0T2Zmc2V0UGFyZW50KCkpLnlcblx0XHRcdH0pLnNldFN0eWxlKCdkaXNwbGF5JywgJ25vbmUnKTtcblxuXHRcdFx0dmFyIG1vdmUgPSBuZXcgRHJhZy5Nb3ZlKGNsb25lLCB7XG5cdFx0XHRcdGRyb3BwYWJsZXM6ICQkKFt1bF0pLmFwcGVuZCh1bC5nZXRFbGVtZW50cygnLnRsX2ZvbGRlcixsaS5wYXJlbnQsLnRsX2ZvbGRlcl90b3AnKSksXG5cdFx0XHRcdHVuRHJhZ2dhYmxlVGFnczogW10sXG5cdFx0XHRcdG1vZGlmaWVyczoge1xuXHRcdFx0XHRcdHg6ICdsZWZ0Jyxcblx0XHRcdFx0XHR5OiAndG9wJ1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRvblN0YXJ0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRjbG9uZS5zZXRTdHlsZSgnZGlzcGxheScsICcnKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0b25FbnRlcjogZnVuY3Rpb24oZWxlbWVudCwgZHJvcHBhYmxlKSB7XG5cdFx0XHRcdFx0ZHJvcHBhYmxlID0gZml4RHJvcHBhYmxlKGRyb3BwYWJsZSk7XG5cdFx0XHRcdFx0ZHJvcHBhYmxlLmFkZENsYXNzKCd0bF9mb2xkZXJfZHJvcHBpbmcnKTtcblxuXHRcdFx0XHRcdGlmIChkcm9wcGFibGUuaGFzQ2xhc3MoJ3RsX2ZvbGRlcicpICYmIGN1cnJlbnRIb3ZlciAhPT0gZHJvcHBhYmxlKSB7XG5cdFx0XHRcdFx0XHRjdXJyZW50SG92ZXIgPSBkcm9wcGFibGU7XG5cdFx0XHRcdFx0XHRjdXJyZW50SG92ZXJUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cdFx0XHRcdFx0XHRleHBhbmRMaW5rID0gZHJvcHBhYmxlLmdldEVsZW1lbnQoJ2EuZm9sZGFibGUnKTtcblxuXHRcdFx0XHRcdFx0aWYgKGV4cGFuZExpbmsgJiYgIWV4cGFuZExpbmsuaGFzQ2xhc3MoJ2ZvbGRhYmxlLS1vcGVuJykpIHtcblx0XHRcdFx0XHRcdFx0Ly8gRXhwYW5kIHRoZSBmb2xkZXIgYWZ0ZXIgb25lIHNlY29uZCBob3ZlciB0aW1lXG5cdFx0XHRcdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGN1cnJlbnRIb3ZlciA9PT0gZHJvcHBhYmxlICYmIGN1cnJlbnRIb3ZlclRpbWUgKyA5MDAgPCBuZXcgRGF0ZSgpLmdldFRpbWUoKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIGV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0hUTUxFdmVudHMnKTtcblx0XHRcdFx0XHRcdFx0XHRcdGV2ZW50LmluaXRFdmVudCgnY2xpY2snLCB0cnVlLCB0cnVlKTtcblx0XHRcdFx0XHRcdFx0XHRcdGV4cGFuZExpbmsuZGlzcGF0Y2hFdmVudChldmVudCk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnRIb3ZlciA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnRIb3ZlclRpbWUgPSB1bmRlZmluZWQ7XG5cblx0XHRcdFx0XHRcdFx0XHRcdHdpbmRvdy5hZGRFdmVudCgnYWpheF9jaGFuZ2UnLCBmdW5jdGlvbiBvbkFqYXgoKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmIChtb3ZlICYmIG1vdmUuZHJvcHBhYmxlcyAmJiB1bCAmJiB1bC5nZXRFbGVtZW50cykge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1vdmUuZHJvcHBhYmxlcyA9ICQkKFt1bF0pLmFwcGVuZCh1bC5nZXRFbGVtZW50cygnLnRsX2ZvbGRlcixsaS5wYXJlbnQnKSk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdFx0d2luZG93LnJlbW92ZUV2ZW50KCdhamF4X2NoYW5nZScsIG9uQWpheCk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0sIDEwMDApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdFx0b25DYW5jZWw6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGN1cnJlbnRIb3ZlciA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRjdXJyZW50SG92ZXJUaW1lID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRcdFx0ZHMuc3RvcCgpO1xuXHRcdFx0XHRcdGNsb25lLmRlc3Ryb3koKTtcblx0XHRcdFx0XHR3aW5kb3cucmVtb3ZlRXZlbnQoJ2tleXVwJywgb25LZXl1cCk7XG5cdFx0XHRcdFx0dWwuZ2V0RWxlbWVudHMoJy50bF9mb2xkZXJfZHJvcHBpbmcnKS5yZW1vdmVDbGFzcygndGxfZm9sZGVyX2Ryb3BwaW5nJyk7XG5cdFx0XHRcdFx0dWwucmVtb3ZlQ2xhc3MoJ3RsX2xpc3RpbmdfZHJhZ2dpbmcnKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0b25Ecm9wOiBmdW5jdGlvbihlbGVtZW50LCBkcm9wcGFibGUpIHtcblx0XHRcdFx0XHRjdXJyZW50SG92ZXIgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0Y3VycmVudEhvdmVyVGltZSA9IHVuZGVmaW5lZDtcblxuXHRcdFx0XHRcdGRzLnN0b3AoKTtcblx0XHRcdFx0XHRjbG9uZS5kZXN0cm95KCk7XG5cdFx0XHRcdFx0d2luZG93LnJlbW92ZUV2ZW50KCdrZXl1cCcsIG9uS2V5dXApO1xuXHRcdFx0XHRcdHVsLmdldEVsZW1lbnRzKCcudGxfZm9sZGVyX2Ryb3BwaW5nJykucmVtb3ZlQ2xhc3MoJ3RsX2ZvbGRlcl9kcm9wcGluZycpO1xuXHRcdFx0XHRcdHVsLnJlbW92ZUNsYXNzKCd0bF9saXN0aW5nX2RyYWdnaW5nJyk7XG5cblx0XHRcdFx0XHRkcm9wcGFibGUgPSBmaXhEcm9wcGFibGUoZHJvcHBhYmxlKTtcblxuXHRcdFx0XHRcdGlmICghZHJvcHBhYmxlKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dmFyIGlkID0gZHJhZ0VsZW1lbnQuZ2V0KCdkYXRhLWlkJyksXG5cdFx0XHRcdFx0XHRwaWQgPSBkcm9wcGFibGUuZ2V0KCdkYXRhLWlkJykgfHwgZGVjb2RlVVJJQ29tcG9uZW50KG9wdGlvbnMudXJsLnNwbGl0KC9bPyZdcGlkPS8pWzFdLnNwbGl0KCcmJylbMF0pO1xuXG5cdFx0XHRcdFx0Ly8gSWdub3JlIGludmFsaWQgbW92ZSBvcGVyYXRpb25zXG5cdFx0XHRcdFx0aWYgKGlkICYmIHBpZCAmJiAoKHBpZCsnLycpLmluZGV4T2YoaWQrJy8nKSA9PT0gMCB8fCBwaWQrJy8nID09PSBpZC5yZXBsYWNlKC9bXi9dKyQvLCAnJykpKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0d2luZG93LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdzdG9yZS1zY3JvbGwtb2Zmc2V0JykpO1xuXHRcdFx0XHRcdGRvY3VtZW50LmxvY2F0aW9uLmhyZWYgPSBvcHRpb25zLnVybCArICcmaWQ9JyArIGVuY29kZVVSSUNvbXBvbmVudChpZCkgKyAnJnBpZD0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHBpZCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdG9uTGVhdmU6IGZ1bmN0aW9uKGVsZW1lbnQsIGRyb3BwYWJsZSkge1xuXHRcdFx0XHRcdGRyb3BwYWJsZSA9IGZpeERyb3BwYWJsZShkcm9wcGFibGUpO1xuXHRcdFx0XHRcdGRyb3BwYWJsZS5yZW1vdmVDbGFzcygndGxfZm9sZGVyX2Ryb3BwaW5nJyk7XG5cdFx0XHRcdFx0Y3VycmVudEhvdmVyID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdGN1cnJlbnRIb3ZlclRpbWUgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXG5cdFx0XHRtb3ZlLnN0YXJ0KGV2ZW50KTtcblx0XHRcdHdpbmRvdy5hZGRFdmVudCgna2V5dXAnLCBvbktleXVwKTtcblxuXHRcdFx0ZnVuY3Rpb24gb25LZXl1cChldmVudCkge1xuXHRcdFx0XHRpZiAoZXZlbnQua2V5ID09PSAnZXNjJyAmJiBtb3ZlICYmIG1vdmUuc3RvcCkge1xuXHRcdFx0XHRcdG1vdmUuZHJvcHBhYmxlcyA9ICQkKFtdKTtcblx0XHRcdFx0XHRtb3ZlLnN0b3AoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0ZnVuY3Rpb24gZml4RHJvcHBhYmxlKGRyb3BwYWJsZSkge1xuXHRcdFx0aWYgKGRyb3BwYWJsZSAmJiBkcm9wcGFibGUuaGFzQ2xhc3MoJ3BhcmVudCcpICYmIGRyb3BwYWJsZS5nZXRQcmV2aW91cygnLnRsX2ZvbGRlcicpKSB7XG5cdFx0XHRcdHJldHVybiBkcm9wcGFibGUuZ2V0UHJldmlvdXMoJy50bF9mb2xkZXInKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRyb3BwYWJsZTtcblx0XHR9XG5cdH0sXG5cblx0LyoqXG5cdCAqIExpc3Qgd2l6YXJkXG5cdCAqXG5cdCAqIEBwYXJhbSB7c3RyaW5nfSBpZCBUaGUgSUQgb2YgdGhlIHRhcmdldCBlbGVtZW50XG5cdCAqL1xuXHRsaXN0V2l6YXJkOiBmdW5jdGlvbihpZCkge1xuXHRcdGNvbnNvbGUud2FybignQmFja2VuZC5saXN0V2l6YXJkKCkgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSB0aGUgc3RpbXVsdXMgY29udHJvbGxlciBpbnN0ZWFkLicpO1xuXG5cdFx0dmFyIHVsID0gJChpZCksXG5cdFx0XHRtYWtlU29ydGFibGUgPSBmdW5jdGlvbih1bCkge1xuXHRcdFx0XHRuZXcgU29ydGFibGVzKHVsLCB7XG5cdFx0XHRcdFx0Y29uc3RyYWluOiB0cnVlLFxuXHRcdFx0XHRcdG9wYWNpdHk6IDAuNixcblx0XHRcdFx0XHRoYW5kbGU6ICcuZHJhZy1oYW5kbGUnXG5cdFx0XHRcdH0pO1xuXHRcdFx0fSxcblx0XHRcdGFkZEV2ZW50c1RvID0gZnVuY3Rpb24obGkpIHtcblx0XHRcdFx0dmFyIGNvbW1hbmQsIGNsb25lLCBpbnB1dCwgcHJldmlvdXMsIG5leHQ7XG5cblx0XHRcdFx0bGkuZ2V0RWxlbWVudHMoJ2J1dHRvbicpLmVhY2goZnVuY3Rpb24oYnQpIHtcblx0XHRcdFx0XHRpZiAoYnQuaGFzRXZlbnQoJ2NsaWNrJykpIHJldHVybjtcblx0XHRcdFx0XHRjb21tYW5kID0gYnQuZ2V0UHJvcGVydHkoJ2RhdGEtY29tbWFuZCcpO1xuXG5cdFx0XHRcdFx0c3dpdGNoIChjb21tYW5kKSB7XG5cdFx0XHRcdFx0XHRjYXNlICdjb3B5Jzpcblx0XHRcdFx0XHRcdFx0YnQuYWRkRXZlbnQoJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0d2luZG93LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdzdG9yZS1zY3JvbGwtb2Zmc2V0JykpO1xuXHRcdFx0XHRcdFx0XHRcdGNsb25lID0gbGkuY2xvbmUodHJ1ZSkuaW5qZWN0KGxpLCAnYmVmb3JlJyk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGlucHV0ID0gbGkuZ2V0Rmlyc3QoJ2lucHV0JykpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNsb25lLmdldEZpcnN0KCdpbnB1dCcpLnZhbHVlID0gaW5wdXQudmFsdWU7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGFkZEV2ZW50c1RvKGNsb25lKTtcblx0XHRcdFx0XHRcdFx0XHRpbnB1dC5zZWxlY3QoKTtcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnZGVsZXRlJzpcblx0XHRcdFx0XHRcdFx0YnQuYWRkRXZlbnQoJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0d2luZG93LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdzdG9yZS1zY3JvbGwtb2Zmc2V0JykpO1xuXHRcdFx0XHRcdFx0XHRcdGlmICh1bC5nZXRDaGlsZHJlbigpLmxlbmd0aCA+IDEpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGxpLmRlc3Ryb3koKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgbnVsbDpcblx0XHRcdFx0XHRcdFx0YnQuYWRkRXZlbnQoJ2tleWRvd24nLCBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGUuZXZlbnQua2V5Q29kZSA9PSAzOCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKHByZXZpb3VzID0gbGkuZ2V0UHJldmlvdXMoJ2xpJykpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0bGkuaW5qZWN0KHByZXZpb3VzLCAnYmVmb3JlJyk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRsaS5pbmplY3QodWwsICdib3R0b20nKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdGJ0LmZvY3VzKCk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChlLmV2ZW50LmtleUNvZGUgPT0gNDApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdFx0XHRcdGlmIChuZXh0ID0gbGkuZ2V0TmV4dCgnbGknKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRsaS5pbmplY3QobmV4dCwgJ2FmdGVyJyk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRsaS5pbmplY3QodWwuZ2V0Rmlyc3QoJ2xpJyksICdiZWZvcmUnKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdGJ0LmZvY3VzKCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH07XG5cblx0XHRtYWtlU29ydGFibGUodWwpO1xuXG5cdFx0dWwuZ2V0Q2hpbGRyZW4oKS5lYWNoKGZ1bmN0aW9uKGxpKSB7XG5cdFx0XHRhZGRFdmVudHNUbyhsaSk7XG5cdFx0fSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIFRhYmxlIHdpemFyZFxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIElEIG9mIHRoZSB0YXJnZXQgZWxlbWVudFxuXHQgKi9cblx0dGFibGVXaXphcmQ6IGZ1bmN0aW9uKGlkKSB7XG5cdFx0dmFyIHRhYmxlID0gJChpZCksXG5cdFx0XHR0aGVhZCA9IHRhYmxlLmdldEVsZW1lbnQoJ3RoZWFkJyksXG5cdFx0XHR0Ym9keSA9IHRhYmxlLmdldEVsZW1lbnQoJ3Rib2R5JyksXG5cdFx0XHRtYWtlU29ydGFibGUgPSBmdW5jdGlvbih0Ym9keSkge1xuXHRcdFx0XHR2YXIgcm93cyA9IHRib2R5LmdldENoaWxkcmVuKCksXG5cdFx0XHRcdFx0dGV4dGFyZWEsIGNoaWxkcmVuLCBpLCBqO1xuXG5cdFx0XHRcdGZvciAoaT0wOyBpPHJvd3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRjaGlsZHJlbiA9IHJvd3NbaV0uZ2V0Q2hpbGRyZW4oKTtcblx0XHRcdFx0XHRmb3IgKGo9MDsgajxjaGlsZHJlbi5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdFx0aWYgKHRleHRhcmVhID0gY2hpbGRyZW5bal0uZ2V0Rmlyc3QoJ3RleHRhcmVhJykpIHtcblx0XHRcdFx0XHRcdFx0dGV4dGFyZWEubmFtZSA9IHRleHRhcmVhLm5hbWUucmVwbGFjZSgvXFxbWzAtOV0rXVtbMC05XStdL2csICdbJyArIGkgKyAnXVsnICsgaiArICddJylcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRuZXcgU29ydGFibGVzKHRib2R5LCB7XG5cdFx0XHRcdFx0Y29uc3RyYWluOiB0cnVlLFxuXHRcdFx0XHRcdG9wYWNpdHk6IDAuNixcblx0XHRcdFx0XHRoYW5kbGU6ICcuZHJhZy1oYW5kbGUnLFxuXHRcdFx0XHRcdG9uQ29tcGxldGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0bWFrZVNvcnRhYmxlKHRib2R5KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSxcblx0XHRcdGFkZEV2ZW50c1RvID0gZnVuY3Rpb24odHIpIHtcblx0XHRcdFx0dmFyIGhlYWQgPSB0aGVhZC5nZXRGaXJzdCgndHInKSxcblx0XHRcdFx0XHRjb21tYW5kLCB0ZXh0YXJlYSwgY3VycmVudCwgbmV4dCwgbnRyLCBjaGlsZHJlbiwgaW5kZXgsIGk7XG5cblx0XHRcdFx0dHIuZ2V0RWxlbWVudHMoJ2J1dHRvbicpLmVhY2goZnVuY3Rpb24oYnQpIHtcblx0XHRcdFx0XHRpZiAoYnQuaGFzRXZlbnQoJ2NsaWNrJykpIHJldHVybjtcblx0XHRcdFx0XHRjb21tYW5kID0gYnQuZ2V0UHJvcGVydHkoJ2RhdGEtY29tbWFuZCcpO1xuXG5cdFx0XHRcdFx0c3dpdGNoIChjb21tYW5kKSB7XG5cdFx0XHRcdFx0XHRjYXNlICdyY29weSc6XG5cdFx0XHRcdFx0XHRcdGJ0LmFkZEV2ZW50KCdjbGljaycsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdHdpbmRvdy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnc3RvcmUtc2Nyb2xsLW9mZnNldCcpKTtcblx0XHRcdFx0XHRcdFx0XHRudHIgPSBuZXcgRWxlbWVudCgndHInKTtcblx0XHRcdFx0XHRcdFx0XHRjaGlsZHJlbiA9IHRyLmdldENoaWxkcmVuKCk7XG5cdFx0XHRcdFx0XHRcdFx0Zm9yIChpPTA7IGk8Y2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRcdG5leHQgPSBjaGlsZHJlbltpXS5jbG9uZSh0cnVlKS5pbmplY3QobnRyLCAnYm90dG9tJyk7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAodGV4dGFyZWEgPSBjaGlsZHJlbltpXS5nZXRGaXJzdCgndGV4dGFyZWEnKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRuZXh0LmdldEZpcnN0KCd0ZXh0YXJlYScpLnZhbHVlID0gdGV4dGFyZWEudmFsdWU7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdG50ci5pbmplY3QodHIsICdhZnRlcicpO1xuXHRcdFx0XHRcdFx0XHRcdGFkZEV2ZW50c1RvKG50cik7XG5cdFx0XHRcdFx0XHRcdFx0bWFrZVNvcnRhYmxlKHRib2R5KTtcblx0XHRcdFx0XHRcdFx0XHRudHIuZ2V0Rmlyc3QoJ3RkJykuZ2V0Rmlyc3QoJ3RleHRhcmVhJykuc2VsZWN0KCk7XG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ3JkZWxldGUnOlxuXHRcdFx0XHRcdFx0XHRidC5hZGRFdmVudCgnY2xpY2snLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHR3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ3N0b3JlLXNjcm9sbC1vZmZzZXQnKSk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHRib2R5LmdldENoaWxkcmVuKCkubGVuZ3RoID4gMSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dHIuZGVzdHJveSgpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRtYWtlU29ydGFibGUodGJvZHkpO1xuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdjY29weSc6XG5cdFx0XHRcdFx0XHRcdGJ0LmFkZEV2ZW50KCdjbGljaycsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdHdpbmRvdy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnc3RvcmUtc2Nyb2xsLW9mZnNldCcpKTtcblx0XHRcdFx0XHRcdFx0XHRpbmRleCA9IGdldEluZGV4KGJ0KTtcblx0XHRcdFx0XHRcdFx0XHRjaGlsZHJlbiA9IHRib2R5LmdldENoaWxkcmVuKCk7XG5cdFx0XHRcdFx0XHRcdFx0Zm9yIChpPTA7IGk8Y2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnQgPSBjaGlsZHJlbltpXS5nZXRDaGlsZHJlbigpW2luZGV4XTtcblx0XHRcdFx0XHRcdFx0XHRcdG5leHQgPSBjdXJyZW50LmNsb25lKHRydWUpLmluamVjdChjdXJyZW50LCAnYWZ0ZXInKTtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICh0ZXh0YXJlYSA9IGN1cnJlbnQuZ2V0Rmlyc3QoJ3RleHRhcmVhJykpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0bmV4dC5nZXRGaXJzdCgndGV4dGFyZWEnKS52YWx1ZSA9IHRleHRhcmVhLnZhbHVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0YWRkRXZlbnRzVG8obmV4dCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHZhciBoZWFkRmlyc3QgPSBoZWFkLmdldEZpcnN0KCd0ZCcpO1xuXHRcdFx0XHRcdFx0XHRcdG5leHQgPSBoZWFkRmlyc3QuY2xvbmUodHJ1ZSkuaW5qZWN0KGhlYWQuZ2V0TGFzdCgndGQnKSwgJ2JlZm9yZScpO1xuXHRcdFx0XHRcdFx0XHRcdGFkZEV2ZW50c1RvKG5leHQpO1xuXHRcdFx0XHRcdFx0XHRcdG1ha2VTb3J0YWJsZSh0Ym9keSk7XG5cdFx0XHRcdFx0XHRcdFx0Y2hpbGRyZW5bMF0uZ2V0Q2hpbGRyZW4oKVtpbmRleCArIDFdLmdldEZpcnN0KCd0ZXh0YXJlYScpLnNlbGVjdCgpO1xuXHRcdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRjYXNlICdjbW92ZWwnOlxuXHRcdFx0XHRcdFx0XHRidC5hZGRFdmVudCgnY2xpY2snLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHR3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ3N0b3JlLXNjcm9sbC1vZmZzZXQnKSk7XG5cdFx0XHRcdFx0XHRcdFx0aW5kZXggPSBnZXRJbmRleChidCk7XG5cdFx0XHRcdFx0XHRcdFx0Y2hpbGRyZW4gPSB0Ym9keS5nZXRDaGlsZHJlbigpO1xuXHRcdFx0XHRcdFx0XHRcdGlmIChpbmRleCA+IDApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGZvciAoaT0wOyBpPGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnQgPSBjaGlsZHJlbltpXS5nZXRDaGlsZHJlbigpW2luZGV4XTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudC5pbmplY3QoY3VycmVudC5nZXRQcmV2aW91cygpLCAnYmVmb3JlJyk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGZvciAoaT0wOyBpPGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnQgPSBjaGlsZHJlbltpXS5nZXRDaGlsZHJlbigpW2luZGV4XTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudC5pbmplY3QoY2hpbGRyZW5baV0uZ2V0TGFzdCgpLCAnYmVmb3JlJyk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdG1ha2VTb3J0YWJsZSh0Ym9keSk7XG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ2Ntb3Zlcic6XG5cdFx0XHRcdFx0XHRcdGJ0LmFkZEV2ZW50KCdjbGljaycsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdHdpbmRvdy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnc3RvcmUtc2Nyb2xsLW9mZnNldCcpKTtcblx0XHRcdFx0XHRcdFx0XHRpbmRleCA9IGdldEluZGV4KGJ0KTtcblx0XHRcdFx0XHRcdFx0XHRjaGlsZHJlbiA9IHRib2R5LmdldENoaWxkcmVuKCk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGluZGV4IDwgKHRyLmdldENoaWxkcmVuKCkubGVuZ3RoIC0gMikpIHtcblx0XHRcdFx0XHRcdFx0XHRcdGZvciAoaT0wOyBpPGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnQgPSBjaGlsZHJlbltpXS5nZXRDaGlsZHJlbigpW2luZGV4XTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudC5pbmplY3QoY3VycmVudC5nZXROZXh0KCksICdhZnRlcicpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRmb3IgKGk9MDsgaTxjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gY2hpbGRyZW5baV0uZ2V0Q2hpbGRyZW4oKVtpbmRleF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnQuaW5qZWN0KGNoaWxkcmVuW2ldLmdldEZpcnN0KCksICdiZWZvcmUnKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0bWFrZVNvcnRhYmxlKHRib2R5KTtcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnY2RlbGV0ZSc6XG5cdFx0XHRcdFx0XHRcdGJ0LmFkZEV2ZW50KCdjbGljaycsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdHdpbmRvdy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnc3RvcmUtc2Nyb2xsLW9mZnNldCcpKTtcblx0XHRcdFx0XHRcdFx0XHRpbmRleCA9IGdldEluZGV4KGJ0KTtcblx0XHRcdFx0XHRcdFx0XHRjaGlsZHJlbiA9IHRib2R5LmdldENoaWxkcmVuKCk7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKHRyLmdldENoaWxkcmVuKCkubGVuZ3RoID4gMikge1xuXHRcdFx0XHRcdFx0XHRcdFx0Zm9yIChpPTA7IGk8Y2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y2hpbGRyZW5baV0uZ2V0Q2hpbGRyZW4oKVtpbmRleF0uZGVzdHJveSgpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0aGVhZC5nZXRGaXJzdCgndGQnKS5kZXN0cm95KCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdG1ha2VTb3J0YWJsZSh0Ym9keSk7XG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgbnVsbDpcblx0XHRcdFx0XHRcdFx0YnQuYWRkRXZlbnQoJ2tleWRvd24nLCBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGUuZXZlbnQua2V5Q29kZSA9PSAzOCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKG50ciA9IHRyLmdldFByZXZpb3VzKCd0cicpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRyLmluamVjdChudHIsICdiZWZvcmUnKTtcblx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRyLmluamVjdCh0Ym9keSwgJ2JvdHRvbScpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0YnQuZm9jdXMoKTtcblx0XHRcdFx0XHRcdFx0XHRcdG1ha2VTb3J0YWJsZSh0Ym9keSk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChlLmV2ZW50LmtleUNvZGUgPT0gNDApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdFx0XHRcdGlmIChudHIgPSB0ci5nZXROZXh0KCd0cicpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRyLmluamVjdChudHIsICdhZnRlcicpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHIuaW5qZWN0KHRib2R5LCAndG9wJyk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRidC5mb2N1cygpO1xuXHRcdFx0XHRcdFx0XHRcdFx0bWFrZVNvcnRhYmxlKHRib2R5KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSxcblx0XHRcdGdldEluZGV4ID0gZnVuY3Rpb24oYnQpIHtcblx0XHRcdFx0dmFyIHRkID0gJChidCkuZ2V0UGFyZW50KCd0ZCcpLFxuXHRcdFx0XHRcdHRyID0gdGQuZ2V0UGFyZW50KCd0cicpLFxuXHRcdFx0XHRcdGNvbHMgPSB0ci5nZXRDaGlsZHJlbigpLFxuXHRcdFx0XHRcdGluZGV4ID0gMCwgaTtcblxuXHRcdFx0XHRmb3IgKGk9MDsgaTxjb2xzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0aWYgKGNvbHNbaV0gPT0gdGQpIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpbmRleCsrO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGluZGV4O1xuXHRcdFx0fTtcblxuXHRcdG1ha2VTb3J0YWJsZSh0Ym9keSk7XG5cblx0XHR0aGVhZC5nZXRDaGlsZHJlbigpLmVhY2goZnVuY3Rpb24odHIpIHtcblx0XHRcdGFkZEV2ZW50c1RvKHRyKTtcblx0XHR9KTtcblxuXHRcdHRib2R5LmdldENoaWxkcmVuKCkuZWFjaChmdW5jdGlvbih0cikge1xuXHRcdFx0YWRkRXZlbnRzVG8odHIpO1xuXHRcdH0pO1xuXG5cdFx0QmFja2VuZC50YWJsZVdpemFyZFJlc2l6ZSgpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBSZXNpemUgdGhlIHRhYmxlIHdpemFyZCBmaWVsZHMgb24gZm9jdXNcblx0ICpcblx0ICogQHBhcmFtIHtmbG9hdH0gW2ZhY3Rvcl0gVGhlIHJlc2l6ZSBmYWN0b3Jcblx0ICovXG5cdHRhYmxlV2l6YXJkUmVzaXplOiBmdW5jdGlvbihmYWN0b3IpIHtcblx0XHR2YXIgc2l6ZSA9IHdpbmRvdy5sb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnY29udGFvX3RhYmxlX3dpemFyZF9jZWxsX3NpemUnKTtcblxuXHRcdGlmIChmYWN0b3IgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0c2l6ZSA9ICcnO1xuXHRcdFx0JCQoJy50bF90YWJsZXdpemFyZCB0ZXh0YXJlYScpLmVhY2goZnVuY3Rpb24oZWwpIHtcblx0XHRcdFx0ZWwuc2V0U3R5bGUoJ3dpZHRoJywgKGVsLmdldFN0eWxlKCd3aWR0aCcpLnRvSW50KCkgKiBmYWN0b3IpLnJvdW5kKCkubGltaXQoMTQyLCAyODQpKTtcblx0XHRcdFx0ZWwuc2V0U3R5bGUoJ2hlaWdodCcsIChlbC5nZXRTdHlsZSgnaGVpZ2h0JykudG9JbnQoKSAqIGZhY3Rvcikucm91bmQoKS5saW1pdCg2NiwgMTMyKSk7XG5cdFx0XHRcdGlmIChzaXplID09ICcnKSB7XG5cdFx0XHRcdFx0c2l6ZSA9IGVsLmdldFN0eWxlKCd3aWR0aCcpICsgJ3wnICsgZWwuZ2V0U3R5bGUoJ2hlaWdodCcpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnY29udGFvX3RhYmxlX3dpemFyZF9jZWxsX3NpemUnLCBzaXplKTtcblx0XHR9IGVsc2UgaWYgKHNpemUgIT09IG51bGwpIHtcblx0XHRcdHZhciBjaHVua3MgPSBzaXplLnNwbGl0KCd8Jyk7XG5cdFx0XHQkJCgnLnRsX3RhYmxld2l6YXJkIHRleHRhcmVhJykuZWFjaChmdW5jdGlvbihlbCkge1xuXHRcdFx0XHRlbC5zZXRTdHlsZSgnd2lkdGgnLCBjaHVua3NbMF0pO1xuXHRcdFx0XHRlbC5zZXRTdHlsZSgnaGVpZ2h0JywgY2h1bmtzWzFdKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogU2V0IHRoZSB3aWR0aCBvZiB0aGUgdGFibGUgd2l6YXJkXG5cdCAqL1xuXHR0YWJsZVdpemFyZFNldFdpZHRoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgd3JhcCA9ICQoJ3RsX3RhYmxld2l6YXJkJyk7XG5cdFx0aWYgKCF3cmFwKSByZXR1cm47XG5cdFx0d3JhcC5zZXRTdHlsZSgnd2lkdGgnLCBNYXRoLnJvdW5kKHdyYXAuZ2V0UGFyZW50KCcudGxfZm9ybWJvZHlfZWRpdCcpLmdldENvbXB1dGVkU2l6ZSgpLndpZHRoICogMC45NikpO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBPcHRpb25zIHdpemFyZFxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIElEIG9mIHRoZSB0YXJnZXQgZWxlbWVudFxuXHQgKi9cblx0b3B0aW9uc1dpemFyZDogZnVuY3Rpb24oaWQpIHtcblx0XHRjb25zb2xlLndhcm4oJ0JhY2tlbmQub3B0aW9uc1dpemFyZCgpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgdGhlIHN0aW11bHVzIGNvbnRyb2xsZXIgaW5zdGVhZC4nKTtcblxuXHRcdHZhciB0YWJsZSA9ICQoaWQpLFxuXHRcdFx0dGJvZHkgPSB0YWJsZS5nZXRFbGVtZW50KCd0Ym9keScpLFxuXHRcdFx0bWFrZVNvcnRhYmxlID0gZnVuY3Rpb24odGJvZHkpIHtcblx0XHRcdFx0dmFyIHJvd3MgPSB0Ym9keS5nZXRDaGlsZHJlbigpLFxuXHRcdFx0XHRcdGNoaWxkcmVuLCBpLCBqLCBpbnB1dDtcblxuXHRcdFx0XHRmb3IgKGk9MDsgaTxyb3dzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0Y2hpbGRyZW4gPSByb3dzW2ldLmdldENoaWxkcmVuKCk7XG5cdFx0XHRcdFx0Zm9yIChqPTA7IGo8Y2hpbGRyZW4ubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHRcdGlmIChpbnB1dCA9IGNoaWxkcmVuW2pdLmdldEZpcnN0KCdpbnB1dCcpKSB7XG5cdFx0XHRcdFx0XHRcdGlucHV0Lm5hbWUgPSBpbnB1dC5uYW1lLnJlcGxhY2UoL1xcW1swLTldK10vZywgJ1snICsgaSArICddJyk7XG5cdFx0XHRcdFx0XHRcdGlmIChpbnB1dC50eXBlID09ICdjaGVja2JveCcpIHtcblx0XHRcdFx0XHRcdFx0XHRpbnB1dC5pZCA9IGlucHV0Lm5hbWUucmVwbGFjZSgvXFxbWzAtOV0rXS9nLCAnJykucmVwbGFjZSgvXFxbL2csICdfJykucmVwbGFjZSgvXS9nLCAnJykgKyAnXycgKyBpO1xuXHRcdFx0XHRcdFx0XHRcdGlucHV0LmdldE5leHQoJ2xhYmVsJykuc2V0KCdmb3InLCBpbnB1dC5pZCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRuZXcgU29ydGFibGVzKHRib2R5LCB7XG5cdFx0XHRcdFx0Y29uc3RyYWluOiB0cnVlLFxuXHRcdFx0XHRcdG9wYWNpdHk6IDAuNixcblx0XHRcdFx0XHRoYW5kbGU6ICcuZHJhZy1oYW5kbGUnLFxuXHRcdFx0XHRcdG9uQ29tcGxldGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0bWFrZVNvcnRhYmxlKHRib2R5KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSxcblx0XHRcdGFkZEV2ZW50c1RvID0gZnVuY3Rpb24odHIpIHtcblx0XHRcdFx0dmFyIGNvbW1hbmQsIGlucHV0LCBuZXh0LCBudHIsIGNoaWxkcmVuLCBpO1xuXHRcdFx0XHR0ci5nZXRFbGVtZW50cygnYnV0dG9uJykuZWFjaChmdW5jdGlvbihidCkge1xuXHRcdFx0XHRcdGlmIChidC5oYXNFdmVudCgnY2xpY2snKSkgcmV0dXJuO1xuXHRcdFx0XHRcdGNvbW1hbmQgPSBidC5nZXRQcm9wZXJ0eSgnZGF0YS1jb21tYW5kJyk7XG5cblx0XHRcdFx0XHRzd2l0Y2ggKGNvbW1hbmQpIHtcblx0XHRcdFx0XHRcdGNhc2UgJ2NvcHknOlxuXHRcdFx0XHRcdFx0XHRidC5hZGRFdmVudCgnY2xpY2snLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHR3aW5kb3cuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ3N0b3JlLXNjcm9sbC1vZmZzZXQnKSk7XG5cdFx0XHRcdFx0XHRcdFx0bnRyID0gbmV3IEVsZW1lbnQoJ3RyJyk7XG5cdFx0XHRcdFx0XHRcdFx0Y2hpbGRyZW4gPSB0ci5nZXRDaGlsZHJlbigpO1xuXHRcdFx0XHRcdFx0XHRcdGZvciAoaT0wOyBpPGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRuZXh0ID0gY2hpbGRyZW5baV0uY2xvbmUodHJ1ZSkuaW5qZWN0KG50ciwgJ2JvdHRvbScpO1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKGlucHV0ID0gY2hpbGRyZW5baV0uZ2V0Rmlyc3QoJ2lucHV0JykpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0bmV4dC5nZXRGaXJzdCgnaW5wdXQnKS52YWx1ZSA9IGlucHV0LnZhbHVlO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoaW5wdXQudHlwZSA9PSAnY2hlY2tib3gnKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bmV4dC5nZXRGaXJzdCgnaW5wdXQnKS5jaGVja2VkID0gaW5wdXQuY2hlY2tlZCA/ICdjaGVja2VkJyA6ICcnO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdG50ci5pbmplY3QodHIsICdhZnRlcicpO1xuXHRcdFx0XHRcdFx0XHRcdGFkZEV2ZW50c1RvKG50cik7XG5cdFx0XHRcdFx0XHRcdFx0bWFrZVNvcnRhYmxlKHRib2R5KTtcblx0XHRcdFx0XHRcdFx0XHRudHIuZ2V0Rmlyc3QoJ3RkJykuZ2V0Rmlyc3QoJ2lucHV0Jykuc2VsZWN0KCk7XG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgJ2RlbGV0ZSc6XG5cdFx0XHRcdFx0XHRcdGJ0LmFkZEV2ZW50KCdjbGljaycsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdHdpbmRvdy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnc3RvcmUtc2Nyb2xsLW9mZnNldCcpKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAodGJvZHkuZ2V0Q2hpbGRyZW4oKS5sZW5ndGggPiAxKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHR0ci5kZXN0cm95KCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdG1ha2VTb3J0YWJsZSh0Ym9keSk7XG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdGNhc2UgbnVsbDpcblx0XHRcdFx0XHRcdFx0YnQuYWRkRXZlbnQoJ2tleWRvd24nLCBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKGUuZXZlbnQua2V5Q29kZSA9PSAzOCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKG50ciA9IHRyLmdldFByZXZpb3VzKCd0cicpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRyLmluamVjdChudHIsICdiZWZvcmUnKTtcblx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRyLmluamVjdCh0Ym9keSwgJ2JvdHRvbScpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0YnQuZm9jdXMoKTtcblx0XHRcdFx0XHRcdFx0XHRcdG1ha2VTb3J0YWJsZSh0Ym9keSk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmIChlLmV2ZW50LmtleUNvZGUgPT0gNDApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdFx0XHRcdGlmIChudHIgPSB0ci5nZXROZXh0KCd0cicpKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRyLmluamVjdChudHIsICdhZnRlcicpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHIuaW5qZWN0KHRib2R5LCAndG9wJyk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRidC5mb2N1cygpO1xuXHRcdFx0XHRcdFx0XHRcdFx0bWFrZVNvcnRhYmxlKHRib2R5KTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0fTtcblxuXHRcdG1ha2VTb3J0YWJsZSh0Ym9keSk7XG5cblx0XHR0Ym9keS5nZXRDaGlsZHJlbigpLmVhY2goZnVuY3Rpb24odHIpIHtcblx0XHRcdGFkZEV2ZW50c1RvKHRyKTtcblx0XHR9KTtcblx0fSxcblxuXHQvKipcblx0ICogS2V5L3ZhbHVlIHdpemFyZFxuXHQgKlxuXHQgKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIElEIG9mIHRoZSB0YXJnZXQgZWxlbWVudFxuXHQgKi9cblx0a2V5VmFsdWVXaXphcmQ6IGZ1bmN0aW9uKGlkKSB7XG5cdFx0Y29uc29sZS53YXJuKCdCYWNrZW5kLmtleVZhbHVlV2l6YXJkKCkgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSB0aGUgc3RpbXVsdXMgY29udHJvbGxlciBpbnN0ZWFkLicpO1xuXG5cdFx0dmFyIHRhYmxlID0gJChpZCksXG5cdFx0XHR0Ym9keSA9IHRhYmxlLmdldEVsZW1lbnQoJ3Rib2R5JyksXG5cdFx0XHRtYWtlU29ydGFibGUgPSBmdW5jdGlvbih0Ym9keSkge1xuXHRcdFx0XHR2YXIgcm93cyA9IHRib2R5LmdldENoaWxkcmVuKCksXG5cdFx0XHRcdFx0Y2hpbGRyZW4sIGksIGosIGlucHV0O1xuXG5cdFx0XHRcdGZvciAoaT0wOyBpPHJvd3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRjaGlsZHJlbiA9IHJvd3NbaV0uZ2V0Q2hpbGRyZW4oKTtcblx0XHRcdFx0XHRmb3IgKGo9MDsgajxjaGlsZHJlbi5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRcdFx0aWYgKGlucHV0ID0gY2hpbGRyZW5bal0uZ2V0Rmlyc3QoJ2lucHV0JykpIHtcblx0XHRcdFx0XHRcdFx0aW5wdXQubmFtZSA9IGlucHV0Lm5hbWUucmVwbGFjZSgvXFxbWzAtOV0rXS9nLCAnWycgKyBpICsgJ10nKVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdG5ldyBTb3J0YWJsZXModGJvZHksIHtcblx0XHRcdFx0XHRjb25zdHJhaW46IHRydWUsXG5cdFx0XHRcdFx0b3BhY2l0eTogMC42LFxuXHRcdFx0XHRcdGhhbmRsZTogJy5kcmFnLWhhbmRsZScsXG5cdFx0XHRcdFx0b25Db21wbGV0ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRtYWtlU29ydGFibGUodGJvZHkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9LFxuXHRcdFx0YWRkRXZlbnRzVG8gPSBmdW5jdGlvbih0cikge1xuXHRcdFx0XHR2YXIgY29tbWFuZCwgaW5wdXQsIG5leHQsIG50ciwgY2hpbGRyZW4sIGk7XG5cdFx0XHRcdHRyLmdldEVsZW1lbnRzKCdidXR0b24nKS5lYWNoKGZ1bmN0aW9uKGJ0KSB7XG5cdFx0XHRcdFx0aWYgKGJ0Lmhhc0V2ZW50KCdjbGljaycpKSByZXR1cm47XG5cdFx0XHRcdFx0Y29tbWFuZCA9IGJ0LmdldFByb3BlcnR5KCdkYXRhLWNvbW1hbmQnKTtcblxuXHRcdFx0XHRcdHN3aXRjaCAoY29tbWFuZCkge1xuXHRcdFx0XHRcdFx0Y2FzZSAnY29weSc6XG5cdFx0XHRcdFx0XHRcdGJ0LmFkZEV2ZW50KCdjbGljaycsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdHdpbmRvdy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnc3RvcmUtc2Nyb2xsLW9mZnNldCcpKTtcblx0XHRcdFx0XHRcdFx0XHRudHIgPSBuZXcgRWxlbWVudCgndHInKTtcblx0XHRcdFx0XHRcdFx0XHRjaGlsZHJlbiA9IHRyLmdldENoaWxkcmVuKCk7XG5cdFx0XHRcdFx0XHRcdFx0Zm9yIChpPTA7IGk8Y2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRcdG5leHQgPSBjaGlsZHJlbltpXS5jbG9uZSh0cnVlKS5pbmplY3QobnRyLCAnYm90dG9tJyk7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoaW5wdXQgPSBjaGlsZHJlbltpXS5nZXRGaXJzdCgnaW5wdXQnKSkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRuZXh0LmdldEZpcnN0KCkudmFsdWUgPSBpbnB1dC52YWx1ZTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0bnRyLmluamVjdCh0ciwgJ2FmdGVyJyk7XG5cdFx0XHRcdFx0XHRcdFx0YWRkRXZlbnRzVG8obnRyKTtcblx0XHRcdFx0XHRcdFx0XHRtYWtlU29ydGFibGUodGJvZHkpO1xuXHRcdFx0XHRcdFx0XHRcdG50ci5nZXRGaXJzdCgndGQnKS5nZXRGaXJzdCgnaW5wdXQnKS5zZWxlY3QoKTtcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnZGVsZXRlJzpcblx0XHRcdFx0XHRcdFx0YnQuYWRkRXZlbnQoJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0d2luZG93LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdzdG9yZS1zY3JvbGwtb2Zmc2V0JykpO1xuXHRcdFx0XHRcdFx0XHRcdGlmICh0Ym9keS5nZXRDaGlsZHJlbigpLmxlbmd0aCA+IDEpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHRyLmRlc3Ryb3koKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0bWFrZVNvcnRhYmxlKHRib2R5KTtcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSBudWxsOlxuXHRcdFx0XHRcdFx0XHRidC5hZGRFdmVudCgna2V5ZG93bicsIGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoZS5ldmVudC5rZXlDb2RlID09IDM4KSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAobnRyID0gdHIuZ2V0UHJldmlvdXMoJ3RyJykpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHIuaW5qZWN0KG50ciwgJ2JlZm9yZScpO1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHIuaW5qZWN0KHRib2R5LCAnYm90dG9tJyk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRidC5mb2N1cygpO1xuXHRcdFx0XHRcdFx0XHRcdFx0bWFrZVNvcnRhYmxlKHRib2R5KTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGUuZXZlbnQua2V5Q29kZSA9PSA0MCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKG50ciA9IHRyLmdldE5leHQoJ3RyJykpIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dHIuaW5qZWN0KG50ciwgJ2FmdGVyJyk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0ci5pbmplY3QodGJvZHksICd0b3AnKTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdGJ0LmZvY3VzKCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRtYWtlU29ydGFibGUodGJvZHkpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9O1xuXG5cdFx0bWFrZVNvcnRhYmxlKHRib2R5KTtcblxuXHRcdHRib2R5LmdldENoaWxkcmVuKCkuZWFjaChmdW5jdGlvbih0cikge1xuXHRcdFx0YWRkRXZlbnRzVG8odHIpO1xuXHRcdH0pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDaGVja2JveCB3aXphcmRcblx0ICpcblx0ICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSBJRCBvZiB0aGUgdGFyZ2V0IGVsZW1lbnRcblx0ICovXG5cdGNoZWNrYm94V2l6YXJkOiBmdW5jdGlvbihpZCkge1xuXHRcdGNvbnNvbGUud2FybignQmFja2VuZC5jaGVja2JveFdpemFyZCgpIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgdGhlIFN0aW11bHVzIGNvbnRyb2xsZXIgaW5zdGVhZC4nKTtcblxuXHRcdHZhciBjb250YWluZXIgPSAkKGlkKS5nZXRFbGVtZW50KCcuc29ydGFibGUnKSxcblx0XHRcdG1ha2VTb3J0YWJsZSA9IGZ1bmN0aW9uKGNvbnRhaW5lcikge1xuXHRcdFx0XHRuZXcgU29ydGFibGVzKGNvbnRhaW5lciwge1xuXHRcdFx0XHRcdGNvbnN0cmFpbjogdHJ1ZSxcblx0XHRcdFx0XHRvcGFjaXR5OiAwLjYsXG5cdFx0XHRcdFx0aGFuZGxlOiAnLmRyYWctaGFuZGxlJ1xuXHRcdFx0XHR9KTtcblx0XHRcdH0sXG5cdFx0XHRhZGRFdmVudHNUbyA9IGZ1bmN0aW9uKHNwYW4pIHtcblx0XHRcdFx0dmFyIG5zcGFuO1xuXHRcdFx0XHRzcGFuLmdldEVsZW1lbnRzKCdidXR0b24nKS5lYWNoKGZ1bmN0aW9uKGJ0KSB7XG5cdFx0XHRcdFx0aWYgKGJ0Lmhhc0V2ZW50KCdjbGljaycpKSByZXR1cm47XG5cdFx0XHRcdFx0YnQuYWRkRXZlbnQoJ2tleWRvd24nLCBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdFx0XHRpZiAoZS5ldmVudC5rZXlDb2RlID09IDM4KSB7XG5cdFx0XHRcdFx0XHRcdGUucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdFx0aWYgKChuc3BhbiA9IHNwYW4uZ2V0UHJldmlvdXMoJ3NwYW4nKSkpIHtcblx0XHRcdFx0XHRcdFx0XHRzcGFuLmluamVjdChuc3BhbiwgJ2JlZm9yZScpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHNwYW4uaW5qZWN0KGNvbnRhaW5lciwgJ2JvdHRvbScpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGJ0LmZvY3VzKCk7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKGUuZXZlbnQua2V5Q29kZSA9PSA0MCkge1xuXHRcdFx0XHRcdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRcdGlmIChuc3BhbiA9IHNwYW4uZ2V0TmV4dCgnc3BhbicpKSB7XG5cdFx0XHRcdFx0XHRcdFx0c3Bhbi5pbmplY3QobnNwYW4sICdhZnRlcicpO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHNwYW4uaW5qZWN0KGNvbnRhaW5lciwgJ3RvcCcpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGJ0LmZvY3VzKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fTtcblxuXHRcdG1ha2VTb3J0YWJsZShjb250YWluZXIpO1xuXG5cdFx0Y29udGFpbmVyLmdldENoaWxkcmVuKCkuZWFjaChmdW5jdGlvbihzcGFuKSB7XG5cdFx0XHRhZGRFdmVudHNUbyhzcGFuKTtcblx0XHR9KTtcblx0fSxcblxuXHQvKipcblx0ICogVXBkYXRlIHRoZSBmaWVsZHMgb2YgdGhlIGltYWdlU2l6ZSB3aWRnZXQgdXBvbiBjaGFuZ2Vcblx0ICovXG5cdGVuYWJsZUltYWdlU2l6ZVdpZGdldHM6IGZ1bmN0aW9uKCkge1xuXHRcdCQkKCcudGxfaW1hZ2Vfc2l6ZScpLmVhY2goZnVuY3Rpb24oZWwpIHtcblx0XHRcdHZhciBzZWxlY3QgPSBlbC5nZXRFbGVtZW50KCdzZWxlY3QnKSxcblx0XHRcdFx0d2lkdGhJbnB1dCA9IGVsLmdldENoaWxkcmVuKCdpbnB1dCcpWzBdLFxuXHRcdFx0XHRoZWlnaHRJbnB1dCA9IGVsLmdldENoaWxkcmVuKCdpbnB1dCcpWzFdLFxuXHRcdFx0XHR1cGRhdGUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoc2VsZWN0LmdldCgndmFsdWUnKSA9PT0gJycgfHwgc2VsZWN0LmdldCgndmFsdWUnKS5pbmRleE9mKCdfJykgPT09IDAgfHwgc2VsZWN0LmdldCgndmFsdWUnKS50b0ludCgpLnRvU3RyaW5nKCkgPT09IHNlbGVjdC5nZXQoJ3ZhbHVlJykpIHtcblx0XHRcdFx0XHRcdHdpZHRoSW5wdXQucmVhZE9ubHkgPSB0cnVlO1xuXHRcdFx0XHRcdFx0aGVpZ2h0SW5wdXQucmVhZE9ubHkgPSB0cnVlO1xuXHRcdFx0XHRcdFx0dmFyIGRpbWVuc2lvbnMgPSAkKHNlbGVjdC5nZXRTZWxlY3RlZCgpWzBdKS5nZXQoJ3RleHQnKTtcblx0XHRcdFx0XHRcdGRpbWVuc2lvbnMgPSBkaW1lbnNpb25zLnNwbGl0KCcoJykubGVuZ3RoID4gMVxuXHRcdFx0XHRcdFx0XHQ/IGRpbWVuc2lvbnMuc3BsaXQoJygnKS5nZXRMYXN0KCkuc3BsaXQoJyknKVswXS5zcGxpdCgneCcpXG5cdFx0XHRcdFx0XHRcdDogWycnLCAnJ107XG5cdFx0XHRcdFx0XHR3aWR0aElucHV0LnNldCgndmFsdWUnLCAnJykuc2V0KCdwbGFjZWhvbGRlcicsIGRpbWVuc2lvbnNbMF0gKiAxIHx8ICcnKTtcblx0XHRcdFx0XHRcdGhlaWdodElucHV0LnNldCgndmFsdWUnLCAnJykuc2V0KCdwbGFjZWhvbGRlcicsIGRpbWVuc2lvbnNbMV0gKiAxIHx8ICcnKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0d2lkdGhJbnB1dC5zZXQoJ3BsYWNlaG9sZGVyJywgJycpO1xuXHRcdFx0XHRcdFx0aGVpZ2h0SW5wdXQuc2V0KCdwbGFjZWhvbGRlcicsICcnKTtcblx0XHRcdFx0XHRcdHdpZHRoSW5wdXQucmVhZE9ubHkgPSBmYWxzZTtcblx0XHRcdFx0XHRcdGhlaWdodElucHV0LnJlYWRPbmx5ID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHQ7XG5cblx0XHRcdHVwZGF0ZSgpO1xuXHRcdFx0c2VsZWN0LmFkZEV2ZW50KCdjaGFuZ2UnLCB1cGRhdGUpO1xuXHRcdFx0c2VsZWN0LmFkZEV2ZW50KCdrZXl1cCcsIHVwZGF0ZSk7XG5cdFx0fSk7XG5cdH0sXG5cblx0LyoqXG5cdCAqIEFsbG93IHRvZ2dsaW5nIGNoZWNrYm94ZXMgb3IgcmFkaW8gYnV0dG9ucyBieSBjbGlja2luZyBhIHJvd1xuXHQgKlxuXHQgKiBAYXV0aG9yIEthbWlsIEt1em1pbnNraVxuXHQgKi9cblx0ZW5hYmxlVG9nZ2xlU2VsZWN0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY29udGFpbmVyID0gJCgndGxfbGlzdGluZycpLFxuXHRcdFx0c2hpZnRUb2dnbGUgPSBmdW5jdGlvbihlbCkge1xuXHRcdFx0XHR0aGlzSW5kZXggPSBjaGVja2JveGVzLmluZGV4T2YoZWwpO1xuXHRcdFx0XHRzdGFydEluZGV4ID0gY2hlY2tib3hlcy5pbmRleE9mKHN0YXJ0KTtcblx0XHRcdFx0ZnJvbSA9IE1hdGgubWluKHRoaXNJbmRleCwgc3RhcnRJbmRleCk7XG5cdFx0XHRcdHRvID0gTWF0aC5tYXgodGhpc0luZGV4LCBzdGFydEluZGV4KTtcblx0XHRcdFx0c3RhdHVzID0gISFjaGVja2JveGVzW3N0YXJ0SW5kZXhdLmNoZWNrZWQ7XG5cblx0XHRcdFx0Zm9yIChmcm9tOyBmcm9tPD10bzsgZnJvbSsrKSB7XG5cdFx0XHRcdFx0Y2hlY2tib3hlc1tmcm9tXS5jaGVja2VkID0gc3RhdHVzO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0Y2xpY2tFdmVudCA9IGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0aWYgKGUudGFyZ2V0IGluc3RhbmNlb2YgSFRNTEFuY2hvckVsZW1lbnQgfHwgZS50YXJnZXQgaW5zdGFuY2VvZiBIVE1MQnV0dG9uRWxlbWVudCB8fCBlLnRhcmdldCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQgfHwgZS50YXJnZXQ/LmNsb3Nlc3QoJ2EsIGJ1dHRvbiwgaW5wdXQsIC5vcGVyYXRpb25zJykpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR2YXIgaW5wdXQgPSB0aGlzLmdldEVsZW1lbnQoJ2lucHV0W3R5cGU9XCJjaGVja2JveFwiXSxpbnB1dFt0eXBlPVwicmFkaW9cIl0nKSxcblx0XHRcdFx0XHRsaW1pdFRvZ2dsZXIgPSAkKGUudGFyZ2V0KS5nZXRQYXJlbnQoJy5saW1pdF90b2dnbGVyJyk7XG5cblx0XHRcdFx0aWYgKCFpbnB1dCB8fCBpbnB1dC5nZXQoJ2Rpc2FibGVkJykgfHwgbGltaXRUb2dnbGVyICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmFkaW8gYnV0dG9uc1xuXHRcdFx0XHRpZiAoaW5wdXQudHlwZSA9PSAncmFkaW8nKSB7XG5cdFx0XHRcdFx0aWYgKCFpbnB1dC5jaGVja2VkKSB7XG5cdFx0XHRcdFx0XHRpbnB1dC5jaGVja2VkID0gJ2NoZWNrZWQnO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENoZWNrYm94ZXNcblx0XHRcdFx0aWYgKGUuc2hpZnQgJiYgc3RhcnQpIHtcblx0XHRcdFx0XHRzaGlmdFRvZ2dsZShpbnB1dCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aW5wdXQuY2hlY2tlZCA9IGlucHV0LmNoZWNrZWQgPyAnJyA6ICdjaGVja2VkJztcblxuXHRcdFx0XHRcdGlmIChpbnB1dC5nZXQoJ29uY2xpY2snKSA9PSAnQmFja2VuZC50b2dnbGVDaGVja2JveGVzKHRoaXMpJykge1xuXHRcdFx0XHRcdFx0QmFja2VuZC50b2dnbGVDaGVja2JveGVzKGlucHV0KTsgLy8gc2VlICM2Mzk5XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0c3RhcnQgPSBpbnB1dDtcblx0XHRcdH0sXG5cdFx0XHRjaGVja2JveGVzID0gW10sIHN0YXJ0LCB0aGlzSW5kZXgsIHN0YXJ0SW5kZXgsIHN0YXR1cywgZnJvbSwgdG87XG5cblx0XHRpZiAoY29udGFpbmVyKSB7XG5cdFx0XHRjaGVja2JveGVzID0gY29udGFpbmVyLmdldEVsZW1lbnRzKCdpbnB1dFt0eXBlPVwiY2hlY2tib3hcIl0nKTtcblx0XHR9XG5cblx0XHQvLyBSb3cgY2xpY2tcblx0XHQkJCgnLnRvZ2dsZV9zZWxlY3QnKS5lYWNoKGZ1bmN0aW9uKGVsKSB7XG5cdFx0XHR2YXIgYm91bmRFdmVudCA9IGVsLnJldHJpZXZlKCdib3VuZEV2ZW50Jyk7XG5cblx0XHRcdGlmIChib3VuZEV2ZW50KSB7XG5cdFx0XHRcdGVsLnJlbW92ZUV2ZW50KCdjbGljaycsIGJvdW5kRXZlbnQpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBEbyBub3QgcHJvcGFnYXRlIHRoZSBmb3JtIGZpZWxkIGNsaWNrIGV2ZW50c1xuXHRcdFx0ZWwuZ2V0RWxlbWVudHMoJ2xhYmVsLGlucHV0W3R5cGU9XCJjaGVja2JveFwiXSxpbnB1dFt0eXBlPVwicmFkaW9cIl0nKS5lYWNoKGZ1bmN0aW9uKGkpIHtcblx0XHRcdFx0aS5hZGRFdmVudCgnY2xpY2snLCBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ym91bmRFdmVudCA9IGNsaWNrRXZlbnQuYmluZChlbCk7XG5cblx0XHRcdGVsLmFkZEV2ZW50KCdjbGljaycsIGJvdW5kRXZlbnQpO1xuXHRcdFx0ZWwuc3RvcmUoJ2JvdW5kRXZlbnQnLCBib3VuZEV2ZW50KTtcblx0XHR9KTtcblxuXHRcdC8vIENoZWNrYm94IGNsaWNrXG5cdFx0Y2hlY2tib3hlcy5lYWNoKGZ1bmN0aW9uKGVsKSB7XG5cdFx0XHRlbC5hZGRFdmVudCgnY2xpY2snLCBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdGlmIChlLnNoaWZ0ICYmIHN0YXJ0KSB7XG5cdFx0XHRcdFx0c2hpZnRUb2dnbGUodGhpcyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRzdGFydCA9IHRoaXM7XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0fSxcblxuXHQvKipcblx0ICogQWxsb3cgdG8gbWFyayB0aGUgaW1wb3J0YW50IHBhcnQgb2YgYW4gaW1hZ2Vcblx0ICpcblx0ICogQHBhcmFtIHtvYmplY3R9IGVsIFRoZSBET00gZWxlbWVudFxuXHQgKi9cblx0ZWRpdFByZXZpZXdXaXphcmQ6IGZ1bmN0aW9uKGVsKSB7XG5cdFx0ZWwgPSAkKGVsKTtcblx0XHR2YXIgaW1hZ2VFbGVtZW50ID0gZWwuZ2V0RWxlbWVudCgnaW1nJyksXG5cdFx0XHRpbnB1dEVsZW1lbnRzID0ge30sXG5cdFx0XHRpc0RyYXdpbmcgPSBmYWxzZSxcblx0XHRcdHBhcnRFbGVtZW50LCBzdGFydFBvcyxcblx0XHRcdGdldFNjYWxlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0eDogaW1hZ2VFbGVtZW50LmdldENvbXB1dGVkU2l6ZSgpLndpZHRoLFxuXHRcdFx0XHRcdHk6IGltYWdlRWxlbWVudC5nZXRDb21wdXRlZFNpemUoKS5oZWlnaHRcblx0XHRcdFx0fTtcblx0XHRcdH0sXG5cdFx0XHR1cGRhdGVJbWFnZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgc2NhbGUgPSBnZXRTY2FsZSgpLFxuXHRcdFx0XHRcdGltYWdlU2l6ZSA9IGltYWdlRWxlbWVudC5nZXRDb21wdXRlZFNpemUoKTtcblx0XHRcdFx0cGFydEVsZW1lbnQuc2V0U3R5bGVzKHtcblx0XHRcdFx0XHR0b3A6IGltYWdlU2l6ZS5jb21wdXRlZFRvcCArIChpbnB1dEVsZW1lbnRzLnkuZ2V0KCd2YWx1ZScpICogc2NhbGUueSkucm91bmQoKSArICdweCcsXG5cdFx0XHRcdFx0bGVmdDogaW1hZ2VTaXplLmNvbXB1dGVkTGVmdCArIChpbnB1dEVsZW1lbnRzLnguZ2V0KCd2YWx1ZScpICogc2NhbGUueCkucm91bmQoKSArICdweCcsXG5cdFx0XHRcdFx0d2lkdGg6IChpbnB1dEVsZW1lbnRzLndpZHRoLmdldCgndmFsdWUnKSAqIHNjYWxlLngpLnJvdW5kKCkgKyAncHgnLFxuXHRcdFx0XHRcdGhlaWdodDogKGlucHV0RWxlbWVudHMuaGVpZ2h0LmdldCgndmFsdWUnKSAqIHNjYWxlLnkpLnJvdW5kKCkgKyAncHgnXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRpZiAoIWlucHV0RWxlbWVudHMud2lkdGguZ2V0KCd2YWx1ZScpLnRvRmxvYXQoKSB8fCAhaW5wdXRFbGVtZW50cy5oZWlnaHQuZ2V0KCd2YWx1ZScpLnRvRmxvYXQoKSkge1xuXHRcdFx0XHRcdHBhcnRFbGVtZW50LnNldFN0eWxlKCdkaXNwbGF5JywgJ25vbmUnKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwYXJ0RWxlbWVudC5zZXRTdHlsZSgnZGlzcGxheScsIG51bGwpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0dXBkYXRlVmFsdWVzID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBzY2FsZSA9IGdldFNjYWxlKCksXG5cdFx0XHRcdFx0c3R5bGVzID0gcGFydEVsZW1lbnQuZ2V0U3R5bGVzKCd0b3AnLCAnbGVmdCcsICd3aWR0aCcsICdoZWlnaHQnKSxcblx0XHRcdFx0XHRpbWFnZVNpemUgPSBpbWFnZUVsZW1lbnQuZ2V0Q29tcHV0ZWRTaXplKCksXG5cdFx0XHRcdFx0dmFsdWVzID0ge1xuXHRcdFx0XHRcdFx0eDogTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgKHN0eWxlcy5sZWZ0LnRvRmxvYXQoKSAtIGltYWdlU2l6ZS5jb21wdXRlZExlZnQpIC8gc2NhbGUueCkpLFxuXHRcdFx0XHRcdFx0eTogTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgKHN0eWxlcy50b3AudG9GbG9hdCgpIC0gaW1hZ2VTaXplLmNvbXB1dGVkVG9wKSAvIHNjYWxlLnkpKVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdHZhbHVlcy53aWR0aCA9IE1hdGgubWluKDEgLSB2YWx1ZXMueCwgc3R5bGVzLndpZHRoLnRvRmxvYXQoKSAvIHNjYWxlLngpO1xuXHRcdFx0XHR2YWx1ZXMuaGVpZ2h0ID0gTWF0aC5taW4oMSAtIHZhbHVlcy55LCBzdHlsZXMuaGVpZ2h0LnRvRmxvYXQoKSAvIHNjYWxlLnkpO1xuXHRcdFx0XHRpZiAoIXZhbHVlcy53aWR0aCB8fCAhdmFsdWVzLmhlaWdodCkge1xuXHRcdFx0XHRcdHZhbHVlcy54ID0gdmFsdWVzLnkgPSB2YWx1ZXMud2lkdGggPSB2YWx1ZXMuaGVpZ2h0ID0gJyc7XG5cdFx0XHRcdFx0cGFydEVsZW1lbnQuc2V0U3R5bGUoJ2Rpc3BsYXknLCAnbm9uZScpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHBhcnRFbGVtZW50LnNldFN0eWxlKCdkaXNwbGF5JywgbnVsbCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0T2JqZWN0LmVhY2godmFsdWVzLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG5cdFx0XHRcdFx0aW5wdXRFbGVtZW50c1trZXldLnNldCgndmFsdWUnLCB2YWx1ZSA9PT0gJycgPyAnJyA6IE51bWJlcih2YWx1ZSkudG9GaXhlZCgxNSkpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0sXG5cdFx0XHRzdGFydCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdGlmIChpc0RyYXdpbmcpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aXNEcmF3aW5nID0gdHJ1ZTtcblx0XHRcdFx0c3RhcnRQb3MgPSB7XG5cdFx0XHRcdFx0eDogZXZlbnQucGFnZS54IC0gZWwuZ2V0UG9zaXRpb24oKS54IC0gaW1hZ2VFbGVtZW50LmdldENvbXB1dGVkU2l6ZSgpLmNvbXB1dGVkTGVmdCxcblx0XHRcdFx0XHR5OiBldmVudC5wYWdlLnkgLSBlbC5nZXRQb3NpdGlvbigpLnkgLSBpbWFnZUVsZW1lbnQuZ2V0Q29tcHV0ZWRTaXplKCkuY29tcHV0ZWRUb3Bcblx0XHRcdFx0fTtcblx0XHRcdFx0bW92ZShldmVudCk7XG5cdFx0XHR9LFxuXHRcdFx0bW92ZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRcdGlmICghaXNEcmF3aW5nKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdHZhciBpbWFnZVNpemUgPSBpbWFnZUVsZW1lbnQuZ2V0Q29tcHV0ZWRTaXplKCk7XG5cdFx0XHRcdHZhciByZWN0ID0ge1xuXHRcdFx0XHRcdHg6IFtcblx0XHRcdFx0XHRcdE1hdGgubWF4KDAsIE1hdGgubWluKGltYWdlU2l6ZS53aWR0aCwgc3RhcnRQb3MueCkpLFxuXHRcdFx0XHRcdFx0TWF0aC5tYXgoMCwgTWF0aC5taW4oaW1hZ2VTaXplLndpZHRoLCBldmVudC5wYWdlLnggLSBlbC5nZXRQb3NpdGlvbigpLnggLSBpbWFnZVNpemUuY29tcHV0ZWRMZWZ0KSlcblx0XHRcdFx0XHRdLFxuXHRcdFx0XHRcdHk6IFtcblx0XHRcdFx0XHRcdE1hdGgubWF4KDAsIE1hdGgubWluKGltYWdlU2l6ZS5oZWlnaHQsIHN0YXJ0UG9zLnkpKSxcblx0XHRcdFx0XHRcdE1hdGgubWF4KDAsIE1hdGgubWluKGltYWdlU2l6ZS5oZWlnaHQsIGV2ZW50LnBhZ2UueSAtIGVsLmdldFBvc2l0aW9uKCkueSAtIGltYWdlU2l6ZS5jb21wdXRlZFRvcCkpXG5cdFx0XHRcdFx0XVxuXHRcdFx0XHR9O1xuXHRcdFx0XHRwYXJ0RWxlbWVudC5zZXRTdHlsZXMoe1xuXHRcdFx0XHRcdHRvcDogTWF0aC5taW4ocmVjdC55WzBdLCByZWN0LnlbMV0pICsgaW1hZ2VTaXplLmNvbXB1dGVkVG9wICsgJ3B4Jyxcblx0XHRcdFx0XHRsZWZ0OiBNYXRoLm1pbihyZWN0LnhbMF0sIHJlY3QueFsxXSkgKyBpbWFnZVNpemUuY29tcHV0ZWRMZWZ0ICsgJ3B4Jyxcblx0XHRcdFx0XHR3aWR0aDogTWF0aC5hYnMocmVjdC54WzBdIC0gcmVjdC54WzFdKSArICdweCcsXG5cdFx0XHRcdFx0aGVpZ2h0OiBNYXRoLmFicyhyZWN0LnlbMF0gLSByZWN0LnlbMV0pICsgJ3B4J1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0dXBkYXRlVmFsdWVzKCk7XG5cdFx0XHR9LFxuXHRcdFx0c3RvcCA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRcdG1vdmUoZXZlbnQpO1xuXHRcdFx0XHRpc0RyYXdpbmcgPSBmYWxzZTtcblx0XHRcdH0sXG5cdFx0XHRpbml0ID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGVsLmdldFBhcmVudCgnLnRsX3Rib3gsLnRsX2JveCcpLmdldEVsZW1lbnRzKCdpbnB1dFtuYW1lXj1cImltcG9ydGFudFBhcnRcIl0nKS5lYWNoKGZ1bmN0aW9uKGlucHV0KSB7XG5cdFx0XHRcdFx0Wyd4JywgJ3knLCAnd2lkdGgnLCAnaGVpZ2h0J10uZWFjaChmdW5jdGlvbihrZXkpIHtcblx0XHRcdFx0XHRcdGlmIChpbnB1dC5nZXQoJ25hbWUnKS5zdWJzdHIoMTMsIGtleS5sZW5ndGgpID09PSBrZXkuY2FwaXRhbGl6ZSgpKSB7XG5cdFx0XHRcdFx0XHRcdGlucHV0RWxlbWVudHNba2V5XSA9IGlucHV0ID0gJChpbnB1dCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRpZiAoT2JqZWN0LmdldExlbmd0aChpbnB1dEVsZW1lbnRzKSAhPT0gNCkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRPYmplY3QuZWFjaChpbnB1dEVsZW1lbnRzLCBmdW5jdGlvbihpbnB1dCkge1xuXHRcdFx0XHRcdGlucHV0LmdldFBhcmVudCgpLnNldFN0eWxlKCdkaXNwbGF5JywgJ25vbmUnKTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdGVsLmFkZENsYXNzKCd0bF9lZGl0X3ByZXZpZXdfZW5hYmxlZCcpO1xuXHRcdFx0XHRwYXJ0RWxlbWVudCA9IG5ldyBFbGVtZW50KCdkaXYnLCB7XG5cdFx0XHRcdFx0J2NsYXNzJzogJ3RsX2VkaXRfcHJldmlld19pbXBvcnRhbnRfcGFydCdcblx0XHRcdFx0fSkuaW5qZWN0KGVsKTtcblx0XHRcdFx0dXBkYXRlSW1hZ2UoKTtcblx0XHRcdFx0aW1hZ2VFbGVtZW50LmFkZEV2ZW50KCdsb2FkJywgdXBkYXRlSW1hZ2UpO1xuXHRcdFx0XHRlbC5hZGRFdmVudHMoe1xuXHRcdFx0XHRcdG1vdXNlZG93bjogc3RhcnQsXG5cdFx0XHRcdFx0dG91Y2hzdGFydDogc3RhcnRcblx0XHRcdFx0fSk7XG5cdFx0XHRcdCQoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KS5hZGRFdmVudHMoe1xuXHRcdFx0XHRcdG1vdXNlbW92ZTogbW92ZSxcblx0XHRcdFx0XHR0b3VjaG1vdmU6IG1vdmUsXG5cdFx0XHRcdFx0bW91c2V1cDogc3RvcCxcblx0XHRcdFx0XHR0b3VjaGVuZDogc3RvcCxcblx0XHRcdFx0XHR0b3VjaGNhbmNlbDogc3RvcCxcblx0XHRcdFx0XHRyZXNpemU6IHVwZGF0ZUltYWdlXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdDtcblxuXHRcdHdpbmRvdy5hZGRFdmVudCgnZG9tcmVhZHknLCBpbml0KTtcblx0fSxcblxuXHQvKipcblx0ICogRW5hYmxlIGRyYWcgYW5kIGRyb3AgZmlsZSB1cGxvYWQgZm9yIHRoZSBmaWxlIHRyZWVcblx0ICpcblx0ICogQHBhcmFtIHtvYmplY3R9IHdyYXAgICAgVGhlIERPTSBlbGVtZW50XG5cdCAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIEFuIG9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0XG5cdCAqL1xuXHRlbmFibGVGaWxlVHJlZVVwbG9hZDogZnVuY3Rpb24od3JhcCwgb3B0aW9ucykge1xuXHRcdHdyYXAgPSAkKHdyYXApO1xuXG5cdFx0dmFyIGZhbGxiYWNrVXJsID0gb3B0aW9ucy51cmwsXG5cdFx0XHRkekVsZW1lbnQgPSBuZXcgRWxlbWVudCgnZGl2Jywge1xuXHRcdFx0XHQnY2xhc3MnOiAnZHJvcHpvbmUgZHJvcHpvbmUtZmlsZXRyZWUnLFxuXHRcdFx0XHRodG1sOiAnPHNwYW4gY2xhc3M9XCJkcm9wem9uZS1wcmV2aWV3c1wiPjwvc3Bhbj4nXG5cdFx0XHR9KS5pbmplY3Qod3JhcCwgJ3RvcCcpLFxuXHRcdFx0Y3VycmVudEhvdmVyLCBjdXJyZW50SG92ZXJUaW1lLCBleHBhbmRMaW5rO1xuXG5cdFx0b3B0aW9ucy5wcmV2aWV3c0NvbnRhaW5lciA9IGR6RWxlbWVudC5nZXRFbGVtZW50KCcuZHJvcHpvbmUtcHJldmlld3MnKTtcblx0XHRvcHRpb25zLmNsaWNrYWJsZSA9IGZhbHNlO1xuXG5cdFx0dmFyIGR6ID0gbmV3IERyb3B6b25lKHdyYXAsIG9wdGlvbnMpO1xuXG5cdFx0ZHoub24oJ3F1ZXVlY29tcGxldGUnLCBmdW5jdGlvbigpIHtcblx0XHRcdHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcblx0XHR9KTtcblxuXHRcdGR6Lm9uKCdkcmFnb3ZlcicsIGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRpZiAoIWV2ZW50LmRhdGFUcmFuc2ZlciB8fCAhZXZlbnQuZGF0YVRyYW5zZmVyLnR5cGVzIHx8IGV2ZW50LmRhdGFUcmFuc2Zlci50eXBlcy5pbmRleE9mKCdGaWxlcycpID09PSAtMSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHdyYXAuZ2V0RWxlbWVudHMoJy50bF9mb2xkZXJfZHJvcHBpbmcnKS5yZW1vdmVDbGFzcygndGxfZm9sZGVyX2Ryb3BwaW5nJyk7XG5cdFx0XHR2YXIgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0ICYmICQoZXZlbnQudGFyZ2V0KTtcblxuXHRcdFx0aWYgKHRhcmdldCkge1xuXHRcdFx0XHR2YXIgZm9sZGVyID0gdGFyZ2V0Lm1hdGNoKCcudGxfZm9sZGVyJykgPyB0YXJnZXQgOiB0YXJnZXQuZ2V0UGFyZW50KCcudGxfZm9sZGVyJyk7XG5cblx0XHRcdFx0aWYgKCFmb2xkZXIpIHtcblx0XHRcdFx0XHRmb2xkZXIgPSB0YXJnZXQuZ2V0UGFyZW50KCcucGFyZW50Jyk7XG5cdFx0XHRcdFx0Zm9sZGVyID0gZm9sZGVyICYmIGZvbGRlci5nZXRQcmV2aW91cygnLnRsX2ZvbGRlcicpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGZvbGRlcikge1xuXHRcdFx0XHRcdHZhciBsaW5rID0gZm9sZGVyLmdldEVsZW1lbnQoJ2ltZ1tzcmMkPVwiL2ljb25zL25ldy5zdmdcIl0nKTtcblx0XHRcdFx0XHRsaW5rID0gbGluayAmJiBsaW5rLmdldFBhcmVudCgnYScpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmIChsaW5rICYmIGxpbmsuaHJlZikge1xuXHRcdFx0XHRkei5vcHRpb25zLnVybCA9ICcnK2xpbmsuaHJlZjtcblx0XHRcdFx0Zm9sZGVyLmFkZENsYXNzKCd0bF9mb2xkZXJfZHJvcHBpbmcnKTtcblxuXHRcdFx0XHRpZiAoY3VycmVudEhvdmVyICE9PSBmb2xkZXIpIHtcblx0XHRcdFx0XHRjdXJyZW50SG92ZXIgPSBmb2xkZXI7XG5cdFx0XHRcdFx0Y3VycmVudEhvdmVyVGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXHRcdFx0XHRcdGV4cGFuZExpbmsgPSBmb2xkZXIuZ2V0RWxlbWVudCgnYS5mb2xkYWJsZScpO1xuXG5cdFx0XHRcdFx0aWYgKGV4cGFuZExpbmsgJiYgIWV4cGFuZExpbmsuaGFzQ2xhc3MoJ2ZvbGRhYmxlLS1vcGVuJykpIHtcblx0XHRcdFx0XHRcdC8vIEV4cGFuZCB0aGUgZm9sZGVyIGFmdGVyIG9uZSBzZWNvbmQgaG92ZXIgdGltZVxuXHRcdFx0XHRcdFx0c2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0aWYgKGN1cnJlbnRIb3ZlciA9PT0gZm9sZGVyICYmIGN1cnJlbnRIb3ZlclRpbWUgKyA5MDAgPCBuZXcgRGF0ZSgpLmdldFRpbWUoKSkge1xuXHRcdFx0XHRcdFx0XHRcdHZhciBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdIVE1MRXZlbnRzJyk7XG5cdFx0XHRcdFx0XHRcdFx0ZXZlbnQuaW5pdEV2ZW50KCdjbGljaycsIHRydWUsIHRydWUpO1xuXHRcdFx0XHRcdFx0XHRcdGV4cGFuZExpbmsuZGlzcGF0Y2hFdmVudChldmVudCk7XG5cdFx0XHRcdFx0XHRcdFx0Y3VycmVudEhvdmVyID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHRcdGN1cnJlbnRIb3ZlclRpbWUgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0sIDEwMDApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZHoub3B0aW9ucy51cmwgPSBmYWxsYmFja1VybDtcblx0XHRcdFx0Y3VycmVudEhvdmVyID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRjdXJyZW50SG92ZXJUaW1lID0gdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0ZHoub24oJ2Ryb3AnLCBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0aWYgKCFldmVudC5kYXRhVHJhbnNmZXIgfHwgIWV2ZW50LmRhdGFUcmFuc2Zlci50eXBlcyB8fCBldmVudC5kYXRhVHJhbnNmZXIudHlwZXMuaW5kZXhPZignRmlsZXMnKSA9PT0gLTEpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRkekVsZW1lbnQuYWRkQ2xhc3MoJ2Ryb3B6b25lLWZpbGV0cmVlLWVuYWJsZWQnKTtcblx0XHRcdHdpbmRvdy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnc3RvcmUtc2Nyb2xsLW9mZnNldCcpKTtcblx0XHR9KTtcblxuXHRcdGR6Lm9uKCdkcmFnbGVhdmUnLCBmdW5jdGlvbigpIHtcblx0XHRcdHdyYXAuZ2V0RWxlbWVudHMoJy50bF9mb2xkZXJfZHJvcHBpbmcnKS5yZW1vdmVDbGFzcygndGxfZm9sZGVyX2Ryb3BwaW5nJyk7XG5cdFx0XHRjdXJyZW50SG92ZXIgPSB1bmRlZmluZWQ7XG5cdFx0XHRjdXJyZW50SG92ZXJUaW1lID0gdW5kZWZpbmVkO1xuXHRcdH0pO1xuXHR9LFxuXG5cdC8qKlxuXHQgKiBDcmF3bCB0aGUgd2Vic2l0ZVxuXHQgKi9cblx0Y3Jhd2w6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0aW1lb3V0ID0gMjAwMCxcblx0XHRcdGNyYXdsID0gJCgndGxfY3Jhd2wnKSxcblx0XHRcdHByb2dyZXNzQmFyID0gY3Jhd2wuZ2V0RWxlbWVudCgnZGl2LnByb2dyZXNzLWJhcicpLFxuXHRcdFx0cHJvZ3Jlc3NDb3VudCA9IGNyYXdsLmdldEVsZW1lbnQoJ3AucHJvZ3Jlc3MtY291bnQnKSxcblx0XHRcdHJlc3VsdHMgPSBjcmF3bC5nZXRFbGVtZW50KCdkaXYucmVzdWx0cycpLFxuXHRcdFx0ZGVidWdMb2cgPSBjcmF3bC5nZXRFbGVtZW50KCdwLmRlYnVnLWxvZycpO1xuXG5cdFx0ZnVuY3Rpb24gdXBkYXRlRGF0YShyZXNwb25zZSkge1xuXHRcdFx0dmFyIHRvdGFsID0gcmVzcG9uc2UudG90YWwsXG5cdFx0XHRcdGRvbmUgPSB0b3RhbCAtIHJlc3BvbnNlLnBlbmRpbmcsXG5cdFx0XHRcdHBlcmNlbnRhZ2UgPSB0b3RhbCA+IDAgPyBwYXJzZUludChkb25lIC8gdG90YWwgKiAxMDAsIDEwKSA6IDEwMCxcblx0XHRcdFx0cmVzdWx0O1xuXG5cdFx0XHQvLyBJbml0aWFsaXplIHRoZSBzdGF0dXMgYmFyIGF0IDEwJVxuXHRcdFx0aWYgKGRvbmUgPCAxICYmIHBlcmNlbnRhZ2UgPCAxKSB7XG5cdFx0XHRcdGRvbmUgPSAxO1xuXHRcdFx0XHRwZXJjZW50YWdlID0gMTA7XG5cdFx0XHRcdHRvdGFsID0gMTA7XG5cdFx0XHR9XG5cblx0XHRcdHByb2dyZXNzQmFyLnNldFN0eWxlKCd3aWR0aCcsIHBlcmNlbnRhZ2UgKyAnJScpO1xuXHRcdFx0cHJvZ3Jlc3NCYXIuc2V0KCdodG1sJywgcGVyY2VudGFnZSArICclJyk7XG5cdFx0XHRwcm9ncmVzc0Jhci5zZXRBdHRyaWJ1dGUoJ2FyaWEtdmFsdWVub3cnLCBwZXJjZW50YWdlKTtcblx0XHRcdHByb2dyZXNzQ291bnQuc2V0KCdodG1sJywgZG9uZSArICcgLyAnICsgdG90YWwpO1xuXG5cdFx0XHRpZiAocmVzcG9uc2UuaGFzRGVidWdMb2cpIHtcblx0XHRcdFx0ZGVidWdMb2cuc2V0U3R5bGUoJ2Rpc3BsYXknLCAnYmxvY2snKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKHJlc3BvbnNlLmhhc0RlYnVnTG9nKSB7XG5cdFx0XHRcdGRlYnVnTG9nLnNldFN0eWxlKCdkaXNwbGF5JywgJ2Jsb2NrJyk7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghcmVzcG9uc2UuZmluaXNoZWQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRwcm9ncmVzc0Jhci5yZW1vdmVDbGFzcygncnVubmluZycpLmFkZENsYXNzKCdmaW5pc2hlZCcpO1xuXHRcdFx0cmVzdWx0cy5yZW1vdmVDbGFzcygncnVubmluZycpLmFkZENsYXNzKCdmaW5pc2hlZCcpO1xuXG5cdFx0XHRmb3IgKHJlc3VsdCBpbiByZXNwb25zZS5yZXN1bHRzKSB7XG5cdFx0XHRcdGlmIChyZXNwb25zZS5yZXN1bHRzLmhhc093blByb3BlcnR5KHJlc3VsdCkpIHtcblx0XHRcdFx0XHR2YXIgc3VtbWFyeSA9IHJlc3VsdHMuZ2V0RWxlbWVudCgnLnJlc3VsdFtkYXRhLXN1YnNjcmliZXI9XCInICsgcmVzdWx0ICsgJ1wiXSBwLnN1bW1hcnknKSxcblx0XHRcdFx0XHRcdHdhcm5pbmcgPSByZXN1bHRzLmdldEVsZW1lbnQoJy5yZXN1bHRbZGF0YS1zdWJzY3JpYmVyPVwiJyArIHJlc3VsdCArICdcIl0gcC53YXJuaW5nJyksXG5cdFx0XHRcdFx0XHRsb2cgPSByZXN1bHRzLmdldEVsZW1lbnQoJy5yZXN1bHRbZGF0YS1zdWJzY3JpYmVyPVwiJyArIHJlc3VsdCArICdcIl0gcC5zdWJzY3JpYmVyLWxvZycpLFxuXHRcdFx0XHRcdFx0c3Vic2NyaWJlclJlc3VsdHMgPSByZXNwb25zZS5yZXN1bHRzW3Jlc3VsdF0sXG5cdFx0XHRcdFx0XHRzdWJzY3JpYmVyU3VtbWFyeSA9IHN1YnNjcmliZXJSZXN1bHRzLnN1bW1hcnk7XG5cblx0XHRcdFx0XHRpZiAoc3Vic2NyaWJlclJlc3VsdHMud2FybmluZykge1xuXHRcdFx0XHRcdFx0d2FybmluZy5zZXQoJ2h0bWwnLCBzdWJzY3JpYmVyUmVzdWx0cy53YXJuaW5nKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoc3Vic2NyaWJlclJlc3VsdHMuaGFzTG9nKSB7XG5cdFx0XHRcdFx0XHRsb2cuc2V0U3R5bGUoJ2Rpc3BsYXknLCAnYmxvY2snKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRzdW1tYXJ5LmFkZENsYXNzKHN1YnNjcmliZXJSZXN1bHRzLndhc1N1Y2Nlc3NmdWwgPyAnc3VjY2VzcycgOiAnZmFpbHVyZScpO1xuXHRcdFx0XHRcdHN1bW1hcnkuc2V0KCdodG1sJywgc3Vic2NyaWJlclN1bW1hcnkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZXhlY1JlcXVlc3Qob25seVN0YXR1c1VwZGF0ZSA9IGZhbHNlKSB7XG5cdFx0XHRuZXcgUmVxdWVzdCh7XG5cdFx0XHRcdHVybDogd2luZG93LmxvY2F0aW9uLmhyZWYsXG5cdFx0XHRcdGhlYWRlcnM6IHtcblx0XHRcdFx0XHQnT25seS1TdGF0dXMtVXBkYXRlJzogb25seVN0YXR1c1VwZGF0ZVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRvblN1Y2Nlc3M6IGZ1bmN0aW9uKHJlc3BvbnNlVGV4dCkge1xuXHRcdFx0XHRcdHZhciByZXNwb25zZSA9IEpTT04uZGVjb2RlKHJlc3BvbnNlVGV4dCk7XG5cblx0XHRcdFx0XHR1cGRhdGVEYXRhKHJlc3BvbnNlKTtcblxuXHRcdFx0XHRcdGlmICghcmVzcG9uc2UuZmluaXNoZWQpIHtcblx0XHRcdFx0XHRcdHNldFRpbWVvdXQoZXhlY1JlcXVlc3QsIHRpbWVvdXQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSkuc2VuZCgpO1xuXHRcdH1cblxuXHRcdGV4ZWNSZXF1ZXN0KHRydWUpO1xuXHR9XG59O1xuXG53aW5kb3cuVGhlbWUgPVxue1xuXHQvKipcblx0ICogQ2hlY2sgZm9yIFdlYktpdFxuXHQgKiBAbWVtYmVyIHtib29sZWFufVxuIFx0ICovXG5cdGlzV2Via2l0OiAoQnJvd3Nlci5jaHJvbWUgfHwgQnJvd3Nlci5zYWZhcmkgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvKD86d2Via2l0fGtodG1sKS9pKSksXG5cblx0LyoqXG5cdCAqIFN0b3AgdGhlIHByb3BhZ2F0aW9uIG9mIGNsaWNrIGV2ZW50cyBvZiBjZXJ0YWluIGVsZW1lbnRzXG5cdCAqL1xuXHRzdG9wQ2xpY2tQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0Ly8gRG8gbm90IHByb3BhZ2F0ZSB0aGUgY2xpY2sgZXZlbnRzIG9mIHRoZSBpY29uc1xuXHRcdCQkKCcucGlja2VyX3NlbGVjdG9yJykuZWFjaChmdW5jdGlvbih1bCkge1xuXHRcdFx0dWwuZ2V0RWxlbWVudHMoJ2EnKS5lYWNoKGZ1bmN0aW9uKGVsKSB7XG5cdFx0XHRcdGVsLmFkZEV2ZW50KCdjbGljaycsIGZ1bmN0aW9uKGUpIHtcblx0XHRcdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH0pO1xuXHRcdH0pO1xuXG5cdFx0Ly8gRG8gbm90IHByb3BhZ2F0ZSB0aGUgY2xpY2sgZXZlbnRzIG9mIHRoZSBjaGVja2JveGVzXG5cdFx0JCQoJy5waWNrZXJfc2VsZWN0b3IsLmNsaWNrMmVkaXQnKS5lYWNoKGZ1bmN0aW9uKHVsKSB7XG5cdFx0XHR1bC5nZXRFbGVtZW50cygnaW5wdXRbdHlwZT1cImNoZWNrYm94XCJdJykuZWFjaChmdW5jdGlvbihlbCkge1xuXHRcdFx0XHRlbC5hZGRFdmVudCgnY2xpY2snLCBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0fSxcblxuXHQvKipcblx0ICogU2V0IHVwIHRoZSB0ZXh0YXJlYSByZXNpemluZ1xuXHQgKi9cblx0c2V0dXBUZXh0YXJlYVJlc2l6aW5nOiBmdW5jdGlvbigpIHtcblx0XHQkJCgnLnRsX3RleHRhcmVhJykuZWFjaChmdW5jdGlvbihlbCkge1xuXHRcdFx0aWYgKEJyb3dzZXIuaWU2IHx8IEJyb3dzZXIuaWU3IHx8IEJyb3dzZXIuaWU4KSByZXR1cm47XG5cdFx0XHRpZiAoZWwuaGFzQ2xhc3MoJ25vcmVzaXplJykgfHwgZWwucmV0cmlldmUoJ2F1dG9ncm93JykpIHJldHVybjtcblxuXHRcdFx0Ly8gU2V0IHVwIHRoZSBkdW1teSBlbGVtZW50XG5cdFx0XHR2YXIgZHVtbXkgPSBuZXcgRWxlbWVudCgnZGl2Jywge1xuXHRcdFx0XHRodG1sOiAnWCcsXG5cdFx0XHRcdHN0eWxlczoge1xuXHRcdFx0XHRcdCdwb3NpdGlvbic6J2Fic29sdXRlJyxcblx0XHRcdFx0XHQndG9wJzowLFxuXHRcdFx0XHRcdCdsZWZ0JzonLTk5OWVtJyxcblx0XHRcdFx0XHQnb3ZlcmZsb3cteCc6J2hpZGRlbidcblx0XHRcdFx0fVxuXHRcdFx0fSkuc2V0U3R5bGVzKFxuXHRcdFx0XHRlbC5nZXRTdHlsZXMoJ2ZvbnQtc2l6ZScsICdmb250LWZhbWlseScsICd3aWR0aCcsICdsaW5lLWhlaWdodCcpXG5cdFx0XHQpLmluamVjdChkb2N1bWVudC5ib2R5KTtcblxuXHRcdFx0Ly8gQWxzbyBjb25zaWRlciB0aGUgYm94LXNpemluZ1xuXHRcdFx0aWYgKGVsLmdldFN0eWxlKCctbW96LWJveC1zaXppbmcnKSA9PSAnYm9yZGVyLWJveCcgfHwgZWwuZ2V0U3R5bGUoJy13ZWJraXQtYm94LXNpemluZycpID09ICdib3JkZXItYm94JyB8fCBlbC5nZXRTdHlsZSgnYm94LXNpemluZycpID09ICdib3JkZXItYm94Jykge1xuXHRcdFx0XHRkdW1teS5zZXRTdHlsZXMoe1xuXHRcdFx0XHRcdCdwYWRkaW5nJzogZWwuZ2V0U3R5bGUoJ3BhZGRpbmcnKSxcblx0XHRcdFx0XHQnYm9yZGVyJzogZWwuZ2V0U3R5bGUoJ2JvcmRlci1sZWZ0Jylcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNpbmdsZSBsaW5lIGhlaWdodFxuXHRcdFx0dmFyIGxpbmUgPSBNYXRoLm1heChkdW1teS5jbGllbnRIZWlnaHQsIDMwKTtcblxuXHRcdFx0Ly8gUmVzcG9uZCB0byB0aGUgXCJpbnB1dFwiIGV2ZW50XG5cdFx0XHRlbC5hZGRFdmVudCgnaW5wdXQnLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZHVtbXkuc2V0KCdodG1sJywgdGhpcy5nZXQoJ3ZhbHVlJylcblx0XHRcdFx0XHQucmVwbGFjZSgvPC9nLCAnJmx0OycpXG5cdFx0XHRcdFx0LnJlcGxhY2UoLz4vZywgJyZndDsnKVxuXHRcdFx0XHRcdC5yZXBsYWNlKC9cXG58XFxyXFxuL2csICc8YnI+WCcpKTtcblx0XHRcdFx0dmFyIGhlaWdodCA9IE1hdGgubWF4KGxpbmUsIGR1bW15LmdldFNpemUoKS55KTtcblx0XHRcdFx0aWYgKHRoaXMuY2xpZW50SGVpZ2h0ICE9IGhlaWdodCkgdGhpcy50d2VlbignaGVpZ2h0JywgaGVpZ2h0KTtcblx0XHRcdH0pLnNldCgndHdlZW4nLCB7ICdkdXJhdGlvbic6MTAwIH0pLnNldFN0eWxlKCdoZWlnaHQnLCBsaW5lICsgJ3B4Jyk7XG5cblx0XHRcdC8vIEZpcmUgdGhlIGV2ZW50XG5cdFx0XHRlbC5maXJlRXZlbnQoJ2lucHV0Jyk7XG5cdFx0XHRlbC5zdG9yZSgnYXV0b2dyb3cnLCB0cnVlKTtcblx0XHR9KTtcblx0fSxcblxuXHQvKipcblx0ICogU2V0IHVwIHRoZSBtZW51IHRvZ2dsZVxuXHQgKi9cblx0c2V0dXBNZW51VG9nZ2xlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgYnVyZ2VyID0gJCgnYnVyZ2VyJyk7XG5cdFx0aWYgKCFidXJnZXIpIHJldHVybjtcblxuXHRcdGJ1cmdlclxuXHRcdFx0LmFkZEV2ZW50KCdjbGljaycsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkb2N1bWVudC5ib2R5LnRvZ2dsZUNsYXNzKCdzaG93LW5hdmlnYXRpb24nKTtcblx0XHRcdFx0YnVyZ2VyLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIGRvY3VtZW50LmJvZHkuaGFzQ2xhc3MoJ3Nob3ctbmF2aWdhdGlvbicpID8gJ3RydWUnIDogJ2ZhbHNlJylcblx0XHRcdH0pXG5cdFx0XHQuYWRkRXZlbnQoJ2tleWRvd24nLCBmdW5jdGlvbihlKSB7XG5cdFx0XHRcdGlmIChlLmV2ZW50LmtleUNvZGUgPT0gMjcpIHtcblx0XHRcdFx0XHRkb2N1bWVudC5ib2R5LnJlbW92ZUNsYXNzKCdzaG93LW5hdmlnYXRpb24nKTtcblx0XHRcdFx0fVxuXHRcdFx0fSlcblx0XHQ7XG5cblx0XHRpZiAod2luZG93Lm1hdGNoTWVkaWEpIHtcblx0XHRcdHZhciBtYXRjaE1lZGlhID0gd2luZG93Lm1hdGNoTWVkaWEoJyhtYXgtd2lkdGg6OTkxcHgpJyk7XG5cdFx0XHR2YXIgc2V0QXJpYUNvbnRyb2xzID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmIChtYXRjaE1lZGlhLm1hdGNoZXMpIHtcblx0XHRcdFx0XHRidXJnZXIuc2V0QXR0cmlidXRlKCdhcmlhLWNvbnRyb2xzJywgJ2xlZnQnKVxuXHRcdFx0XHRcdGJ1cmdlci5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCBkb2N1bWVudC5ib2R5Lmhhc0NsYXNzKCdzaG93LW5hdmlnYXRpb24nKSA/ICd0cnVlJyA6ICdmYWxzZScpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YnVyZ2VyLnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1jb250cm9scycpO1xuXHRcdFx0XHRcdGJ1cmdlci5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHRcdG1hdGNoTWVkaWEuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgc2V0QXJpYUNvbnRyb2xzKTtcblx0XHRcdHNldEFyaWFDb250cm9scygpO1xuXHRcdH1cblx0fSxcblxuXHQvKipcblx0ICogU2V0IHVwIHRoZSBwcm9maWxlIHRvZ2dsZVxuXHQgKi9cblx0c2V0dXBQcm9maWxlVG9nZ2xlOiBmdW5jdGlvbigpIHtcblx0XHRpZiAod2luZG93LmNvbnNvbGUpIHtcblx0XHRcdGNvbnNvbGUud2FybignVGhlbWUuc2V0dXBQcm9maWxlVG9nZ2xlKCkgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSB0aGUgc3RpbXVsdXMgY29udHJvbGxlciBpbnN0ZWFkLicpO1xuXHRcdH1cblxuXHRcdHZhciB0bWVudSA9ICQoJ3RtZW51Jyk7XG5cdFx0aWYgKCF0bWVudSkgcmV0dXJuO1xuXG5cdFx0dmFyIGxpID0gdG1lbnUuZ2V0RWxlbWVudCgnLnN1Ym1lbnUnKSxcblx0XHRcdGJ1dHRvbiA9IGxpLmdldEZpcnN0KCdzcGFuJykuZ2V0Rmlyc3QoJ2J1dHRvbicpLFxuXHRcdFx0bWVudSA9IGxpLmdldEZpcnN0KCd1bCcpO1xuXHRcdGlmICghbGkgfHwgIWJ1dHRvbiB8fCAhbWVudSkgcmV0dXJuO1xuXG5cdFx0YnV0dG9uLnNldEF0dHJpYnV0ZSgnYXJpYS1jb250cm9scycsICd0bWVudV9fcHJvZmlsZScpO1xuXHRcdGJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCAnZmFsc2UnKTtcblxuXHRcdG1lbnUuaWQgPSAndG1lbnVfX3Byb2ZpbGUnO1xuXG5cdFx0YnV0dG9uLmFkZEV2ZW50KCdjbGljaycsIGZ1bmN0aW9uKGUpIHtcblx0XHRcdGlmIChsaS5oYXNDbGFzcygnYWN0aXZlJykpIHtcblx0XHRcdFx0bGkucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuXHRcdFx0XHRidXR0b24uc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgJ2ZhbHNlJyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRsaS5hZGRDbGFzcygnYWN0aXZlJyk7XG5cdFx0XHRcdGJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCAndHJ1ZScpO1xuXHRcdFx0fVxuXHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHR9KTtcblxuXHRcdCQoZG9jdW1lbnQuYm9keSkuYWRkRXZlbnQoJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAobGkuaGFzQ2xhc3MoJ2FjdGl2ZScpKSB7XG5cdFx0XHRcdGxpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSxcblxuXHQvKipcblx0ICogU2V0IHVwIHRoZSBzcGxpdCBidXR0b24gdG9nZ2xlXG5cdCAqL1xuXHRzZXR1cFNwbGl0QnV0dG9uVG9nZ2xlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdG9nZ2xlID0gJCgnc2J0b2cnKTtcblx0XHRpZiAoIXRvZ2dsZSkgcmV0dXJuO1xuXG5cdFx0dmFyIHVsID0gdG9nZ2xlLmdldFBhcmVudCgnLnNwbGl0LWJ1dHRvbicpLmdldEVsZW1lbnQoJ3VsJyksXG5cdFx0XHR0YWIsIHRpbWVyO1xuXG5cdFx0dG9nZ2xlLmFkZEV2ZW50KCdjbGljaycsIGZ1bmN0aW9uKGUpIHtcblx0XHRcdHRhYiA9IGZhbHNlO1xuXHRcdFx0dWwudG9nZ2xlQ2xhc3MoJ2ludmlzaWJsZScpO1xuXHRcdFx0dG9nZ2xlLnRvZ2dsZUNsYXNzKCdhY3RpdmUnKTtcblx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0fSk7XG5cblx0XHQkKGRvY3VtZW50LmJvZHkpLmFkZEV2ZW50KCdjbGljaycsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dGFiID0gZmFsc2U7XG5cdFx0XHR1bC5hZGRDbGFzcygnaW52aXNpYmxlJyk7XG5cdFx0XHR0b2dnbGUucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xuXHRcdH0pO1xuXG5cdFx0JChkb2N1bWVudC5ib2R5KS5hZGRFdmVudCgna2V5ZG93bicsIGZ1bmN0aW9uKGUpIHtcblx0XHRcdHRhYiA9IChlLmV2ZW50LmtleUNvZGUgPT0gOSk7XG5cdFx0fSk7XG5cblx0XHRbdG9nZ2xlXS5hcHBlbmQodWwuZ2V0RWxlbWVudHMoJ2J1dHRvbicpKS5lYWNoKGZ1bmN0aW9uKGVsKSB7XG5cdFx0XHRlbC5hZGRFdmVudCgnZm9jdXMnLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCF0YWIpIHJldHVybjtcblx0XHRcdFx0dWwucmVtb3ZlQ2xhc3MoJ2ludmlzaWJsZScpO1xuXHRcdFx0XHR0b2dnbGUuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xuXHRcdFx0XHRjbGVhclRpbWVvdXQodGltZXIpO1xuXHRcdFx0fSk7XG5cblx0XHRcdGVsLmFkZEV2ZW50KCdibHVyJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICghdGFiKSByZXR1cm47XG5cdFx0XHRcdHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR1bC5hZGRDbGFzcygnaW52aXNpYmxlJyk7XG5cdFx0XHRcdFx0dG9nZ2xlLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcblx0XHRcdFx0fSwgMTAwKTtcblx0XHRcdH0pO1xuXHRcdH0pO1xuXG5cdFx0dG9nZ2xlLnNldCgndGFiaW5kZXgnLCAnLTEnKTtcblx0fVxufTtcblxuLy8gSW5pdGlhbGl6ZSB0aGUgYmFjayBlbmQgc2NyaXB0XG53aW5kb3cuYWRkRXZlbnQoJ2RvbXJlYWR5JywgZnVuY3Rpb24oKSB7XG5cdCQoZG9jdW1lbnQuYm9keSkuYWRkQ2xhc3MoJ2pzJyk7XG5cblx0Ly8gTWFyayB0b3VjaCBkZXZpY2VzIChzZWUgIzU1NjMpXG5cdGlmIChCcm93c2VyLkZlYXR1cmVzLlRvdWNoKSB7XG5cdFx0JChkb2N1bWVudC5ib2R5KS5hZGRDbGFzcygndG91Y2gnKTtcblx0fVxuXG5cdEJhY2tlbmQudGFibGVXaXphcmRTZXRXaWR0aCgpO1xuXHRCYWNrZW5kLmVuYWJsZVRvZ2dsZVNlbGVjdCgpO1xuXG5cdFRoZW1lLnN0b3BDbGlja1Byb3BhZ2F0aW9uKCk7XG5cdFRoZW1lLnNldHVwVGV4dGFyZWFSZXNpemluZygpO1xuXHRUaGVtZS5zZXR1cE1lbnVUb2dnbGUoKTtcblx0VGhlbWUuc2V0dXBTcGxpdEJ1dHRvblRvZ2dsZSgpO1xufSk7XG5cbi8vIFJlc2l6ZSB0aGUgdGFibGUgd2l6YXJkXG53aW5kb3cuYWRkRXZlbnQoJ3Jlc2l6ZScsIGZ1bmN0aW9uKCkge1xuXHRCYWNrZW5kLnRhYmxlV2l6YXJkU2V0V2lkdGgoKTtcbn0pO1xuXG4vLyBSZS1hcHBseSBjZXJ0YWluIGNoYW5nZXMgdXBvbiBhamF4X2NoYW5nZVxud2luZG93LmFkZEV2ZW50KCdhamF4X2NoYW5nZScsIGZ1bmN0aW9uKCkge1xuXHRCYWNrZW5kLmVuYWJsZVRvZ2dsZVNlbGVjdCgpO1xuXG5cdFRoZW1lLnN0b3BDbGlja1Byb3BhZ2F0aW9uKCk7XG5cdFRoZW1lLnNldHVwVGV4dGFyZWFSZXNpemluZygpO1xufSk7XG4iLCJ3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGZ1bmN0aW9uKCkge1xuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2Rpdi5saW1pdF9oZWlnaHQnKS5mb3JFYWNoKGZ1bmN0aW9uKGRpdikge1xuICAgICAgICBpZiAod2luZG93LmNvbnNvbGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignVXNpbmcgXCJsaW1pdF9oZWlnaHRcIiBjbGFzcyBvbiBjaGlsZF9yZWNvcmRfY2FsbGJhY2sgaXMgZGVwcmVjYXRlZC4gU2V0IGEgbGlzdC5zb3J0aW5nLmxpbWl0SGVpZ2h0IGluIHlvdXIgRENBIGluc3RlYWQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwYXJlbnQgPSBkaXYucGFyZW50Tm9kZS5jbG9zZXN0KCcudGxfY29udGVudCcpO1xuXG4gICAgICAgIC8vIFJldHVybiBpZiB0aGUgZWxlbWVudCBpcyBhIHdyYXBwZXJcbiAgICAgICAgaWYgKHBhcmVudCAmJiAocGFyZW50LmNsYXNzTGlzdC5jb250YWlucygnd3JhcHBlcl9zdGFydCcpIHx8IHBhcmVudC5jbGFzc0xpc3QuY29udGFpbnMoJ3dyYXBwZXJfc3RvcCcpKSkgcmV0dXJuO1xuXG4gICAgICAgIGNvbnN0IGhndCA9IE51bWJlcihkaXYuY2xhc3NOYW1lLnJlcGxhY2UoL1teMC05XSovLCAnJykpO1xuXG4gICAgICAgIC8vIFJldHVybiBpZiB0aGVyZSBpcyBubyBoZWlnaHQgdmFsdWVcbiAgICAgICAgaWYgKCFoZ3QpIHJldHVybjtcblxuICAgICAgICBjb25zdCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRpdiwgbnVsbCk7XG4gICAgICAgIGNvbnN0IHBhZGRpbmcgPSBwYXJzZUZsb2F0KHN0eWxlLnBhZGRpbmdUb3ApICsgcGFyc2VGbG9hdChzdHlsZS5wYWRkaW5nQm90dG9tKTtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gZGl2LmNsaWVudEhlaWdodCAtIHBhZGRpbmc7XG5cbiAgICAgICAgLy8gRG8gbm90IGFkZCB0aGUgdG9nZ2xlIGlmIHRoZSBwcmV2aWV3IGhlaWdodCBpcyBiZWxvdyB0aGUgbWF4LWhlaWdodFxuICAgICAgICBpZiAoaGVpZ2h0IDw9IGhndCkgcmV0dXJuO1xuXG4gICAgICAgIC8vIFJlc2l6ZSB0aGUgZWxlbWVudCBpZiBpdCBpcyBoaWdoZXIgdGhhbiB0aGUgbWF4aW11bSBoZWlnaHRcbiAgICAgICAgZGl2LnN0eWxlLmhlaWdodCA9IGhndCsncHgnO1xuXG4gICAgICAgIGNvbnN0IGJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICBidXR0b24uc2V0QXR0cmlidXRlKCd0eXBlJywgJ2J1dHRvbicpO1xuICAgICAgICBidXR0b24udGl0bGUgPSBDb250YW8ubGFuZy5leHBhbmQ7XG4gICAgICAgIGJ1dHRvbi5pbm5lckhUTUwgPSAnPHNwYW4+Li4uPC9zcGFuPic7XG4gICAgICAgIGJ1dHRvbi5jbGFzc0xpc3QuYWRkKCd1bnNlbGVjdGFibGUnKTtcblxuICAgICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChkaXYuc3R5bGUuaGVpZ2h0ID09ICdhdXRvJykge1xuICAgICAgICAgICAgICAgIGRpdi5zdHlsZS5oZWlnaHQgPSBoZ3QrJ3B4JztcbiAgICAgICAgICAgICAgICBidXR0b24udGl0bGUgPSBDb250YW8ubGFuZy5leHBhbmQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRpdi5zdHlsZS5oZWlnaHQgPSAnYXV0byc7XG4gICAgICAgICAgICAgICAgYnV0dG9uLnRpdGxlID0gQ29udGFvLmxhbmcuY29sbGFwc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGNvbnN0IHRvZ2dsZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdG9nZ2xlci5jbGFzc0xpc3QuYWRkKCdsaW1pdF90b2dnbGVyJyk7XG4gICAgICAgIHRvZ2dsZXIuYXBwZW5kKGJ1dHRvbik7XG5cbiAgICAgICAgZGl2LmFwcGVuZCh0b2dnbGVyKTtcbiAgICB9KTtcbn0pO1xuIiwiLypcbi0tLVxuXG5uYW1lOiBSZXF1ZXN0LkNvbnRhb1xuXG5kZXNjcmlwdGlvbjogRXh0ZW5kcyB0aGUgTW9vVG9vbHMgUmVxdWVzdC5KU09OIGNsYXNzIHdpdGggQ29udGFvLXNwZWNpZmljIHJvdXRpbmVzLlxuXG5saWNlbnNlOiBMR1BMdjNcblxuYXV0aG9yczpcbiAtIExlbyBGZXllclxuXG5yZXF1aXJlczogW1JlcXVlc3QsIEpTT05dXG5cbnByb3ZpZGVzOiBSZXF1ZXN0LkNvbnRhb1xuXG4uLi5cbiovXG5cblJlcXVlc3QuQ29udGFvID0gbmV3IENsYXNzKFxue1xuXHRFeHRlbmRzOiBSZXF1ZXN0LkpTT04sXG5cblx0b3B0aW9uczoge1xuXHRcdGZvbGxvd1JlZGlyZWN0czogdHJ1ZSxcblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0aWYgKCFvcHRpb25zKSB7XG5cdFx0XHRvcHRpb25zID0ge307XG5cdFx0fVxuXG5cdFx0aWYgKCFvcHRpb25zLnVybCAmJiBvcHRpb25zLmZpZWxkICYmIG9wdGlvbnMuZmllbGQuZm9ybSAmJiBvcHRpb25zLmZpZWxkLmZvcm0uYWN0aW9uKSB7XG5cdFx0XHRvcHRpb25zLnVybCA9IG9wdGlvbnMuZmllbGQuZm9ybS5hY3Rpb247XG5cdFx0fVxuXG5cdFx0aWYgKCFvcHRpb25zLnVybCkge1xuXHRcdFx0b3B0aW9ucy51cmwgPSB3aW5kb3cubG9jYXRpb24uaHJlZjtcblx0XHR9XG5cblx0XHR0aGlzLnBhcmVudChvcHRpb25zKTtcblx0fSxcblxuXHRzdWNjZXNzOiBmdW5jdGlvbih0ZXh0KSB7XG5cdFx0dmFyIHVybCA9IHRoaXMuZ2V0SGVhZGVyKCdYLUFqYXgtTG9jYXRpb24nKSxcblx0XHRcdGpzb247XG5cblx0XHRpZiAodXJsICYmIHRoaXMub3B0aW9ucy5mb2xsb3dSZWRpcmVjdHMpIHtcblx0XHRcdGxvY2F0aW9uLnJlcGxhY2UodXJsKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0IGJvdGggcGxhaW4gdGV4dCBhbmQgSlNPTiByZXNwb25zZXNcblx0XHR0cnkge1xuXHRcdFx0anNvbiA9IHRoaXMucmVzcG9uc2UuanNvbiA9IEpTT04uZGVjb2RlKHRleHQsIHRoaXMub3B0aW9ucy5zZWN1cmUpO1xuXHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0anNvbiA9IHsnY29udGVudCc6dGV4dH07XG5cdFx0fVxuXG5cdFx0Ly8gRW1wdHkgcmVzcG9uc2Vcblx0XHRpZiAoanNvbiA9PT0gbnVsbCkge1xuXHRcdFx0anNvbiA9IHsnY29udGVudCc6Jyd9O1xuXHRcdH0gZWxzZSBpZiAodHlwZW9mKGpzb24pICE9ICdvYmplY3QnKSB7XG5cdFx0XHRqc29uID0geydjb250ZW50Jzp0ZXh0fTtcblx0XHR9XG5cblx0XHQvLyBJc29sYXRlIHNjcmlwdHMgYW5kIGV4ZWN1dGUgdGhlbVxuXHRcdGlmIChqc29uLmNvbnRlbnQgIT0gJycpIHtcblx0XHRcdGpzb24uY29udGVudCA9IGpzb24uY29udGVudC5zdHJpcFNjcmlwdHMoZnVuY3Rpb24oc2NyaXB0KSB7XG5cdFx0XHRcdGpzb24uamF2YXNjcmlwdCA9IHNjcmlwdC5yZXBsYWNlKC88IS0tfFxcL1xcLy0tPnw8IVxcW0NEQVRBXFxbXFwvXFwvPnw8IV1dPi9nLCAnJyk7XG5cdFx0XHR9KTtcblx0XHRcdGlmIChqc29uLmphdmFzY3JpcHQgJiYgdGhpcy5vcHRpb25zLmV2YWxTY3JpcHRzKSB7XG5cdFx0XHRcdEJyb3dzZXIuZXhlYyhqc29uLmphdmFzY3JpcHQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHRoaXMub25TdWNjZXNzKGpzb24uY29udGVudCwganNvbik7XG5cdH0sXG5cblx0ZmFpbHVyZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHVybCA9IHRoaXMuZ2V0SGVhZGVyKCdYLUFqYXgtTG9jYXRpb24nKTtcblxuXHRcdGlmICh1cmwgJiYgNDAxID09PSB0aGlzLnN0YXR1cykge1xuXHRcdFx0bG9jYXRpb24ucmVwbGFjZSh1cmwpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICh1cmwgJiYgdGhpcy5vcHRpb25zLmZvbGxvd1JlZGlyZWN0cyAmJiB0aGlzLnN0YXR1cyA+PSAzMDAgJiYgdGhpcy5zdGF0dXMgPCA0MDApIHtcblx0XHRcdGxvY2F0aW9uLnJlcGxhY2UodXJsKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLm9uRmFpbHVyZSgpO1xuXHR9XG59KTtcblxuXG4vKlxuLS0tXG5cbm5hbWU6IERyYWdcblxuZGVzY3JpcHRpb246IEV4dGVuZHMgdGhlIGJhc2UgRHJhZyBjbGFzcyB3aXRoIHRvdWNoIHN1cHBvcnQuXG5cbmxpY2Vuc2U6IExHUEx2M1xuXG5hdXRob3JzOlxuIC0gQW5kcmVhcyBTY2hlbXBwXG5cbnJlcXVpcmVzOiBbRHJhZ11cblxucHJvdmlkZXM6IERyYWdcblxuLi4uXG4qL1xuXG5DbGFzcy5yZWZhY3RvcihEcmFnLFxue1xuXHRhdHRhY2g6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuaGFuZGxlcy5hZGRFdmVudCgndG91Y2hzdGFydCcsIHRoaXMuYm91bmQuc3RhcnQpO1xuXHRcdHJldHVybiB0aGlzLnByZXZpb3VzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdH0sXG5cblx0ZGV0YWNoOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmhhbmRsZXMucmVtb3ZlRXZlbnQoJ3RvdWNoc3RhcnQnLCB0aGlzLmJvdW5kLnN0YXJ0KTtcblx0XHRyZXR1cm4gdGhpcy5wcmV2aW91cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHR9LFxuXG5cdHN0YXJ0OiBmdW5jdGlvbigpIHtcblx0XHRkb2N1bWVudC5hZGRFdmVudHMoe1xuXHRcdFx0dG91Y2htb3ZlOiB0aGlzLmJvdW5kLmNoZWNrLFxuXHRcdFx0dG91Y2hlbmQ6IHRoaXMuYm91bmQuY2FuY2VsXG5cdFx0fSk7XG5cdFx0dGhpcy5wcmV2aW91cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHR9LFxuXG5cdGNoZWNrOiBmdW5jdGlvbihldmVudCkge1xuXHRcdGlmICh0aGlzLm9wdGlvbnMucHJldmVudERlZmF1bHQpIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0dmFyIGRpc3RhbmNlID0gTWF0aC5yb3VuZChNYXRoLnNxcnQoTWF0aC5wb3coZXZlbnQucGFnZS54IC0gdGhpcy5tb3VzZS5zdGFydC54LCAyKSArIE1hdGgucG93KGV2ZW50LnBhZ2UueSAtIHRoaXMubW91c2Uuc3RhcnQueSwgMikpKTtcblx0XHRpZiAoZGlzdGFuY2UgPiB0aGlzLm9wdGlvbnMuc25hcCkge1xuXHRcdFx0dGhpcy5jYW5jZWwoKTtcblx0XHRcdHRoaXMuZG9jdW1lbnQuYWRkRXZlbnRzKHtcblx0XHRcdFx0bW91c2Vtb3ZlOiB0aGlzLmJvdW5kLmRyYWcsXG5cdFx0XHRcdG1vdXNldXA6IHRoaXMuYm91bmQuc3RvcFxuXHRcdFx0fSk7XG5cdFx0XHRkb2N1bWVudC5hZGRFdmVudHMoe1xuXHRcdFx0XHR0b3VjaG1vdmU6IHRoaXMuYm91bmQuZHJhZyxcblx0XHRcdFx0dG91Y2hlbmQ6IHRoaXMuYm91bmQuc3RvcFxuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLmZpcmVFdmVudCgnc3RhcnQnLCBbdGhpcy5lbGVtZW50LCBldmVudF0pLmZpcmVFdmVudCgnc25hcCcsIHRoaXMuZWxlbWVudCk7XG5cdFx0fVxuXHR9LFxuXG5cdGNhbmNlbDogZnVuY3Rpb24oKSB7XG5cdFx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRzKHtcblx0XHRcdHRvdWNobW92ZTogdGhpcy5ib3VuZC5jaGVjayxcblx0XHRcdHRvdWNoZW5kOiB0aGlzLmJvdW5kLmNhbmNlbFxuXHRcdH0pO1xuXHRcdHJldHVybiB0aGlzLnByZXZpb3VzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdH0sXG5cblx0c3RvcDogZnVuY3Rpb24oKSB7XG5cdFx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRzKHtcblx0XHRcdHRvdWNobW92ZTogdGhpcy5ib3VuZC5kcmFnLFxuXHRcdFx0dG91Y2hlbmQ6IHRoaXMuYm91bmQuc3RvcFxuXHRcdH0pO1xuXHRcdHJldHVybiB0aGlzLnByZXZpb3VzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdH1cbn0pO1xuXG4vKlxuLS0tXG5cbm5hbWU6IFNvcnRhYmxlc1xuXG5kZXNjcmlwdGlvbjogRXh0ZW5kcyB0aGUgYmFzZSBTb3J0YWJsZXMgY2xhc3Mgd2l0aCB0b3VjaCBzdXBwb3J0LlxuXG5saWNlbnNlOiBMR1BMdjNcblxuYXV0aG9yczpcbiAtIEFuZHJlYXMgU2NoZW1wcFxuXG5yZXF1aXJlczogW1NvcnRhYmxlc11cblxucHJvdmlkZXM6IFNvcnRhYmxlc1xuXG4uLi5cbiovXG5cbkNsYXNzLnJlZmFjdG9yKFNvcnRhYmxlcyxcbntcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24obGlzdHMsIG9wdGlvbnMpIHtcblx0XHRvcHRpb25zLmRyYWdPcHRpb25zID0gT2JqZWN0Lm1lcmdlKG9wdGlvbnMuZHJhZ09wdGlvbnMgfHwge30sIHsgcHJldmVudERlZmF1bHQ6IChvcHRpb25zLmRyYWdPcHRpb25zICYmIG9wdGlvbnMuZHJhZ09wdGlvbnMucHJldmVudERlZmF1bHQpIHx8IEJyb3dzZXIuRmVhdHVyZXMuVG91Y2ggfSk7XG5cdFx0aWYgKG9wdGlvbnMuZHJhZ09wdGlvbnMudW5EcmFnZ2FibGVUYWdzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdG9wdGlvbnMuZHJhZ09wdGlvbnMudW5EcmFnZ2FibGVUYWdzID0gdGhpcy5vcHRpb25zLnVuRHJhZ2dhYmxlVGFncy5maWx0ZXIoZnVuY3Rpb24odGFnKSB7XG5cdFx0XHRcdHJldHVybiB0YWcgIT0gJ2J1dHRvbic7XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMucHJldmlvdXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0fSxcblxuXHRhZGRJdGVtczogZnVuY3Rpb24oKSB7XG5cdFx0QXJyYXkuZmxhdHRlbihhcmd1bWVudHMpLmVhY2goZnVuY3Rpb24oZWxlbWVudCkge1xuXHRcdFx0dGhpcy5lbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuXHRcdFx0dmFyIHN0YXJ0ID0gZWxlbWVudC5yZXRyaWV2ZSgnc29ydGFibGVzOnN0YXJ0JywgZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdFx0dGhpcy5zdGFydC5jYWxsKHRoaXMsIGV2ZW50LCBlbGVtZW50KTtcblx0XHRcdH0uYmluZCh0aGlzKSk7XG5cdFx0XHQodGhpcy5vcHRpb25zLmhhbmRsZSA/IGVsZW1lbnQuZ2V0RWxlbWVudCh0aGlzLm9wdGlvbnMuaGFuZGxlKSB8fCBlbGVtZW50IDogZWxlbWVudCkuYWRkRXZlbnRzKHtcblx0XHRcdFx0bW91c2Vkb3duOiBzdGFydCxcblx0XHRcdFx0dG91Y2hzdGFydDogc3RhcnRcblx0XHRcdH0pO1xuXHRcdH0sIHRoaXMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJlbW92ZUl0ZW1zOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gJCQoQXJyYXkuZmxhdHRlbihhcmd1bWVudHMpLm1hcChmdW5jdGlvbihlbGVtZW50KSB7XG5cdFx0XHR0aGlzLmVsZW1lbnRzLmVyYXNlKGVsZW1lbnQpO1xuXHRcdFx0dmFyIHN0YXJ0ID0gZWxlbWVudC5yZXRyaWV2ZSgnc29ydGFibGVzOnN0YXJ0Jyk7XG5cdFx0XHQodGhpcy5vcHRpb25zLmhhbmRsZSA/IGVsZW1lbnQuZ2V0RWxlbWVudCh0aGlzLm9wdGlvbnMuaGFuZGxlKSB8fCBlbGVtZW50IDogZWxlbWVudCkucmVtb3ZlRXZlbnRzKHtcblx0XHRcdFx0bW91c2Vkb3duOiBzdGFydCxcblx0XHRcdFx0dG91Y2hlbmQ6IHN0YXJ0XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiBlbGVtZW50O1xuXHRcdH0sIHRoaXMpKTtcblx0fSxcblxuXHRnZXRDbG9uZTogZnVuY3Rpb24oZXZlbnQsIGVsZW1lbnQpIHtcblx0XHRpZiAoIXRoaXMub3B0aW9ucy5jbG9uZSkgcmV0dXJuIG5ldyBFbGVtZW50KGVsZW1lbnQudGFnTmFtZSkuaW5qZWN0KGRvY3VtZW50LmJvZHkpO1xuXHRcdGlmICh0eXBlT2YodGhpcy5vcHRpb25zLmNsb25lKSA9PSAnZnVuY3Rpb24nKSByZXR1cm4gdGhpcy5vcHRpb25zLmNsb25lLmNhbGwodGhpcywgZXZlbnQsIGVsZW1lbnQsIHRoaXMubGlzdCk7XG5cdFx0dmFyIGNsb25lID0gdGhpcy5wcmV2aW91cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdGNsb25lLmFkZEV2ZW50KCd0b3VjaHN0YXJ0JywgZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdGVsZW1lbnQuZmlyZUV2ZW50KCd0b3VjaHN0YXJ0JywgZXZlbnQpO1xuXHRcdH0pO1xuXHRcdHJldHVybiBjbG9uZTtcblx0fVxufSk7XG5cbi8qXG4tLS1cblxuc2NyaXB0OiBSZXF1ZXN0LlF1ZXVlLmpzXG5cbm5hbWU6IFJlcXVlc3QuUXVldWVcblxuZGVzY3JpcHRpb246IEV4dGVuZHMgdGhlIGJhc2UgUmVxdWVzdC5RdWV1ZSBjbGFzcyBhbmQgYXR0ZW1wdHMgdG8gZml4IHNvbWUgaXNzdWVzLlxuXG5saWNlbnNlOiBNSVQtc3R5bGUgbGljZW5zZVxuXG5hdXRob3JzOlxuIC0gTGVvIEZleWVyXG5cbnJlcXVpcmVzOlxuXHQtIENvcmUvRWxlbWVudFxuXHQtIENvcmUvUmVxdWVzdFxuXHQtIENsYXNzLkJpbmRzXG5cbnByb3ZpZGVzOiBbUmVxdWVzdC5RdWV1ZV1cblxuLi4uXG4qL1xuXG5DbGFzcy5yZWZhY3RvcihSZXF1ZXN0LlF1ZXVlLFxue1xuXHQvLyBEbyBub3QgZmlyZSB0aGUgXCJlbmRcIiBldmVudCBoZXJlXG5cdG9uQ29tcGxldGU6IGZ1bmN0aW9uKCl7XG5cdFx0dGhpcy5maXJlRXZlbnQoJ2NvbXBsZXRlJywgYXJndW1lbnRzKTtcblx0fSxcblxuXHQvLyBDYWxsIHJlc3VtZSgpIGluc3RlYWQgb2YgcnVuTmV4dCgpXG5cdG9uQ2FuY2VsOiBmdW5jdGlvbigpe1xuXHRcdGlmICh0aGlzLm9wdGlvbnMuYXV0b0FkdmFuY2UgJiYgIXRoaXMuZXJyb3IpIHRoaXMucmVzdW1lKCk7XG5cdFx0dGhpcy5maXJlRXZlbnQoJ2NhbmNlbCcsIGFyZ3VtZW50cyk7XG5cdH0sXG5cblx0Ly8gQ2FsbCByZXN1bWUoKSBpbnN0ZWFkIG9mIHJ1bk5leHQoKSBhbmQgZmlyZSB0aGUgXCJlbmRcIiBldmVudFxuXHRvblN1Y2Nlc3M6IGZ1bmN0aW9uKCl7XG5cdFx0aWYgKHRoaXMub3B0aW9ucy5hdXRvQWR2YW5jZSAmJiAhdGhpcy5lcnJvcikgdGhpcy5yZXN1bWUoKTtcblx0XHR0aGlzLmZpcmVFdmVudCgnc3VjY2VzcycsIGFyZ3VtZW50cyk7XG5cdFx0aWYgKCF0aGlzLnF1ZXVlLmxlbmd0aCAmJiAhdGhpcy5pc1J1bm5pbmcoKSkgdGhpcy5maXJlRXZlbnQoJ2VuZCcpO1xuXHR9LFxuXG5cdC8vIENhbGwgcmVzdW1lKCkgaW5zdGVhZCBvZiBydW5OZXh0KCkgYW5kIGZpcmUgdGhlIFwiZW5kXCIgZXZlbnRcblx0b25GYWlsdXJlOiBmdW5jdGlvbigpe1xuXHRcdHRoaXMuZXJyb3IgPSB0cnVlO1xuXHRcdGlmICghdGhpcy5vcHRpb25zLnN0b3BPbkZhaWx1cmUgJiYgdGhpcy5vcHRpb25zLmF1dG9BZHZhbmNlKSB0aGlzLnJlc3VtZSgpO1xuXHRcdHRoaXMuZmlyZUV2ZW50KCdmYWlsdXJlJywgYXJndW1lbnRzKTtcblx0XHRpZiAoIXRoaXMucXVldWUubGVuZ3RoICYmICF0aGlzLmlzUnVubmluZygpKSB0aGlzLmZpcmVFdmVudCgnZW5kJyk7XG5cdH0sXG5cblx0Ly8gQ2FsbCByZXN1bWUoKSBpbnN0ZWFkIG9mIHJ1bk5leHQoKVxuXHRvbkV4Y2VwdGlvbjogZnVuY3Rpb24oKXtcblx0XHR0aGlzLmVycm9yID0gdHJ1ZTtcblx0XHRpZiAoIXRoaXMub3B0aW9ucy5zdG9wT25GYWlsdXJlICYmIHRoaXMub3B0aW9ucy5hdXRvQWR2YW5jZSkgdGhpcy5yZXN1bWUoKTtcblx0XHR0aGlzLmZpcmVFdmVudCgnZXhjZXB0aW9uJywgYXJndW1lbnRzKTtcblx0fVxufSk7XG4iLCIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbmV4cG9ydCB7fTsiLCIvKlxuU3RpbXVsdXMgV2VicGFjayBIZWxwZXJzIDEuMC4wXG5Db3B5cmlnaHQgwqkgMjAyMSBCYXNlY2FtcCwgTExDXG4gKi9cbmZ1bmN0aW9uIGRlZmluaXRpb25zRnJvbUNvbnRleHQoY29udGV4dCkge1xuICAgIHJldHVybiBjb250ZXh0LmtleXMoKVxuICAgICAgICAubWFwKChrZXkpID0+IGRlZmluaXRpb25Gb3JNb2R1bGVXaXRoQ29udGV4dEFuZEtleShjb250ZXh0LCBrZXkpKVxuICAgICAgICAuZmlsdGVyKCh2YWx1ZSkgPT4gdmFsdWUpO1xufVxuZnVuY3Rpb24gZGVmaW5pdGlvbkZvck1vZHVsZVdpdGhDb250ZXh0QW5kS2V5KGNvbnRleHQsIGtleSkge1xuICAgIGNvbnN0IGlkZW50aWZpZXIgPSBpZGVudGlmaWVyRm9yQ29udGV4dEtleShrZXkpO1xuICAgIGlmIChpZGVudGlmaWVyKSB7XG4gICAgICAgIHJldHVybiBkZWZpbml0aW9uRm9yTW9kdWxlQW5kSWRlbnRpZmllcihjb250ZXh0KGtleSksIGlkZW50aWZpZXIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRlZmluaXRpb25Gb3JNb2R1bGVBbmRJZGVudGlmaWVyKG1vZHVsZSwgaWRlbnRpZmllcikge1xuICAgIGNvbnN0IGNvbnRyb2xsZXJDb25zdHJ1Y3RvciA9IG1vZHVsZS5kZWZhdWx0O1xuICAgIGlmICh0eXBlb2YgY29udHJvbGxlckNvbnN0cnVjdG9yID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4geyBpZGVudGlmaWVyLCBjb250cm9sbGVyQ29uc3RydWN0b3IgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBpZGVudGlmaWVyRm9yQ29udGV4dEtleShrZXkpIHtcbiAgICBjb25zdCBsb2dpY2FsTmFtZSA9IChrZXkubWF0Y2goL14oPzpcXC5cXC8pPyguKykoPzpbXy1dY29udHJvbGxlclxcLi4rPykkLykgfHwgW10pWzFdO1xuICAgIGlmIChsb2dpY2FsTmFtZSkge1xuICAgICAgICByZXR1cm4gbG9naWNhbE5hbWUucmVwbGFjZSgvXy9nLCBcIi1cIikucmVwbGFjZSgvXFwvL2csIFwiLS1cIik7XG4gICAgfVxufVxuXG5leHBvcnQgeyBkZWZpbml0aW9uRm9yTW9kdWxlQW5kSWRlbnRpZmllciwgZGVmaW5pdGlvbkZvck1vZHVsZVdpdGhDb250ZXh0QW5kS2V5LCBkZWZpbml0aW9uc0Zyb21Db250ZXh0LCBpZGVudGlmaWVyRm9yQ29udGV4dEtleSB9O1xuIiwiLypcblN0aW11bHVzIDMuMi4xXG5Db3B5cmlnaHQgwqkgMjAyMyBCYXNlY2FtcCwgTExDXG4gKi9cbmNsYXNzIEV2ZW50TGlzdGVuZXIge1xuICAgIGNvbnN0cnVjdG9yKGV2ZW50VGFyZ2V0LCBldmVudE5hbWUsIGV2ZW50T3B0aW9ucykge1xuICAgICAgICB0aGlzLmV2ZW50VGFyZ2V0ID0gZXZlbnRUYXJnZXQ7XG4gICAgICAgIHRoaXMuZXZlbnROYW1lID0gZXZlbnROYW1lO1xuICAgICAgICB0aGlzLmV2ZW50T3B0aW9ucyA9IGV2ZW50T3B0aW9ucztcbiAgICAgICAgdGhpcy51bm9yZGVyZWRCaW5kaW5ncyA9IG5ldyBTZXQoKTtcbiAgICB9XG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgdGhpcy5ldmVudFRhcmdldC5hZGRFdmVudExpc3RlbmVyKHRoaXMuZXZlbnROYW1lLCB0aGlzLCB0aGlzLmV2ZW50T3B0aW9ucyk7XG4gICAgfVxuICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMuZXZlbnRUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLmV2ZW50TmFtZSwgdGhpcywgdGhpcy5ldmVudE9wdGlvbnMpO1xuICAgIH1cbiAgICBiaW5kaW5nQ29ubmVjdGVkKGJpbmRpbmcpIHtcbiAgICAgICAgdGhpcy51bm9yZGVyZWRCaW5kaW5ncy5hZGQoYmluZGluZyk7XG4gICAgfVxuICAgIGJpbmRpbmdEaXNjb25uZWN0ZWQoYmluZGluZykge1xuICAgICAgICB0aGlzLnVub3JkZXJlZEJpbmRpbmdzLmRlbGV0ZShiaW5kaW5nKTtcbiAgICB9XG4gICAgaGFuZGxlRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgZXh0ZW5kZWRFdmVudCA9IGV4dGVuZEV2ZW50KGV2ZW50KTtcbiAgICAgICAgZm9yIChjb25zdCBiaW5kaW5nIG9mIHRoaXMuYmluZGluZ3MpIHtcbiAgICAgICAgICAgIGlmIChleHRlbmRlZEV2ZW50LmltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYmluZGluZy5oYW5kbGVFdmVudChleHRlbmRlZEV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBoYXNCaW5kaW5ncygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudW5vcmRlcmVkQmluZGluZ3Muc2l6ZSA+IDA7XG4gICAgfVxuICAgIGdldCBiaW5kaW5ncygpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy51bm9yZGVyZWRCaW5kaW5ncykuc29ydCgobGVmdCwgcmlnaHQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxlZnRJbmRleCA9IGxlZnQuaW5kZXgsIHJpZ2h0SW5kZXggPSByaWdodC5pbmRleDtcbiAgICAgICAgICAgIHJldHVybiBsZWZ0SW5kZXggPCByaWdodEluZGV4ID8gLTEgOiBsZWZ0SW5kZXggPiByaWdodEluZGV4ID8gMSA6IDA7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGV4dGVuZEV2ZW50KGV2ZW50KSB7XG4gICAgaWYgKFwiaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkXCIgaW4gZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgeyBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gfSA9IGV2ZW50O1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihldmVudCwge1xuICAgICAgICAgICAgaW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiBmYWxzZSxcbiAgICAgICAgICAgIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmNsYXNzIERpc3BhdGNoZXIge1xuICAgIGNvbnN0cnVjdG9yKGFwcGxpY2F0aW9uKSB7XG4gICAgICAgIHRoaXMuYXBwbGljYXRpb24gPSBhcHBsaWNhdGlvbjtcbiAgICAgICAgdGhpcy5ldmVudExpc3RlbmVyTWFwcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICBpZiAoIXRoaXMuc3RhcnRlZCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lcnMuZm9yRWFjaCgoZXZlbnRMaXN0ZW5lcikgPT4gZXZlbnRMaXN0ZW5lci5jb25uZWN0KCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5ldmVudExpc3RlbmVycy5mb3JFYWNoKChldmVudExpc3RlbmVyKSA9PiBldmVudExpc3RlbmVyLmRpc2Nvbm5lY3QoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmV2ZW50TGlzdGVuZXJNYXBzLnZhbHVlcygpKS5yZWR1Y2UoKGxpc3RlbmVycywgbWFwKSA9PiBsaXN0ZW5lcnMuY29uY2F0KEFycmF5LmZyb20obWFwLnZhbHVlcygpKSksIFtdKTtcbiAgICB9XG4gICAgYmluZGluZ0Nvbm5lY3RlZChiaW5kaW5nKSB7XG4gICAgICAgIHRoaXMuZmV0Y2hFdmVudExpc3RlbmVyRm9yQmluZGluZyhiaW5kaW5nKS5iaW5kaW5nQ29ubmVjdGVkKGJpbmRpbmcpO1xuICAgIH1cbiAgICBiaW5kaW5nRGlzY29ubmVjdGVkKGJpbmRpbmcsIGNsZWFyRXZlbnRMaXN0ZW5lcnMgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLmZldGNoRXZlbnRMaXN0ZW5lckZvckJpbmRpbmcoYmluZGluZykuYmluZGluZ0Rpc2Nvbm5lY3RlZChiaW5kaW5nKTtcbiAgICAgICAgaWYgKGNsZWFyRXZlbnRMaXN0ZW5lcnMpXG4gICAgICAgICAgICB0aGlzLmNsZWFyRXZlbnRMaXN0ZW5lcnNGb3JCaW5kaW5nKGJpbmRpbmcpO1xuICAgIH1cbiAgICBoYW5kbGVFcnJvcihlcnJvciwgbWVzc2FnZSwgZGV0YWlsID0ge30pIHtcbiAgICAgICAgdGhpcy5hcHBsaWNhdGlvbi5oYW5kbGVFcnJvcihlcnJvciwgYEVycm9yICR7bWVzc2FnZX1gLCBkZXRhaWwpO1xuICAgIH1cbiAgICBjbGVhckV2ZW50TGlzdGVuZXJzRm9yQmluZGluZyhiaW5kaW5nKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50TGlzdGVuZXIgPSB0aGlzLmZldGNoRXZlbnRMaXN0ZW5lckZvckJpbmRpbmcoYmluZGluZyk7XG4gICAgICAgIGlmICghZXZlbnRMaXN0ZW5lci5oYXNCaW5kaW5ncygpKSB7XG4gICAgICAgICAgICBldmVudExpc3RlbmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlTWFwcGVkRXZlbnRMaXN0ZW5lckZvcihiaW5kaW5nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVNYXBwZWRFdmVudExpc3RlbmVyRm9yKGJpbmRpbmcpIHtcbiAgICAgICAgY29uc3QgeyBldmVudFRhcmdldCwgZXZlbnROYW1lLCBldmVudE9wdGlvbnMgfSA9IGJpbmRpbmc7XG4gICAgICAgIGNvbnN0IGV2ZW50TGlzdGVuZXJNYXAgPSB0aGlzLmZldGNoRXZlbnRMaXN0ZW5lck1hcEZvckV2ZW50VGFyZ2V0KGV2ZW50VGFyZ2V0KTtcbiAgICAgICAgY29uc3QgY2FjaGVLZXkgPSB0aGlzLmNhY2hlS2V5KGV2ZW50TmFtZSwgZXZlbnRPcHRpb25zKTtcbiAgICAgICAgZXZlbnRMaXN0ZW5lck1hcC5kZWxldGUoY2FjaGVLZXkpO1xuICAgICAgICBpZiAoZXZlbnRMaXN0ZW5lck1hcC5zaXplID09IDApXG4gICAgICAgICAgICB0aGlzLmV2ZW50TGlzdGVuZXJNYXBzLmRlbGV0ZShldmVudFRhcmdldCk7XG4gICAgfVxuICAgIGZldGNoRXZlbnRMaXN0ZW5lckZvckJpbmRpbmcoYmluZGluZykge1xuICAgICAgICBjb25zdCB7IGV2ZW50VGFyZ2V0LCBldmVudE5hbWUsIGV2ZW50T3B0aW9ucyB9ID0gYmluZGluZztcbiAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hFdmVudExpc3RlbmVyKGV2ZW50VGFyZ2V0LCBldmVudE5hbWUsIGV2ZW50T3B0aW9ucyk7XG4gICAgfVxuICAgIGZldGNoRXZlbnRMaXN0ZW5lcihldmVudFRhcmdldCwgZXZlbnROYW1lLCBldmVudE9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZXZlbnRMaXN0ZW5lck1hcCA9IHRoaXMuZmV0Y2hFdmVudExpc3RlbmVyTWFwRm9yRXZlbnRUYXJnZXQoZXZlbnRUYXJnZXQpO1xuICAgICAgICBjb25zdCBjYWNoZUtleSA9IHRoaXMuY2FjaGVLZXkoZXZlbnROYW1lLCBldmVudE9wdGlvbnMpO1xuICAgICAgICBsZXQgZXZlbnRMaXN0ZW5lciA9IGV2ZW50TGlzdGVuZXJNYXAuZ2V0KGNhY2hlS2V5KTtcbiAgICAgICAgaWYgKCFldmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBldmVudExpc3RlbmVyID0gdGhpcy5jcmVhdGVFdmVudExpc3RlbmVyKGV2ZW50VGFyZ2V0LCBldmVudE5hbWUsIGV2ZW50T3B0aW9ucyk7XG4gICAgICAgICAgICBldmVudExpc3RlbmVyTWFwLnNldChjYWNoZUtleSwgZXZlbnRMaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV2ZW50TGlzdGVuZXI7XG4gICAgfVxuICAgIGNyZWF0ZUV2ZW50TGlzdGVuZXIoZXZlbnRUYXJnZXQsIGV2ZW50TmFtZSwgZXZlbnRPcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50TGlzdGVuZXIgPSBuZXcgRXZlbnRMaXN0ZW5lcihldmVudFRhcmdldCwgZXZlbnROYW1lLCBldmVudE9wdGlvbnMpO1xuICAgICAgICBpZiAodGhpcy5zdGFydGVkKSB7XG4gICAgICAgICAgICBldmVudExpc3RlbmVyLmNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXZlbnRMaXN0ZW5lcjtcbiAgICB9XG4gICAgZmV0Y2hFdmVudExpc3RlbmVyTWFwRm9yRXZlbnRUYXJnZXQoZXZlbnRUYXJnZXQpIHtcbiAgICAgICAgbGV0IGV2ZW50TGlzdGVuZXJNYXAgPSB0aGlzLmV2ZW50TGlzdGVuZXJNYXBzLmdldChldmVudFRhcmdldCk7XG4gICAgICAgIGlmICghZXZlbnRMaXN0ZW5lck1hcCkge1xuICAgICAgICAgICAgZXZlbnRMaXN0ZW5lck1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRMaXN0ZW5lck1hcHMuc2V0KGV2ZW50VGFyZ2V0LCBldmVudExpc3RlbmVyTWFwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXZlbnRMaXN0ZW5lck1hcDtcbiAgICB9XG4gICAgY2FjaGVLZXkoZXZlbnROYW1lLCBldmVudE9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcGFydHMgPSBbZXZlbnROYW1lXTtcbiAgICAgICAgT2JqZWN0LmtleXMoZXZlbnRPcHRpb25zKVxuICAgICAgICAgICAgLnNvcnQoKVxuICAgICAgICAgICAgLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgcGFydHMucHVzaChgJHtldmVudE9wdGlvbnNba2V5XSA/IFwiXCIgOiBcIiFcIn0ke2tleX1gKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwYXJ0cy5qb2luKFwiOlwiKTtcbiAgICB9XG59XG5cbmNvbnN0IGRlZmF1bHRBY3Rpb25EZXNjcmlwdG9yRmlsdGVycyA9IHtcbiAgICBzdG9wKHsgZXZlbnQsIHZhbHVlIH0pIHtcbiAgICAgICAgaWYgKHZhbHVlKVxuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgcHJldmVudCh7IGV2ZW50LCB2YWx1ZSB9KSB7XG4gICAgICAgIGlmICh2YWx1ZSlcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgc2VsZih7IGV2ZW50LCB2YWx1ZSwgZWxlbWVudCB9KSB7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQgPT09IGV2ZW50LnRhcmdldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfSxcbn07XG5jb25zdCBkZXNjcmlwdG9yUGF0dGVybiA9IC9eKD86KD86KFteLl0rPylcXCspPyguKz8pKD86XFwuKC4rPykpPyg/OkAod2luZG93fGRvY3VtZW50KSk/LT4pPyguKz8pKD86IyhbXjpdKz8pKSg/OjooLispKT8kLztcbmZ1bmN0aW9uIHBhcnNlQWN0aW9uRGVzY3JpcHRvclN0cmluZyhkZXNjcmlwdG9yU3RyaW5nKSB7XG4gICAgY29uc3Qgc291cmNlID0gZGVzY3JpcHRvclN0cmluZy50cmltKCk7XG4gICAgY29uc3QgbWF0Y2hlcyA9IHNvdXJjZS5tYXRjaChkZXNjcmlwdG9yUGF0dGVybikgfHwgW107XG4gICAgbGV0IGV2ZW50TmFtZSA9IG1hdGNoZXNbMl07XG4gICAgbGV0IGtleUZpbHRlciA9IG1hdGNoZXNbM107XG4gICAgaWYgKGtleUZpbHRlciAmJiAhW1wia2V5ZG93blwiLCBcImtleXVwXCIsIFwia2V5cHJlc3NcIl0uaW5jbHVkZXMoZXZlbnROYW1lKSkge1xuICAgICAgICBldmVudE5hbWUgKz0gYC4ke2tleUZpbHRlcn1gO1xuICAgICAgICBrZXlGaWx0ZXIgPSBcIlwiO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBldmVudFRhcmdldDogcGFyc2VFdmVudFRhcmdldChtYXRjaGVzWzRdKSxcbiAgICAgICAgZXZlbnROYW1lLFxuICAgICAgICBldmVudE9wdGlvbnM6IG1hdGNoZXNbN10gPyBwYXJzZUV2ZW50T3B0aW9ucyhtYXRjaGVzWzddKSA6IHt9LFxuICAgICAgICBpZGVudGlmaWVyOiBtYXRjaGVzWzVdLFxuICAgICAgICBtZXRob2ROYW1lOiBtYXRjaGVzWzZdLFxuICAgICAgICBrZXlGaWx0ZXI6IG1hdGNoZXNbMV0gfHwga2V5RmlsdGVyLFxuICAgIH07XG59XG5mdW5jdGlvbiBwYXJzZUV2ZW50VGFyZ2V0KGV2ZW50VGFyZ2V0TmFtZSkge1xuICAgIGlmIChldmVudFRhcmdldE5hbWUgPT0gXCJ3aW5kb3dcIikge1xuICAgICAgICByZXR1cm4gd2luZG93O1xuICAgIH1cbiAgICBlbHNlIGlmIChldmVudFRhcmdldE5hbWUgPT0gXCJkb2N1bWVudFwiKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICB9XG59XG5mdW5jdGlvbiBwYXJzZUV2ZW50T3B0aW9ucyhldmVudE9wdGlvbnMpIHtcbiAgICByZXR1cm4gZXZlbnRPcHRpb25zXG4gICAgICAgIC5zcGxpdChcIjpcIilcbiAgICAgICAgLnJlZHVjZSgob3B0aW9ucywgdG9rZW4pID0+IE9iamVjdC5hc3NpZ24ob3B0aW9ucywgeyBbdG9rZW4ucmVwbGFjZSgvXiEvLCBcIlwiKV06ICEvXiEvLnRlc3QodG9rZW4pIH0pLCB7fSk7XG59XG5mdW5jdGlvbiBzdHJpbmdpZnlFdmVudFRhcmdldChldmVudFRhcmdldCkge1xuICAgIGlmIChldmVudFRhcmdldCA9PSB3aW5kb3cpIHtcbiAgICAgICAgcmV0dXJuIFwid2luZG93XCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV2ZW50VGFyZ2V0ID09IGRvY3VtZW50KSB7XG4gICAgICAgIHJldHVybiBcImRvY3VtZW50XCI7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjYW1lbGl6ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKC8oPzpbXy1dKShbYS16MC05XSkvZywgKF8sIGNoYXIpID0+IGNoYXIudG9VcHBlckNhc2UoKSk7XG59XG5mdW5jdGlvbiBuYW1lc3BhY2VDYW1lbGl6ZSh2YWx1ZSkge1xuICAgIHJldHVybiBjYW1lbGl6ZSh2YWx1ZS5yZXBsYWNlKC8tLS9nLCBcIi1cIikucmVwbGFjZSgvX18vZywgXCJfXCIpKTtcbn1cbmZ1bmN0aW9uIGNhcGl0YWxpemUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB2YWx1ZS5zbGljZSgxKTtcbn1cbmZ1bmN0aW9uIGRhc2hlcml6ZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKC8oW0EtWl0pL2csIChfLCBjaGFyKSA9PiBgLSR7Y2hhci50b0xvd2VyQ2FzZSgpfWApO1xufVxuZnVuY3Rpb24gdG9rZW5pemUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUubWF0Y2goL1teXFxzXSsvZykgfHwgW107XG59XG5cbmZ1bmN0aW9uIGlzU29tZXRoaW5nKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0ICE9PSB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBoYXNQcm9wZXJ0eShvYmplY3QsIHByb3BlcnR5KSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTtcbn1cblxuY29uc3QgYWxsTW9kaWZpZXJzID0gW1wibWV0YVwiLCBcImN0cmxcIiwgXCJhbHRcIiwgXCJzaGlmdFwiXTtcbmNsYXNzIEFjdGlvbiB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgaW5kZXgsIGRlc2NyaXB0b3IsIHNjaGVtYSkge1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMuZXZlbnRUYXJnZXQgPSBkZXNjcmlwdG9yLmV2ZW50VGFyZ2V0IHx8IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMuZXZlbnROYW1lID0gZGVzY3JpcHRvci5ldmVudE5hbWUgfHwgZ2V0RGVmYXVsdEV2ZW50TmFtZUZvckVsZW1lbnQoZWxlbWVudCkgfHwgZXJyb3IoXCJtaXNzaW5nIGV2ZW50IG5hbWVcIik7XG4gICAgICAgIHRoaXMuZXZlbnRPcHRpb25zID0gZGVzY3JpcHRvci5ldmVudE9wdGlvbnMgfHwge307XG4gICAgICAgIHRoaXMuaWRlbnRpZmllciA9IGRlc2NyaXB0b3IuaWRlbnRpZmllciB8fCBlcnJvcihcIm1pc3NpbmcgaWRlbnRpZmllclwiKTtcbiAgICAgICAgdGhpcy5tZXRob2ROYW1lID0gZGVzY3JpcHRvci5tZXRob2ROYW1lIHx8IGVycm9yKFwibWlzc2luZyBtZXRob2QgbmFtZVwiKTtcbiAgICAgICAgdGhpcy5rZXlGaWx0ZXIgPSBkZXNjcmlwdG9yLmtleUZpbHRlciB8fCBcIlwiO1xuICAgICAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgICB9XG4gICAgc3RhdGljIGZvclRva2VuKHRva2VuLCBzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzKHRva2VuLmVsZW1lbnQsIHRva2VuLmluZGV4LCBwYXJzZUFjdGlvbkRlc2NyaXB0b3JTdHJpbmcodG9rZW4uY29udGVudCksIHNjaGVtYSk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBjb25zdCBldmVudEZpbHRlciA9IHRoaXMua2V5RmlsdGVyID8gYC4ke3RoaXMua2V5RmlsdGVyfWAgOiBcIlwiO1xuICAgICAgICBjb25zdCBldmVudFRhcmdldCA9IHRoaXMuZXZlbnRUYXJnZXROYW1lID8gYEAke3RoaXMuZXZlbnRUYXJnZXROYW1lfWAgOiBcIlwiO1xuICAgICAgICByZXR1cm4gYCR7dGhpcy5ldmVudE5hbWV9JHtldmVudEZpbHRlcn0ke2V2ZW50VGFyZ2V0fS0+JHt0aGlzLmlkZW50aWZpZXJ9IyR7dGhpcy5tZXRob2ROYW1lfWA7XG4gICAgfVxuICAgIHNob3VsZElnbm9yZUtleWJvYXJkRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmtleUZpbHRlcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpbHRlcnMgPSB0aGlzLmtleUZpbHRlci5zcGxpdChcIitcIik7XG4gICAgICAgIGlmICh0aGlzLmtleUZpbHRlckRpc3NhdGlzZmllZChldmVudCwgZmlsdGVycykpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0YW5kYXJkRmlsdGVyID0gZmlsdGVycy5maWx0ZXIoKGtleSkgPT4gIWFsbE1vZGlmaWVycy5pbmNsdWRlcyhrZXkpKVswXTtcbiAgICAgICAgaWYgKCFzdGFuZGFyZEZpbHRlcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaGFzUHJvcGVydHkodGhpcy5rZXlNYXBwaW5ncywgc3RhbmRhcmRGaWx0ZXIpKSB7XG4gICAgICAgICAgICBlcnJvcihgY29udGFpbnMgdW5rbm93biBrZXkgZmlsdGVyOiAke3RoaXMua2V5RmlsdGVyfWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmtleU1hcHBpbmdzW3N0YW5kYXJkRmlsdGVyXS50b0xvd2VyQ2FzZSgpICE9PSBldmVudC5rZXkudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgc2hvdWxkSWdub3JlTW91c2VFdmVudChldmVudCkge1xuICAgICAgICBpZiAoIXRoaXMua2V5RmlsdGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmlsdGVycyA9IFt0aGlzLmtleUZpbHRlcl07XG4gICAgICAgIGlmICh0aGlzLmtleUZpbHRlckRpc3NhdGlzZmllZChldmVudCwgZmlsdGVycykpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZ2V0IHBhcmFtcygpIHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0ge307XG4gICAgICAgIGNvbnN0IHBhdHRlcm4gPSBuZXcgUmVnRXhwKGBeZGF0YS0ke3RoaXMuaWRlbnRpZmllcn0tKC4rKS1wYXJhbSRgLCBcImlcIik7XG4gICAgICAgIGZvciAoY29uc3QgeyBuYW1lLCB2YWx1ZSB9IG9mIEFycmF5LmZyb20odGhpcy5lbGVtZW50LmF0dHJpYnV0ZXMpKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IG5hbWUubWF0Y2gocGF0dGVybik7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBtYXRjaCAmJiBtYXRjaFsxXTtcbiAgICAgICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXNbY2FtZWxpemUoa2V5KV0gPSB0eXBlY2FzdCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9XG4gICAgZ2V0IGV2ZW50VGFyZ2V0TmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ2lmeUV2ZW50VGFyZ2V0KHRoaXMuZXZlbnRUYXJnZXQpO1xuICAgIH1cbiAgICBnZXQga2V5TWFwcGluZ3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjaGVtYS5rZXlNYXBwaW5ncztcbiAgICB9XG4gICAga2V5RmlsdGVyRGlzc2F0aXNmaWVkKGV2ZW50LCBmaWx0ZXJzKSB7XG4gICAgICAgIGNvbnN0IFttZXRhLCBjdHJsLCBhbHQsIHNoaWZ0XSA9IGFsbE1vZGlmaWVycy5tYXAoKG1vZGlmaWVyKSA9PiBmaWx0ZXJzLmluY2x1ZGVzKG1vZGlmaWVyKSk7XG4gICAgICAgIHJldHVybiBldmVudC5tZXRhS2V5ICE9PSBtZXRhIHx8IGV2ZW50LmN0cmxLZXkgIT09IGN0cmwgfHwgZXZlbnQuYWx0S2V5ICE9PSBhbHQgfHwgZXZlbnQuc2hpZnRLZXkgIT09IHNoaWZ0O1xuICAgIH1cbn1cbmNvbnN0IGRlZmF1bHRFdmVudE5hbWVzID0ge1xuICAgIGE6ICgpID0+IFwiY2xpY2tcIixcbiAgICBidXR0b246ICgpID0+IFwiY2xpY2tcIixcbiAgICBmb3JtOiAoKSA9PiBcInN1Ym1pdFwiLFxuICAgIGRldGFpbHM6ICgpID0+IFwidG9nZ2xlXCIsXG4gICAgaW5wdXQ6IChlKSA9PiAoZS5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpID09IFwic3VibWl0XCIgPyBcImNsaWNrXCIgOiBcImlucHV0XCIpLFxuICAgIHNlbGVjdDogKCkgPT4gXCJjaGFuZ2VcIixcbiAgICB0ZXh0YXJlYTogKCkgPT4gXCJpbnB1dFwiLFxufTtcbmZ1bmN0aW9uIGdldERlZmF1bHRFdmVudE5hbWVGb3JFbGVtZW50KGVsZW1lbnQpIHtcbiAgICBjb25zdCB0YWdOYW1lID0gZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKHRhZ05hbWUgaW4gZGVmYXVsdEV2ZW50TmFtZXMpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRFdmVudE5hbWVzW3RhZ05hbWVdKGVsZW1lbnQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVycm9yKG1lc3NhZ2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG59XG5mdW5jdGlvbiB0eXBlY2FzdCh2YWx1ZSkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKG9fTykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufVxuXG5jbGFzcyBCaW5kaW5nIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBhY3Rpb24pIHtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5hY3Rpb24gPSBhY3Rpb247XG4gICAgfVxuICAgIGdldCBpbmRleCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aW9uLmluZGV4O1xuICAgIH1cbiAgICBnZXQgZXZlbnRUYXJnZXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFjdGlvbi5ldmVudFRhcmdldDtcbiAgICB9XG4gICAgZ2V0IGV2ZW50T3B0aW9ucygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aW9uLmV2ZW50T3B0aW9ucztcbiAgICB9XG4gICAgZ2V0IGlkZW50aWZpZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQuaWRlbnRpZmllcjtcbiAgICB9XG4gICAgaGFuZGxlRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgYWN0aW9uRXZlbnQgPSB0aGlzLnByZXBhcmVBY3Rpb25FdmVudChldmVudCk7XG4gICAgICAgIGlmICh0aGlzLndpbGxCZUludm9rZWRCeUV2ZW50KGV2ZW50KSAmJiB0aGlzLmFwcGx5RXZlbnRNb2RpZmllcnMoYWN0aW9uRXZlbnQpKSB7XG4gICAgICAgICAgICB0aGlzLmludm9rZVdpdGhFdmVudChhY3Rpb25FdmVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGV2ZW50TmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aW9uLmV2ZW50TmFtZTtcbiAgICB9XG4gICAgZ2V0IG1ldGhvZCgpIHtcbiAgICAgICAgY29uc3QgbWV0aG9kID0gdGhpcy5jb250cm9sbGVyW3RoaXMubWV0aG9kTmFtZV07XG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIG1ldGhvZDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFjdGlvbiBcIiR7dGhpcy5hY3Rpb259XCIgcmVmZXJlbmNlcyB1bmRlZmluZWQgbWV0aG9kIFwiJHt0aGlzLm1ldGhvZE5hbWV9XCJgKTtcbiAgICB9XG4gICAgYXBwbHlFdmVudE1vZGlmaWVycyhldmVudCkge1xuICAgICAgICBjb25zdCB7IGVsZW1lbnQgfSA9IHRoaXMuYWN0aW9uO1xuICAgICAgICBjb25zdCB7IGFjdGlvbkRlc2NyaXB0b3JGaWx0ZXJzIH0gPSB0aGlzLmNvbnRleHQuYXBwbGljYXRpb247XG4gICAgICAgIGNvbnN0IHsgY29udHJvbGxlciB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgcGFzc2VzID0gdHJ1ZTtcbiAgICAgICAgZm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMuZXZlbnRPcHRpb25zKSkge1xuICAgICAgICAgICAgaWYgKG5hbWUgaW4gYWN0aW9uRGVzY3JpcHRvckZpbHRlcnMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWx0ZXIgPSBhY3Rpb25EZXNjcmlwdG9yRmlsdGVyc1tuYW1lXTtcbiAgICAgICAgICAgICAgICBwYXNzZXMgPSBwYXNzZXMgJiYgZmlsdGVyKHsgbmFtZSwgdmFsdWUsIGV2ZW50LCBlbGVtZW50LCBjb250cm9sbGVyIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhc3NlcztcbiAgICB9XG4gICAgcHJlcGFyZUFjdGlvbkV2ZW50KGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGV2ZW50LCB7IHBhcmFtczogdGhpcy5hY3Rpb24ucGFyYW1zIH0pO1xuICAgIH1cbiAgICBpbnZva2VXaXRoRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgeyB0YXJnZXQsIGN1cnJlbnRUYXJnZXQgfSA9IGV2ZW50O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5tZXRob2QuY2FsbCh0aGlzLmNvbnRyb2xsZXIsIGV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5sb2dEZWJ1Z0FjdGl2aXR5KHRoaXMubWV0aG9kTmFtZSwgeyBldmVudCwgdGFyZ2V0LCBjdXJyZW50VGFyZ2V0LCBhY3Rpb246IHRoaXMubWV0aG9kTmFtZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaWRlbnRpZmllciwgY29udHJvbGxlciwgZWxlbWVudCwgaW5kZXggfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBkZXRhaWwgPSB7IGlkZW50aWZpZXIsIGNvbnRyb2xsZXIsIGVsZW1lbnQsIGluZGV4LCBldmVudCB9O1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LmhhbmRsZUVycm9yKGVycm9yLCBgaW52b2tpbmcgYWN0aW9uIFwiJHt0aGlzLmFjdGlvbn1cImAsIGRldGFpbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2lsbEJlSW52b2tlZEJ5RXZlbnQoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgZXZlbnRUYXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgICAgIGlmIChldmVudCBpbnN0YW5jZW9mIEtleWJvYXJkRXZlbnQgJiYgdGhpcy5hY3Rpb24uc2hvdWxkSWdub3JlS2V5Ym9hcmRFdmVudChldmVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZlbnQgaW5zdGFuY2VvZiBNb3VzZUV2ZW50ICYmIHRoaXMuYWN0aW9uLnNob3VsZElnbm9yZU1vdXNlRXZlbnQoZXZlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudCA9PT0gZXZlbnRUYXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV2ZW50VGFyZ2V0IGluc3RhbmNlb2YgRWxlbWVudCAmJiB0aGlzLmVsZW1lbnQuY29udGFpbnMoZXZlbnRUYXJnZXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zY29wZS5jb250YWluc0VsZW1lbnQoZXZlbnRUYXJnZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NvcGUuY29udGFpbnNFbGVtZW50KHRoaXMuYWN0aW9uLmVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBjb250cm9sbGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0LmNvbnRyb2xsZXI7XG4gICAgfVxuICAgIGdldCBtZXRob2ROYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hY3Rpb24ubWV0aG9kTmFtZTtcbiAgICB9XG4gICAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjb3BlLmVsZW1lbnQ7XG4gICAgfVxuICAgIGdldCBzY29wZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5zY29wZTtcbiAgICB9XG59XG5cbmNsYXNzIEVsZW1lbnRPYnNlcnZlciB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgZGVsZWdhdGUpIHtcbiAgICAgICAgdGhpcy5tdXRhdGlvbk9ic2VydmVySW5pdCA9IHsgYXR0cmlidXRlczogdHJ1ZSwgY2hpbGRMaXN0OiB0cnVlLCBzdWJ0cmVlOiB0cnVlIH07XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlbGVnYXRlID0gZGVsZWdhdGU7XG4gICAgICAgIHRoaXMuZWxlbWVudHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMubXV0YXRpb25PYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKChtdXRhdGlvbnMpID0+IHRoaXMucHJvY2Vzc011dGF0aW9ucyhtdXRhdGlvbnMpKTtcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5zdGFydGVkKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5tdXRhdGlvbk9ic2VydmVyLm9ic2VydmUodGhpcy5lbGVtZW50LCB0aGlzLm11dGF0aW9uT2JzZXJ2ZXJJbml0KTtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBhdXNlKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMubXV0YXRpb25PYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICBpZiAoIXRoaXMuc3RhcnRlZCkge1xuICAgICAgICAgICAgdGhpcy5tdXRhdGlvbk9ic2VydmVyLm9ic2VydmUodGhpcy5lbGVtZW50LCB0aGlzLm11dGF0aW9uT2JzZXJ2ZXJJbml0KTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhcnRlZCkge1xuICAgICAgICAgICAgdGhpcy5tdXRhdGlvbk9ic2VydmVyLnRha2VSZWNvcmRzKCk7XG4gICAgICAgICAgICB0aGlzLm11dGF0aW9uT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVmcmVzaCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhcnRlZCkge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2hlcyA9IG5ldyBTZXQodGhpcy5tYXRjaEVsZW1lbnRzSW5UcmVlKCkpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIEFycmF5LmZyb20odGhpcy5lbGVtZW50cykpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW1hdGNoZXMuaGFzKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlRWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgQXJyYXkuZnJvbShtYXRjaGVzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkRWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBwcm9jZXNzTXV0YXRpb25zKG11dGF0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5zdGFydGVkKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG11dGF0aW9uIG9mIG11dGF0aW9ucykge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc011dGF0aW9uKG11dGF0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBwcm9jZXNzTXV0YXRpb24obXV0YXRpb24pIHtcbiAgICAgICAgaWYgKG11dGF0aW9uLnR5cGUgPT0gXCJhdHRyaWJ1dGVzXCIpIHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc0F0dHJpYnV0ZUNoYW5nZShtdXRhdGlvbi50YXJnZXQsIG11dGF0aW9uLmF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG11dGF0aW9uLnR5cGUgPT0gXCJjaGlsZExpc3RcIikge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzUmVtb3ZlZE5vZGVzKG11dGF0aW9uLnJlbW92ZWROb2Rlcyk7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NBZGRlZE5vZGVzKG11dGF0aW9uLmFkZGVkTm9kZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByb2Nlc3NBdHRyaWJ1dGVDaGFuZ2UoZWxlbWVudCwgYXR0cmlidXRlTmFtZSkge1xuICAgICAgICBpZiAodGhpcy5lbGVtZW50cy5oYXMoZWxlbWVudCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlbGVnYXRlLmVsZW1lbnRBdHRyaWJ1dGVDaGFuZ2VkICYmIHRoaXMubWF0Y2hFbGVtZW50KGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5lbGVtZW50QXR0cmlidXRlQ2hhbmdlZChlbGVtZW50LCBhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlRWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLm1hdGNoRWxlbWVudChlbGVtZW50KSkge1xuICAgICAgICAgICAgdGhpcy5hZGRFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByb2Nlc3NSZW1vdmVkTm9kZXMobm9kZXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIEFycmF5LmZyb20obm9kZXMpKSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5lbGVtZW50RnJvbU5vZGUobm9kZSk7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc1RyZWUoZWxlbWVudCwgdGhpcy5yZW1vdmVFbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBwcm9jZXNzQWRkZWROb2Rlcyhub2Rlcykge1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgQXJyYXkuZnJvbShub2RlcykpIHtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnRGcm9tTm9kZShub2RlKTtcbiAgICAgICAgICAgIGlmIChlbGVtZW50ICYmIHRoaXMuZWxlbWVudElzQWN0aXZlKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzVHJlZShlbGVtZW50LCB0aGlzLmFkZEVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG1hdGNoRWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlLm1hdGNoRWxlbWVudChlbGVtZW50KTtcbiAgICB9XG4gICAgbWF0Y2hFbGVtZW50c0luVHJlZSh0cmVlID0gdGhpcy5lbGVtZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlLm1hdGNoRWxlbWVudHNJblRyZWUodHJlZSk7XG4gICAgfVxuICAgIHByb2Nlc3NUcmVlKHRyZWUsIHByb2Nlc3Nvcikge1xuICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdGhpcy5tYXRjaEVsZW1lbnRzSW5UcmVlKHRyZWUpKSB7XG4gICAgICAgICAgICBwcm9jZXNzb3IuY2FsbCh0aGlzLCBlbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbGVtZW50RnJvbU5vZGUobm9kZSkge1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxlbWVudElzQWN0aXZlKGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKGVsZW1lbnQuaXNDb25uZWN0ZWQgIT0gdGhpcy5lbGVtZW50LmlzQ29ubmVjdGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50LmNvbnRhaW5zKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFkZEVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgICBpZiAoIXRoaXMuZWxlbWVudHMuaGFzKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5lbGVtZW50SXNBY3RpdmUoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnRzLmFkZChlbGVtZW50KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZS5lbGVtZW50TWF0Y2hlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlbGVnYXRlLmVsZW1lbnRNYXRjaGVkKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudHMuaGFzKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnRzLmRlbGV0ZShlbGVtZW50KTtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlbGVnYXRlLmVsZW1lbnRVbm1hdGNoZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGVnYXRlLmVsZW1lbnRVbm1hdGNoZWQoZWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIEF0dHJpYnV0ZU9ic2VydmVyIHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBhdHRyaWJ1dGVOYW1lLCBkZWxlZ2F0ZSkge1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZU5hbWUgPSBhdHRyaWJ1dGVOYW1lO1xuICAgICAgICB0aGlzLmRlbGVnYXRlID0gZGVsZWdhdGU7XG4gICAgICAgIHRoaXMuZWxlbWVudE9ic2VydmVyID0gbmV3IEVsZW1lbnRPYnNlcnZlcihlbGVtZW50LCB0aGlzKTtcbiAgICB9XG4gICAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRPYnNlcnZlci5lbGVtZW50O1xuICAgIH1cbiAgICBnZXQgc2VsZWN0b3IoKSB7XG4gICAgICAgIHJldHVybiBgWyR7dGhpcy5hdHRyaWJ1dGVOYW1lfV1gO1xuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50T2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICB9XG4gICAgcGF1c2UoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5lbGVtZW50T2JzZXJ2ZXIucGF1c2UoY2FsbGJhY2spO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICB0aGlzLmVsZW1lbnRPYnNlcnZlci5zdG9wKCk7XG4gICAgfVxuICAgIHJlZnJlc2goKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudE9ic2VydmVyLnJlZnJlc2goKTtcbiAgICB9XG4gICAgZ2V0IHN0YXJ0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRPYnNlcnZlci5zdGFydGVkO1xuICAgIH1cbiAgICBtYXRjaEVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gZWxlbWVudC5oYXNBdHRyaWJ1dGUodGhpcy5hdHRyaWJ1dGVOYW1lKTtcbiAgICB9XG4gICAgbWF0Y2hFbGVtZW50c0luVHJlZSh0cmVlKSB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gdGhpcy5tYXRjaEVsZW1lbnQodHJlZSkgPyBbdHJlZV0gOiBbXTtcbiAgICAgICAgY29uc3QgbWF0Y2hlcyA9IEFycmF5LmZyb20odHJlZS5xdWVyeVNlbGVjdG9yQWxsKHRoaXMuc2VsZWN0b3IpKTtcbiAgICAgICAgcmV0dXJuIG1hdGNoLmNvbmNhdChtYXRjaGVzKTtcbiAgICB9XG4gICAgZWxlbWVudE1hdGNoZWQoZWxlbWVudCkge1xuICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZS5lbGVtZW50TWF0Y2hlZEF0dHJpYnV0ZSkge1xuICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5lbGVtZW50TWF0Y2hlZEF0dHJpYnV0ZShlbGVtZW50LCB0aGlzLmF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsZW1lbnRVbm1hdGNoZWQoZWxlbWVudCkge1xuICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZS5lbGVtZW50VW5tYXRjaGVkQXR0cmlidXRlKSB7XG4gICAgICAgICAgICB0aGlzLmRlbGVnYXRlLmVsZW1lbnRVbm1hdGNoZWRBdHRyaWJ1dGUoZWxlbWVudCwgdGhpcy5hdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbGVtZW50QXR0cmlidXRlQ2hhbmdlZChlbGVtZW50LCBhdHRyaWJ1dGVOYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLmRlbGVnYXRlLmVsZW1lbnRBdHRyaWJ1dGVWYWx1ZUNoYW5nZWQgJiYgdGhpcy5hdHRyaWJ1dGVOYW1lID09IGF0dHJpYnV0ZU5hbWUpIHtcbiAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUuZWxlbWVudEF0dHJpYnV0ZVZhbHVlQ2hhbmdlZChlbGVtZW50LCBhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gYWRkKG1hcCwga2V5LCB2YWx1ZSkge1xuICAgIGZldGNoKG1hcCwga2V5KS5hZGQodmFsdWUpO1xufVxuZnVuY3Rpb24gZGVsKG1hcCwga2V5LCB2YWx1ZSkge1xuICAgIGZldGNoKG1hcCwga2V5KS5kZWxldGUodmFsdWUpO1xuICAgIHBydW5lKG1hcCwga2V5KTtcbn1cbmZ1bmN0aW9uIGZldGNoKG1hcCwga2V5KSB7XG4gICAgbGV0IHZhbHVlcyA9IG1hcC5nZXQoa2V5KTtcbiAgICBpZiAoIXZhbHVlcykge1xuICAgICAgICB2YWx1ZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIG1hcC5zZXQoa2V5LCB2YWx1ZXMpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xufVxuZnVuY3Rpb24gcHJ1bmUobWFwLCBrZXkpIHtcbiAgICBjb25zdCB2YWx1ZXMgPSBtYXAuZ2V0KGtleSk7XG4gICAgaWYgKHZhbHVlcyAhPSBudWxsICYmIHZhbHVlcy5zaXplID09IDApIHtcbiAgICAgICAgbWFwLmRlbGV0ZShrZXkpO1xuICAgIH1cbn1cblxuY2xhc3MgTXVsdGltYXAge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnZhbHVlc0J5S2V5ID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBnZXQga2V5cygpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy52YWx1ZXNCeUtleS5rZXlzKCkpO1xuICAgIH1cbiAgICBnZXQgdmFsdWVzKCkge1xuICAgICAgICBjb25zdCBzZXRzID0gQXJyYXkuZnJvbSh0aGlzLnZhbHVlc0J5S2V5LnZhbHVlcygpKTtcbiAgICAgICAgcmV0dXJuIHNldHMucmVkdWNlKCh2YWx1ZXMsIHNldCkgPT4gdmFsdWVzLmNvbmNhdChBcnJheS5mcm9tKHNldCkpLCBbXSk7XG4gICAgfVxuICAgIGdldCBzaXplKCkge1xuICAgICAgICBjb25zdCBzZXRzID0gQXJyYXkuZnJvbSh0aGlzLnZhbHVlc0J5S2V5LnZhbHVlcygpKTtcbiAgICAgICAgcmV0dXJuIHNldHMucmVkdWNlKChzaXplLCBzZXQpID0+IHNpemUgKyBzZXQuc2l6ZSwgMCk7XG4gICAgfVxuICAgIGFkZChrZXksIHZhbHVlKSB7XG4gICAgICAgIGFkZCh0aGlzLnZhbHVlc0J5S2V5LCBrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgZGVsZXRlKGtleSwgdmFsdWUpIHtcbiAgICAgICAgZGVsKHRoaXMudmFsdWVzQnlLZXksIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICBoYXMoa2V5LCB2YWx1ZSkge1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSB0aGlzLnZhbHVlc0J5S2V5LmdldChrZXkpO1xuICAgICAgICByZXR1cm4gdmFsdWVzICE9IG51bGwgJiYgdmFsdWVzLmhhcyh2YWx1ZSk7XG4gICAgfVxuICAgIGhhc0tleShrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVzQnlLZXkuaGFzKGtleSk7XG4gICAgfVxuICAgIGhhc1ZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHNldHMgPSBBcnJheS5mcm9tKHRoaXMudmFsdWVzQnlLZXkudmFsdWVzKCkpO1xuICAgICAgICByZXR1cm4gc2V0cy5zb21lKChzZXQpID0+IHNldC5oYXModmFsdWUpKTtcbiAgICB9XG4gICAgZ2V0VmFsdWVzRm9yS2V5KGtleSkge1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSB0aGlzLnZhbHVlc0J5S2V5LmdldChrZXkpO1xuICAgICAgICByZXR1cm4gdmFsdWVzID8gQXJyYXkuZnJvbSh2YWx1ZXMpIDogW107XG4gICAgfVxuICAgIGdldEtleXNGb3JWYWx1ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnZhbHVlc0J5S2V5KVxuICAgICAgICAgICAgLmZpbHRlcigoW19rZXksIHZhbHVlc10pID0+IHZhbHVlcy5oYXModmFsdWUpKVxuICAgICAgICAgICAgLm1hcCgoW2tleSwgX3ZhbHVlc10pID0+IGtleSk7XG4gICAgfVxufVxuXG5jbGFzcyBJbmRleGVkTXVsdGltYXAgZXh0ZW5kcyBNdWx0aW1hcCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMua2V5c0J5VmFsdWUgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGdldCB2YWx1ZXMoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMua2V5c0J5VmFsdWUua2V5cygpKTtcbiAgICB9XG4gICAgYWRkKGtleSwgdmFsdWUpIHtcbiAgICAgICAgc3VwZXIuYWRkKGtleSwgdmFsdWUpO1xuICAgICAgICBhZGQodGhpcy5rZXlzQnlWYWx1ZSwgdmFsdWUsIGtleSk7XG4gICAgfVxuICAgIGRlbGV0ZShrZXksIHZhbHVlKSB7XG4gICAgICAgIHN1cGVyLmRlbGV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgZGVsKHRoaXMua2V5c0J5VmFsdWUsIHZhbHVlLCBrZXkpO1xuICAgIH1cbiAgICBoYXNWYWx1ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5rZXlzQnlWYWx1ZS5oYXModmFsdWUpO1xuICAgIH1cbiAgICBnZXRLZXlzRm9yVmFsdWUodmFsdWUpIHtcbiAgICAgICAgY29uc3Qgc2V0ID0gdGhpcy5rZXlzQnlWYWx1ZS5nZXQodmFsdWUpO1xuICAgICAgICByZXR1cm4gc2V0ID8gQXJyYXkuZnJvbShzZXQpIDogW107XG4gICAgfVxufVxuXG5jbGFzcyBTZWxlY3Rvck9ic2VydmVyIHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBzZWxlY3RvciwgZGVsZWdhdGUsIGRldGFpbHMpIHtcbiAgICAgICAgdGhpcy5fc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICAgICAgdGhpcy5kZXRhaWxzID0gZGV0YWlscztcbiAgICAgICAgdGhpcy5lbGVtZW50T2JzZXJ2ZXIgPSBuZXcgRWxlbWVudE9ic2VydmVyKGVsZW1lbnQsIHRoaXMpO1xuICAgICAgICB0aGlzLmRlbGVnYXRlID0gZGVsZWdhdGU7XG4gICAgICAgIHRoaXMubWF0Y2hlc0J5RWxlbWVudCA9IG5ldyBNdWx0aW1hcCgpO1xuICAgIH1cbiAgICBnZXQgc3RhcnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudE9ic2VydmVyLnN0YXJ0ZWQ7XG4gICAgfVxuICAgIGdldCBzZWxlY3RvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlbGVjdG9yO1xuICAgIH1cbiAgICBzZXQgc2VsZWN0b3Ioc2VsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5fc2VsZWN0b3IgPSBzZWxlY3RvcjtcbiAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICB0aGlzLmVsZW1lbnRPYnNlcnZlci5zdGFydCgpO1xuICAgIH1cbiAgICBwYXVzZShjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmVsZW1lbnRPYnNlcnZlci5wYXVzZShjYWxsYmFjayk7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudE9ic2VydmVyLnN0b3AoKTtcbiAgICB9XG4gICAgcmVmcmVzaCgpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50T2JzZXJ2ZXIucmVmcmVzaCgpO1xuICAgIH1cbiAgICBnZXQgZWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudE9ic2VydmVyLmVsZW1lbnQ7XG4gICAgfVxuICAgIG1hdGNoRWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IHsgc2VsZWN0b3IgfSA9IHRoaXM7XG4gICAgICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2hlcyA9IGVsZW1lbnQubWF0Y2hlcyhzZWxlY3Rvcik7XG4gICAgICAgICAgICBpZiAodGhpcy5kZWxlZ2F0ZS5zZWxlY3Rvck1hdGNoRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXRjaGVzICYmIHRoaXMuZGVsZWdhdGUuc2VsZWN0b3JNYXRjaEVsZW1lbnQoZWxlbWVudCwgdGhpcy5kZXRhaWxzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXRjaGVzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1hdGNoRWxlbWVudHNJblRyZWUodHJlZSkge1xuICAgICAgICBjb25zdCB7IHNlbGVjdG9yIH0gPSB0aGlzO1xuICAgICAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gdGhpcy5tYXRjaEVsZW1lbnQodHJlZSkgPyBbdHJlZV0gOiBbXTtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSBBcnJheS5mcm9tKHRyZWUucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpLmZpbHRlcigobWF0Y2gpID0+IHRoaXMubWF0Y2hFbGVtZW50KG1hdGNoKSk7XG4gICAgICAgICAgICByZXR1cm4gbWF0Y2guY29uY2F0KG1hdGNoZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsZW1lbnRNYXRjaGVkKGVsZW1lbnQpIHtcbiAgICAgICAgY29uc3QgeyBzZWxlY3RvciB9ID0gdGhpcztcbiAgICAgICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdG9yTWF0Y2hlZChlbGVtZW50LCBzZWxlY3Rvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxlbWVudFVubWF0Y2hlZChlbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdG9ycyA9IHRoaXMubWF0Y2hlc0J5RWxlbWVudC5nZXRLZXlzRm9yVmFsdWUoZWxlbWVudCk7XG4gICAgICAgIGZvciAoY29uc3Qgc2VsZWN0b3Igb2Ygc2VsZWN0b3JzKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdG9yVW5tYXRjaGVkKGVsZW1lbnQsIHNlbGVjdG9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbGVtZW50QXR0cmlidXRlQ2hhbmdlZChlbGVtZW50LCBfYXR0cmlidXRlTmFtZSkge1xuICAgICAgICBjb25zdCB7IHNlbGVjdG9yIH0gPSB0aGlzO1xuICAgICAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSB0aGlzLm1hdGNoRWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoZWRCZWZvcmUgPSB0aGlzLm1hdGNoZXNCeUVsZW1lbnQuaGFzKHNlbGVjdG9yLCBlbGVtZW50KTtcbiAgICAgICAgICAgIGlmIChtYXRjaGVzICYmICFtYXRjaGVkQmVmb3JlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3Rvck1hdGNoZWQoZWxlbWVudCwgc2VsZWN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIW1hdGNoZXMgJiYgbWF0Y2hlZEJlZm9yZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0b3JVbm1hdGNoZWQoZWxlbWVudCwgc2VsZWN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHNlbGVjdG9yTWF0Y2hlZChlbGVtZW50LCBzZWxlY3Rvcikge1xuICAgICAgICB0aGlzLmRlbGVnYXRlLnNlbGVjdG9yTWF0Y2hlZChlbGVtZW50LCBzZWxlY3RvciwgdGhpcy5kZXRhaWxzKTtcbiAgICAgICAgdGhpcy5tYXRjaGVzQnlFbGVtZW50LmFkZChzZWxlY3RvciwgZWxlbWVudCk7XG4gICAgfVxuICAgIHNlbGVjdG9yVW5tYXRjaGVkKGVsZW1lbnQsIHNlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMuZGVsZWdhdGUuc2VsZWN0b3JVbm1hdGNoZWQoZWxlbWVudCwgc2VsZWN0b3IsIHRoaXMuZGV0YWlscyk7XG4gICAgICAgIHRoaXMubWF0Y2hlc0J5RWxlbWVudC5kZWxldGUoc2VsZWN0b3IsIGVsZW1lbnQpO1xuICAgIH1cbn1cblxuY2xhc3MgU3RyaW5nTWFwT2JzZXJ2ZXIge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGRlbGVnYXRlKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMuZGVsZWdhdGUgPSBkZWxlZ2F0ZTtcbiAgICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc3RyaW5nTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLm11dGF0aW9uT2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcigobXV0YXRpb25zKSA9PiB0aGlzLnByb2Nlc3NNdXRhdGlvbnMobXV0YXRpb25zKSk7XG4gICAgfVxuICAgIHN0YXJ0KCkge1xuICAgICAgICBpZiAoIXRoaXMuc3RhcnRlZCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMubXV0YXRpb25PYnNlcnZlci5vYnNlcnZlKHRoaXMuZWxlbWVudCwgeyBhdHRyaWJ1dGVzOiB0cnVlLCBhdHRyaWJ1dGVPbGRWYWx1ZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMubXV0YXRpb25PYnNlcnZlci50YWtlUmVjb3JkcygpO1xuICAgICAgICAgICAgdGhpcy5tdXRhdGlvbk9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlZnJlc2goKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYXR0cmlidXRlTmFtZSBvZiB0aGlzLmtub3duQXR0cmlidXRlTmFtZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSwgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJvY2Vzc011dGF0aW9ucyhtdXRhdGlvbnMpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhcnRlZCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBtdXRhdGlvbiBvZiBtdXRhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NNdXRhdGlvbihtdXRhdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJvY2Vzc011dGF0aW9uKG11dGF0aW9uKSB7XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZU5hbWUgPSBtdXRhdGlvbi5hdHRyaWJ1dGVOYW1lO1xuICAgICAgICBpZiAoYXR0cmlidXRlTmFtZSkge1xuICAgICAgICAgICAgdGhpcy5yZWZyZXNoQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsIG11dGF0aW9uLm9sZFZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWZyZXNoQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMuZGVsZWdhdGUuZ2V0U3RyaW5nTWFwS2V5Rm9yQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICBpZiAoa2V5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zdHJpbmdNYXAuaGFzKGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHJpbmdNYXBLZXlBZGRlZChrZXksIGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RyaW5nTWFwLmdldChhdHRyaWJ1dGVOYW1lKSAhPSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RyaW5nTWFwVmFsdWVDaGFuZ2VkKHZhbHVlLCBrZXksIG9sZFZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLnN0cmluZ01hcC5nZXQoYXR0cmlidXRlTmFtZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHJpbmdNYXAuZGVsZXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChvbGRWYWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHJpbmdNYXBLZXlSZW1vdmVkKGtleSwgYXR0cmlidXRlTmFtZSwgb2xkVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHJpbmdNYXAuc2V0KGF0dHJpYnV0ZU5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzdHJpbmdNYXBLZXlBZGRlZChrZXksIGF0dHJpYnV0ZU5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVsZWdhdGUuc3RyaW5nTWFwS2V5QWRkZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUuc3RyaW5nTWFwS2V5QWRkZWQoa2V5LCBhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdHJpbmdNYXBWYWx1ZUNoYW5nZWQodmFsdWUsIGtleSwgb2xkVmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVsZWdhdGUuc3RyaW5nTWFwVmFsdWVDaGFuZ2VkKSB7XG4gICAgICAgICAgICB0aGlzLmRlbGVnYXRlLnN0cmluZ01hcFZhbHVlQ2hhbmdlZCh2YWx1ZSwga2V5LCBvbGRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RyaW5nTWFwS2V5UmVtb3ZlZChrZXksIGF0dHJpYnV0ZU5hbWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmRlbGVnYXRlLnN0cmluZ01hcEtleVJlbW92ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUuc3RyaW5nTWFwS2V5UmVtb3ZlZChrZXksIGF0dHJpYnV0ZU5hbWUsIG9sZFZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQga25vd25BdHRyaWJ1dGVOYW1lcygpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldCh0aGlzLmN1cnJlbnRBdHRyaWJ1dGVOYW1lcy5jb25jYXQodGhpcy5yZWNvcmRlZEF0dHJpYnV0ZU5hbWVzKSkpO1xuICAgIH1cbiAgICBnZXQgY3VycmVudEF0dHJpYnV0ZU5hbWVzKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmVsZW1lbnQuYXR0cmlidXRlcykubWFwKChhdHRyaWJ1dGUpID0+IGF0dHJpYnV0ZS5uYW1lKTtcbiAgICB9XG4gICAgZ2V0IHJlY29yZGVkQXR0cmlidXRlTmFtZXMoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuc3RyaW5nTWFwLmtleXMoKSk7XG4gICAgfVxufVxuXG5jbGFzcyBUb2tlbkxpc3RPYnNlcnZlciB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgYXR0cmlidXRlTmFtZSwgZGVsZWdhdGUpIHtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVPYnNlcnZlciA9IG5ldyBBdHRyaWJ1dGVPYnNlcnZlcihlbGVtZW50LCBhdHRyaWJ1dGVOYW1lLCB0aGlzKTtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xuICAgICAgICB0aGlzLnRva2Vuc0J5RWxlbWVudCA9IG5ldyBNdWx0aW1hcCgpO1xuICAgIH1cbiAgICBnZXQgc3RhcnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0cmlidXRlT2JzZXJ2ZXIuc3RhcnRlZDtcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlT2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICB9XG4gICAgcGF1c2UoY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVPYnNlcnZlci5wYXVzZShjYWxsYmFjayk7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlT2JzZXJ2ZXIuc3RvcCgpO1xuICAgIH1cbiAgICByZWZyZXNoKCkge1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZU9ic2VydmVyLnJlZnJlc2goKTtcbiAgICB9XG4gICAgZ2V0IGVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZU9ic2VydmVyLmVsZW1lbnQ7XG4gICAgfVxuICAgIGdldCBhdHRyaWJ1dGVOYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVPYnNlcnZlci5hdHRyaWJ1dGVOYW1lO1xuICAgIH1cbiAgICBlbGVtZW50TWF0Y2hlZEF0dHJpYnV0ZShlbGVtZW50KSB7XG4gICAgICAgIHRoaXMudG9rZW5zTWF0Y2hlZCh0aGlzLnJlYWRUb2tlbnNGb3JFbGVtZW50KGVsZW1lbnQpKTtcbiAgICB9XG4gICAgZWxlbWVudEF0dHJpYnV0ZVZhbHVlQ2hhbmdlZChlbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IFt1bm1hdGNoZWRUb2tlbnMsIG1hdGNoZWRUb2tlbnNdID0gdGhpcy5yZWZyZXNoVG9rZW5zRm9yRWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgdGhpcy50b2tlbnNVbm1hdGNoZWQodW5tYXRjaGVkVG9rZW5zKTtcbiAgICAgICAgdGhpcy50b2tlbnNNYXRjaGVkKG1hdGNoZWRUb2tlbnMpO1xuICAgIH1cbiAgICBlbGVtZW50VW5tYXRjaGVkQXR0cmlidXRlKGVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy50b2tlbnNVbm1hdGNoZWQodGhpcy50b2tlbnNCeUVsZW1lbnQuZ2V0VmFsdWVzRm9yS2V5KGVsZW1lbnQpKTtcbiAgICB9XG4gICAgdG9rZW5zTWF0Y2hlZCh0b2tlbnMpIHtcbiAgICAgICAgdG9rZW5zLmZvckVhY2goKHRva2VuKSA9PiB0aGlzLnRva2VuTWF0Y2hlZCh0b2tlbikpO1xuICAgIH1cbiAgICB0b2tlbnNVbm1hdGNoZWQodG9rZW5zKSB7XG4gICAgICAgIHRva2Vucy5mb3JFYWNoKCh0b2tlbikgPT4gdGhpcy50b2tlblVubWF0Y2hlZCh0b2tlbikpO1xuICAgIH1cbiAgICB0b2tlbk1hdGNoZWQodG9rZW4pIHtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZS50b2tlbk1hdGNoZWQodG9rZW4pO1xuICAgICAgICB0aGlzLnRva2Vuc0J5RWxlbWVudC5hZGQodG9rZW4uZWxlbWVudCwgdG9rZW4pO1xuICAgIH1cbiAgICB0b2tlblVubWF0Y2hlZCh0b2tlbikge1xuICAgICAgICB0aGlzLmRlbGVnYXRlLnRva2VuVW5tYXRjaGVkKHRva2VuKTtcbiAgICAgICAgdGhpcy50b2tlbnNCeUVsZW1lbnQuZGVsZXRlKHRva2VuLmVsZW1lbnQsIHRva2VuKTtcbiAgICB9XG4gICAgcmVmcmVzaFRva2Vuc0ZvckVsZW1lbnQoZWxlbWVudCkge1xuICAgICAgICBjb25zdCBwcmV2aW91c1Rva2VucyA9IHRoaXMudG9rZW5zQnlFbGVtZW50LmdldFZhbHVlc0ZvcktleShlbGVtZW50KTtcbiAgICAgICAgY29uc3QgY3VycmVudFRva2VucyA9IHRoaXMucmVhZFRva2Vuc0ZvckVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgIGNvbnN0IGZpcnN0RGlmZmVyaW5nSW5kZXggPSB6aXAocHJldmlvdXNUb2tlbnMsIGN1cnJlbnRUb2tlbnMpLmZpbmRJbmRleCgoW3ByZXZpb3VzVG9rZW4sIGN1cnJlbnRUb2tlbl0pID0+ICF0b2tlbnNBcmVFcXVhbChwcmV2aW91c1Rva2VuLCBjdXJyZW50VG9rZW4pKTtcbiAgICAgICAgaWYgKGZpcnN0RGlmZmVyaW5nSW5kZXggPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBbW10sIFtdXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbcHJldmlvdXNUb2tlbnMuc2xpY2UoZmlyc3REaWZmZXJpbmdJbmRleCksIGN1cnJlbnRUb2tlbnMuc2xpY2UoZmlyc3REaWZmZXJpbmdJbmRleCldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlYWRUb2tlbnNGb3JFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlTmFtZSA9IHRoaXMuYXR0cmlidXRlTmFtZTtcbiAgICAgICAgY29uc3QgdG9rZW5TdHJpbmcgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKSB8fCBcIlwiO1xuICAgICAgICByZXR1cm4gcGFyc2VUb2tlblN0cmluZyh0b2tlblN0cmluZywgZWxlbWVudCwgYXR0cmlidXRlTmFtZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2VUb2tlblN0cmluZyh0b2tlblN0cmluZywgZWxlbWVudCwgYXR0cmlidXRlTmFtZSkge1xuICAgIHJldHVybiB0b2tlblN0cmluZ1xuICAgICAgICAudHJpbSgpXG4gICAgICAgIC5zcGxpdCgvXFxzKy8pXG4gICAgICAgIC5maWx0ZXIoKGNvbnRlbnQpID0+IGNvbnRlbnQubGVuZ3RoKVxuICAgICAgICAubWFwKChjb250ZW50LCBpbmRleCkgPT4gKHsgZWxlbWVudCwgYXR0cmlidXRlTmFtZSwgY29udGVudCwgaW5kZXggfSkpO1xufVxuZnVuY3Rpb24gemlwKGxlZnQsIHJpZ2h0KSB7XG4gICAgY29uc3QgbGVuZ3RoID0gTWF0aC5tYXgobGVmdC5sZW5ndGgsIHJpZ2h0Lmxlbmd0aCk7XG4gICAgcmV0dXJuIEFycmF5LmZyb20oeyBsZW5ndGggfSwgKF8sIGluZGV4KSA9PiBbbGVmdFtpbmRleF0sIHJpZ2h0W2luZGV4XV0pO1xufVxuZnVuY3Rpb24gdG9rZW5zQXJlRXF1YWwobGVmdCwgcmlnaHQpIHtcbiAgICByZXR1cm4gbGVmdCAmJiByaWdodCAmJiBsZWZ0LmluZGV4ID09IHJpZ2h0LmluZGV4ICYmIGxlZnQuY29udGVudCA9PSByaWdodC5jb250ZW50O1xufVxuXG5jbGFzcyBWYWx1ZUxpc3RPYnNlcnZlciB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgYXR0cmlidXRlTmFtZSwgZGVsZWdhdGUpIHtcbiAgICAgICAgdGhpcy50b2tlbkxpc3RPYnNlcnZlciA9IG5ldyBUb2tlbkxpc3RPYnNlcnZlcihlbGVtZW50LCBhdHRyaWJ1dGVOYW1lLCB0aGlzKTtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xuICAgICAgICB0aGlzLnBhcnNlUmVzdWx0c0J5VG9rZW4gPSBuZXcgV2Vha01hcCgpO1xuICAgICAgICB0aGlzLnZhbHVlc0J5VG9rZW5CeUVsZW1lbnQgPSBuZXcgV2Vha01hcCgpO1xuICAgIH1cbiAgICBnZXQgc3RhcnRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5MaXN0T2JzZXJ2ZXIuc3RhcnRlZDtcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIHRoaXMudG9rZW5MaXN0T2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgdGhpcy50b2tlbkxpc3RPYnNlcnZlci5zdG9wKCk7XG4gICAgfVxuICAgIHJlZnJlc2goKSB7XG4gICAgICAgIHRoaXMudG9rZW5MaXN0T2JzZXJ2ZXIucmVmcmVzaCgpO1xuICAgIH1cbiAgICBnZXQgZWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5MaXN0T2JzZXJ2ZXIuZWxlbWVudDtcbiAgICB9XG4gICAgZ2V0IGF0dHJpYnV0ZU5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRva2VuTGlzdE9ic2VydmVyLmF0dHJpYnV0ZU5hbWU7XG4gICAgfVxuICAgIHRva2VuTWF0Y2hlZCh0b2tlbikge1xuICAgICAgICBjb25zdCB7IGVsZW1lbnQgfSA9IHRva2VuO1xuICAgICAgICBjb25zdCB7IHZhbHVlIH0gPSB0aGlzLmZldGNoUGFyc2VSZXN1bHRGb3JUb2tlbih0b2tlbik7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5mZXRjaFZhbHVlc0J5VG9rZW5Gb3JFbGVtZW50KGVsZW1lbnQpLnNldCh0b2tlbiwgdmFsdWUpO1xuICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5lbGVtZW50TWF0Y2hlZFZhbHVlKGVsZW1lbnQsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b2tlblVubWF0Y2hlZCh0b2tlbikge1xuICAgICAgICBjb25zdCB7IGVsZW1lbnQgfSA9IHRva2VuO1xuICAgICAgICBjb25zdCB7IHZhbHVlIH0gPSB0aGlzLmZldGNoUGFyc2VSZXN1bHRGb3JUb2tlbih0b2tlbik7XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5mZXRjaFZhbHVlc0J5VG9rZW5Gb3JFbGVtZW50KGVsZW1lbnQpLmRlbGV0ZSh0b2tlbik7XG4gICAgICAgICAgICB0aGlzLmRlbGVnYXRlLmVsZW1lbnRVbm1hdGNoZWRWYWx1ZShlbGVtZW50LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmV0Y2hQYXJzZVJlc3VsdEZvclRva2VuKHRva2VuKSB7XG4gICAgICAgIGxldCBwYXJzZVJlc3VsdCA9IHRoaXMucGFyc2VSZXN1bHRzQnlUb2tlbi5nZXQodG9rZW4pO1xuICAgICAgICBpZiAoIXBhcnNlUmVzdWx0KSB7XG4gICAgICAgICAgICBwYXJzZVJlc3VsdCA9IHRoaXMucGFyc2VUb2tlbih0b2tlbik7XG4gICAgICAgICAgICB0aGlzLnBhcnNlUmVzdWx0c0J5VG9rZW4uc2V0KHRva2VuLCBwYXJzZVJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlUmVzdWx0O1xuICAgIH1cbiAgICBmZXRjaFZhbHVlc0J5VG9rZW5Gb3JFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgbGV0IHZhbHVlc0J5VG9rZW4gPSB0aGlzLnZhbHVlc0J5VG9rZW5CeUVsZW1lbnQuZ2V0KGVsZW1lbnQpO1xuICAgICAgICBpZiAoIXZhbHVlc0J5VG9rZW4pIHtcbiAgICAgICAgICAgIHZhbHVlc0J5VG9rZW4gPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICB0aGlzLnZhbHVlc0J5VG9rZW5CeUVsZW1lbnQuc2V0KGVsZW1lbnQsIHZhbHVlc0J5VG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZXNCeVRva2VuO1xuICAgIH1cbiAgICBwYXJzZVRva2VuKHRva2VuKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZGVsZWdhdGUucGFyc2VWYWx1ZUZvclRva2VuKHRva2VuKTtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlIH07XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4geyBlcnJvciB9O1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jbGFzcyBCaW5kaW5nT2JzZXJ2ZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIGRlbGVnYXRlKSB7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuZGVsZWdhdGUgPSBkZWxlZ2F0ZTtcbiAgICAgICAgdGhpcy5iaW5kaW5nc0J5QWN0aW9uID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZhbHVlTGlzdE9ic2VydmVyKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlTGlzdE9ic2VydmVyID0gbmV3IFZhbHVlTGlzdE9ic2VydmVyKHRoaXMuZWxlbWVudCwgdGhpcy5hY3Rpb25BdHRyaWJ1dGUsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy52YWx1ZUxpc3RPYnNlcnZlci5zdGFydCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlTGlzdE9ic2VydmVyKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlTGlzdE9ic2VydmVyLnN0b3AoKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnZhbHVlTGlzdE9ic2VydmVyO1xuICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0QWxsQWN0aW9ucygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBlbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0LmVsZW1lbnQ7XG4gICAgfVxuICAgIGdldCBpZGVudGlmaWVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0LmlkZW50aWZpZXI7XG4gICAgfVxuICAgIGdldCBhY3Rpb25BdHRyaWJ1dGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjaGVtYS5hY3Rpb25BdHRyaWJ1dGU7XG4gICAgfVxuICAgIGdldCBzY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQuc2NoZW1hO1xuICAgIH1cbiAgICBnZXQgYmluZGluZ3MoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuYmluZGluZ3NCeUFjdGlvbi52YWx1ZXMoKSk7XG4gICAgfVxuICAgIGNvbm5lY3RBY3Rpb24oYWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGJpbmRpbmcgPSBuZXcgQmluZGluZyh0aGlzLmNvbnRleHQsIGFjdGlvbik7XG4gICAgICAgIHRoaXMuYmluZGluZ3NCeUFjdGlvbi5zZXQoYWN0aW9uLCBiaW5kaW5nKTtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZS5iaW5kaW5nQ29ubmVjdGVkKGJpbmRpbmcpO1xuICAgIH1cbiAgICBkaXNjb25uZWN0QWN0aW9uKGFjdGlvbikge1xuICAgICAgICBjb25zdCBiaW5kaW5nID0gdGhpcy5iaW5kaW5nc0J5QWN0aW9uLmdldChhY3Rpb24pO1xuICAgICAgICBpZiAoYmluZGluZykge1xuICAgICAgICAgICAgdGhpcy5iaW5kaW5nc0J5QWN0aW9uLmRlbGV0ZShhY3Rpb24pO1xuICAgICAgICAgICAgdGhpcy5kZWxlZ2F0ZS5iaW5kaW5nRGlzY29ubmVjdGVkKGJpbmRpbmcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRpc2Nvbm5lY3RBbGxBY3Rpb25zKCkge1xuICAgICAgICB0aGlzLmJpbmRpbmdzLmZvckVhY2goKGJpbmRpbmcpID0+IHRoaXMuZGVsZWdhdGUuYmluZGluZ0Rpc2Nvbm5lY3RlZChiaW5kaW5nLCB0cnVlKSk7XG4gICAgICAgIHRoaXMuYmluZGluZ3NCeUFjdGlvbi5jbGVhcigpO1xuICAgIH1cbiAgICBwYXJzZVZhbHVlRm9yVG9rZW4odG9rZW4pIHtcbiAgICAgICAgY29uc3QgYWN0aW9uID0gQWN0aW9uLmZvclRva2VuKHRva2VuLCB0aGlzLnNjaGVtYSk7XG4gICAgICAgIGlmIChhY3Rpb24uaWRlbnRpZmllciA9PSB0aGlzLmlkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBhY3Rpb247XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxlbWVudE1hdGNoZWRWYWx1ZShlbGVtZW50LCBhY3Rpb24pIHtcbiAgICAgICAgdGhpcy5jb25uZWN0QWN0aW9uKGFjdGlvbik7XG4gICAgfVxuICAgIGVsZW1lbnRVbm1hdGNoZWRWYWx1ZShlbGVtZW50LCBhY3Rpb24pIHtcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0QWN0aW9uKGFjdGlvbik7XG4gICAgfVxufVxuXG5jbGFzcyBWYWx1ZU9ic2VydmVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCByZWNlaXZlcikge1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLnJlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgICAgIHRoaXMuc3RyaW5nTWFwT2JzZXJ2ZXIgPSBuZXcgU3RyaW5nTWFwT2JzZXJ2ZXIodGhpcy5lbGVtZW50LCB0aGlzKTtcbiAgICAgICAgdGhpcy52YWx1ZURlc2NyaXB0b3JNYXAgPSB0aGlzLmNvbnRyb2xsZXIudmFsdWVEZXNjcmlwdG9yTWFwO1xuICAgIH1cbiAgICBzdGFydCgpIHtcbiAgICAgICAgdGhpcy5zdHJpbmdNYXBPYnNlcnZlci5zdGFydCgpO1xuICAgICAgICB0aGlzLmludm9rZUNoYW5nZWRDYWxsYmFja3NGb3JEZWZhdWx0VmFsdWVzKCk7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIHRoaXMuc3RyaW5nTWFwT2JzZXJ2ZXIuc3RvcCgpO1xuICAgIH1cbiAgICBnZXQgZWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5lbGVtZW50O1xuICAgIH1cbiAgICBnZXQgY29udHJvbGxlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5jb250cm9sbGVyO1xuICAgIH1cbiAgICBnZXRTdHJpbmdNYXBLZXlGb3JBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSkge1xuICAgICAgICBpZiAoYXR0cmlidXRlTmFtZSBpbiB0aGlzLnZhbHVlRGVzY3JpcHRvck1hcCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVEZXNjcmlwdG9yTWFwW2F0dHJpYnV0ZU5hbWVdLm5hbWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RyaW5nTWFwS2V5QWRkZWQoa2V5LCBhdHRyaWJ1dGVOYW1lKSB7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSB0aGlzLnZhbHVlRGVzY3JpcHRvck1hcFthdHRyaWJ1dGVOYW1lXTtcbiAgICAgICAgaWYgKCF0aGlzLmhhc1ZhbHVlKGtleSkpIHtcbiAgICAgICAgICAgIHRoaXMuaW52b2tlQ2hhbmdlZENhbGxiYWNrKGtleSwgZGVzY3JpcHRvci53cml0ZXIodGhpcy5yZWNlaXZlcltrZXldKSwgZGVzY3JpcHRvci53cml0ZXIoZGVzY3JpcHRvci5kZWZhdWx0VmFsdWUpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdHJpbmdNYXBWYWx1ZUNoYW5nZWQodmFsdWUsIG5hbWUsIG9sZFZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSB0aGlzLnZhbHVlRGVzY3JpcHRvck5hbWVNYXBbbmFtZV07XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKG9sZFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICBvbGRWYWx1ZSA9IGRlc2NyaXB0b3Iud3JpdGVyKGRlc2NyaXB0b3IuZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmludm9rZUNoYW5nZWRDYWxsYmFjayhuYW1lLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgIH1cbiAgICBzdHJpbmdNYXBLZXlSZW1vdmVkKGtleSwgYXR0cmlidXRlTmFtZSwgb2xkVmFsdWUpIHtcbiAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IHRoaXMudmFsdWVEZXNjcmlwdG9yTmFtZU1hcFtrZXldO1xuICAgICAgICBpZiAodGhpcy5oYXNWYWx1ZShrZXkpKSB7XG4gICAgICAgICAgICB0aGlzLmludm9rZUNoYW5nZWRDYWxsYmFjayhrZXksIGRlc2NyaXB0b3Iud3JpdGVyKHRoaXMucmVjZWl2ZXJba2V5XSksIG9sZFZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW52b2tlQ2hhbmdlZENhbGxiYWNrKGtleSwgZGVzY3JpcHRvci53cml0ZXIoZGVzY3JpcHRvci5kZWZhdWx0VmFsdWUpLCBvbGRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW52b2tlQ2hhbmdlZENhbGxiYWNrc0ZvckRlZmF1bHRWYWx1ZXMoKSB7XG4gICAgICAgIGZvciAoY29uc3QgeyBrZXksIG5hbWUsIGRlZmF1bHRWYWx1ZSwgd3JpdGVyIH0gb2YgdGhpcy52YWx1ZURlc2NyaXB0b3JzKSB7XG4gICAgICAgICAgICBpZiAoZGVmYXVsdFZhbHVlICE9IHVuZGVmaW5lZCAmJiAhdGhpcy5jb250cm9sbGVyLmRhdGEuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmludm9rZUNoYW5nZWRDYWxsYmFjayhuYW1lLCB3cml0ZXIoZGVmYXVsdFZhbHVlKSwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpbnZva2VDaGFuZ2VkQ2FsbGJhY2sobmFtZSwgcmF3VmFsdWUsIHJhd09sZFZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNoYW5nZWRNZXRob2ROYW1lID0gYCR7bmFtZX1DaGFuZ2VkYDtcbiAgICAgICAgY29uc3QgY2hhbmdlZE1ldGhvZCA9IHRoaXMucmVjZWl2ZXJbY2hhbmdlZE1ldGhvZE5hbWVdO1xuICAgICAgICBpZiAodHlwZW9mIGNoYW5nZWRNZXRob2QgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gdGhpcy52YWx1ZURlc2NyaXB0b3JOYW1lTWFwW25hbWVdO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGRlc2NyaXB0b3IucmVhZGVyKHJhd1ZhbHVlKTtcbiAgICAgICAgICAgICAgICBsZXQgb2xkVmFsdWUgPSByYXdPbGRWYWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAocmF3T2xkVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgb2xkVmFsdWUgPSBkZXNjcmlwdG9yLnJlYWRlcihyYXdPbGRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNoYW5nZWRNZXRob2QuY2FsbCh0aGlzLnJlY2VpdmVyLCB2YWx1ZSwgb2xkVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgVHlwZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLm1lc3NhZ2UgPSBgU3RpbXVsdXMgVmFsdWUgXCIke3RoaXMuY29udGV4dC5pZGVudGlmaWVyfS4ke2Rlc2NyaXB0b3IubmFtZX1cIiAtICR7ZXJyb3IubWVzc2FnZX1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgdmFsdWVEZXNjcmlwdG9ycygpIHtcbiAgICAgICAgY29uc3QgeyB2YWx1ZURlc2NyaXB0b3JNYXAgfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh2YWx1ZURlc2NyaXB0b3JNYXApLm1hcCgoa2V5KSA9PiB2YWx1ZURlc2NyaXB0b3JNYXBba2V5XSk7XG4gICAgfVxuICAgIGdldCB2YWx1ZURlc2NyaXB0b3JOYW1lTWFwKCkge1xuICAgICAgICBjb25zdCBkZXNjcmlwdG9ycyA9IHt9O1xuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLnZhbHVlRGVzY3JpcHRvck1hcCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkZXNjcmlwdG9yID0gdGhpcy52YWx1ZURlc2NyaXB0b3JNYXBba2V5XTtcbiAgICAgICAgICAgIGRlc2NyaXB0b3JzW2Rlc2NyaXB0b3IubmFtZV0gPSBkZXNjcmlwdG9yO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0b3JzO1xuICAgIH1cbiAgICBoYXNWYWx1ZShhdHRyaWJ1dGVOYW1lKSB7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSB0aGlzLnZhbHVlRGVzY3JpcHRvck5hbWVNYXBbYXR0cmlidXRlTmFtZV07XG4gICAgICAgIGNvbnN0IGhhc01ldGhvZE5hbWUgPSBgaGFzJHtjYXBpdGFsaXplKGRlc2NyaXB0b3IubmFtZSl9YDtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVjZWl2ZXJbaGFzTWV0aG9kTmFtZV07XG4gICAgfVxufVxuXG5jbGFzcyBUYXJnZXRPYnNlcnZlciB7XG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgZGVsZWdhdGUpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xuICAgICAgICB0aGlzLnRhcmdldHNCeU5hbWUgPSBuZXcgTXVsdGltYXAoKTtcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGlmICghdGhpcy50b2tlbkxpc3RPYnNlcnZlcikge1xuICAgICAgICAgICAgdGhpcy50b2tlbkxpc3RPYnNlcnZlciA9IG5ldyBUb2tlbkxpc3RPYnNlcnZlcih0aGlzLmVsZW1lbnQsIHRoaXMuYXR0cmlidXRlTmFtZSwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLnRva2VuTGlzdE9ic2VydmVyLnN0YXJ0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgaWYgKHRoaXMudG9rZW5MaXN0T2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdEFsbFRhcmdldHMoKTtcbiAgICAgICAgICAgIHRoaXMudG9rZW5MaXN0T2JzZXJ2ZXIuc3RvcCgpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMudG9rZW5MaXN0T2JzZXJ2ZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9rZW5NYXRjaGVkKHsgZWxlbWVudCwgY29udGVudDogbmFtZSB9KSB7XG4gICAgICAgIGlmICh0aGlzLnNjb3BlLmNvbnRhaW5zRWxlbWVudChlbGVtZW50KSkge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0VGFyZ2V0KGVsZW1lbnQsIG5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRva2VuVW5tYXRjaGVkKHsgZWxlbWVudCwgY29udGVudDogbmFtZSB9KSB7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdFRhcmdldChlbGVtZW50LCBuYW1lKTtcbiAgICB9XG4gICAgY29ubmVjdFRhcmdldChlbGVtZW50LCBuYW1lKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCF0aGlzLnRhcmdldHNCeU5hbWUuaGFzKG5hbWUsIGVsZW1lbnQpKSB7XG4gICAgICAgICAgICB0aGlzLnRhcmdldHNCeU5hbWUuYWRkKG5hbWUsIGVsZW1lbnQpO1xuICAgICAgICAgICAgKF9hID0gdGhpcy50b2tlbkxpc3RPYnNlcnZlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBhdXNlKCgpID0+IHRoaXMuZGVsZWdhdGUudGFyZ2V0Q29ubmVjdGVkKGVsZW1lbnQsIG5hbWUpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXNjb25uZWN0VGFyZ2V0KGVsZW1lbnQsIG5hbWUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAodGhpcy50YXJnZXRzQnlOYW1lLmhhcyhuYW1lLCBlbGVtZW50KSkge1xuICAgICAgICAgICAgdGhpcy50YXJnZXRzQnlOYW1lLmRlbGV0ZShuYW1lLCBlbGVtZW50KTtcbiAgICAgICAgICAgIChfYSA9IHRoaXMudG9rZW5MaXN0T2JzZXJ2ZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXVzZSgoKSA9PiB0aGlzLmRlbGVnYXRlLnRhcmdldERpc2Nvbm5lY3RlZChlbGVtZW50LCBuYW1lKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGlzY29ubmVjdEFsbFRhcmdldHMoKSB7XG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiB0aGlzLnRhcmdldHNCeU5hbWUua2V5cykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHRoaXMudGFyZ2V0c0J5TmFtZS5nZXRWYWx1ZXNGb3JLZXkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3RUYXJnZXQoZWxlbWVudCwgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGF0dHJpYnV0ZU5hbWUoKSB7XG4gICAgICAgIHJldHVybiBgZGF0YS0ke3RoaXMuY29udGV4dC5pZGVudGlmaWVyfS10YXJnZXRgO1xuICAgIH1cbiAgICBnZXQgZWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5lbGVtZW50O1xuICAgIH1cbiAgICBnZXQgc2NvcGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQuc2NvcGU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiByZWFkSW5oZXJpdGFibGVTdGF0aWNBcnJheVZhbHVlcyhjb25zdHJ1Y3RvciwgcHJvcGVydHlOYW1lKSB7XG4gICAgY29uc3QgYW5jZXN0b3JzID0gZ2V0QW5jZXN0b3JzRm9yQ29uc3RydWN0b3IoY29uc3RydWN0b3IpO1xuICAgIHJldHVybiBBcnJheS5mcm9tKGFuY2VzdG9ycy5yZWR1Y2UoKHZhbHVlcywgY29uc3RydWN0b3IpID0+IHtcbiAgICAgICAgZ2V0T3duU3RhdGljQXJyYXlWYWx1ZXMoY29uc3RydWN0b3IsIHByb3BlcnR5TmFtZSkuZm9yRWFjaCgobmFtZSkgPT4gdmFsdWVzLmFkZChuYW1lKSk7XG4gICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgfSwgbmV3IFNldCgpKSk7XG59XG5mdW5jdGlvbiByZWFkSW5oZXJpdGFibGVTdGF0aWNPYmplY3RQYWlycyhjb25zdHJ1Y3RvciwgcHJvcGVydHlOYW1lKSB7XG4gICAgY29uc3QgYW5jZXN0b3JzID0gZ2V0QW5jZXN0b3JzRm9yQ29uc3RydWN0b3IoY29uc3RydWN0b3IpO1xuICAgIHJldHVybiBhbmNlc3RvcnMucmVkdWNlKChwYWlycywgY29uc3RydWN0b3IpID0+IHtcbiAgICAgICAgcGFpcnMucHVzaCguLi5nZXRPd25TdGF0aWNPYmplY3RQYWlycyhjb25zdHJ1Y3RvciwgcHJvcGVydHlOYW1lKSk7XG4gICAgICAgIHJldHVybiBwYWlycztcbiAgICB9LCBbXSk7XG59XG5mdW5jdGlvbiBnZXRBbmNlc3RvcnNGb3JDb25zdHJ1Y3Rvcihjb25zdHJ1Y3Rvcikge1xuICAgIGNvbnN0IGFuY2VzdG9ycyA9IFtdO1xuICAgIHdoaWxlIChjb25zdHJ1Y3Rvcikge1xuICAgICAgICBhbmNlc3RvcnMucHVzaChjb25zdHJ1Y3Rvcik7XG4gICAgICAgIGNvbnN0cnVjdG9yID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGNvbnN0cnVjdG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIGFuY2VzdG9ycy5yZXZlcnNlKCk7XG59XG5mdW5jdGlvbiBnZXRPd25TdGF0aWNBcnJheVZhbHVlcyhjb25zdHJ1Y3RvciwgcHJvcGVydHlOYW1lKSB7XG4gICAgY29uc3QgZGVmaW5pdGlvbiA9IGNvbnN0cnVjdG9yW3Byb3BlcnR5TmFtZV07XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZGVmaW5pdGlvbikgPyBkZWZpbml0aW9uIDogW107XG59XG5mdW5jdGlvbiBnZXRPd25TdGF0aWNPYmplY3RQYWlycyhjb25zdHJ1Y3RvciwgcHJvcGVydHlOYW1lKSB7XG4gICAgY29uc3QgZGVmaW5pdGlvbiA9IGNvbnN0cnVjdG9yW3Byb3BlcnR5TmFtZV07XG4gICAgcmV0dXJuIGRlZmluaXRpb24gPyBPYmplY3Qua2V5cyhkZWZpbml0aW9uKS5tYXAoKGtleSkgPT4gW2tleSwgZGVmaW5pdGlvbltrZXldXSkgOiBbXTtcbn1cblxuY2xhc3MgT3V0bGV0T2JzZXJ2ZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIGRlbGVnYXRlKSB7XG4gICAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLmRlbGVnYXRlID0gZGVsZWdhdGU7XG4gICAgICAgIHRoaXMub3V0bGV0c0J5TmFtZSA9IG5ldyBNdWx0aW1hcCgpO1xuICAgICAgICB0aGlzLm91dGxldEVsZW1lbnRzQnlOYW1lID0gbmV3IE11bHRpbWFwKCk7XG4gICAgICAgIHRoaXMuc2VsZWN0b3JPYnNlcnZlck1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGVPYnNlcnZlck1hcCA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5zdGFydGVkKSB7XG4gICAgICAgICAgICB0aGlzLm91dGxldERlZmluaXRpb25zLmZvckVhY2goKG91dGxldE5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldHVwU2VsZWN0b3JPYnNlcnZlckZvck91dGxldChvdXRsZXROYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldHVwQXR0cmlidXRlT2JzZXJ2ZXJGb3JPdXRsZXQob3V0bGV0TmFtZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmRlcGVuZGVudENvbnRleHRzLmZvckVhY2goKGNvbnRleHQpID0+IGNvbnRleHQucmVmcmVzaCgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWZyZXNoKCkge1xuICAgICAgICB0aGlzLnNlbGVjdG9yT2JzZXJ2ZXJNYXAuZm9yRWFjaCgob2JzZXJ2ZXIpID0+IG9ic2VydmVyLnJlZnJlc2goKSk7XG4gICAgICAgIHRoaXMuYXR0cmlidXRlT2JzZXJ2ZXJNYXAuZm9yRWFjaCgob2JzZXJ2ZXIpID0+IG9ic2VydmVyLnJlZnJlc2goKSk7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0QWxsT3V0bGV0cygpO1xuICAgICAgICAgICAgdGhpcy5zdG9wU2VsZWN0b3JPYnNlcnZlcnMoKTtcbiAgICAgICAgICAgIHRoaXMuc3RvcEF0dHJpYnV0ZU9ic2VydmVycygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHN0b3BTZWxlY3Rvck9ic2VydmVycygpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0b3JPYnNlcnZlck1hcC5zaXplID4gMCkge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rvck9ic2VydmVyTWFwLmZvckVhY2goKG9ic2VydmVyKSA9PiBvYnNlcnZlci5zdG9wKCkpO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3Rvck9ic2VydmVyTWFwLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RvcEF0dHJpYnV0ZU9ic2VydmVycygpIHtcbiAgICAgICAgaWYgKHRoaXMuYXR0cmlidXRlT2JzZXJ2ZXJNYXAuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuYXR0cmlidXRlT2JzZXJ2ZXJNYXAuZm9yRWFjaCgob2JzZXJ2ZXIpID0+IG9ic2VydmVyLnN0b3AoKSk7XG4gICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZU9ic2VydmVyTWFwLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VsZWN0b3JNYXRjaGVkKGVsZW1lbnQsIF9zZWxlY3RvciwgeyBvdXRsZXROYW1lIH0pIHtcbiAgICAgICAgY29uc3Qgb3V0bGV0ID0gdGhpcy5nZXRPdXRsZXQoZWxlbWVudCwgb3V0bGV0TmFtZSk7XG4gICAgICAgIGlmIChvdXRsZXQpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdE91dGxldChvdXRsZXQsIGVsZW1lbnQsIG91dGxldE5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNlbGVjdG9yVW5tYXRjaGVkKGVsZW1lbnQsIF9zZWxlY3RvciwgeyBvdXRsZXROYW1lIH0pIHtcbiAgICAgICAgY29uc3Qgb3V0bGV0ID0gdGhpcy5nZXRPdXRsZXRGcm9tTWFwKGVsZW1lbnQsIG91dGxldE5hbWUpO1xuICAgICAgICBpZiAob3V0bGV0KSB7XG4gICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3RPdXRsZXQob3V0bGV0LCBlbGVtZW50LCBvdXRsZXROYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZWxlY3Rvck1hdGNoRWxlbWVudChlbGVtZW50LCB7IG91dGxldE5hbWUgfSkge1xuICAgICAgICBjb25zdCBzZWxlY3RvciA9IHRoaXMuc2VsZWN0b3Iob3V0bGV0TmFtZSk7XG4gICAgICAgIGNvbnN0IGhhc091dGxldCA9IHRoaXMuaGFzT3V0bGV0KGVsZW1lbnQsIG91dGxldE5hbWUpO1xuICAgICAgICBjb25zdCBoYXNPdXRsZXRDb250cm9sbGVyID0gZWxlbWVudC5tYXRjaGVzKGBbJHt0aGlzLnNjaGVtYS5jb250cm9sbGVyQXR0cmlidXRlfX49JHtvdXRsZXROYW1lfV1gKTtcbiAgICAgICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gaGFzT3V0bGV0ICYmIGhhc091dGxldENvbnRyb2xsZXIgJiYgZWxlbWVudC5tYXRjaGVzKHNlbGVjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbGVtZW50TWF0Y2hlZEF0dHJpYnV0ZShfZWxlbWVudCwgYXR0cmlidXRlTmFtZSkge1xuICAgICAgICBjb25zdCBvdXRsZXROYW1lID0gdGhpcy5nZXRPdXRsZXROYW1lRnJvbU91dGxldEF0dHJpYnV0ZU5hbWUoYXR0cmlidXRlTmFtZSk7XG4gICAgICAgIGlmIChvdXRsZXROYW1lKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNlbGVjdG9yT2JzZXJ2ZXJGb3JPdXRsZXQob3V0bGV0TmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxlbWVudEF0dHJpYnV0ZVZhbHVlQ2hhbmdlZChfZWxlbWVudCwgYXR0cmlidXRlTmFtZSkge1xuICAgICAgICBjb25zdCBvdXRsZXROYW1lID0gdGhpcy5nZXRPdXRsZXROYW1lRnJvbU91dGxldEF0dHJpYnV0ZU5hbWUoYXR0cmlidXRlTmFtZSk7XG4gICAgICAgIGlmIChvdXRsZXROYW1lKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNlbGVjdG9yT2JzZXJ2ZXJGb3JPdXRsZXQob3V0bGV0TmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxlbWVudFVubWF0Y2hlZEF0dHJpYnV0ZShfZWxlbWVudCwgYXR0cmlidXRlTmFtZSkge1xuICAgICAgICBjb25zdCBvdXRsZXROYW1lID0gdGhpcy5nZXRPdXRsZXROYW1lRnJvbU91dGxldEF0dHJpYnV0ZU5hbWUoYXR0cmlidXRlTmFtZSk7XG4gICAgICAgIGlmIChvdXRsZXROYW1lKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNlbGVjdG9yT2JzZXJ2ZXJGb3JPdXRsZXQob3V0bGV0TmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29ubmVjdE91dGxldChvdXRsZXQsIGVsZW1lbnQsIG91dGxldE5hbWUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIXRoaXMub3V0bGV0RWxlbWVudHNCeU5hbWUuaGFzKG91dGxldE5hbWUsIGVsZW1lbnQpKSB7XG4gICAgICAgICAgICB0aGlzLm91dGxldHNCeU5hbWUuYWRkKG91dGxldE5hbWUsIG91dGxldCk7XG4gICAgICAgICAgICB0aGlzLm91dGxldEVsZW1lbnRzQnlOYW1lLmFkZChvdXRsZXROYW1lLCBlbGVtZW50KTtcbiAgICAgICAgICAgIChfYSA9IHRoaXMuc2VsZWN0b3JPYnNlcnZlck1hcC5nZXQob3V0bGV0TmFtZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXVzZSgoKSA9PiB0aGlzLmRlbGVnYXRlLm91dGxldENvbm5lY3RlZChvdXRsZXQsIGVsZW1lbnQsIG91dGxldE5hbWUpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXNjb25uZWN0T3V0bGV0KG91dGxldCwgZWxlbWVudCwgb3V0bGV0TmFtZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0aGlzLm91dGxldEVsZW1lbnRzQnlOYW1lLmhhcyhvdXRsZXROYW1lLCBlbGVtZW50KSkge1xuICAgICAgICAgICAgdGhpcy5vdXRsZXRzQnlOYW1lLmRlbGV0ZShvdXRsZXROYW1lLCBvdXRsZXQpO1xuICAgICAgICAgICAgdGhpcy5vdXRsZXRFbGVtZW50c0J5TmFtZS5kZWxldGUob3V0bGV0TmFtZSwgZWxlbWVudCk7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLnNlbGVjdG9yT2JzZXJ2ZXJNYXBcbiAgICAgICAgICAgICAgICAuZ2V0KG91dGxldE5hbWUpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGF1c2UoKCkgPT4gdGhpcy5kZWxlZ2F0ZS5vdXRsZXREaXNjb25uZWN0ZWQob3V0bGV0LCBlbGVtZW50LCBvdXRsZXROYW1lKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGlzY29ubmVjdEFsbE91dGxldHMoKSB7XG4gICAgICAgIGZvciAoY29uc3Qgb3V0bGV0TmFtZSBvZiB0aGlzLm91dGxldEVsZW1lbnRzQnlOYW1lLmtleXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiB0aGlzLm91dGxldEVsZW1lbnRzQnlOYW1lLmdldFZhbHVlc0ZvcktleShvdXRsZXROYW1lKSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgb3V0bGV0IG9mIHRoaXMub3V0bGV0c0J5TmFtZS5nZXRWYWx1ZXNGb3JLZXkob3V0bGV0TmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0T3V0bGV0KG91dGxldCwgZWxlbWVudCwgb3V0bGV0TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZVNlbGVjdG9yT2JzZXJ2ZXJGb3JPdXRsZXQob3V0bGV0TmFtZSkge1xuICAgICAgICBjb25zdCBvYnNlcnZlciA9IHRoaXMuc2VsZWN0b3JPYnNlcnZlck1hcC5nZXQob3V0bGV0TmFtZSk7XG4gICAgICAgIGlmIChvYnNlcnZlcikge1xuICAgICAgICAgICAgb2JzZXJ2ZXIuc2VsZWN0b3IgPSB0aGlzLnNlbGVjdG9yKG91dGxldE5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldHVwU2VsZWN0b3JPYnNlcnZlckZvck91dGxldChvdXRsZXROYW1lKSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdG9yID0gdGhpcy5zZWxlY3RvcihvdXRsZXROYW1lKTtcbiAgICAgICAgY29uc3Qgc2VsZWN0b3JPYnNlcnZlciA9IG5ldyBTZWxlY3Rvck9ic2VydmVyKGRvY3VtZW50LmJvZHksIHNlbGVjdG9yLCB0aGlzLCB7IG91dGxldE5hbWUgfSk7XG4gICAgICAgIHRoaXMuc2VsZWN0b3JPYnNlcnZlck1hcC5zZXQob3V0bGV0TmFtZSwgc2VsZWN0b3JPYnNlcnZlcik7XG4gICAgICAgIHNlbGVjdG9yT2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICB9XG4gICAgc2V0dXBBdHRyaWJ1dGVPYnNlcnZlckZvck91dGxldChvdXRsZXROYW1lKSB7XG4gICAgICAgIGNvbnN0IGF0dHJpYnV0ZU5hbWUgPSB0aGlzLmF0dHJpYnV0ZU5hbWVGb3JPdXRsZXROYW1lKG91dGxldE5hbWUpO1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGVPYnNlcnZlciA9IG5ldyBBdHRyaWJ1dGVPYnNlcnZlcih0aGlzLnNjb3BlLmVsZW1lbnQsIGF0dHJpYnV0ZU5hbWUsIHRoaXMpO1xuICAgICAgICB0aGlzLmF0dHJpYnV0ZU9ic2VydmVyTWFwLnNldChvdXRsZXROYW1lLCBhdHRyaWJ1dGVPYnNlcnZlcik7XG4gICAgICAgIGF0dHJpYnV0ZU9ic2VydmVyLnN0YXJ0KCk7XG4gICAgfVxuICAgIHNlbGVjdG9yKG91dGxldE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NvcGUub3V0bGV0cy5nZXRTZWxlY3RvckZvck91dGxldE5hbWUob3V0bGV0TmFtZSk7XG4gICAgfVxuICAgIGF0dHJpYnV0ZU5hbWVGb3JPdXRsZXROYW1lKG91dGxldE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NvcGUuc2NoZW1hLm91dGxldEF0dHJpYnV0ZUZvclNjb3BlKHRoaXMuaWRlbnRpZmllciwgb3V0bGV0TmFtZSk7XG4gICAgfVxuICAgIGdldE91dGxldE5hbWVGcm9tT3V0bGV0QXR0cmlidXRlTmFtZShhdHRyaWJ1dGVOYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm91dGxldERlZmluaXRpb25zLmZpbmQoKG91dGxldE5hbWUpID0+IHRoaXMuYXR0cmlidXRlTmFtZUZvck91dGxldE5hbWUob3V0bGV0TmFtZSkgPT09IGF0dHJpYnV0ZU5hbWUpO1xuICAgIH1cbiAgICBnZXQgb3V0bGV0RGVwZW5kZW5jaWVzKCkge1xuICAgICAgICBjb25zdCBkZXBlbmRlbmNpZXMgPSBuZXcgTXVsdGltYXAoKTtcbiAgICAgICAgdGhpcy5yb3V0ZXIubW9kdWxlcy5mb3JFYWNoKChtb2R1bGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnN0cnVjdG9yID0gbW9kdWxlLmRlZmluaXRpb24uY29udHJvbGxlckNvbnN0cnVjdG9yO1xuICAgICAgICAgICAgY29uc3Qgb3V0bGV0cyA9IHJlYWRJbmhlcml0YWJsZVN0YXRpY0FycmF5VmFsdWVzKGNvbnN0cnVjdG9yLCBcIm91dGxldHNcIik7XG4gICAgICAgICAgICBvdXRsZXRzLmZvckVhY2goKG91dGxldCkgPT4gZGVwZW5kZW5jaWVzLmFkZChvdXRsZXQsIG1vZHVsZS5pZGVudGlmaWVyKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGVwZW5kZW5jaWVzO1xuICAgIH1cbiAgICBnZXQgb3V0bGV0RGVmaW5pdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm91dGxldERlcGVuZGVuY2llcy5nZXRLZXlzRm9yVmFsdWUodGhpcy5pZGVudGlmaWVyKTtcbiAgICB9XG4gICAgZ2V0IGRlcGVuZGVudENvbnRyb2xsZXJJZGVudGlmaWVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3V0bGV0RGVwZW5kZW5jaWVzLmdldFZhbHVlc0ZvcktleSh0aGlzLmlkZW50aWZpZXIpO1xuICAgIH1cbiAgICBnZXQgZGVwZW5kZW50Q29udGV4dHMoKSB7XG4gICAgICAgIGNvbnN0IGlkZW50aWZpZXJzID0gdGhpcy5kZXBlbmRlbnRDb250cm9sbGVySWRlbnRpZmllcnM7XG4gICAgICAgIHJldHVybiB0aGlzLnJvdXRlci5jb250ZXh0cy5maWx0ZXIoKGNvbnRleHQpID0+IGlkZW50aWZpZXJzLmluY2x1ZGVzKGNvbnRleHQuaWRlbnRpZmllcikpO1xuICAgIH1cbiAgICBoYXNPdXRsZXQoZWxlbWVudCwgb3V0bGV0TmFtZSkge1xuICAgICAgICByZXR1cm4gISF0aGlzLmdldE91dGxldChlbGVtZW50LCBvdXRsZXROYW1lKSB8fCAhIXRoaXMuZ2V0T3V0bGV0RnJvbU1hcChlbGVtZW50LCBvdXRsZXROYW1lKTtcbiAgICB9XG4gICAgZ2V0T3V0bGV0KGVsZW1lbnQsIG91dGxldE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbGljYXRpb24uZ2V0Q29udHJvbGxlckZvckVsZW1lbnRBbmRJZGVudGlmaWVyKGVsZW1lbnQsIG91dGxldE5hbWUpO1xuICAgIH1cbiAgICBnZXRPdXRsZXRGcm9tTWFwKGVsZW1lbnQsIG91dGxldE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3V0bGV0c0J5TmFtZS5nZXRWYWx1ZXNGb3JLZXkob3V0bGV0TmFtZSkuZmluZCgob3V0bGV0KSA9PiBvdXRsZXQuZWxlbWVudCA9PT0gZWxlbWVudCk7XG4gICAgfVxuICAgIGdldCBzY29wZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5zY29wZTtcbiAgICB9XG4gICAgZ2V0IHNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5zY2hlbWE7XG4gICAgfVxuICAgIGdldCBpZGVudGlmaWVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0LmlkZW50aWZpZXI7XG4gICAgfVxuICAgIGdldCBhcHBsaWNhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5hcHBsaWNhdGlvbjtcbiAgICB9XG4gICAgZ2V0IHJvdXRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbGljYXRpb24ucm91dGVyO1xuICAgIH1cbn1cblxuY2xhc3MgQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IobW9kdWxlLCBzY29wZSkge1xuICAgICAgICB0aGlzLmxvZ0RlYnVnQWN0aXZpdHkgPSAoZnVuY3Rpb25OYW1lLCBkZXRhaWwgPSB7fSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBpZGVudGlmaWVyLCBjb250cm9sbGVyLCBlbGVtZW50IH0gPSB0aGlzO1xuICAgICAgICAgICAgZGV0YWlsID0gT2JqZWN0LmFzc2lnbih7IGlkZW50aWZpZXIsIGNvbnRyb2xsZXIsIGVsZW1lbnQgfSwgZGV0YWlsKTtcbiAgICAgICAgICAgIHRoaXMuYXBwbGljYXRpb24ubG9nRGVidWdBY3Rpdml0eSh0aGlzLmlkZW50aWZpZXIsIGZ1bmN0aW9uTmFtZSwgZGV0YWlsKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5tb2R1bGUgPSBtb2R1bGU7XG4gICAgICAgIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgICAgICAgdGhpcy5jb250cm9sbGVyID0gbmV3IG1vZHVsZS5jb250cm9sbGVyQ29uc3RydWN0b3IodGhpcyk7XG4gICAgICAgIHRoaXMuYmluZGluZ09ic2VydmVyID0gbmV3IEJpbmRpbmdPYnNlcnZlcih0aGlzLCB0aGlzLmRpc3BhdGNoZXIpO1xuICAgICAgICB0aGlzLnZhbHVlT2JzZXJ2ZXIgPSBuZXcgVmFsdWVPYnNlcnZlcih0aGlzLCB0aGlzLmNvbnRyb2xsZXIpO1xuICAgICAgICB0aGlzLnRhcmdldE9ic2VydmVyID0gbmV3IFRhcmdldE9ic2VydmVyKHRoaXMsIHRoaXMpO1xuICAgICAgICB0aGlzLm91dGxldE9ic2VydmVyID0gbmV3IE91dGxldE9ic2VydmVyKHRoaXMsIHRoaXMpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5jb250cm9sbGVyLmluaXRpYWxpemUoKTtcbiAgICAgICAgICAgIHRoaXMubG9nRGVidWdBY3Rpdml0eShcImluaXRpYWxpemVcIik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUVycm9yKGVycm9yLCBcImluaXRpYWxpemluZyBjb250cm9sbGVyXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMuYmluZGluZ09ic2VydmVyLnN0YXJ0KCk7XG4gICAgICAgIHRoaXMudmFsdWVPYnNlcnZlci5zdGFydCgpO1xuICAgICAgICB0aGlzLnRhcmdldE9ic2VydmVyLnN0YXJ0KCk7XG4gICAgICAgIHRoaXMub3V0bGV0T2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuY29udHJvbGxlci5jb25uZWN0KCk7XG4gICAgICAgICAgICB0aGlzLmxvZ0RlYnVnQWN0aXZpdHkoXCJjb25uZWN0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVFcnJvcihlcnJvciwgXCJjb25uZWN0aW5nIGNvbnRyb2xsZXJcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVmcmVzaCgpIHtcbiAgICAgICAgdGhpcy5vdXRsZXRPYnNlcnZlci5yZWZyZXNoKCk7XG4gICAgfVxuICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xsZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgdGhpcy5sb2dEZWJ1Z0FjdGl2aXR5KFwiZGlzY29ubmVjdFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IsIFwiZGlzY29ubmVjdGluZyBjb250cm9sbGVyXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3V0bGV0T2JzZXJ2ZXIuc3RvcCgpO1xuICAgICAgICB0aGlzLnRhcmdldE9ic2VydmVyLnN0b3AoKTtcbiAgICAgICAgdGhpcy52YWx1ZU9ic2VydmVyLnN0b3AoKTtcbiAgICAgICAgdGhpcy5iaW5kaW5nT2JzZXJ2ZXIuc3RvcCgpO1xuICAgIH1cbiAgICBnZXQgYXBwbGljYXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZHVsZS5hcHBsaWNhdGlvbjtcbiAgICB9XG4gICAgZ2V0IGlkZW50aWZpZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZHVsZS5pZGVudGlmaWVyO1xuICAgIH1cbiAgICBnZXQgc2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBsaWNhdGlvbi5zY2hlbWE7XG4gICAgfVxuICAgIGdldCBkaXNwYXRjaGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBsaWNhdGlvbi5kaXNwYXRjaGVyO1xuICAgIH1cbiAgICBnZXQgZWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NvcGUuZWxlbWVudDtcbiAgICB9XG4gICAgZ2V0IHBhcmVudEVsZW1lbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICB9XG4gICAgaGFuZGxlRXJyb3IoZXJyb3IsIG1lc3NhZ2UsIGRldGFpbCA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgaWRlbnRpZmllciwgY29udHJvbGxlciwgZWxlbWVudCB9ID0gdGhpcztcbiAgICAgICAgZGV0YWlsID0gT2JqZWN0LmFzc2lnbih7IGlkZW50aWZpZXIsIGNvbnRyb2xsZXIsIGVsZW1lbnQgfSwgZGV0YWlsKTtcbiAgICAgICAgdGhpcy5hcHBsaWNhdGlvbi5oYW5kbGVFcnJvcihlcnJvciwgYEVycm9yICR7bWVzc2FnZX1gLCBkZXRhaWwpO1xuICAgIH1cbiAgICB0YXJnZXRDb25uZWN0ZWQoZWxlbWVudCwgbmFtZSkge1xuICAgICAgICB0aGlzLmludm9rZUNvbnRyb2xsZXJNZXRob2QoYCR7bmFtZX1UYXJnZXRDb25uZWN0ZWRgLCBlbGVtZW50KTtcbiAgICB9XG4gICAgdGFyZ2V0RGlzY29ubmVjdGVkKGVsZW1lbnQsIG5hbWUpIHtcbiAgICAgICAgdGhpcy5pbnZva2VDb250cm9sbGVyTWV0aG9kKGAke25hbWV9VGFyZ2V0RGlzY29ubmVjdGVkYCwgZWxlbWVudCk7XG4gICAgfVxuICAgIG91dGxldENvbm5lY3RlZChvdXRsZXQsIGVsZW1lbnQsIG5hbWUpIHtcbiAgICAgICAgdGhpcy5pbnZva2VDb250cm9sbGVyTWV0aG9kKGAke25hbWVzcGFjZUNhbWVsaXplKG5hbWUpfU91dGxldENvbm5lY3RlZGAsIG91dGxldCwgZWxlbWVudCk7XG4gICAgfVxuICAgIG91dGxldERpc2Nvbm5lY3RlZChvdXRsZXQsIGVsZW1lbnQsIG5hbWUpIHtcbiAgICAgICAgdGhpcy5pbnZva2VDb250cm9sbGVyTWV0aG9kKGAke25hbWVzcGFjZUNhbWVsaXplKG5hbWUpfU91dGxldERpc2Nvbm5lY3RlZGAsIG91dGxldCwgZWxlbWVudCk7XG4gICAgfVxuICAgIGludm9rZUNvbnRyb2xsZXJNZXRob2QobWV0aG9kTmFtZSwgLi4uYXJncykge1xuICAgICAgICBjb25zdCBjb250cm9sbGVyID0gdGhpcy5jb250cm9sbGVyO1xuICAgICAgICBpZiAodHlwZW9mIGNvbnRyb2xsZXJbbWV0aG9kTmFtZV0gPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyW21ldGhvZE5hbWVdKC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBibGVzcyhjb25zdHJ1Y3Rvcikge1xuICAgIHJldHVybiBzaGFkb3coY29uc3RydWN0b3IsIGdldEJsZXNzZWRQcm9wZXJ0aWVzKGNvbnN0cnVjdG9yKSk7XG59XG5mdW5jdGlvbiBzaGFkb3coY29uc3RydWN0b3IsIHByb3BlcnRpZXMpIHtcbiAgICBjb25zdCBzaGFkb3dDb25zdHJ1Y3RvciA9IGV4dGVuZChjb25zdHJ1Y3Rvcik7XG4gICAgY29uc3Qgc2hhZG93UHJvcGVydGllcyA9IGdldFNoYWRvd1Byb3BlcnRpZXMoY29uc3RydWN0b3IucHJvdG90eXBlLCBwcm9wZXJ0aWVzKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhzaGFkb3dDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHNoYWRvd1Byb3BlcnRpZXMpO1xuICAgIHJldHVybiBzaGFkb3dDb25zdHJ1Y3Rvcjtcbn1cbmZ1bmN0aW9uIGdldEJsZXNzZWRQcm9wZXJ0aWVzKGNvbnN0cnVjdG9yKSB7XG4gICAgY29uc3QgYmxlc3NpbmdzID0gcmVhZEluaGVyaXRhYmxlU3RhdGljQXJyYXlWYWx1ZXMoY29uc3RydWN0b3IsIFwiYmxlc3NpbmdzXCIpO1xuICAgIHJldHVybiBibGVzc2luZ3MucmVkdWNlKChibGVzc2VkUHJvcGVydGllcywgYmxlc3NpbmcpID0+IHtcbiAgICAgICAgY29uc3QgcHJvcGVydGllcyA9IGJsZXNzaW5nKGNvbnN0cnVjdG9yKTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcHJvcGVydGllcykge1xuICAgICAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IGJsZXNzZWRQcm9wZXJ0aWVzW2tleV0gfHwge307XG4gICAgICAgICAgICBibGVzc2VkUHJvcGVydGllc1trZXldID0gT2JqZWN0LmFzc2lnbihkZXNjcmlwdG9yLCBwcm9wZXJ0aWVzW2tleV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBibGVzc2VkUHJvcGVydGllcztcbiAgICB9LCB7fSk7XG59XG5mdW5jdGlvbiBnZXRTaGFkb3dQcm9wZXJ0aWVzKHByb3RvdHlwZSwgcHJvcGVydGllcykge1xuICAgIHJldHVybiBnZXRPd25LZXlzKHByb3BlcnRpZXMpLnJlZHVjZSgoc2hhZG93UHJvcGVydGllcywga2V5KSA9PiB7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBnZXRTaGFkb3dlZERlc2NyaXB0b3IocHJvdG90eXBlLCBwcm9wZXJ0aWVzLCBrZXkpO1xuICAgICAgICBpZiAoZGVzY3JpcHRvcikge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihzaGFkb3dQcm9wZXJ0aWVzLCB7IFtrZXldOiBkZXNjcmlwdG9yIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaGFkb3dQcm9wZXJ0aWVzO1xuICAgIH0sIHt9KTtcbn1cbmZ1bmN0aW9uIGdldFNoYWRvd2VkRGVzY3JpcHRvcihwcm90b3R5cGUsIHByb3BlcnRpZXMsIGtleSkge1xuICAgIGNvbnN0IHNoYWRvd2luZ0Rlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3RvdHlwZSwga2V5KTtcbiAgICBjb25zdCBzaGFkb3dlZEJ5VmFsdWUgPSBzaGFkb3dpbmdEZXNjcmlwdG9yICYmIFwidmFsdWVcIiBpbiBzaGFkb3dpbmdEZXNjcmlwdG9yO1xuICAgIGlmICghc2hhZG93ZWRCeVZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3BlcnRpZXMsIGtleSkudmFsdWU7XG4gICAgICAgIGlmIChzaGFkb3dpbmdEZXNjcmlwdG9yKSB7XG4gICAgICAgICAgICBkZXNjcmlwdG9yLmdldCA9IHNoYWRvd2luZ0Rlc2NyaXB0b3IuZ2V0IHx8IGRlc2NyaXB0b3IuZ2V0O1xuICAgICAgICAgICAgZGVzY3JpcHRvci5zZXQgPSBzaGFkb3dpbmdEZXNjcmlwdG9yLnNldCB8fCBkZXNjcmlwdG9yLnNldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVzY3JpcHRvcjtcbiAgICB9XG59XG5jb25zdCBnZXRPd25LZXlzID0gKCgpID0+IHtcbiAgICBpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiAob2JqZWN0KSA9PiBbLi4uT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqZWN0KSwgLi4uT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcztcbiAgICB9XG59KSgpO1xuY29uc3QgZXh0ZW5kID0gKCgpID0+IHtcbiAgICBmdW5jdGlvbiBleHRlbmRXaXRoUmVmbGVjdChjb25zdHJ1Y3Rvcikge1xuICAgICAgICBmdW5jdGlvbiBleHRlbmRlZCgpIHtcbiAgICAgICAgICAgIHJldHVybiBSZWZsZWN0LmNvbnN0cnVjdChjb25zdHJ1Y3RvciwgYXJndW1lbnRzLCBuZXcudGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICBleHRlbmRlZC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGNvbnN0cnVjdG9yLnByb3RvdHlwZSwge1xuICAgICAgICAgICAgY29uc3RydWN0b3I6IHsgdmFsdWU6IGV4dGVuZGVkIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBSZWZsZWN0LnNldFByb3RvdHlwZU9mKGV4dGVuZGVkLCBjb25zdHJ1Y3Rvcik7XG4gICAgICAgIHJldHVybiBleHRlbmRlZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGVzdFJlZmxlY3RFeHRlbnNpb24oKSB7XG4gICAgICAgIGNvbnN0IGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGlzLmEuY2FsbCh0aGlzKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgYiA9IGV4dGVuZFdpdGhSZWZsZWN0KGEpO1xuICAgICAgICBiLnByb3RvdHlwZS5hID0gZnVuY3Rpb24gKCkgeyB9O1xuICAgICAgICByZXR1cm4gbmV3IGIoKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgdGVzdFJlZmxlY3RFeHRlbnNpb24oKTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFdpdGhSZWZsZWN0O1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIChjb25zdHJ1Y3RvcikgPT4gY2xhc3MgZXh0ZW5kZWQgZXh0ZW5kcyBjb25zdHJ1Y3RvciB7XG4gICAgICAgIH07XG4gICAgfVxufSkoKTtcblxuZnVuY3Rpb24gYmxlc3NEZWZpbml0aW9uKGRlZmluaXRpb24pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBpZGVudGlmaWVyOiBkZWZpbml0aW9uLmlkZW50aWZpZXIsXG4gICAgICAgIGNvbnRyb2xsZXJDb25zdHJ1Y3RvcjogYmxlc3MoZGVmaW5pdGlvbi5jb250cm9sbGVyQ29uc3RydWN0b3IpLFxuICAgIH07XG59XG5cbmNsYXNzIE1vZHVsZSB7XG4gICAgY29uc3RydWN0b3IoYXBwbGljYXRpb24sIGRlZmluaXRpb24pIHtcbiAgICAgICAgdGhpcy5hcHBsaWNhdGlvbiA9IGFwcGxpY2F0aW9uO1xuICAgICAgICB0aGlzLmRlZmluaXRpb24gPSBibGVzc0RlZmluaXRpb24oZGVmaW5pdGlvbik7XG4gICAgICAgIHRoaXMuY29udGV4dHNCeVNjb3BlID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgdGhpcy5jb25uZWN0ZWRDb250ZXh0cyA9IG5ldyBTZXQoKTtcbiAgICB9XG4gICAgZ2V0IGlkZW50aWZpZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlZmluaXRpb24uaWRlbnRpZmllcjtcbiAgICB9XG4gICAgZ2V0IGNvbnRyb2xsZXJDb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVmaW5pdGlvbi5jb250cm9sbGVyQ29uc3RydWN0b3I7XG4gICAgfVxuICAgIGdldCBjb250ZXh0cygpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5jb25uZWN0ZWRDb250ZXh0cyk7XG4gICAgfVxuICAgIGNvbm5lY3RDb250ZXh0Rm9yU2NvcGUoc2NvcGUpIHtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuZmV0Y2hDb250ZXh0Rm9yU2NvcGUoc2NvcGUpO1xuICAgICAgICB0aGlzLmNvbm5lY3RlZENvbnRleHRzLmFkZChjb250ZXh0KTtcbiAgICAgICAgY29udGV4dC5jb25uZWN0KCk7XG4gICAgfVxuICAgIGRpc2Nvbm5lY3RDb250ZXh0Rm9yU2NvcGUoc2NvcGUpIHtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuY29udGV4dHNCeVNjb3BlLmdldChzY29wZSk7XG4gICAgICAgIGlmIChjb250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RlZENvbnRleHRzLmRlbGV0ZShjb250ZXh0KTtcbiAgICAgICAgICAgIGNvbnRleHQuZGlzY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZldGNoQ29udGV4dEZvclNjb3BlKHNjb3BlKSB7XG4gICAgICAgIGxldCBjb250ZXh0ID0gdGhpcy5jb250ZXh0c0J5U2NvcGUuZ2V0KHNjb3BlKTtcbiAgICAgICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICAgICAgICBjb250ZXh0ID0gbmV3IENvbnRleHQodGhpcywgc2NvcGUpO1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0c0J5U2NvcGUuc2V0KHNjb3BlLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udGV4dDtcbiAgICB9XG59XG5cbmNsYXNzIENsYXNzTWFwIHtcbiAgICBjb25zdHJ1Y3RvcihzY29wZSkge1xuICAgICAgICB0aGlzLnNjb3BlID0gc2NvcGU7XG4gICAgfVxuICAgIGhhcyhuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEuaGFzKHRoaXMuZ2V0RGF0YUtleShuYW1lKSk7XG4gICAgfVxuICAgIGdldChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEFsbChuYW1lKVswXTtcbiAgICB9XG4gICAgZ2V0QWxsKG5hbWUpIHtcbiAgICAgICAgY29uc3QgdG9rZW5TdHJpbmcgPSB0aGlzLmRhdGEuZ2V0KHRoaXMuZ2V0RGF0YUtleShuYW1lKSkgfHwgXCJcIjtcbiAgICAgICAgcmV0dXJuIHRva2VuaXplKHRva2VuU3RyaW5nKTtcbiAgICB9XG4gICAgZ2V0QXR0cmlidXRlTmFtZShuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGEuZ2V0QXR0cmlidXRlTmFtZUZvcktleSh0aGlzLmdldERhdGFLZXkobmFtZSkpO1xuICAgIH1cbiAgICBnZXREYXRhS2V5KG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGAke25hbWV9LWNsYXNzYDtcbiAgICB9XG4gICAgZ2V0IGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjb3BlLmRhdGE7XG4gICAgfVxufVxuXG5jbGFzcyBEYXRhTWFwIHtcbiAgICBjb25zdHJ1Y3RvcihzY29wZSkge1xuICAgICAgICB0aGlzLnNjb3BlID0gc2NvcGU7XG4gICAgfVxuICAgIGdldCBlbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY29wZS5lbGVtZW50O1xuICAgIH1cbiAgICBnZXQgaWRlbnRpZmllcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NvcGUuaWRlbnRpZmllcjtcbiAgICB9XG4gICAgZ2V0KGtleSkge1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5nZXRBdHRyaWJ1dGVOYW1lRm9yS2V5KGtleSk7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgIH1cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5nZXRBdHRyaWJ1dGVOYW1lRm9yS2V5KGtleSk7XG4gICAgICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXQoa2V5KTtcbiAgICB9XG4gICAgaGFzKGtleSkge1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5nZXRBdHRyaWJ1dGVOYW1lRm9yS2V5KGtleSk7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnQuaGFzQXR0cmlidXRlKG5hbWUpO1xuICAgIH1cbiAgICBkZWxldGUoa2V5KSB7XG4gICAgICAgIGlmICh0aGlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5nZXRBdHRyaWJ1dGVOYW1lRm9yS2V5KGtleSk7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0QXR0cmlidXRlTmFtZUZvcktleShrZXkpIHtcbiAgICAgICAgcmV0dXJuIGBkYXRhLSR7dGhpcy5pZGVudGlmaWVyfS0ke2Rhc2hlcml6ZShrZXkpfWA7XG4gICAgfVxufVxuXG5jbGFzcyBHdWlkZSB7XG4gICAgY29uc3RydWN0b3IobG9nZ2VyKSB7XG4gICAgICAgIHRoaXMud2FybmVkS2V5c0J5T2JqZWN0ID0gbmV3IFdlYWtNYXAoKTtcbiAgICAgICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gICAgfVxuICAgIHdhcm4ob2JqZWN0LCBrZXksIG1lc3NhZ2UpIHtcbiAgICAgICAgbGV0IHdhcm5lZEtleXMgPSB0aGlzLndhcm5lZEtleXNCeU9iamVjdC5nZXQob2JqZWN0KTtcbiAgICAgICAgaWYgKCF3YXJuZWRLZXlzKSB7XG4gICAgICAgICAgICB3YXJuZWRLZXlzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgdGhpcy53YXJuZWRLZXlzQnlPYmplY3Quc2V0KG9iamVjdCwgd2FybmVkS2V5cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF3YXJuZWRLZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICB3YXJuZWRLZXlzLmFkZChrZXkpO1xuICAgICAgICAgICAgdGhpcy5sb2dnZXIud2FybihtZXNzYWdlLCBvYmplY3QpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiBhdHRyaWJ1dGVWYWx1ZUNvbnRhaW5zVG9rZW4oYXR0cmlidXRlTmFtZSwgdG9rZW4pIHtcbiAgICByZXR1cm4gYFske2F0dHJpYnV0ZU5hbWV9fj1cIiR7dG9rZW59XCJdYDtcbn1cblxuY2xhc3MgVGFyZ2V0U2V0IHtcbiAgICBjb25zdHJ1Y3RvcihzY29wZSkge1xuICAgICAgICB0aGlzLnNjb3BlID0gc2NvcGU7XG4gICAgfVxuICAgIGdldCBlbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY29wZS5lbGVtZW50O1xuICAgIH1cbiAgICBnZXQgaWRlbnRpZmllcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NvcGUuaWRlbnRpZmllcjtcbiAgICB9XG4gICAgZ2V0IHNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NvcGUuc2NoZW1hO1xuICAgIH1cbiAgICBoYXModGFyZ2V0TmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5maW5kKHRhcmdldE5hbWUpICE9IG51bGw7XG4gICAgfVxuICAgIGZpbmQoLi4udGFyZ2V0TmFtZXMpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldE5hbWVzLnJlZHVjZSgodGFyZ2V0LCB0YXJnZXROYW1lKSA9PiB0YXJnZXQgfHwgdGhpcy5maW5kVGFyZ2V0KHRhcmdldE5hbWUpIHx8IHRoaXMuZmluZExlZ2FjeVRhcmdldCh0YXJnZXROYW1lKSwgdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgZmluZEFsbCguLi50YXJnZXROYW1lcykge1xuICAgICAgICByZXR1cm4gdGFyZ2V0TmFtZXMucmVkdWNlKCh0YXJnZXRzLCB0YXJnZXROYW1lKSA9PiBbXG4gICAgICAgICAgICAuLi50YXJnZXRzLFxuICAgICAgICAgICAgLi4udGhpcy5maW5kQWxsVGFyZ2V0cyh0YXJnZXROYW1lKSxcbiAgICAgICAgICAgIC4uLnRoaXMuZmluZEFsbExlZ2FjeVRhcmdldHModGFyZ2V0TmFtZSksXG4gICAgICAgIF0sIFtdKTtcbiAgICB9XG4gICAgZmluZFRhcmdldCh0YXJnZXROYW1lKSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdG9yID0gdGhpcy5nZXRTZWxlY3RvckZvclRhcmdldE5hbWUodGFyZ2V0TmFtZSk7XG4gICAgICAgIHJldHVybiB0aGlzLnNjb3BlLmZpbmRFbGVtZW50KHNlbGVjdG9yKTtcbiAgICB9XG4gICAgZmluZEFsbFRhcmdldHModGFyZ2V0TmFtZSkge1xuICAgICAgICBjb25zdCBzZWxlY3RvciA9IHRoaXMuZ2V0U2VsZWN0b3JGb3JUYXJnZXROYW1lKHRhcmdldE5hbWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5zY29wZS5maW5kQWxsRWxlbWVudHMoc2VsZWN0b3IpO1xuICAgIH1cbiAgICBnZXRTZWxlY3RvckZvclRhcmdldE5hbWUodGFyZ2V0TmFtZSkge1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGVOYW1lID0gdGhpcy5zY2hlbWEudGFyZ2V0QXR0cmlidXRlRm9yU2NvcGUodGhpcy5pZGVudGlmaWVyKTtcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZVZhbHVlQ29udGFpbnNUb2tlbihhdHRyaWJ1dGVOYW1lLCB0YXJnZXROYW1lKTtcbiAgICB9XG4gICAgZmluZExlZ2FjeVRhcmdldCh0YXJnZXROYW1lKSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdG9yID0gdGhpcy5nZXRMZWdhY3lTZWxlY3RvckZvclRhcmdldE5hbWUodGFyZ2V0TmFtZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmRlcHJlY2F0ZSh0aGlzLnNjb3BlLmZpbmRFbGVtZW50KHNlbGVjdG9yKSwgdGFyZ2V0TmFtZSk7XG4gICAgfVxuICAgIGZpbmRBbGxMZWdhY3lUYXJnZXRzKHRhcmdldE5hbWUpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0b3IgPSB0aGlzLmdldExlZ2FjeVNlbGVjdG9yRm9yVGFyZ2V0TmFtZSh0YXJnZXROYW1lKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NvcGUuZmluZEFsbEVsZW1lbnRzKHNlbGVjdG9yKS5tYXAoKGVsZW1lbnQpID0+IHRoaXMuZGVwcmVjYXRlKGVsZW1lbnQsIHRhcmdldE5hbWUpKTtcbiAgICB9XG4gICAgZ2V0TGVnYWN5U2VsZWN0b3JGb3JUYXJnZXROYW1lKHRhcmdldE5hbWUpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0RGVzY3JpcHRvciA9IGAke3RoaXMuaWRlbnRpZmllcn0uJHt0YXJnZXROYW1lfWA7XG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGVWYWx1ZUNvbnRhaW5zVG9rZW4odGhpcy5zY2hlbWEudGFyZ2V0QXR0cmlidXRlLCB0YXJnZXREZXNjcmlwdG9yKTtcbiAgICB9XG4gICAgZGVwcmVjYXRlKGVsZW1lbnQsIHRhcmdldE5hbWUpIHtcbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaWRlbnRpZmllciB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZU5hbWUgPSB0aGlzLnNjaGVtYS50YXJnZXRBdHRyaWJ1dGU7XG4gICAgICAgICAgICBjb25zdCByZXZpc2VkQXR0cmlidXRlTmFtZSA9IHRoaXMuc2NoZW1hLnRhcmdldEF0dHJpYnV0ZUZvclNjb3BlKGlkZW50aWZpZXIpO1xuICAgICAgICAgICAgdGhpcy5ndWlkZS53YXJuKGVsZW1lbnQsIGB0YXJnZXQ6JHt0YXJnZXROYW1lfWAsIGBQbGVhc2UgcmVwbGFjZSAke2F0dHJpYnV0ZU5hbWV9PVwiJHtpZGVudGlmaWVyfS4ke3RhcmdldE5hbWV9XCIgd2l0aCAke3JldmlzZWRBdHRyaWJ1dGVOYW1lfT1cIiR7dGFyZ2V0TmFtZX1cIi4gYCArXG4gICAgICAgICAgICAgICAgYFRoZSAke2F0dHJpYnV0ZU5hbWV9IGF0dHJpYnV0ZSBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbiBvZiBTdGltdWx1cy5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG4gICAgZ2V0IGd1aWRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY29wZS5ndWlkZTtcbiAgICB9XG59XG5cbmNsYXNzIE91dGxldFNldCB7XG4gICAgY29uc3RydWN0b3Ioc2NvcGUsIGNvbnRyb2xsZXJFbGVtZW50KSB7XG4gICAgICAgIHRoaXMuc2NvcGUgPSBzY29wZTtcbiAgICAgICAgdGhpcy5jb250cm9sbGVyRWxlbWVudCA9IGNvbnRyb2xsZXJFbGVtZW50O1xuICAgIH1cbiAgICBnZXQgZWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NvcGUuZWxlbWVudDtcbiAgICB9XG4gICAgZ2V0IGlkZW50aWZpZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjb3BlLmlkZW50aWZpZXI7XG4gICAgfVxuICAgIGdldCBzY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjb3BlLnNjaGVtYTtcbiAgICB9XG4gICAgaGFzKG91dGxldE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZChvdXRsZXROYW1lKSAhPSBudWxsO1xuICAgIH1cbiAgICBmaW5kKC4uLm91dGxldE5hbWVzKSB7XG4gICAgICAgIHJldHVybiBvdXRsZXROYW1lcy5yZWR1Y2UoKG91dGxldCwgb3V0bGV0TmFtZSkgPT4gb3V0bGV0IHx8IHRoaXMuZmluZE91dGxldChvdXRsZXROYW1lKSwgdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgZmluZEFsbCguLi5vdXRsZXROYW1lcykge1xuICAgICAgICByZXR1cm4gb3V0bGV0TmFtZXMucmVkdWNlKChvdXRsZXRzLCBvdXRsZXROYW1lKSA9PiBbLi4ub3V0bGV0cywgLi4udGhpcy5maW5kQWxsT3V0bGV0cyhvdXRsZXROYW1lKV0sIFtdKTtcbiAgICB9XG4gICAgZ2V0U2VsZWN0b3JGb3JPdXRsZXROYW1lKG91dGxldE5hbWUpIHtcbiAgICAgICAgY29uc3QgYXR0cmlidXRlTmFtZSA9IHRoaXMuc2NoZW1hLm91dGxldEF0dHJpYnV0ZUZvclNjb3BlKHRoaXMuaWRlbnRpZmllciwgb3V0bGV0TmFtZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xsZXJFbGVtZW50LmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICB9XG4gICAgZmluZE91dGxldChvdXRsZXROYW1lKSB7XG4gICAgICAgIGNvbnN0IHNlbGVjdG9yID0gdGhpcy5nZXRTZWxlY3RvckZvck91dGxldE5hbWUob3V0bGV0TmFtZSk7XG4gICAgICAgIGlmIChzZWxlY3RvcilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbmRFbGVtZW50KHNlbGVjdG9yLCBvdXRsZXROYW1lKTtcbiAgICB9XG4gICAgZmluZEFsbE91dGxldHMob3V0bGV0TmFtZSkge1xuICAgICAgICBjb25zdCBzZWxlY3RvciA9IHRoaXMuZ2V0U2VsZWN0b3JGb3JPdXRsZXROYW1lKG91dGxldE5hbWUpO1xuICAgICAgICByZXR1cm4gc2VsZWN0b3IgPyB0aGlzLmZpbmRBbGxFbGVtZW50cyhzZWxlY3Rvciwgb3V0bGV0TmFtZSkgOiBbXTtcbiAgICB9XG4gICAgZmluZEVsZW1lbnQoc2VsZWN0b3IsIG91dGxldE5hbWUpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLnNjb3BlLnF1ZXJ5RWxlbWVudHMoc2VsZWN0b3IpO1xuICAgICAgICByZXR1cm4gZWxlbWVudHMuZmlsdGVyKChlbGVtZW50KSA9PiB0aGlzLm1hdGNoZXNFbGVtZW50KGVsZW1lbnQsIHNlbGVjdG9yLCBvdXRsZXROYW1lKSlbMF07XG4gICAgfVxuICAgIGZpbmRBbGxFbGVtZW50cyhzZWxlY3Rvciwgb3V0bGV0TmFtZSkge1xuICAgICAgICBjb25zdCBlbGVtZW50cyA9IHRoaXMuc2NvcGUucXVlcnlFbGVtZW50cyhzZWxlY3Rvcik7XG4gICAgICAgIHJldHVybiBlbGVtZW50cy5maWx0ZXIoKGVsZW1lbnQpID0+IHRoaXMubWF0Y2hlc0VsZW1lbnQoZWxlbWVudCwgc2VsZWN0b3IsIG91dGxldE5hbWUpKTtcbiAgICB9XG4gICAgbWF0Y2hlc0VsZW1lbnQoZWxlbWVudCwgc2VsZWN0b3IsIG91dGxldE5hbWUpIHtcbiAgICAgICAgY29uc3QgY29udHJvbGxlckF0dHJpYnV0ZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKHRoaXMuc2NvcGUuc2NoZW1hLmNvbnRyb2xsZXJBdHRyaWJ1dGUpIHx8IFwiXCI7XG4gICAgICAgIHJldHVybiBlbGVtZW50Lm1hdGNoZXMoc2VsZWN0b3IpICYmIGNvbnRyb2xsZXJBdHRyaWJ1dGUuc3BsaXQoXCIgXCIpLmluY2x1ZGVzKG91dGxldE5hbWUpO1xuICAgIH1cbn1cblxuY2xhc3MgU2NvcGUge1xuICAgIGNvbnN0cnVjdG9yKHNjaGVtYSwgZWxlbWVudCwgaWRlbnRpZmllciwgbG9nZ2VyKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0cyA9IG5ldyBUYXJnZXRTZXQodGhpcyk7XG4gICAgICAgIHRoaXMuY2xhc3NlcyA9IG5ldyBDbGFzc01hcCh0aGlzKTtcbiAgICAgICAgdGhpcy5kYXRhID0gbmV3IERhdGFNYXAodGhpcyk7XG4gICAgICAgIHRoaXMuY29udGFpbnNFbGVtZW50ID0gKGVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50LmNsb3Nlc3QodGhpcy5jb250cm9sbGVyU2VsZWN0b3IpID09PSB0aGlzLmVsZW1lbnQ7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLmlkZW50aWZpZXIgPSBpZGVudGlmaWVyO1xuICAgICAgICB0aGlzLmd1aWRlID0gbmV3IEd1aWRlKGxvZ2dlcik7XG4gICAgICAgIHRoaXMub3V0bGV0cyA9IG5ldyBPdXRsZXRTZXQodGhpcy5kb2N1bWVudFNjb3BlLCBlbGVtZW50KTtcbiAgICB9XG4gICAgZmluZEVsZW1lbnQoc2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudC5tYXRjaGVzKHNlbGVjdG9yKSA/IHRoaXMuZWxlbWVudCA6IHRoaXMucXVlcnlFbGVtZW50cyhzZWxlY3RvcikuZmluZCh0aGlzLmNvbnRhaW5zRWxlbWVudCk7XG4gICAgfVxuICAgIGZpbmRBbGxFbGVtZW50cyhzZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgLi4uKHRoaXMuZWxlbWVudC5tYXRjaGVzKHNlbGVjdG9yKSA/IFt0aGlzLmVsZW1lbnRdIDogW10pLFxuICAgICAgICAgICAgLi4udGhpcy5xdWVyeUVsZW1lbnRzKHNlbGVjdG9yKS5maWx0ZXIodGhpcy5jb250YWluc0VsZW1lbnQpLFxuICAgICAgICBdO1xuICAgIH1cbiAgICBxdWVyeUVsZW1lbnRzKHNlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSk7XG4gICAgfVxuICAgIGdldCBjb250cm9sbGVyU2VsZWN0b3IoKSB7XG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGVWYWx1ZUNvbnRhaW5zVG9rZW4odGhpcy5zY2hlbWEuY29udHJvbGxlckF0dHJpYnV0ZSwgdGhpcy5pZGVudGlmaWVyKTtcbiAgICB9XG4gICAgZ2V0IGlzRG9jdW1lbnRTY29wZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudCA9PT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIH1cbiAgICBnZXQgZG9jdW1lbnRTY29wZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNEb2N1bWVudFNjb3BlXG4gICAgICAgICAgICA/IHRoaXNcbiAgICAgICAgICAgIDogbmV3IFNjb3BlKHRoaXMuc2NoZW1hLCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIHRoaXMuaWRlbnRpZmllciwgdGhpcy5ndWlkZS5sb2dnZXIpO1xuICAgIH1cbn1cblxuY2xhc3MgU2NvcGVPYnNlcnZlciB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgc2NoZW1hLCBkZWxlZ2F0ZSkge1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xuICAgICAgICB0aGlzLnZhbHVlTGlzdE9ic2VydmVyID0gbmV3IFZhbHVlTGlzdE9ic2VydmVyKHRoaXMuZWxlbWVudCwgdGhpcy5jb250cm9sbGVyQXR0cmlidXRlLCB0aGlzKTtcbiAgICAgICAgdGhpcy5zY29wZXNCeUlkZW50aWZpZXJCeUVsZW1lbnQgPSBuZXcgV2Vha01hcCgpO1xuICAgICAgICB0aGlzLnNjb3BlUmVmZXJlbmNlQ291bnRzID0gbmV3IFdlYWtNYXAoKTtcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIHRoaXMudmFsdWVMaXN0T2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgdGhpcy52YWx1ZUxpc3RPYnNlcnZlci5zdG9wKCk7XG4gICAgfVxuICAgIGdldCBjb250cm9sbGVyQXR0cmlidXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY2hlbWEuY29udHJvbGxlckF0dHJpYnV0ZTtcbiAgICB9XG4gICAgcGFyc2VWYWx1ZUZvclRva2VuKHRva2VuKSB7XG4gICAgICAgIGNvbnN0IHsgZWxlbWVudCwgY29udGVudDogaWRlbnRpZmllciB9ID0gdG9rZW47XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlVmFsdWVGb3JFbGVtZW50QW5kSWRlbnRpZmllcihlbGVtZW50LCBpZGVudGlmaWVyKTtcbiAgICB9XG4gICAgcGFyc2VWYWx1ZUZvckVsZW1lbnRBbmRJZGVudGlmaWVyKGVsZW1lbnQsIGlkZW50aWZpZXIpIHtcbiAgICAgICAgY29uc3Qgc2NvcGVzQnlJZGVudGlmaWVyID0gdGhpcy5mZXRjaFNjb3Blc0J5SWRlbnRpZmllckZvckVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgIGxldCBzY29wZSA9IHNjb3Blc0J5SWRlbnRpZmllci5nZXQoaWRlbnRpZmllcik7XG4gICAgICAgIGlmICghc2NvcGUpIHtcbiAgICAgICAgICAgIHNjb3BlID0gdGhpcy5kZWxlZ2F0ZS5jcmVhdGVTY29wZUZvckVsZW1lbnRBbmRJZGVudGlmaWVyKGVsZW1lbnQsIGlkZW50aWZpZXIpO1xuICAgICAgICAgICAgc2NvcGVzQnlJZGVudGlmaWVyLnNldChpZGVudGlmaWVyLCBzY29wZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNjb3BlO1xuICAgIH1cbiAgICBlbGVtZW50TWF0Y2hlZFZhbHVlKGVsZW1lbnQsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IHJlZmVyZW5jZUNvdW50ID0gKHRoaXMuc2NvcGVSZWZlcmVuY2VDb3VudHMuZ2V0KHZhbHVlKSB8fCAwKSArIDE7XG4gICAgICAgIHRoaXMuc2NvcGVSZWZlcmVuY2VDb3VudHMuc2V0KHZhbHVlLCByZWZlcmVuY2VDb3VudCk7XG4gICAgICAgIGlmIChyZWZlcmVuY2VDb3VudCA9PSAxKSB7XG4gICAgICAgICAgICB0aGlzLmRlbGVnYXRlLnNjb3BlQ29ubmVjdGVkKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbGVtZW50VW5tYXRjaGVkVmFsdWUoZWxlbWVudCwgdmFsdWUpIHtcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlQ291bnQgPSB0aGlzLnNjb3BlUmVmZXJlbmNlQ291bnRzLmdldCh2YWx1ZSk7XG4gICAgICAgIGlmIChyZWZlcmVuY2VDb3VudCkge1xuICAgICAgICAgICAgdGhpcy5zY29wZVJlZmVyZW5jZUNvdW50cy5zZXQodmFsdWUsIHJlZmVyZW5jZUNvdW50IC0gMSk7XG4gICAgICAgICAgICBpZiAocmVmZXJlbmNlQ291bnQgPT0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVsZWdhdGUuc2NvcGVEaXNjb25uZWN0ZWQodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZldGNoU2NvcGVzQnlJZGVudGlmaWVyRm9yRWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgIGxldCBzY29wZXNCeUlkZW50aWZpZXIgPSB0aGlzLnNjb3Blc0J5SWRlbnRpZmllckJ5RWxlbWVudC5nZXQoZWxlbWVudCk7XG4gICAgICAgIGlmICghc2NvcGVzQnlJZGVudGlmaWVyKSB7XG4gICAgICAgICAgICBzY29wZXNCeUlkZW50aWZpZXIgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICB0aGlzLnNjb3Blc0J5SWRlbnRpZmllckJ5RWxlbWVudC5zZXQoZWxlbWVudCwgc2NvcGVzQnlJZGVudGlmaWVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NvcGVzQnlJZGVudGlmaWVyO1xuICAgIH1cbn1cblxuY2xhc3MgUm91dGVyIHtcbiAgICBjb25zdHJ1Y3RvcihhcHBsaWNhdGlvbikge1xuICAgICAgICB0aGlzLmFwcGxpY2F0aW9uID0gYXBwbGljYXRpb247XG4gICAgICAgIHRoaXMuc2NvcGVPYnNlcnZlciA9IG5ldyBTY29wZU9ic2VydmVyKHRoaXMuZWxlbWVudCwgdGhpcy5zY2hlbWEsIHRoaXMpO1xuICAgICAgICB0aGlzLnNjb3Blc0J5SWRlbnRpZmllciA9IG5ldyBNdWx0aW1hcCgpO1xuICAgICAgICB0aGlzLm1vZHVsZXNCeUlkZW50aWZpZXIgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGdldCBlbGVtZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBsaWNhdGlvbi5lbGVtZW50O1xuICAgIH1cbiAgICBnZXQgc2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBsaWNhdGlvbi5zY2hlbWE7XG4gICAgfVxuICAgIGdldCBsb2dnZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcGxpY2F0aW9uLmxvZ2dlcjtcbiAgICB9XG4gICAgZ2V0IGNvbnRyb2xsZXJBdHRyaWJ1dGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjaGVtYS5jb250cm9sbGVyQXR0cmlidXRlO1xuICAgIH1cbiAgICBnZXQgbW9kdWxlcygpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmZyb20odGhpcy5tb2R1bGVzQnlJZGVudGlmaWVyLnZhbHVlcygpKTtcbiAgICB9XG4gICAgZ2V0IGNvbnRleHRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb2R1bGVzLnJlZHVjZSgoY29udGV4dHMsIG1vZHVsZSkgPT4gY29udGV4dHMuY29uY2F0KG1vZHVsZS5jb250ZXh0cyksIFtdKTtcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIHRoaXMuc2NvcGVPYnNlcnZlci5zdGFydCgpO1xuICAgIH1cbiAgICBzdG9wKCkge1xuICAgICAgICB0aGlzLnNjb3BlT2JzZXJ2ZXIuc3RvcCgpO1xuICAgIH1cbiAgICBsb2FkRGVmaW5pdGlvbihkZWZpbml0aW9uKSB7XG4gICAgICAgIHRoaXMudW5sb2FkSWRlbnRpZmllcihkZWZpbml0aW9uLmlkZW50aWZpZXIpO1xuICAgICAgICBjb25zdCBtb2R1bGUgPSBuZXcgTW9kdWxlKHRoaXMuYXBwbGljYXRpb24sIGRlZmluaXRpb24pO1xuICAgICAgICB0aGlzLmNvbm5lY3RNb2R1bGUobW9kdWxlKTtcbiAgICAgICAgY29uc3QgYWZ0ZXJMb2FkID0gZGVmaW5pdGlvbi5jb250cm9sbGVyQ29uc3RydWN0b3IuYWZ0ZXJMb2FkO1xuICAgICAgICBpZiAoYWZ0ZXJMb2FkKSB7XG4gICAgICAgICAgICBhZnRlckxvYWQuY2FsbChkZWZpbml0aW9uLmNvbnRyb2xsZXJDb25zdHJ1Y3RvciwgZGVmaW5pdGlvbi5pZGVudGlmaWVyLCB0aGlzLmFwcGxpY2F0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1bmxvYWRJZGVudGlmaWVyKGlkZW50aWZpZXIpIHtcbiAgICAgICAgY29uc3QgbW9kdWxlID0gdGhpcy5tb2R1bGVzQnlJZGVudGlmaWVyLmdldChpZGVudGlmaWVyKTtcbiAgICAgICAgaWYgKG1vZHVsZSkge1xuICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0TW9kdWxlKG1vZHVsZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0Q29udGV4dEZvckVsZW1lbnRBbmRJZGVudGlmaWVyKGVsZW1lbnQsIGlkZW50aWZpZXIpIHtcbiAgICAgICAgY29uc3QgbW9kdWxlID0gdGhpcy5tb2R1bGVzQnlJZGVudGlmaWVyLmdldChpZGVudGlmaWVyKTtcbiAgICAgICAgaWYgKG1vZHVsZSkge1xuICAgICAgICAgICAgcmV0dXJuIG1vZHVsZS5jb250ZXh0cy5maW5kKChjb250ZXh0KSA9PiBjb250ZXh0LmVsZW1lbnQgPT0gZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJvcG9zZVRvQ29ubmVjdFNjb3BlRm9yRWxlbWVudEFuZElkZW50aWZpZXIoZWxlbWVudCwgaWRlbnRpZmllcikge1xuICAgICAgICBjb25zdCBzY29wZSA9IHRoaXMuc2NvcGVPYnNlcnZlci5wYXJzZVZhbHVlRm9yRWxlbWVudEFuZElkZW50aWZpZXIoZWxlbWVudCwgaWRlbnRpZmllcik7XG4gICAgICAgIGlmIChzY29wZSkge1xuICAgICAgICAgICAgdGhpcy5zY29wZU9ic2VydmVyLmVsZW1lbnRNYXRjaGVkVmFsdWUoc2NvcGUuZWxlbWVudCwgc2NvcGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgQ291bGRuJ3QgZmluZCBvciBjcmVhdGUgc2NvcGUgZm9yIGlkZW50aWZpZXI6IFwiJHtpZGVudGlmaWVyfVwiIGFuZCBlbGVtZW50OmAsIGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZUVycm9yKGVycm9yLCBtZXNzYWdlLCBkZXRhaWwpIHtcbiAgICAgICAgdGhpcy5hcHBsaWNhdGlvbi5oYW5kbGVFcnJvcihlcnJvciwgbWVzc2FnZSwgZGV0YWlsKTtcbiAgICB9XG4gICAgY3JlYXRlU2NvcGVGb3JFbGVtZW50QW5kSWRlbnRpZmllcihlbGVtZW50LCBpZGVudGlmaWVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2NvcGUodGhpcy5zY2hlbWEsIGVsZW1lbnQsIGlkZW50aWZpZXIsIHRoaXMubG9nZ2VyKTtcbiAgICB9XG4gICAgc2NvcGVDb25uZWN0ZWQoc2NvcGUpIHtcbiAgICAgICAgdGhpcy5zY29wZXNCeUlkZW50aWZpZXIuYWRkKHNjb3BlLmlkZW50aWZpZXIsIHNjb3BlKTtcbiAgICAgICAgY29uc3QgbW9kdWxlID0gdGhpcy5tb2R1bGVzQnlJZGVudGlmaWVyLmdldChzY29wZS5pZGVudGlmaWVyKTtcbiAgICAgICAgaWYgKG1vZHVsZSkge1xuICAgICAgICAgICAgbW9kdWxlLmNvbm5lY3RDb250ZXh0Rm9yU2NvcGUoc2NvcGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNjb3BlRGlzY29ubmVjdGVkKHNjb3BlKSB7XG4gICAgICAgIHRoaXMuc2NvcGVzQnlJZGVudGlmaWVyLmRlbGV0ZShzY29wZS5pZGVudGlmaWVyLCBzY29wZSk7XG4gICAgICAgIGNvbnN0IG1vZHVsZSA9IHRoaXMubW9kdWxlc0J5SWRlbnRpZmllci5nZXQoc2NvcGUuaWRlbnRpZmllcik7XG4gICAgICAgIGlmIChtb2R1bGUpIHtcbiAgICAgICAgICAgIG1vZHVsZS5kaXNjb25uZWN0Q29udGV4dEZvclNjb3BlKHNjb3BlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25uZWN0TW9kdWxlKG1vZHVsZSkge1xuICAgICAgICB0aGlzLm1vZHVsZXNCeUlkZW50aWZpZXIuc2V0KG1vZHVsZS5pZGVudGlmaWVyLCBtb2R1bGUpO1xuICAgICAgICBjb25zdCBzY29wZXMgPSB0aGlzLnNjb3Blc0J5SWRlbnRpZmllci5nZXRWYWx1ZXNGb3JLZXkobW9kdWxlLmlkZW50aWZpZXIpO1xuICAgICAgICBzY29wZXMuZm9yRWFjaCgoc2NvcGUpID0+IG1vZHVsZS5jb25uZWN0Q29udGV4dEZvclNjb3BlKHNjb3BlKSk7XG4gICAgfVxuICAgIGRpc2Nvbm5lY3RNb2R1bGUobW9kdWxlKSB7XG4gICAgICAgIHRoaXMubW9kdWxlc0J5SWRlbnRpZmllci5kZWxldGUobW9kdWxlLmlkZW50aWZpZXIpO1xuICAgICAgICBjb25zdCBzY29wZXMgPSB0aGlzLnNjb3Blc0J5SWRlbnRpZmllci5nZXRWYWx1ZXNGb3JLZXkobW9kdWxlLmlkZW50aWZpZXIpO1xuICAgICAgICBzY29wZXMuZm9yRWFjaCgoc2NvcGUpID0+IG1vZHVsZS5kaXNjb25uZWN0Q29udGV4dEZvclNjb3BlKHNjb3BlKSk7XG4gICAgfVxufVxuXG5jb25zdCBkZWZhdWx0U2NoZW1hID0ge1xuICAgIGNvbnRyb2xsZXJBdHRyaWJ1dGU6IFwiZGF0YS1jb250cm9sbGVyXCIsXG4gICAgYWN0aW9uQXR0cmlidXRlOiBcImRhdGEtYWN0aW9uXCIsXG4gICAgdGFyZ2V0QXR0cmlidXRlOiBcImRhdGEtdGFyZ2V0XCIsXG4gICAgdGFyZ2V0QXR0cmlidXRlRm9yU2NvcGU6IChpZGVudGlmaWVyKSA9PiBgZGF0YS0ke2lkZW50aWZpZXJ9LXRhcmdldGAsXG4gICAgb3V0bGV0QXR0cmlidXRlRm9yU2NvcGU6IChpZGVudGlmaWVyLCBvdXRsZXQpID0+IGBkYXRhLSR7aWRlbnRpZmllcn0tJHtvdXRsZXR9LW91dGxldGAsXG4gICAga2V5TWFwcGluZ3M6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7IGVudGVyOiBcIkVudGVyXCIsIHRhYjogXCJUYWJcIiwgZXNjOiBcIkVzY2FwZVwiLCBzcGFjZTogXCIgXCIsIHVwOiBcIkFycm93VXBcIiwgZG93bjogXCJBcnJvd0Rvd25cIiwgbGVmdDogXCJBcnJvd0xlZnRcIiwgcmlnaHQ6IFwiQXJyb3dSaWdodFwiLCBob21lOiBcIkhvbWVcIiwgZW5kOiBcIkVuZFwiLCBwYWdlX3VwOiBcIlBhZ2VVcFwiLCBwYWdlX2Rvd246IFwiUGFnZURvd25cIiB9LCBvYmplY3RGcm9tRW50cmllcyhcImFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XCIuc3BsaXQoXCJcIikubWFwKChjKSA9PiBbYywgY10pKSksIG9iamVjdEZyb21FbnRyaWVzKFwiMDEyMzQ1Njc4OVwiLnNwbGl0KFwiXCIpLm1hcCgobikgPT4gW24sIG5dKSkpLFxufTtcbmZ1bmN0aW9uIG9iamVjdEZyb21FbnRyaWVzKGFycmF5KSB7XG4gICAgcmV0dXJuIGFycmF5LnJlZHVjZSgobWVtbywgW2ssIHZdKSA9PiAoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtZW1vKSwgeyBba106IHYgfSkpLCB7fSk7XG59XG5cbmNsYXNzIEFwcGxpY2F0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCBzY2hlbWEgPSBkZWZhdWx0U2NoZW1hKSB7XG4gICAgICAgIHRoaXMubG9nZ2VyID0gY29uc29sZTtcbiAgICAgICAgdGhpcy5kZWJ1ZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxvZ0RlYnVnQWN0aXZpdHkgPSAoaWRlbnRpZmllciwgZnVuY3Rpb25OYW1lLCBkZXRhaWwgPSB7fSkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ0Zvcm1hdHRlZE1lc3NhZ2UoaWRlbnRpZmllciwgZnVuY3Rpb25OYW1lLCBkZXRhaWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaGVyID0gbmV3IERpc3BhdGNoZXIodGhpcyk7XG4gICAgICAgIHRoaXMucm91dGVyID0gbmV3IFJvdXRlcih0aGlzKTtcbiAgICAgICAgdGhpcy5hY3Rpb25EZXNjcmlwdG9yRmlsdGVycyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRBY3Rpb25EZXNjcmlwdG9yRmlsdGVycyk7XG4gICAgfVxuICAgIHN0YXRpYyBzdGFydChlbGVtZW50LCBzY2hlbWEpIHtcbiAgICAgICAgY29uc3QgYXBwbGljYXRpb24gPSBuZXcgdGhpcyhlbGVtZW50LCBzY2hlbWEpO1xuICAgICAgICBhcHBsaWNhdGlvbi5zdGFydCgpO1xuICAgICAgICByZXR1cm4gYXBwbGljYXRpb247XG4gICAgfVxuICAgIGFzeW5jIHN0YXJ0KCkge1xuICAgICAgICBhd2FpdCBkb21SZWFkeSgpO1xuICAgICAgICB0aGlzLmxvZ0RlYnVnQWN0aXZpdHkoXCJhcHBsaWNhdGlvblwiLCBcInN0YXJ0aW5nXCIpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoZXIuc3RhcnQoKTtcbiAgICAgICAgdGhpcy5yb3V0ZXIuc3RhcnQoKTtcbiAgICAgICAgdGhpcy5sb2dEZWJ1Z0FjdGl2aXR5KFwiYXBwbGljYXRpb25cIiwgXCJzdGFydFwiKTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgdGhpcy5sb2dEZWJ1Z0FjdGl2aXR5KFwiYXBwbGljYXRpb25cIiwgXCJzdG9wcGluZ1wiKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaGVyLnN0b3AoKTtcbiAgICAgICAgdGhpcy5yb3V0ZXIuc3RvcCgpO1xuICAgICAgICB0aGlzLmxvZ0RlYnVnQWN0aXZpdHkoXCJhcHBsaWNhdGlvblwiLCBcInN0b3BcIik7XG4gICAgfVxuICAgIHJlZ2lzdGVyKGlkZW50aWZpZXIsIGNvbnRyb2xsZXJDb25zdHJ1Y3Rvcikge1xuICAgICAgICB0aGlzLmxvYWQoeyBpZGVudGlmaWVyLCBjb250cm9sbGVyQ29uc3RydWN0b3IgfSk7XG4gICAgfVxuICAgIHJlZ2lzdGVyQWN0aW9uT3B0aW9uKG5hbWUsIGZpbHRlcikge1xuICAgICAgICB0aGlzLmFjdGlvbkRlc2NyaXB0b3JGaWx0ZXJzW25hbWVdID0gZmlsdGVyO1xuICAgIH1cbiAgICBsb2FkKGhlYWQsIC4uLnJlc3QpIHtcbiAgICAgICAgY29uc3QgZGVmaW5pdGlvbnMgPSBBcnJheS5pc0FycmF5KGhlYWQpID8gaGVhZCA6IFtoZWFkLCAuLi5yZXN0XTtcbiAgICAgICAgZGVmaW5pdGlvbnMuZm9yRWFjaCgoZGVmaW5pdGlvbikgPT4ge1xuICAgICAgICAgICAgaWYgKGRlZmluaXRpb24uY29udHJvbGxlckNvbnN0cnVjdG9yLnNob3VsZExvYWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJvdXRlci5sb2FkRGVmaW5pdGlvbihkZWZpbml0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVubG9hZChoZWFkLCAuLi5yZXN0KSB7XG4gICAgICAgIGNvbnN0IGlkZW50aWZpZXJzID0gQXJyYXkuaXNBcnJheShoZWFkKSA/IGhlYWQgOiBbaGVhZCwgLi4ucmVzdF07XG4gICAgICAgIGlkZW50aWZpZXJzLmZvckVhY2goKGlkZW50aWZpZXIpID0+IHRoaXMucm91dGVyLnVubG9hZElkZW50aWZpZXIoaWRlbnRpZmllcikpO1xuICAgIH1cbiAgICBnZXQgY29udHJvbGxlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvdXRlci5jb250ZXh0cy5tYXAoKGNvbnRleHQpID0+IGNvbnRleHQuY29udHJvbGxlcik7XG4gICAgfVxuICAgIGdldENvbnRyb2xsZXJGb3JFbGVtZW50QW5kSWRlbnRpZmllcihlbGVtZW50LCBpZGVudGlmaWVyKSB7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLnJvdXRlci5nZXRDb250ZXh0Rm9yRWxlbWVudEFuZElkZW50aWZpZXIoZWxlbWVudCwgaWRlbnRpZmllcik7XG4gICAgICAgIHJldHVybiBjb250ZXh0ID8gY29udGV4dC5jb250cm9sbGVyIDogbnVsbDtcbiAgICB9XG4gICAgaGFuZGxlRXJyb3IoZXJyb3IsIG1lc3NhZ2UsIGRldGFpbCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMubG9nZ2VyLmVycm9yKGAlc1xcblxcbiVvXFxuXFxuJW9gLCBtZXNzYWdlLCBlcnJvciwgZGV0YWlsKTtcbiAgICAgICAgKF9hID0gd2luZG93Lm9uZXJyb3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHdpbmRvdywgbWVzc2FnZSwgXCJcIiwgMCwgMCwgZXJyb3IpO1xuICAgIH1cbiAgICBsb2dGb3JtYXR0ZWRNZXNzYWdlKGlkZW50aWZpZXIsIGZ1bmN0aW9uTmFtZSwgZGV0YWlsID0ge30pIHtcbiAgICAgICAgZGV0YWlsID0gT2JqZWN0LmFzc2lnbih7IGFwcGxpY2F0aW9uOiB0aGlzIH0sIGRldGFpbCk7XG4gICAgICAgIHRoaXMubG9nZ2VyLmdyb3VwQ29sbGFwc2VkKGAke2lkZW50aWZpZXJ9ICMke2Z1bmN0aW9uTmFtZX1gKTtcbiAgICAgICAgdGhpcy5sb2dnZXIubG9nKFwiZGV0YWlsczpcIiwgT2JqZWN0LmFzc2lnbih7fSwgZGV0YWlsKSk7XG4gICAgICAgIHRoaXMubG9nZ2VyLmdyb3VwRW5kKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZG9tUmVhZHkoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09IFwibG9hZGluZ1wiKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCAoKSA9PiByZXNvbHZlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIENsYXNzUHJvcGVydGllc0JsZXNzaW5nKGNvbnN0cnVjdG9yKSB7XG4gICAgY29uc3QgY2xhc3NlcyA9IHJlYWRJbmhlcml0YWJsZVN0YXRpY0FycmF5VmFsdWVzKGNvbnN0cnVjdG9yLCBcImNsYXNzZXNcIik7XG4gICAgcmV0dXJuIGNsYXNzZXMucmVkdWNlKChwcm9wZXJ0aWVzLCBjbGFzc0RlZmluaXRpb24pID0+IHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ocHJvcGVydGllcywgcHJvcGVydGllc0ZvckNsYXNzRGVmaW5pdGlvbihjbGFzc0RlZmluaXRpb24pKTtcbiAgICB9LCB7fSk7XG59XG5mdW5jdGlvbiBwcm9wZXJ0aWVzRm9yQ2xhc3NEZWZpbml0aW9uKGtleSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIFtgJHtrZXl9Q2xhc3NgXToge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgY2xhc3NlcyB9ID0gdGhpcztcbiAgICAgICAgICAgICAgICBpZiAoY2xhc3Nlcy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xhc3Nlcy5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGF0dHJpYnV0ZSA9IGNsYXNzZXMuZ2V0QXR0cmlidXRlTmFtZShrZXkpO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgYXR0cmlidXRlIFwiJHthdHRyaWJ1dGV9XCJgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBbYCR7a2V5fUNsYXNzZXNgXToge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNsYXNzZXMuZ2V0QWxsKGtleSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBbYGhhcyR7Y2FwaXRhbGl6ZShrZXkpfUNsYXNzYF06IHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jbGFzc2VzLmhhcyhrZXkpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBPdXRsZXRQcm9wZXJ0aWVzQmxlc3NpbmcoY29uc3RydWN0b3IpIHtcbiAgICBjb25zdCBvdXRsZXRzID0gcmVhZEluaGVyaXRhYmxlU3RhdGljQXJyYXlWYWx1ZXMoY29uc3RydWN0b3IsIFwib3V0bGV0c1wiKTtcbiAgICByZXR1cm4gb3V0bGV0cy5yZWR1Y2UoKHByb3BlcnRpZXMsIG91dGxldERlZmluaXRpb24pID0+IHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24ocHJvcGVydGllcywgcHJvcGVydGllc0Zvck91dGxldERlZmluaXRpb24ob3V0bGV0RGVmaW5pdGlvbikpO1xuICAgIH0sIHt9KTtcbn1cbmZ1bmN0aW9uIGdldE91dGxldENvbnRyb2xsZXIoY29udHJvbGxlciwgZWxlbWVudCwgaWRlbnRpZmllcikge1xuICAgIHJldHVybiBjb250cm9sbGVyLmFwcGxpY2F0aW9uLmdldENvbnRyb2xsZXJGb3JFbGVtZW50QW5kSWRlbnRpZmllcihlbGVtZW50LCBpZGVudGlmaWVyKTtcbn1cbmZ1bmN0aW9uIGdldENvbnRyb2xsZXJBbmRFbnN1cmVDb25uZWN0ZWRTY29wZShjb250cm9sbGVyLCBlbGVtZW50LCBvdXRsZXROYW1lKSB7XG4gICAgbGV0IG91dGxldENvbnRyb2xsZXIgPSBnZXRPdXRsZXRDb250cm9sbGVyKGNvbnRyb2xsZXIsIGVsZW1lbnQsIG91dGxldE5hbWUpO1xuICAgIGlmIChvdXRsZXRDb250cm9sbGVyKVxuICAgICAgICByZXR1cm4gb3V0bGV0Q29udHJvbGxlcjtcbiAgICBjb250cm9sbGVyLmFwcGxpY2F0aW9uLnJvdXRlci5wcm9wb3NlVG9Db25uZWN0U2NvcGVGb3JFbGVtZW50QW5kSWRlbnRpZmllcihlbGVtZW50LCBvdXRsZXROYW1lKTtcbiAgICBvdXRsZXRDb250cm9sbGVyID0gZ2V0T3V0bGV0Q29udHJvbGxlcihjb250cm9sbGVyLCBlbGVtZW50LCBvdXRsZXROYW1lKTtcbiAgICBpZiAob3V0bGV0Q29udHJvbGxlcilcbiAgICAgICAgcmV0dXJuIG91dGxldENvbnRyb2xsZXI7XG59XG5mdW5jdGlvbiBwcm9wZXJ0aWVzRm9yT3V0bGV0RGVmaW5pdGlvbihuYW1lKSB7XG4gICAgY29uc3QgY2FtZWxpemVkTmFtZSA9IG5hbWVzcGFjZUNhbWVsaXplKG5hbWUpO1xuICAgIHJldHVybiB7XG4gICAgICAgIFtgJHtjYW1lbGl6ZWROYW1lfU91dGxldGBdOiB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0bGV0RWxlbWVudCA9IHRoaXMub3V0bGV0cy5maW5kKG5hbWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9yID0gdGhpcy5vdXRsZXRzLmdldFNlbGVjdG9yRm9yT3V0bGV0TmFtZShuYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAob3V0bGV0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvdXRsZXRDb250cm9sbGVyID0gZ2V0Q29udHJvbGxlckFuZEVuc3VyZUNvbm5lY3RlZFNjb3BlKHRoaXMsIG91dGxldEVsZW1lbnQsIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAob3V0bGV0Q29udHJvbGxlcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvdXRsZXRDb250cm9sbGVyO1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBwcm92aWRlZCBvdXRsZXQgZWxlbWVudCBpcyBtaXNzaW5nIGFuIG91dGxldCBjb250cm9sbGVyIFwiJHtuYW1lfVwiIGluc3RhbmNlIGZvciBob3N0IGNvbnRyb2xsZXIgXCIke3RoaXMuaWRlbnRpZmllcn1cImApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1pc3Npbmcgb3V0bGV0IGVsZW1lbnQgXCIke25hbWV9XCIgZm9yIGhvc3QgY29udHJvbGxlciBcIiR7dGhpcy5pZGVudGlmaWVyfVwiLiBTdGltdWx1cyBjb3VsZG4ndCBmaW5kIGEgbWF0Y2hpbmcgb3V0bGV0IGVsZW1lbnQgdXNpbmcgc2VsZWN0b3IgXCIke3NlbGVjdG9yfVwiLmApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgW2Ake2NhbWVsaXplZE5hbWV9T3V0bGV0c2BdOiB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0bGV0cyA9IHRoaXMub3V0bGV0cy5maW5kQWxsKG5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChvdXRsZXRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG91dGxldHNcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoKG91dGxldEVsZW1lbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG91dGxldENvbnRyb2xsZXIgPSBnZXRDb250cm9sbGVyQW5kRW5zdXJlQ29ubmVjdGVkU2NvcGUodGhpcywgb3V0bGV0RWxlbWVudCwgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3V0bGV0Q29udHJvbGxlcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3V0bGV0Q29udHJvbGxlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgVGhlIHByb3ZpZGVkIG91dGxldCBlbGVtZW50IGlzIG1pc3NpbmcgYW4gb3V0bGV0IGNvbnRyb2xsZXIgXCIke25hbWV9XCIgaW5zdGFuY2UgZm9yIGhvc3QgY29udHJvbGxlciBcIiR7dGhpcy5pZGVudGlmaWVyfVwiYCwgb3V0bGV0RWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKChjb250cm9sbGVyKSA9PiBjb250cm9sbGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgW2Ake2NhbWVsaXplZE5hbWV9T3V0bGV0RWxlbWVudGBdOiB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3V0bGV0RWxlbWVudCA9IHRoaXMub3V0bGV0cy5maW5kKG5hbWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9yID0gdGhpcy5vdXRsZXRzLmdldFNlbGVjdG9yRm9yT3V0bGV0TmFtZShuYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAob3V0bGV0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3V0bGV0RWxlbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTWlzc2luZyBvdXRsZXQgZWxlbWVudCBcIiR7bmFtZX1cIiBmb3IgaG9zdCBjb250cm9sbGVyIFwiJHt0aGlzLmlkZW50aWZpZXJ9XCIuIFN0aW11bHVzIGNvdWxkbid0IGZpbmQgYSBtYXRjaGluZyBvdXRsZXQgZWxlbWVudCB1c2luZyBzZWxlY3RvciBcIiR7c2VsZWN0b3J9XCIuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgW2Ake2NhbWVsaXplZE5hbWV9T3V0bGV0RWxlbWVudHNgXToge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm91dGxldHMuZmluZEFsbChuYW1lKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIFtgaGFzJHtjYXBpdGFsaXplKGNhbWVsaXplZE5hbWUpfU91dGxldGBdOiB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3V0bGV0cy5oYXMobmFtZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH07XG59XG5cbmZ1bmN0aW9uIFRhcmdldFByb3BlcnRpZXNCbGVzc2luZyhjb25zdHJ1Y3Rvcikge1xuICAgIGNvbnN0IHRhcmdldHMgPSByZWFkSW5oZXJpdGFibGVTdGF0aWNBcnJheVZhbHVlcyhjb25zdHJ1Y3RvciwgXCJ0YXJnZXRzXCIpO1xuICAgIHJldHVybiB0YXJnZXRzLnJlZHVjZSgocHJvcGVydGllcywgdGFyZ2V0RGVmaW5pdGlvbikgPT4ge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihwcm9wZXJ0aWVzLCBwcm9wZXJ0aWVzRm9yVGFyZ2V0RGVmaW5pdGlvbih0YXJnZXREZWZpbml0aW9uKSk7XG4gICAgfSwge30pO1xufVxuZnVuY3Rpb24gcHJvcGVydGllc0ZvclRhcmdldERlZmluaXRpb24obmFtZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIFtgJHtuYW1lfVRhcmdldGBdOiB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy50YXJnZXRzLmZpbmQobmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIHRhcmdldCBlbGVtZW50IFwiJHtuYW1lfVwiIGZvciBcIiR7dGhpcy5pZGVudGlmaWVyfVwiIGNvbnRyb2xsZXJgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBbYCR7bmFtZX1UYXJnZXRzYF06IHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50YXJnZXRzLmZpbmRBbGwobmFtZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBbYGhhcyR7Y2FwaXRhbGl6ZShuYW1lKX1UYXJnZXRgXToge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRhcmdldHMuaGFzKG5hbWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBWYWx1ZVByb3BlcnRpZXNCbGVzc2luZyhjb25zdHJ1Y3Rvcikge1xuICAgIGNvbnN0IHZhbHVlRGVmaW5pdGlvblBhaXJzID0gcmVhZEluaGVyaXRhYmxlU3RhdGljT2JqZWN0UGFpcnMoY29uc3RydWN0b3IsIFwidmFsdWVzXCIpO1xuICAgIGNvbnN0IHByb3BlcnR5RGVzY3JpcHRvck1hcCA9IHtcbiAgICAgICAgdmFsdWVEZXNjcmlwdG9yTWFwOiB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlRGVmaW5pdGlvblBhaXJzLnJlZHVjZSgocmVzdWx0LCB2YWx1ZURlZmluaXRpb25QYWlyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlRGVzY3JpcHRvciA9IHBhcnNlVmFsdWVEZWZpbml0aW9uUGFpcih2YWx1ZURlZmluaXRpb25QYWlyLCB0aGlzLmlkZW50aWZpZXIpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGVOYW1lID0gdGhpcy5kYXRhLmdldEF0dHJpYnV0ZU5hbWVGb3JLZXkodmFsdWVEZXNjcmlwdG9yLmtleSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHJlc3VsdCwgeyBbYXR0cmlidXRlTmFtZV06IHZhbHVlRGVzY3JpcHRvciB9KTtcbiAgICAgICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgIH07XG4gICAgcmV0dXJuIHZhbHVlRGVmaW5pdGlvblBhaXJzLnJlZHVjZSgocHJvcGVydGllcywgdmFsdWVEZWZpbml0aW9uUGFpcikgPT4ge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihwcm9wZXJ0aWVzLCBwcm9wZXJ0aWVzRm9yVmFsdWVEZWZpbml0aW9uUGFpcih2YWx1ZURlZmluaXRpb25QYWlyKSk7XG4gICAgfSwgcHJvcGVydHlEZXNjcmlwdG9yTWFwKTtcbn1cbmZ1bmN0aW9uIHByb3BlcnRpZXNGb3JWYWx1ZURlZmluaXRpb25QYWlyKHZhbHVlRGVmaW5pdGlvblBhaXIsIGNvbnRyb2xsZXIpIHtcbiAgICBjb25zdCBkZWZpbml0aW9uID0gcGFyc2VWYWx1ZURlZmluaXRpb25QYWlyKHZhbHVlRGVmaW5pdGlvblBhaXIsIGNvbnRyb2xsZXIpO1xuICAgIGNvbnN0IHsga2V5LCBuYW1lLCByZWFkZXI6IHJlYWQsIHdyaXRlcjogd3JpdGUgfSA9IGRlZmluaXRpb247XG4gICAgcmV0dXJuIHtcbiAgICAgICAgW25hbWVdOiB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmRhdGEuZ2V0KGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWFkKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWZpbml0aW9uLmRlZmF1bHRWYWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhLnNldChrZXksIHdyaXRlKHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgICAgW2BoYXMke2NhcGl0YWxpemUobmFtZSl9YF06IHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmhhcyhrZXkpIHx8IGRlZmluaXRpb24uaGFzQ3VzdG9tRGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZnVuY3Rpb24gcGFyc2VWYWx1ZURlZmluaXRpb25QYWlyKFt0b2tlbiwgdHlwZURlZmluaXRpb25dLCBjb250cm9sbGVyKSB7XG4gICAgcmV0dXJuIHZhbHVlRGVzY3JpcHRvckZvclRva2VuQW5kVHlwZURlZmluaXRpb24oe1xuICAgICAgICBjb250cm9sbGVyLFxuICAgICAgICB0b2tlbixcbiAgICAgICAgdHlwZURlZmluaXRpb24sXG4gICAgfSk7XG59XG5mdW5jdGlvbiBwYXJzZVZhbHVlVHlwZUNvbnN0YW50KGNvbnN0YW50KSB7XG4gICAgc3dpdGNoIChjb25zdGFudCkge1xuICAgICAgICBjYXNlIEFycmF5OlxuICAgICAgICAgICAgcmV0dXJuIFwiYXJyYXlcIjtcbiAgICAgICAgY2FzZSBCb29sZWFuOlxuICAgICAgICAgICAgcmV0dXJuIFwiYm9vbGVhblwiO1xuICAgICAgICBjYXNlIE51bWJlcjpcbiAgICAgICAgICAgIHJldHVybiBcIm51bWJlclwiO1xuICAgICAgICBjYXNlIE9iamVjdDpcbiAgICAgICAgICAgIHJldHVybiBcIm9iamVjdFwiO1xuICAgICAgICBjYXNlIFN0cmluZzpcbiAgICAgICAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhcnNlVmFsdWVUeXBlRGVmYXVsdChkZWZhdWx0VmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICAgIHJldHVybiBcImJvb2xlYW5cIjtcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgICAgcmV0dXJuIFwibnVtYmVyXCI7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgIHJldHVybiBcInN0cmluZ1wiO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShkZWZhdWx0VmFsdWUpKVxuICAgICAgICByZXR1cm4gXCJhcnJheVwiO1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZGVmYXVsdFZhbHVlKSA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIilcbiAgICAgICAgcmV0dXJuIFwib2JqZWN0XCI7XG59XG5mdW5jdGlvbiBwYXJzZVZhbHVlVHlwZU9iamVjdChwYXlsb2FkKSB7XG4gICAgY29uc3QgeyBjb250cm9sbGVyLCB0b2tlbiwgdHlwZU9iamVjdCB9ID0gcGF5bG9hZDtcbiAgICBjb25zdCBoYXNUeXBlID0gaXNTb21ldGhpbmcodHlwZU9iamVjdC50eXBlKTtcbiAgICBjb25zdCBoYXNEZWZhdWx0ID0gaXNTb21ldGhpbmcodHlwZU9iamVjdC5kZWZhdWx0KTtcbiAgICBjb25zdCBmdWxsT2JqZWN0ID0gaGFzVHlwZSAmJiBoYXNEZWZhdWx0O1xuICAgIGNvbnN0IG9ubHlUeXBlID0gaGFzVHlwZSAmJiAhaGFzRGVmYXVsdDtcbiAgICBjb25zdCBvbmx5RGVmYXVsdCA9ICFoYXNUeXBlICYmIGhhc0RlZmF1bHQ7XG4gICAgY29uc3QgdHlwZUZyb21PYmplY3QgPSBwYXJzZVZhbHVlVHlwZUNvbnN0YW50KHR5cGVPYmplY3QudHlwZSk7XG4gICAgY29uc3QgdHlwZUZyb21EZWZhdWx0VmFsdWUgPSBwYXJzZVZhbHVlVHlwZURlZmF1bHQocGF5bG9hZC50eXBlT2JqZWN0LmRlZmF1bHQpO1xuICAgIGlmIChvbmx5VHlwZSlcbiAgICAgICAgcmV0dXJuIHR5cGVGcm9tT2JqZWN0O1xuICAgIGlmIChvbmx5RGVmYXVsdClcbiAgICAgICAgcmV0dXJuIHR5cGVGcm9tRGVmYXVsdFZhbHVlO1xuICAgIGlmICh0eXBlRnJvbU9iamVjdCAhPT0gdHlwZUZyb21EZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgY29uc3QgcHJvcGVydHlQYXRoID0gY29udHJvbGxlciA/IGAke2NvbnRyb2xsZXJ9LiR7dG9rZW59YCA6IHRva2VuO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBzcGVjaWZpZWQgZGVmYXVsdCB2YWx1ZSBmb3IgdGhlIFN0aW11bHVzIFZhbHVlIFwiJHtwcm9wZXJ0eVBhdGh9XCIgbXVzdCBtYXRjaCB0aGUgZGVmaW5lZCB0eXBlIFwiJHt0eXBlRnJvbU9iamVjdH1cIi4gVGhlIHByb3ZpZGVkIGRlZmF1bHQgdmFsdWUgb2YgXCIke3R5cGVPYmplY3QuZGVmYXVsdH1cIiBpcyBvZiB0eXBlIFwiJHt0eXBlRnJvbURlZmF1bHRWYWx1ZX1cIi5gKTtcbiAgICB9XG4gICAgaWYgKGZ1bGxPYmplY3QpXG4gICAgICAgIHJldHVybiB0eXBlRnJvbU9iamVjdDtcbn1cbmZ1bmN0aW9uIHBhcnNlVmFsdWVUeXBlRGVmaW5pdGlvbihwYXlsb2FkKSB7XG4gICAgY29uc3QgeyBjb250cm9sbGVyLCB0b2tlbiwgdHlwZURlZmluaXRpb24gfSA9IHBheWxvYWQ7XG4gICAgY29uc3QgdHlwZU9iamVjdCA9IHsgY29udHJvbGxlciwgdG9rZW4sIHR5cGVPYmplY3Q6IHR5cGVEZWZpbml0aW9uIH07XG4gICAgY29uc3QgdHlwZUZyb21PYmplY3QgPSBwYXJzZVZhbHVlVHlwZU9iamVjdCh0eXBlT2JqZWN0KTtcbiAgICBjb25zdCB0eXBlRnJvbURlZmF1bHRWYWx1ZSA9IHBhcnNlVmFsdWVUeXBlRGVmYXVsdCh0eXBlRGVmaW5pdGlvbik7XG4gICAgY29uc3QgdHlwZUZyb21Db25zdGFudCA9IHBhcnNlVmFsdWVUeXBlQ29uc3RhbnQodHlwZURlZmluaXRpb24pO1xuICAgIGNvbnN0IHR5cGUgPSB0eXBlRnJvbU9iamVjdCB8fCB0eXBlRnJvbURlZmF1bHRWYWx1ZSB8fCB0eXBlRnJvbUNvbnN0YW50O1xuICAgIGlmICh0eXBlKVxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICBjb25zdCBwcm9wZXJ0eVBhdGggPSBjb250cm9sbGVyID8gYCR7Y29udHJvbGxlcn0uJHt0eXBlRGVmaW5pdGlvbn1gIDogdG9rZW47XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHZhbHVlIHR5cGUgXCIke3Byb3BlcnR5UGF0aH1cIiBmb3IgXCIke3Rva2VufVwiIHZhbHVlYCk7XG59XG5mdW5jdGlvbiBkZWZhdWx0VmFsdWVGb3JEZWZpbml0aW9uKHR5cGVEZWZpbml0aW9uKSB7XG4gICAgY29uc3QgY29uc3RhbnQgPSBwYXJzZVZhbHVlVHlwZUNvbnN0YW50KHR5cGVEZWZpbml0aW9uKTtcbiAgICBpZiAoY29uc3RhbnQpXG4gICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWVzQnlUeXBlW2NvbnN0YW50XTtcbiAgICBjb25zdCBoYXNEZWZhdWx0ID0gaGFzUHJvcGVydHkodHlwZURlZmluaXRpb24sIFwiZGVmYXVsdFwiKTtcbiAgICBjb25zdCBoYXNUeXBlID0gaGFzUHJvcGVydHkodHlwZURlZmluaXRpb24sIFwidHlwZVwiKTtcbiAgICBjb25zdCB0eXBlT2JqZWN0ID0gdHlwZURlZmluaXRpb247XG4gICAgaWYgKGhhc0RlZmF1bHQpXG4gICAgICAgIHJldHVybiB0eXBlT2JqZWN0LmRlZmF1bHQ7XG4gICAgaWYgKGhhc1R5cGUpIHtcbiAgICAgICAgY29uc3QgeyB0eXBlIH0gPSB0eXBlT2JqZWN0O1xuICAgICAgICBjb25zdCBjb25zdGFudEZyb21UeXBlID0gcGFyc2VWYWx1ZVR5cGVDb25zdGFudCh0eXBlKTtcbiAgICAgICAgaWYgKGNvbnN0YW50RnJvbVR5cGUpXG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlc0J5VHlwZVtjb25zdGFudEZyb21UeXBlXTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVEZWZpbml0aW9uO1xufVxuZnVuY3Rpb24gdmFsdWVEZXNjcmlwdG9yRm9yVG9rZW5BbmRUeXBlRGVmaW5pdGlvbihwYXlsb2FkKSB7XG4gICAgY29uc3QgeyB0b2tlbiwgdHlwZURlZmluaXRpb24gfSA9IHBheWxvYWQ7XG4gICAgY29uc3Qga2V5ID0gYCR7ZGFzaGVyaXplKHRva2VuKX0tdmFsdWVgO1xuICAgIGNvbnN0IHR5cGUgPSBwYXJzZVZhbHVlVHlwZURlZmluaXRpb24ocGF5bG9hZCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAga2V5LFxuICAgICAgICBuYW1lOiBjYW1lbGl6ZShrZXkpLFxuICAgICAgICBnZXQgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZUZvckRlZmluaXRpb24odHlwZURlZmluaXRpb24pO1xuICAgICAgICB9LFxuICAgICAgICBnZXQgaGFzQ3VzdG9tRGVmYXVsdFZhbHVlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlVmFsdWVUeXBlRGVmYXVsdCh0eXBlRGVmaW5pdGlvbikgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgfSxcbiAgICAgICAgcmVhZGVyOiByZWFkZXJzW3R5cGVdLFxuICAgICAgICB3cml0ZXI6IHdyaXRlcnNbdHlwZV0gfHwgd3JpdGVycy5kZWZhdWx0LFxuICAgIH07XG59XG5jb25zdCBkZWZhdWx0VmFsdWVzQnlUeXBlID0ge1xuICAgIGdldCBhcnJheSgpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH0sXG4gICAgYm9vbGVhbjogZmFsc2UsXG4gICAgbnVtYmVyOiAwLFxuICAgIGdldCBvYmplY3QoKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9LFxuICAgIHN0cmluZzogXCJcIixcbn07XG5jb25zdCByZWFkZXJzID0ge1xuICAgIGFycmF5KHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGFycmF5ID0gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGV4cGVjdGVkIHZhbHVlIG9mIHR5cGUgXCJhcnJheVwiIGJ1dCBpbnN0ZWFkIGdvdCB2YWx1ZSBcIiR7dmFsdWV9XCIgb2YgdHlwZSBcIiR7cGFyc2VWYWx1ZVR5cGVEZWZhdWx0KGFycmF5KX1cImApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcnJheTtcbiAgICB9LFxuICAgIGJvb2xlYW4odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICEodmFsdWUgPT0gXCIwXCIgfHwgU3RyaW5nKHZhbHVlKS50b0xvd2VyQ2FzZSgpID09IFwiZmFsc2VcIik7XG4gICAgfSxcbiAgICBudW1iZXIodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZS5yZXBsYWNlKC9fL2csIFwiXCIpKTtcbiAgICB9LFxuICAgIG9iamVjdCh2YWx1ZSkge1xuICAgICAgICBjb25zdCBvYmplY3QgPSBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICAgICAgaWYgKG9iamVjdCA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqZWN0ICE9IFwib2JqZWN0XCIgfHwgQXJyYXkuaXNBcnJheShvYmplY3QpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBleHBlY3RlZCB2YWx1ZSBvZiB0eXBlIFwib2JqZWN0XCIgYnV0IGluc3RlYWQgZ290IHZhbHVlIFwiJHt2YWx1ZX1cIiBvZiB0eXBlIFwiJHtwYXJzZVZhbHVlVHlwZURlZmF1bHQob2JqZWN0KX1cImApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfSxcbiAgICBzdHJpbmcodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG59O1xuY29uc3Qgd3JpdGVycyA9IHtcbiAgICBkZWZhdWx0OiB3cml0ZVN0cmluZyxcbiAgICBhcnJheTogd3JpdGVKU09OLFxuICAgIG9iamVjdDogd3JpdGVKU09OLFxufTtcbmZ1bmN0aW9uIHdyaXRlSlNPTih2YWx1ZSkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG59XG5mdW5jdGlvbiB3cml0ZVN0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiBgJHt2YWx1ZX1gO1xufVxuXG5jbGFzcyBDb250cm9sbGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgc2hvdWxkTG9hZCgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHN0YXRpYyBhZnRlckxvYWQoX2lkZW50aWZpZXIsIF9hcHBsaWNhdGlvbikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGdldCBhcHBsaWNhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5hcHBsaWNhdGlvbjtcbiAgICB9XG4gICAgZ2V0IHNjb3BlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0LnNjb3BlO1xuICAgIH1cbiAgICBnZXQgZWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NvcGUuZWxlbWVudDtcbiAgICB9XG4gICAgZ2V0IGlkZW50aWZpZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjb3BlLmlkZW50aWZpZXI7XG4gICAgfVxuICAgIGdldCB0YXJnZXRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY29wZS50YXJnZXRzO1xuICAgIH1cbiAgICBnZXQgb3V0bGV0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NvcGUub3V0bGV0cztcbiAgICB9XG4gICAgZ2V0IGNsYXNzZXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjb3BlLmNsYXNzZXM7XG4gICAgfVxuICAgIGdldCBkYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY29wZS5kYXRhO1xuICAgIH1cbiAgICBpbml0aWFsaXplKCkge1xuICAgIH1cbiAgICBjb25uZWN0KCkge1xuICAgIH1cbiAgICBkaXNjb25uZWN0KCkge1xuICAgIH1cbiAgICBkaXNwYXRjaChldmVudE5hbWUsIHsgdGFyZ2V0ID0gdGhpcy5lbGVtZW50LCBkZXRhaWwgPSB7fSwgcHJlZml4ID0gdGhpcy5pZGVudGlmaWVyLCBidWJibGVzID0gdHJ1ZSwgY2FuY2VsYWJsZSA9IHRydWUsIH0gPSB7fSkge1xuICAgICAgICBjb25zdCB0eXBlID0gcHJlZml4ID8gYCR7cHJlZml4fToke2V2ZW50TmFtZX1gIDogZXZlbnROYW1lO1xuICAgICAgICBjb25zdCBldmVudCA9IG5ldyBDdXN0b21FdmVudCh0eXBlLCB7IGRldGFpbCwgYnViYmxlcywgY2FuY2VsYWJsZSB9KTtcbiAgICAgICAgdGFyZ2V0LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICByZXR1cm4gZXZlbnQ7XG4gICAgfVxufVxuQ29udHJvbGxlci5ibGVzc2luZ3MgPSBbXG4gICAgQ2xhc3NQcm9wZXJ0aWVzQmxlc3NpbmcsXG4gICAgVGFyZ2V0UHJvcGVydGllc0JsZXNzaW5nLFxuICAgIFZhbHVlUHJvcGVydGllc0JsZXNzaW5nLFxuICAgIE91dGxldFByb3BlcnRpZXNCbGVzc2luZyxcbl07XG5Db250cm9sbGVyLnRhcmdldHMgPSBbXTtcbkNvbnRyb2xsZXIub3V0bGV0cyA9IFtdO1xuQ29udHJvbGxlci52YWx1ZXMgPSB7fTtcblxuZXhwb3J0IHsgQXBwbGljYXRpb24sIEF0dHJpYnV0ZU9ic2VydmVyLCBDb250ZXh0LCBDb250cm9sbGVyLCBFbGVtZW50T2JzZXJ2ZXIsIEluZGV4ZWRNdWx0aW1hcCwgTXVsdGltYXAsIFNlbGVjdG9yT2JzZXJ2ZXIsIFN0cmluZ01hcE9ic2VydmVyLCBUb2tlbkxpc3RPYnNlcnZlciwgVmFsdWVMaXN0T2JzZXJ2ZXIsIGFkZCwgZGVmYXVsdFNjaGVtYSwgZGVsLCBmZXRjaCwgcHJ1bmUgfTtcbiIsIi8qIVxuVHVyYm8gOC4wLjEzXG5Db3B5cmlnaHQgwqkgMjAyNSAzN3NpZ25hbHMgTExDXG4gKi9cbi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE5IEphdmFuIE1ha2htYWxpXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4oZnVuY3Rpb24gKHByb3RvdHlwZSkge1xuICBpZiAodHlwZW9mIHByb3RvdHlwZS5yZXF1ZXN0U3VibWl0ID09IFwiZnVuY3Rpb25cIikgcmV0dXJuXG5cbiAgcHJvdG90eXBlLnJlcXVlc3RTdWJtaXQgPSBmdW5jdGlvbiAoc3VibWl0dGVyKSB7XG4gICAgaWYgKHN1Ym1pdHRlcikge1xuICAgICAgdmFsaWRhdGVTdWJtaXR0ZXIoc3VibWl0dGVyLCB0aGlzKTtcbiAgICAgIHN1Ym1pdHRlci5jbGljaygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdWJtaXR0ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgICBzdWJtaXR0ZXIudHlwZSA9IFwic3VibWl0XCI7XG4gICAgICBzdWJtaXR0ZXIuaGlkZGVuID0gdHJ1ZTtcbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoc3VibWl0dGVyKTtcbiAgICAgIHN1Ym1pdHRlci5jbGljaygpO1xuICAgICAgdGhpcy5yZW1vdmVDaGlsZChzdWJtaXR0ZXIpO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiB2YWxpZGF0ZVN1Ym1pdHRlcihzdWJtaXR0ZXIsIGZvcm0pIHtcbiAgICBzdWJtaXR0ZXIgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCB8fCByYWlzZShUeXBlRXJyb3IsIFwicGFyYW1ldGVyIDEgaXMgbm90IG9mIHR5cGUgJ0hUTUxFbGVtZW50J1wiKTtcbiAgICBzdWJtaXR0ZXIudHlwZSA9PSBcInN1Ym1pdFwiIHx8IHJhaXNlKFR5cGVFcnJvciwgXCJUaGUgc3BlY2lmaWVkIGVsZW1lbnQgaXMgbm90IGEgc3VibWl0IGJ1dHRvblwiKTtcbiAgICBzdWJtaXR0ZXIuZm9ybSA9PSBmb3JtIHx8XG4gICAgICByYWlzZShET01FeGNlcHRpb24sIFwiVGhlIHNwZWNpZmllZCBlbGVtZW50IGlzIG5vdCBvd25lZCBieSB0aGlzIGZvcm0gZWxlbWVudFwiLCBcIk5vdEZvdW5kRXJyb3JcIik7XG4gIH1cblxuICBmdW5jdGlvbiByYWlzZShlcnJvckNvbnN0cnVjdG9yLCBtZXNzYWdlLCBuYW1lKSB7XG4gICAgdGhyb3cgbmV3IGVycm9yQ29uc3RydWN0b3IoXCJGYWlsZWQgdG8gZXhlY3V0ZSAncmVxdWVzdFN1Ym1pdCcgb24gJ0hUTUxGb3JtRWxlbWVudCc6IFwiICsgbWVzc2FnZSArIFwiLlwiLCBuYW1lKVxuICB9XG59KShIVE1MRm9ybUVsZW1lbnQucHJvdG90eXBlKTtcblxuY29uc3Qgc3VibWl0dGVyc0J5Rm9ybSA9IG5ldyBXZWFrTWFwKCk7XG5cbmZ1bmN0aW9uIGZpbmRTdWJtaXR0ZXJGcm9tQ2xpY2tUYXJnZXQodGFyZ2V0KSB7XG4gIGNvbnN0IGVsZW1lbnQgPSB0YXJnZXQgaW5zdGFuY2VvZiBFbGVtZW50ID8gdGFyZ2V0IDogdGFyZ2V0IGluc3RhbmNlb2YgTm9kZSA/IHRhcmdldC5wYXJlbnRFbGVtZW50IDogbnVsbDtcbiAgY29uc3QgY2FuZGlkYXRlID0gZWxlbWVudCA/IGVsZW1lbnQuY2xvc2VzdChcImlucHV0LCBidXR0b25cIikgOiBudWxsO1xuICByZXR1cm4gY2FuZGlkYXRlPy50eXBlID09IFwic3VibWl0XCIgPyBjYW5kaWRhdGUgOiBudWxsXG59XG5cbmZ1bmN0aW9uIGNsaWNrQ2FwdHVyZWQoZXZlbnQpIHtcbiAgY29uc3Qgc3VibWl0dGVyID0gZmluZFN1Ym1pdHRlckZyb21DbGlja1RhcmdldChldmVudC50YXJnZXQpO1xuXG4gIGlmIChzdWJtaXR0ZXIgJiYgc3VibWl0dGVyLmZvcm0pIHtcbiAgICBzdWJtaXR0ZXJzQnlGb3JtLnNldChzdWJtaXR0ZXIuZm9ybSwgc3VibWl0dGVyKTtcbiAgfVxufVxuXG4oZnVuY3Rpb24gKCkge1xuICBpZiAoXCJzdWJtaXR0ZXJcIiBpbiBFdmVudC5wcm90b3R5cGUpIHJldHVyblxuXG4gIGxldCBwcm90b3R5cGUgPSB3aW5kb3cuRXZlbnQucHJvdG90eXBlO1xuICAvLyBDZXJ0YWluIHZlcnNpb25zIG9mIFNhZmFyaSAxNSBoYXZlIGEgYnVnIHdoZXJlIHRoZXkgd29uJ3RcbiAgLy8gcG9wdWxhdGUgdGhlIHN1Ym1pdHRlci4gVGhpcyBodXJ0cyBUdXJib0RyaXZlJ3MgZW5hYmxlL2Rpc2FibGUgZGV0ZWN0aW9uLlxuICAvLyBTZWUgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTIyOTY2MFxuICBpZiAoXCJTdWJtaXRFdmVudFwiIGluIHdpbmRvdykge1xuICAgIGNvbnN0IHByb3RvdHlwZU9mU3VibWl0RXZlbnQgPSB3aW5kb3cuU3VibWl0RXZlbnQucHJvdG90eXBlO1xuXG4gICAgaWYgKC9BcHBsZSBDb21wdXRlci8udGVzdChuYXZpZ2F0b3IudmVuZG9yKSAmJiAhKFwic3VibWl0dGVyXCIgaW4gcHJvdG90eXBlT2ZTdWJtaXRFdmVudCkpIHtcbiAgICAgIHByb3RvdHlwZSA9IHByb3RvdHlwZU9mU3VibWl0RXZlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAvLyBwb2x5ZmlsbCBub3QgbmVlZGVkXG4gICAgfVxuICB9XG5cbiAgYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGNsaWNrQ2FwdHVyZWQsIHRydWUpO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90b3R5cGUsIFwic3VibWl0dGVyXCIsIHtcbiAgICBnZXQoKSB7XG4gICAgICBpZiAodGhpcy50eXBlID09IFwic3VibWl0XCIgJiYgdGhpcy50YXJnZXQgaW5zdGFuY2VvZiBIVE1MRm9ybUVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHN1Ym1pdHRlcnNCeUZvcm0uZ2V0KHRoaXMudGFyZ2V0KVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG59KSgpO1xuXG5jb25zdCBGcmFtZUxvYWRpbmdTdHlsZSA9IHtcbiAgZWFnZXI6IFwiZWFnZXJcIixcbiAgbGF6eTogXCJsYXp5XCJcbn07XG5cbi8qKlxuICogQ29udGFpbnMgYSBmcmFnbWVudCBvZiBIVE1MIHdoaWNoIGlzIHVwZGF0ZWQgYmFzZWQgb24gbmF2aWdhdGlvbiB3aXRoaW5cbiAqIGl0IChlLmcuIHZpYSBsaW5rcyBvciBmb3JtIHN1Ym1pc3Npb25zKS5cbiAqXG4gKiBAY3VzdG9tRWxlbWVudCB0dXJiby1mcmFtZVxuICogQGV4YW1wbGVcbiAqICAgPHR1cmJvLWZyYW1lIGlkPVwibWVzc2FnZXNcIj5cbiAqICAgICA8YSBocmVmPVwiL21lc3NhZ2VzL2V4cGFuZGVkXCI+XG4gKiAgICAgICBTaG93IGFsbCBleHBhbmRlZCBtZXNzYWdlcyBpbiB0aGlzIGZyYW1lLlxuICogICAgIDwvYT5cbiAqXG4gKiAgICAgPGZvcm0gYWN0aW9uPVwiL21lc3NhZ2VzXCI+XG4gKiAgICAgICBTaG93IHJlc3BvbnNlIGZyb20gdGhpcyBmb3JtIHdpdGhpbiB0aGlzIGZyYW1lLlxuICogICAgIDwvZm9ybT5cbiAqICAgPC90dXJiby1mcmFtZT5cbiAqL1xuY2xhc3MgRnJhbWVFbGVtZW50IGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICBzdGF0aWMgZGVsZWdhdGVDb25zdHJ1Y3RvciA9IHVuZGVmaW5lZFxuXG4gIGxvYWRlZCA9IFByb21pc2UucmVzb2x2ZSgpXG5cbiAgc3RhdGljIGdldCBvYnNlcnZlZEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIFtcImRpc2FibGVkXCIsIFwibG9hZGluZ1wiLCBcInNyY1wiXVxuICB9XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmRlbGVnYXRlID0gbmV3IEZyYW1lRWxlbWVudC5kZWxlZ2F0ZUNvbnN0cnVjdG9yKHRoaXMpO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5kZWxlZ2F0ZS5jb25uZWN0KCk7XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICB0aGlzLmRlbGVnYXRlLmRpc2Nvbm5lY3QoKTtcbiAgfVxuXG4gIHJlbG9hZCgpIHtcbiAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZS5zb3VyY2VVUkxSZWxvYWRlZCgpXG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSkge1xuICAgIGlmIChuYW1lID09IFwibG9hZGluZ1wiKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlLmxvYWRpbmdTdHlsZUNoYW5nZWQoKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT0gXCJzcmNcIikge1xuICAgICAgdGhpcy5kZWxlZ2F0ZS5zb3VyY2VVUkxDaGFuZ2VkKCk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09IFwiZGlzYWJsZWRcIikge1xuICAgICAgdGhpcy5kZWxlZ2F0ZS5kaXNhYmxlZENoYW5nZWQoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgVVJMIHRvIGxhemlseSBsb2FkIHNvdXJjZSBIVE1MIGZyb21cbiAgICovXG4gIGdldCBzcmMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKFwic3JjXCIpXG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgVVJMIHRvIGxhemlseSBsb2FkIHNvdXJjZSBIVE1MIGZyb21cbiAgICovXG4gIHNldCBzcmModmFsdWUpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKFwic3JjXCIsIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoXCJzcmNcIik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHJlZnJlc2ggbW9kZSBmb3IgdGhlIGZyYW1lLlxuICAgKi9cbiAgZ2V0IHJlZnJlc2goKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKFwicmVmcmVzaFwiKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHJlZnJlc2ggbW9kZSBmb3IgdGhlIGZyYW1lLlxuICAgKi9cbiAgc2V0IHJlZnJlc2godmFsdWUpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMuc2V0QXR0cmlidXRlKFwicmVmcmVzaFwiLCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKFwicmVmcmVzaFwiKTtcbiAgICB9XG4gIH1cblxuICBnZXQgc2hvdWxkUmVsb2FkV2l0aE1vcnBoKCkge1xuICAgIHJldHVybiB0aGlzLnNyYyAmJiB0aGlzLnJlZnJlc2ggPT09IFwibW9ycGhcIlxuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgaWYgdGhlIGVsZW1lbnQgaXMgbG9hZGluZ1xuICAgKi9cbiAgZ2V0IGxvYWRpbmcoKSB7XG4gICAgcmV0dXJuIGZyYW1lTG9hZGluZ1N0eWxlRnJvbVN0cmluZyh0aGlzLmdldEF0dHJpYnV0ZShcImxvYWRpbmdcIikgfHwgXCJcIilcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB2YWx1ZSBvZiBpZiB0aGUgZWxlbWVudCBpcyBsb2FkaW5nXG4gICAqL1xuICBzZXQgbG9hZGluZyh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJsb2FkaW5nXCIsIHZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoXCJsb2FkaW5nXCIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBkaXNhYmxlZCBzdGF0ZSBvZiB0aGUgZnJhbWUuXG4gICAqXG4gICAqIElmIGRpc2FibGVkLCBubyByZXF1ZXN0cyB3aWxsIGJlIGludGVyY2VwdGVkIGJ5IHRoZSBmcmFtZS5cbiAgICovXG4gIGdldCBkaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5oYXNBdHRyaWJ1dGUoXCJkaXNhYmxlZFwiKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGRpc2FibGVkIHN0YXRlIG9mIHRoZSBmcmFtZS5cbiAgICpcbiAgICogSWYgZGlzYWJsZWQsIG5vIHJlcXVlc3RzIHdpbGwgYmUgaW50ZXJjZXB0ZWQgYnkgdGhlIGZyYW1lLlxuICAgKi9cbiAgc2V0IGRpc2FibGVkKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLnNldEF0dHJpYnV0ZShcImRpc2FibGVkXCIsIFwiXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZShcImRpc2FibGVkXCIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBhdXRvc2Nyb2xsIHN0YXRlIG9mIHRoZSBmcmFtZS5cbiAgICpcbiAgICogSWYgdHJ1ZSwgdGhlIGZyYW1lIHdpbGwgYmUgc2Nyb2xsZWQgaW50byB2aWV3IGF1dG9tYXRpY2FsbHkgb24gdXBkYXRlLlxuICAgKi9cbiAgZ2V0IGF1dG9zY3JvbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzQXR0cmlidXRlKFwiYXV0b3Njcm9sbFwiKVxuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGF1dG9zY3JvbGwgc3RhdGUgb2YgdGhlIGZyYW1lLlxuICAgKlxuICAgKiBJZiB0cnVlLCB0aGUgZnJhbWUgd2lsbCBiZSBzY3JvbGxlZCBpbnRvIHZpZXcgYXV0b21hdGljYWxseSBvbiB1cGRhdGUuXG4gICAqL1xuICBzZXQgYXV0b3Njcm9sbCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoXCJhdXRvc2Nyb2xsXCIsIFwiXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZShcImF1dG9zY3JvbGxcIik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERldGVybWluZXMgaWYgdGhlIGVsZW1lbnQgaGFzIGZpbmlzaGVkIGxvYWRpbmdcbiAgICovXG4gIGdldCBjb21wbGV0ZSgpIHtcbiAgICByZXR1cm4gIXRoaXMuZGVsZWdhdGUuaXNMb2FkaW5nXG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgYWN0aXZlIHN0YXRlIG9mIHRoZSBmcmFtZS5cbiAgICpcbiAgICogSWYgaW5hY3RpdmUsIHNvdXJjZSBjaGFuZ2VzIHdpbGwgbm90IGJlIG9ic2VydmVkLlxuICAgKi9cbiAgZ2V0IGlzQWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLm93bmVyRG9jdW1lbnQgPT09IGRvY3VtZW50ICYmICF0aGlzLmlzUHJldmlld1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGFjdGl2ZSBzdGF0ZSBvZiB0aGUgZnJhbWUuXG4gICAqXG4gICAqIElmIGluYWN0aXZlLCBzb3VyY2UgY2hhbmdlcyB3aWxsIG5vdCBiZSBvYnNlcnZlZC5cbiAgICovXG4gIGdldCBpc1ByZXZpZXcoKSB7XG4gICAgcmV0dXJuIHRoaXMub3duZXJEb2N1bWVudD8uZG9jdW1lbnRFbGVtZW50Py5oYXNBdHRyaWJ1dGUoXCJkYXRhLXR1cmJvLXByZXZpZXdcIilcbiAgfVxufVxuXG5mdW5jdGlvbiBmcmFtZUxvYWRpbmdTdHlsZUZyb21TdHJpbmcoc3R5bGUpIHtcbiAgc3dpdGNoIChzdHlsZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSBcImxhenlcIjpcbiAgICAgIHJldHVybiBGcmFtZUxvYWRpbmdTdHlsZS5sYXp5XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBGcmFtZUxvYWRpbmdTdHlsZS5lYWdlclxuICB9XG59XG5cbmNvbnN0IGRyaXZlID0ge1xuICBlbmFibGVkOiB0cnVlLFxuICBwcm9ncmVzc0JhckRlbGF5OiA1MDAsXG4gIHVudmlzaXRhYmxlRXh0ZW5zaW9uczogbmV3IFNldChcbiAgICBbXG4gICAgICBcIi43elwiLCBcIi5hYWNcIiwgXCIuYXBrXCIsIFwiLmF2aVwiLCBcIi5ibXBcIiwgXCIuYnoyXCIsIFwiLmNzc1wiLCBcIi5jc3ZcIiwgXCIuZGViXCIsIFwiLmRtZ1wiLCBcIi5kb2NcIixcbiAgICAgIFwiLmRvY3hcIiwgXCIuZXhlXCIsIFwiLmdpZlwiLCBcIi5nelwiLCBcIi5oZWljXCIsIFwiLmhlaWZcIiwgXCIuaWNvXCIsIFwiLmlzb1wiLCBcIi5qcGVnXCIsIFwiLmpwZ1wiLFxuICAgICAgXCIuanNcIiwgXCIuanNvblwiLCBcIi5tNGFcIiwgXCIubWt2XCIsIFwiLm1vdlwiLCBcIi5tcDNcIiwgXCIubXA0XCIsIFwiLm1wZWdcIiwgXCIubXBnXCIsIFwiLm1zaVwiLFxuICAgICAgXCIub2dnXCIsIFwiLm9ndlwiLCBcIi5wZGZcIiwgXCIucGtnXCIsIFwiLnBuZ1wiLCBcIi5wcHRcIiwgXCIucHB0eFwiLCBcIi5yYXJcIiwgXCIucnRmXCIsXG4gICAgICBcIi5zdmdcIiwgXCIudGFyXCIsIFwiLnRpZlwiLCBcIi50aWZmXCIsIFwiLnR4dFwiLCBcIi53YXZcIiwgXCIud2VibVwiLCBcIi53ZWJwXCIsIFwiLndtYVwiLCBcIi53bXZcIixcbiAgICAgIFwiLnhsc1wiLCBcIi54bHN4XCIsIFwiLnhtbFwiLCBcIi56aXBcIlxuICAgIF1cbiAgKVxufTtcblxuZnVuY3Rpb24gYWN0aXZhdGVTY3JpcHRFbGVtZW50KGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS10dXJiby1ldmFsXCIpID09IFwiZmFsc2VcIikge1xuICAgIHJldHVybiBlbGVtZW50XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgY3JlYXRlZFNjcmlwdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgIGNvbnN0IGNzcE5vbmNlID0gZ2V0Q3NwTm9uY2UoKTtcbiAgICBpZiAoY3NwTm9uY2UpIHtcbiAgICAgIGNyZWF0ZWRTY3JpcHRFbGVtZW50Lm5vbmNlID0gY3NwTm9uY2U7XG4gICAgfVxuICAgIGNyZWF0ZWRTY3JpcHRFbGVtZW50LnRleHRDb250ZW50ID0gZWxlbWVudC50ZXh0Q29udGVudDtcbiAgICBjcmVhdGVkU2NyaXB0RWxlbWVudC5hc3luYyA9IGZhbHNlO1xuICAgIGNvcHlFbGVtZW50QXR0cmlidXRlcyhjcmVhdGVkU2NyaXB0RWxlbWVudCwgZWxlbWVudCk7XG4gICAgcmV0dXJuIGNyZWF0ZWRTY3JpcHRFbGVtZW50XG4gIH1cbn1cblxuZnVuY3Rpb24gY29weUVsZW1lbnRBdHRyaWJ1dGVzKGRlc3RpbmF0aW9uRWxlbWVudCwgc291cmNlRWxlbWVudCkge1xuICBmb3IgKGNvbnN0IHsgbmFtZSwgdmFsdWUgfSBvZiBzb3VyY2VFbGVtZW50LmF0dHJpYnV0ZXMpIHtcbiAgICBkZXN0aW5hdGlvbkVsZW1lbnQuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVEb2N1bWVudEZyYWdtZW50KGh0bWwpIHtcbiAgY29uc3QgdGVtcGxhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGVtcGxhdGVcIik7XG4gIHRlbXBsYXRlLmlubmVySFRNTCA9IGh0bWw7XG4gIHJldHVybiB0ZW1wbGF0ZS5jb250ZW50XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoKGV2ZW50TmFtZSwgeyB0YXJnZXQsIGNhbmNlbGFibGUsIGRldGFpbCB9ID0ge30pIHtcbiAgY29uc3QgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoZXZlbnROYW1lLCB7XG4gICAgY2FuY2VsYWJsZSxcbiAgICBidWJibGVzOiB0cnVlLFxuICAgIGNvbXBvc2VkOiB0cnVlLFxuICAgIGRldGFpbFxuICB9KTtcblxuICBpZiAodGFyZ2V0ICYmIHRhcmdldC5pc0Nvbm5lY3RlZCkge1xuICAgIHRhcmdldC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgfSBlbHNlIHtcbiAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gIH1cblxuICByZXR1cm4gZXZlbnRcbn1cblxuZnVuY3Rpb24gY2FuY2VsRXZlbnQoZXZlbnQpIHtcbiAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG59XG5cbmZ1bmN0aW9uIG5leHRSZXBhaW50KCkge1xuICBpZiAoZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSBcImhpZGRlblwiKSB7XG4gICAgcmV0dXJuIG5leHRFdmVudExvb3BUaWNrKClcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV4dEFuaW1hdGlvbkZyYW1lKClcbiAgfVxufVxuXG5mdW5jdGlvbiBuZXh0QW5pbWF0aW9uRnJhbWUoKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHJlc29sdmUoKSkpXG59XG5cbmZ1bmN0aW9uIG5leHRFdmVudExvb3BUaWNrKCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQoKCkgPT4gcmVzb2x2ZSgpLCAwKSlcbn1cblxuZnVuY3Rpb24gbmV4dE1pY3JvdGFzaygpIHtcbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpXG59XG5cbmZ1bmN0aW9uIHBhcnNlSFRNTERvY3VtZW50KGh0bWwgPSBcIlwiKSB7XG4gIHJldHVybiBuZXcgRE9NUGFyc2VyKCkucGFyc2VGcm9tU3RyaW5nKGh0bWwsIFwidGV4dC9odG1sXCIpXG59XG5cbmZ1bmN0aW9uIHVuaW5kZW50KHN0cmluZ3MsIC4uLnZhbHVlcykge1xuICBjb25zdCBsaW5lcyA9IGludGVycG9sYXRlKHN0cmluZ3MsIHZhbHVlcykucmVwbGFjZSgvXlxcbi8sIFwiXCIpLnNwbGl0KFwiXFxuXCIpO1xuICBjb25zdCBtYXRjaCA9IGxpbmVzWzBdLm1hdGNoKC9eXFxzKy8pO1xuICBjb25zdCBpbmRlbnQgPSBtYXRjaCA/IG1hdGNoWzBdLmxlbmd0aCA6IDA7XG4gIHJldHVybiBsaW5lcy5tYXAoKGxpbmUpID0+IGxpbmUuc2xpY2UoaW5kZW50KSkuam9pbihcIlxcblwiKVxufVxuXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZShzdHJpbmdzLCB2YWx1ZXMpIHtcbiAgcmV0dXJuIHN0cmluZ3MucmVkdWNlKChyZXN1bHQsIHN0cmluZywgaSkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW2ldID09IHVuZGVmaW5lZCA/IFwiXCIgOiB2YWx1ZXNbaV07XG4gICAgcmV0dXJuIHJlc3VsdCArIHN0cmluZyArIHZhbHVlXG4gIH0sIFwiXCIpXG59XG5cbmZ1bmN0aW9uIHV1aWQoKSB7XG4gIHJldHVybiBBcnJheS5mcm9tKHsgbGVuZ3RoOiAzNiB9KVxuICAgIC5tYXAoKF8sIGkpID0+IHtcbiAgICAgIGlmIChpID09IDggfHwgaSA9PSAxMyB8fCBpID09IDE4IHx8IGkgPT0gMjMpIHtcbiAgICAgICAgcmV0dXJuIFwiLVwiXG4gICAgICB9IGVsc2UgaWYgKGkgPT0gMTQpIHtcbiAgICAgICAgcmV0dXJuIFwiNFwiXG4gICAgICB9IGVsc2UgaWYgKGkgPT0gMTkpIHtcbiAgICAgICAgcmV0dXJuIChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA0KSArIDgpLnRvU3RyaW5nKDE2KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDE1KS50b1N0cmluZygxNilcbiAgICAgIH1cbiAgICB9KVxuICAgIC5qb2luKFwiXCIpXG59XG5cbmZ1bmN0aW9uIGdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCAuLi5lbGVtZW50cykge1xuICBmb3IgKGNvbnN0IHZhbHVlIG9mIGVsZW1lbnRzLm1hcCgoZWxlbWVudCkgPT4gZWxlbWVudD8uZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpKSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gXCJzdHJpbmdcIikgcmV0dXJuIHZhbHVlXG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuXG5mdW5jdGlvbiBoYXNBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSwgLi4uZWxlbWVudHMpIHtcbiAgcmV0dXJuIGVsZW1lbnRzLnNvbWUoKGVsZW1lbnQpID0+IGVsZW1lbnQgJiYgZWxlbWVudC5oYXNBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSkpXG59XG5cbmZ1bmN0aW9uIG1hcmtBc0J1c3koLi4uZWxlbWVudHMpIHtcbiAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgaWYgKGVsZW1lbnQubG9jYWxOYW1lID09IFwidHVyYm8tZnJhbWVcIikge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJidXN5XCIsIFwiXCIpO1xuICAgIH1cbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtYnVzeVwiLCBcInRydWVcIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2xlYXJCdXN5U3RhdGUoLi4uZWxlbWVudHMpIHtcbiAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgaWYgKGVsZW1lbnQubG9jYWxOYW1lID09IFwidHVyYm8tZnJhbWVcIikge1xuICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJidXN5XCIpO1xuICAgIH1cblxuICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwiYXJpYS1idXN5XCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdhaXRGb3JMb2FkKGVsZW1lbnQsIHRpbWVvdXRJbk1pbGxpc2Vjb25kcyA9IDIwMDApIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgY29uc3Qgb25Db21wbGV0ZSA9ICgpID0+IHtcbiAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIG9uQ29tcGxldGUpO1xuICAgICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibG9hZFwiLCBvbkNvbXBsZXRlKTtcbiAgICAgIHJlc29sdmUoKTtcbiAgICB9O1xuXG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibG9hZFwiLCBvbkNvbXBsZXRlLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgb25Db21wbGV0ZSwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgdGltZW91dEluTWlsbGlzZWNvbmRzKTtcbiAgfSlcbn1cblxuZnVuY3Rpb24gZ2V0SGlzdG9yeU1ldGhvZEZvckFjdGlvbihhY3Rpb24pIHtcbiAgc3dpdGNoIChhY3Rpb24pIHtcbiAgICBjYXNlIFwicmVwbGFjZVwiOlxuICAgICAgcmV0dXJuIGhpc3RvcnkucmVwbGFjZVN0YXRlXG4gICAgY2FzZSBcImFkdmFuY2VcIjpcbiAgICBjYXNlIFwicmVzdG9yZVwiOlxuICAgICAgcmV0dXJuIGhpc3RvcnkucHVzaFN0YXRlXG4gIH1cbn1cblxuZnVuY3Rpb24gaXNBY3Rpb24oYWN0aW9uKSB7XG4gIHJldHVybiBhY3Rpb24gPT0gXCJhZHZhbmNlXCIgfHwgYWN0aW9uID09IFwicmVwbGFjZVwiIHx8IGFjdGlvbiA9PSBcInJlc3RvcmVcIlxufVxuXG5mdW5jdGlvbiBnZXRWaXNpdEFjdGlvbiguLi5lbGVtZW50cykge1xuICBjb25zdCBhY3Rpb24gPSBnZXRBdHRyaWJ1dGUoXCJkYXRhLXR1cmJvLWFjdGlvblwiLCAuLi5lbGVtZW50cyk7XG5cbiAgcmV0dXJuIGlzQWN0aW9uKGFjdGlvbikgPyBhY3Rpb24gOiBudWxsXG59XG5cbmZ1bmN0aW9uIGdldE1ldGFFbGVtZW50KG5hbWUpIHtcbiAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYG1ldGFbbmFtZT1cIiR7bmFtZX1cIl1gKVxufVxuXG5mdW5jdGlvbiBnZXRNZXRhQ29udGVudChuYW1lKSB7XG4gIGNvbnN0IGVsZW1lbnQgPSBnZXRNZXRhRWxlbWVudChuYW1lKTtcbiAgcmV0dXJuIGVsZW1lbnQgJiYgZWxlbWVudC5jb250ZW50XG59XG5cbmZ1bmN0aW9uIGdldENzcE5vbmNlKCkge1xuICBjb25zdCBlbGVtZW50ID0gZ2V0TWV0YUVsZW1lbnQoXCJjc3Atbm9uY2VcIik7XG5cbiAgaWYgKGVsZW1lbnQpIHtcbiAgICBjb25zdCB7IG5vbmNlLCBjb250ZW50IH0gPSBlbGVtZW50O1xuICAgIHJldHVybiBub25jZSA9PSBcIlwiID8gY29udGVudCA6IG5vbmNlXG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0TWV0YUNvbnRlbnQobmFtZSwgY29udGVudCkge1xuICBsZXQgZWxlbWVudCA9IGdldE1ldGFFbGVtZW50KG5hbWUpO1xuXG4gIGlmICghZWxlbWVudCkge1xuICAgIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibWV0YVwiKTtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcIm5hbWVcIiwgbmFtZSk7XG5cbiAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICB9XG5cbiAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJjb250ZW50XCIsIGNvbnRlbnQpO1xuXG4gIHJldHVybiBlbGVtZW50XG59XG5cbmZ1bmN0aW9uIGZpbmRDbG9zZXN0UmVjdXJzaXZlbHkoZWxlbWVudCwgc2VsZWN0b3IpIHtcbiAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgcmV0dXJuIChcbiAgICAgIGVsZW1lbnQuY2xvc2VzdChzZWxlY3RvcikgfHwgZmluZENsb3Nlc3RSZWN1cnNpdmVseShlbGVtZW50LmFzc2lnbmVkU2xvdCB8fCBlbGVtZW50LmdldFJvb3ROb2RlKCk/Lmhvc3QsIHNlbGVjdG9yKVxuICAgIClcbiAgfVxufVxuXG5mdW5jdGlvbiBlbGVtZW50SXNGb2N1c2FibGUoZWxlbWVudCkge1xuICBjb25zdCBpbmVydERpc2FibGVkT3JIaWRkZW4gPSBcIltpbmVydF0sIDpkaXNhYmxlZCwgW2hpZGRlbl0sIGRldGFpbHM6bm90KFtvcGVuXSksIGRpYWxvZzpub3QoW29wZW5dKVwiO1xuXG4gIHJldHVybiAhIWVsZW1lbnQgJiYgZWxlbWVudC5jbG9zZXN0KGluZXJ0RGlzYWJsZWRPckhpZGRlbikgPT0gbnVsbCAmJiB0eXBlb2YgZWxlbWVudC5mb2N1cyA9PSBcImZ1bmN0aW9uXCJcbn1cblxuZnVuY3Rpb24gcXVlcnlBdXRvZm9jdXNhYmxlRWxlbWVudChlbGVtZW50T3JEb2N1bWVudEZyYWdtZW50KSB7XG4gIHJldHVybiBBcnJheS5mcm9tKGVsZW1lbnRPckRvY3VtZW50RnJhZ21lbnQucXVlcnlTZWxlY3RvckFsbChcIlthdXRvZm9jdXNdXCIpKS5maW5kKGVsZW1lbnRJc0ZvY3VzYWJsZSlcbn1cblxuYXN5bmMgZnVuY3Rpb24gYXJvdW5kKGNhbGxiYWNrLCByZWFkZXIpIHtcbiAgY29uc3QgYmVmb3JlID0gcmVhZGVyKCk7XG5cbiAgY2FsbGJhY2soKTtcblxuICBhd2FpdCBuZXh0QW5pbWF0aW9uRnJhbWUoKTtcblxuICBjb25zdCBhZnRlciA9IHJlYWRlcigpO1xuXG4gIHJldHVybiBbYmVmb3JlLCBhZnRlcl1cbn1cblxuZnVuY3Rpb24gZG9lc05vdFRhcmdldElGcmFtZShuYW1lKSB7XG4gIGlmIChuYW1lID09PSBcIl9ibGFua1wiKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH0gZWxzZSBpZiAobmFtZSkge1xuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZShuYW1lKSkge1xuICAgICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MSUZyYW1lRWxlbWVudCkgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRMaW5rRnJvbUNsaWNrVGFyZ2V0KHRhcmdldCkge1xuICByZXR1cm4gZmluZENsb3Nlc3RSZWN1cnNpdmVseSh0YXJnZXQsIFwiYVtocmVmXTpub3QoW3RhcmdldF49X10pOm5vdChbZG93bmxvYWRdKVwiKVxufVxuXG5mdW5jdGlvbiBnZXRMb2NhdGlvbkZvckxpbmsobGluaykge1xuICByZXR1cm4gZXhwYW5kVVJMKGxpbmsuZ2V0QXR0cmlidXRlKFwiaHJlZlwiKSB8fCBcIlwiKVxufVxuXG5mdW5jdGlvbiBkZWJvdW5jZShmbiwgZGVsYXkpIHtcbiAgbGV0IHRpbWVvdXRJZCA9IG51bGw7XG5cbiAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgY29uc3QgY2FsbGJhY2sgPSAoKSA9PiBmbi5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGNhbGxiYWNrLCBkZWxheSk7XG4gIH1cbn1cblxuY29uc3Qgc3VibWl0dGVyID0ge1xuICBcImFyaWEtZGlzYWJsZWRcIjoge1xuICAgIGJlZm9yZVN1Ym1pdDogc3VibWl0dGVyID0+IHtcbiAgICAgIHN1Ym1pdHRlci5zZXRBdHRyaWJ1dGUoXCJhcmlhLWRpc2FibGVkXCIsIFwidHJ1ZVwiKTtcbiAgICAgIHN1Ym1pdHRlci5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgY2FuY2VsRXZlbnQpO1xuICAgIH0sXG5cbiAgICBhZnRlclN1Ym1pdDogc3VibWl0dGVyID0+IHtcbiAgICAgIHN1Ym1pdHRlci5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWRpc2FibGVkXCIpO1xuICAgICAgc3VibWl0dGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBjYW5jZWxFdmVudCk7XG4gICAgfVxuICB9LFxuXG4gIFwiZGlzYWJsZWRcIjoge1xuICAgIGJlZm9yZVN1Ym1pdDogc3VibWl0dGVyID0+IHN1Ym1pdHRlci5kaXNhYmxlZCA9IHRydWUsXG4gICAgYWZ0ZXJTdWJtaXQ6IHN1Ym1pdHRlciA9PiBzdWJtaXR0ZXIuZGlzYWJsZWQgPSBmYWxzZVxuICB9XG59O1xuXG5jbGFzcyBDb25maWcge1xuICAjc3VibWl0dGVyID0gbnVsbFxuXG4gIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywgY29uZmlnKTtcbiAgfVxuXG4gIGdldCBzdWJtaXR0ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3N1Ym1pdHRlclxuICB9XG5cbiAgc2V0IHN1Ym1pdHRlcih2YWx1ZSkge1xuICAgIHRoaXMuI3N1Ym1pdHRlciA9IHN1Ym1pdHRlclt2YWx1ZV0gfHwgdmFsdWU7XG4gIH1cbn1cblxuY29uc3QgZm9ybXMgPSBuZXcgQ29uZmlnKHtcbiAgbW9kZTogXCJvblwiLFxuICBzdWJtaXR0ZXI6IFwiZGlzYWJsZWRcIlxufSk7XG5cbmNvbnN0IGNvbmZpZyA9IHtcbiAgZHJpdmUsXG4gIGZvcm1zXG59O1xuXG5mdW5jdGlvbiBleHBhbmRVUkwobG9jYXRhYmxlKSB7XG4gIHJldHVybiBuZXcgVVJMKGxvY2F0YWJsZS50b1N0cmluZygpLCBkb2N1bWVudC5iYXNlVVJJKVxufVxuXG5mdW5jdGlvbiBnZXRBbmNob3IodXJsKSB7XG4gIGxldCBhbmNob3JNYXRjaDtcbiAgaWYgKHVybC5oYXNoKSB7XG4gICAgcmV0dXJuIHVybC5oYXNoLnNsaWNlKDEpXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbmQtYXNzaWduXG4gIH0gZWxzZSBpZiAoKGFuY2hvck1hdGNoID0gdXJsLmhyZWYubWF0Y2goLyMoLiopJC8pKSkge1xuICAgIHJldHVybiBhbmNob3JNYXRjaFsxXVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldEFjdGlvbiQxKGZvcm0sIHN1Ym1pdHRlcikge1xuICBjb25zdCBhY3Rpb24gPSBzdWJtaXR0ZXI/LmdldEF0dHJpYnV0ZShcImZvcm1hY3Rpb25cIikgfHwgZm9ybS5nZXRBdHRyaWJ1dGUoXCJhY3Rpb25cIikgfHwgZm9ybS5hY3Rpb247XG5cbiAgcmV0dXJuIGV4cGFuZFVSTChhY3Rpb24pXG59XG5cbmZ1bmN0aW9uIGdldEV4dGVuc2lvbih1cmwpIHtcbiAgcmV0dXJuIChnZXRMYXN0UGF0aENvbXBvbmVudCh1cmwpLm1hdGNoKC9cXC5bXi5dKiQvKSB8fCBbXSlbMF0gfHwgXCJcIlxufVxuXG5mdW5jdGlvbiBpc1ByZWZpeGVkQnkoYmFzZVVSTCwgdXJsKSB7XG4gIGNvbnN0IHByZWZpeCA9IGdldFByZWZpeCh1cmwpO1xuICByZXR1cm4gYmFzZVVSTC5ocmVmID09PSBleHBhbmRVUkwocHJlZml4KS5ocmVmIHx8IGJhc2VVUkwuaHJlZi5zdGFydHNXaXRoKHByZWZpeClcbn1cblxuZnVuY3Rpb24gbG9jYXRpb25Jc1Zpc2l0YWJsZShsb2NhdGlvbiwgcm9vdExvY2F0aW9uKSB7XG4gIHJldHVybiBpc1ByZWZpeGVkQnkobG9jYXRpb24sIHJvb3RMb2NhdGlvbikgJiYgIWNvbmZpZy5kcml2ZS51bnZpc2l0YWJsZUV4dGVuc2lvbnMuaGFzKGdldEV4dGVuc2lvbihsb2NhdGlvbikpXG59XG5cbmZ1bmN0aW9uIGdldFJlcXVlc3RVUkwodXJsKSB7XG4gIGNvbnN0IGFuY2hvciA9IGdldEFuY2hvcih1cmwpO1xuICByZXR1cm4gYW5jaG9yICE9IG51bGwgPyB1cmwuaHJlZi5zbGljZSgwLCAtKGFuY2hvci5sZW5ndGggKyAxKSkgOiB1cmwuaHJlZlxufVxuXG5mdW5jdGlvbiB0b0NhY2hlS2V5KHVybCkge1xuICByZXR1cm4gZ2V0UmVxdWVzdFVSTCh1cmwpXG59XG5cbmZ1bmN0aW9uIHVybHNBcmVFcXVhbChsZWZ0LCByaWdodCkge1xuICByZXR1cm4gZXhwYW5kVVJMKGxlZnQpLmhyZWYgPT0gZXhwYW5kVVJMKHJpZ2h0KS5ocmVmXG59XG5cbmZ1bmN0aW9uIGdldFBhdGhDb21wb25lbnRzKHVybCkge1xuICByZXR1cm4gdXJsLnBhdGhuYW1lLnNwbGl0KFwiL1wiKS5zbGljZSgxKVxufVxuXG5mdW5jdGlvbiBnZXRMYXN0UGF0aENvbXBvbmVudCh1cmwpIHtcbiAgcmV0dXJuIGdldFBhdGhDb21wb25lbnRzKHVybCkuc2xpY2UoLTEpWzBdXG59XG5cbmZ1bmN0aW9uIGdldFByZWZpeCh1cmwpIHtcbiAgcmV0dXJuIGFkZFRyYWlsaW5nU2xhc2godXJsLm9yaWdpbiArIHVybC5wYXRobmFtZSlcbn1cblxuZnVuY3Rpb24gYWRkVHJhaWxpbmdTbGFzaCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUuZW5kc1dpdGgoXCIvXCIpID8gdmFsdWUgOiB2YWx1ZSArIFwiL1wiXG59XG5cbmNsYXNzIEZldGNoUmVzcG9uc2Uge1xuICBjb25zdHJ1Y3RvcihyZXNwb25zZSkge1xuICAgIHRoaXMucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgfVxuXG4gIGdldCBzdWNjZWVkZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzcG9uc2Uub2tcbiAgfVxuXG4gIGdldCBmYWlsZWQoKSB7XG4gICAgcmV0dXJuICF0aGlzLnN1Y2NlZWRlZFxuICB9XG5cbiAgZ2V0IGNsaWVudEVycm9yKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXR1c0NvZGUgPj0gNDAwICYmIHRoaXMuc3RhdHVzQ29kZSA8PSA0OTlcbiAgfVxuXG4gIGdldCBzZXJ2ZXJFcnJvcigpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0dXNDb2RlID49IDUwMCAmJiB0aGlzLnN0YXR1c0NvZGUgPD0gNTk5XG4gIH1cblxuICBnZXQgcmVkaXJlY3RlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNwb25zZS5yZWRpcmVjdGVkXG4gIH1cblxuICBnZXQgbG9jYXRpb24oKSB7XG4gICAgcmV0dXJuIGV4cGFuZFVSTCh0aGlzLnJlc3BvbnNlLnVybClcbiAgfVxuXG4gIGdldCBpc0hUTUwoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udGVudFR5cGUgJiYgdGhpcy5jb250ZW50VHlwZS5tYXRjaCgvXig/OnRleHRcXC8oW15cXHM7LF0rXFxiKT9odG1sfGFwcGxpY2F0aW9uXFwveGh0bWxcXCt4bWwpXFxiLylcbiAgfVxuXG4gIGdldCBzdGF0dXNDb2RlKCkge1xuICAgIHJldHVybiB0aGlzLnJlc3BvbnNlLnN0YXR1c1xuICB9XG5cbiAgZ2V0IGNvbnRlbnRUeXBlKCkge1xuICAgIHJldHVybiB0aGlzLmhlYWRlcihcIkNvbnRlbnQtVHlwZVwiKVxuICB9XG5cbiAgZ2V0IHJlc3BvbnNlVGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5yZXNwb25zZS5jbG9uZSgpLnRleHQoKVxuICB9XG5cbiAgZ2V0IHJlc3BvbnNlSFRNTCgpIHtcbiAgICBpZiAodGhpcy5pc0hUTUwpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlc3BvbnNlLmNsb25lKCkudGV4dCgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKVxuICAgIH1cbiAgfVxuXG4gIGhlYWRlcihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzcG9uc2UuaGVhZGVycy5nZXQobmFtZSlcbiAgfVxufVxuXG5jbGFzcyBMaW1pdGVkU2V0IGV4dGVuZHMgU2V0IHtcbiAgY29uc3RydWN0b3IobWF4U2l6ZSkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5tYXhTaXplID0gbWF4U2l6ZTtcbiAgfVxuXG4gIGFkZCh2YWx1ZSkge1xuICAgIGlmICh0aGlzLnNpemUgPj0gdGhpcy5tYXhTaXplKSB7XG4gICAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMudmFsdWVzKCk7XG4gICAgICBjb25zdCBvbGRlc3RWYWx1ZSA9IGl0ZXJhdG9yLm5leHQoKS52YWx1ZTtcbiAgICAgIHRoaXMuZGVsZXRlKG9sZGVzdFZhbHVlKTtcbiAgICB9XG4gICAgc3VwZXIuYWRkKHZhbHVlKTtcbiAgfVxufVxuXG5jb25zdCByZWNlbnRSZXF1ZXN0cyA9IG5ldyBMaW1pdGVkU2V0KDIwKTtcblxuY29uc3QgbmF0aXZlRmV0Y2ggPSB3aW5kb3cuZmV0Y2g7XG5cbmZ1bmN0aW9uIGZldGNoV2l0aFR1cmJvSGVhZGVycyh1cmwsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBtb2RpZmllZEhlYWRlcnMgPSBuZXcgSGVhZGVycyhvcHRpb25zLmhlYWRlcnMgfHwge30pO1xuICBjb25zdCByZXF1ZXN0VUlEID0gdXVpZCgpO1xuICByZWNlbnRSZXF1ZXN0cy5hZGQocmVxdWVzdFVJRCk7XG4gIG1vZGlmaWVkSGVhZGVycy5hcHBlbmQoXCJYLVR1cmJvLVJlcXVlc3QtSWRcIiwgcmVxdWVzdFVJRCk7XG5cbiAgcmV0dXJuIG5hdGl2ZUZldGNoKHVybCwge1xuICAgIC4uLm9wdGlvbnMsXG4gICAgaGVhZGVyczogbW9kaWZpZWRIZWFkZXJzXG4gIH0pXG59XG5cbmZ1bmN0aW9uIGZldGNoTWV0aG9kRnJvbVN0cmluZyhtZXRob2QpIHtcbiAgc3dpdGNoIChtZXRob2QudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgXCJnZXRcIjpcbiAgICAgIHJldHVybiBGZXRjaE1ldGhvZC5nZXRcbiAgICBjYXNlIFwicG9zdFwiOlxuICAgICAgcmV0dXJuIEZldGNoTWV0aG9kLnBvc3RcbiAgICBjYXNlIFwicHV0XCI6XG4gICAgICByZXR1cm4gRmV0Y2hNZXRob2QucHV0XG4gICAgY2FzZSBcInBhdGNoXCI6XG4gICAgICByZXR1cm4gRmV0Y2hNZXRob2QucGF0Y2hcbiAgICBjYXNlIFwiZGVsZXRlXCI6XG4gICAgICByZXR1cm4gRmV0Y2hNZXRob2QuZGVsZXRlXG4gIH1cbn1cblxuY29uc3QgRmV0Y2hNZXRob2QgPSB7XG4gIGdldDogXCJnZXRcIixcbiAgcG9zdDogXCJwb3N0XCIsXG4gIHB1dDogXCJwdXRcIixcbiAgcGF0Y2g6IFwicGF0Y2hcIixcbiAgZGVsZXRlOiBcImRlbGV0ZVwiXG59O1xuXG5mdW5jdGlvbiBmZXRjaEVuY3R5cGVGcm9tU3RyaW5nKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgRmV0Y2hFbmN0eXBlLm11bHRpcGFydDpcbiAgICAgIHJldHVybiBGZXRjaEVuY3R5cGUubXVsdGlwYXJ0XG4gICAgY2FzZSBGZXRjaEVuY3R5cGUucGxhaW46XG4gICAgICByZXR1cm4gRmV0Y2hFbmN0eXBlLnBsYWluXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBGZXRjaEVuY3R5cGUudXJsRW5jb2RlZFxuICB9XG59XG5cbmNvbnN0IEZldGNoRW5jdHlwZSA9IHtcbiAgdXJsRW5jb2RlZDogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIixcbiAgbXVsdGlwYXJ0OiBcIm11bHRpcGFydC9mb3JtLWRhdGFcIixcbiAgcGxhaW46IFwidGV4dC9wbGFpblwiXG59O1xuXG5jbGFzcyBGZXRjaFJlcXVlc3Qge1xuICBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKClcbiAgI3Jlc29sdmVSZXF1ZXN0UHJvbWlzZSA9IChfdmFsdWUpID0+IHt9XG5cbiAgY29uc3RydWN0b3IoZGVsZWdhdGUsIG1ldGhvZCwgbG9jYXRpb24sIHJlcXVlc3RCb2R5ID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpLCB0YXJnZXQgPSBudWxsLCBlbmN0eXBlID0gRmV0Y2hFbmN0eXBlLnVybEVuY29kZWQpIHtcbiAgICBjb25zdCBbdXJsLCBib2R5XSA9IGJ1aWxkUmVzb3VyY2VBbmRCb2R5KGV4cGFuZFVSTChsb2NhdGlvbiksIG1ldGhvZCwgcmVxdWVzdEJvZHksIGVuY3R5cGUpO1xuXG4gICAgdGhpcy5kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xuICAgIHRoaXMudXJsID0gdXJsO1xuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgIHRoaXMuZmV0Y2hPcHRpb25zID0ge1xuICAgICAgY3JlZGVudGlhbHM6IFwic2FtZS1vcmlnaW5cIixcbiAgICAgIHJlZGlyZWN0OiBcImZvbGxvd1wiLFxuICAgICAgbWV0aG9kOiBtZXRob2QudG9VcHBlckNhc2UoKSxcbiAgICAgIGhlYWRlcnM6IHsgLi4udGhpcy5kZWZhdWx0SGVhZGVycyB9LFxuICAgICAgYm9keTogYm9keSxcbiAgICAgIHNpZ25hbDogdGhpcy5hYm9ydFNpZ25hbCxcbiAgICAgIHJlZmVycmVyOiB0aGlzLmRlbGVnYXRlLnJlZmVycmVyPy5ocmVmXG4gICAgfTtcbiAgICB0aGlzLmVuY3R5cGUgPSBlbmN0eXBlO1xuICB9XG5cbiAgZ2V0IG1ldGhvZCgpIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaE9wdGlvbnMubWV0aG9kXG4gIH1cblxuICBzZXQgbWV0aG9kKHZhbHVlKSB7XG4gICAgY29uc3QgZmV0Y2hCb2R5ID0gdGhpcy5pc1NhZmUgPyB0aGlzLnVybC5zZWFyY2hQYXJhbXMgOiB0aGlzLmZldGNoT3B0aW9ucy5ib2R5IHx8IG5ldyBGb3JtRGF0YSgpO1xuICAgIGNvbnN0IGZldGNoTWV0aG9kID0gZmV0Y2hNZXRob2RGcm9tU3RyaW5nKHZhbHVlKSB8fCBGZXRjaE1ldGhvZC5nZXQ7XG5cbiAgICB0aGlzLnVybC5zZWFyY2ggPSBcIlwiO1xuXG4gICAgY29uc3QgW3VybCwgYm9keV0gPSBidWlsZFJlc291cmNlQW5kQm9keSh0aGlzLnVybCwgZmV0Y2hNZXRob2QsIGZldGNoQm9keSwgdGhpcy5lbmN0eXBlKTtcblxuICAgIHRoaXMudXJsID0gdXJsO1xuICAgIHRoaXMuZmV0Y2hPcHRpb25zLmJvZHkgPSBib2R5O1xuICAgIHRoaXMuZmV0Y2hPcHRpb25zLm1ldGhvZCA9IGZldGNoTWV0aG9kLnRvVXBwZXJDYXNlKCk7XG4gIH1cblxuICBnZXQgaGVhZGVycygpIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaE9wdGlvbnMuaGVhZGVyc1xuICB9XG5cbiAgc2V0IGhlYWRlcnModmFsdWUpIHtcbiAgICB0aGlzLmZldGNoT3B0aW9ucy5oZWFkZXJzID0gdmFsdWU7XG4gIH1cblxuICBnZXQgYm9keSgpIHtcbiAgICBpZiAodGhpcy5pc1NhZmUpIHtcbiAgICAgIHJldHVybiB0aGlzLnVybC5zZWFyY2hQYXJhbXNcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuZmV0Y2hPcHRpb25zLmJvZHlcbiAgICB9XG4gIH1cblxuICBzZXQgYm9keSh2YWx1ZSkge1xuICAgIHRoaXMuZmV0Y2hPcHRpb25zLmJvZHkgPSB2YWx1ZTtcbiAgfVxuXG4gIGdldCBsb2NhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy51cmxcbiAgfVxuXG4gIGdldCBwYXJhbXMoKSB7XG4gICAgcmV0dXJuIHRoaXMudXJsLnNlYXJjaFBhcmFtc1xuICB9XG5cbiAgZ2V0IGVudHJpZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYm9keSA/IEFycmF5LmZyb20odGhpcy5ib2R5LmVudHJpZXMoKSkgOiBbXVxuICB9XG5cbiAgY2FuY2VsKCkge1xuICAgIHRoaXMuYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gIH1cblxuICBhc3luYyBwZXJmb3JtKCkge1xuICAgIGNvbnN0IHsgZmV0Y2hPcHRpb25zIH0gPSB0aGlzO1xuICAgIHRoaXMuZGVsZWdhdGUucHJlcGFyZVJlcXVlc3QodGhpcyk7XG4gICAgY29uc3QgZXZlbnQgPSBhd2FpdCB0aGlzLiNhbGxvd1JlcXVlc3RUb0JlSW50ZXJjZXB0ZWQoZmV0Y2hPcHRpb25zKTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5kZWxlZ2F0ZS5yZXF1ZXN0U3RhcnRlZCh0aGlzKTtcblxuICAgICAgaWYgKGV2ZW50LmRldGFpbC5mZXRjaFJlcXVlc3QpIHtcbiAgICAgICAgdGhpcy5yZXNwb25zZSA9IGV2ZW50LmRldGFpbC5mZXRjaFJlcXVlc3QucmVzcG9uc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnJlc3BvbnNlID0gZmV0Y2hXaXRoVHVyYm9IZWFkZXJzKHRoaXMudXJsLmhyZWYsIGZldGNoT3B0aW9ucyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5yZXNwb25zZTtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLnJlY2VpdmUocmVzcG9uc2UpXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvci5uYW1lICE9PSBcIkFib3J0RXJyb3JcIikge1xuICAgICAgICBpZiAodGhpcy4jd2lsbERlbGVnYXRlRXJyb3JIYW5kbGluZyhlcnJvcikpIHtcbiAgICAgICAgICB0aGlzLmRlbGVnYXRlLnJlcXVlc3RFcnJvcmVkKHRoaXMsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvclxuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmRlbGVnYXRlLnJlcXVlc3RGaW5pc2hlZCh0aGlzKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyByZWNlaXZlKHJlc3BvbnNlKSB7XG4gICAgY29uc3QgZmV0Y2hSZXNwb25zZSA9IG5ldyBGZXRjaFJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICBjb25zdCBldmVudCA9IGRpc3BhdGNoKFwidHVyYm86YmVmb3JlLWZldGNoLXJlc3BvbnNlXCIsIHtcbiAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICBkZXRhaWw6IHsgZmV0Y2hSZXNwb25zZSB9LFxuICAgICAgdGFyZ2V0OiB0aGlzLnRhcmdldFxuICAgIH0pO1xuICAgIGlmIChldmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlLnJlcXVlc3RQcmV2ZW50ZWRIYW5kbGluZ1Jlc3BvbnNlKHRoaXMsIGZldGNoUmVzcG9uc2UpO1xuICAgIH0gZWxzZSBpZiAoZmV0Y2hSZXNwb25zZS5zdWNjZWVkZWQpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUucmVxdWVzdFN1Y2NlZWRlZFdpdGhSZXNwb25zZSh0aGlzLCBmZXRjaFJlc3BvbnNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5kZWxlZ2F0ZS5yZXF1ZXN0RmFpbGVkV2l0aFJlc3BvbnNlKHRoaXMsIGZldGNoUmVzcG9uc2UpO1xuICAgIH1cbiAgICByZXR1cm4gZmV0Y2hSZXNwb25zZVxuICB9XG5cbiAgZ2V0IGRlZmF1bHRIZWFkZXJzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBBY2NlcHQ6IFwidGV4dC9odG1sLCBhcHBsaWNhdGlvbi94aHRtbCt4bWxcIlxuICAgIH1cbiAgfVxuXG4gIGdldCBpc1NhZmUoKSB7XG4gICAgcmV0dXJuIGlzU2FmZSh0aGlzLm1ldGhvZClcbiAgfVxuXG4gIGdldCBhYm9ydFNpZ25hbCgpIHtcbiAgICByZXR1cm4gdGhpcy5hYm9ydENvbnRyb2xsZXIuc2lnbmFsXG4gIH1cblxuICBhY2NlcHRSZXNwb25zZVR5cGUobWltZVR5cGUpIHtcbiAgICB0aGlzLmhlYWRlcnNbXCJBY2NlcHRcIl0gPSBbbWltZVR5cGUsIHRoaXMuaGVhZGVyc1tcIkFjY2VwdFwiXV0uam9pbihcIiwgXCIpO1xuICB9XG5cbiAgYXN5bmMgI2FsbG93UmVxdWVzdFRvQmVJbnRlcmNlcHRlZChmZXRjaE9wdGlvbnMpIHtcbiAgICBjb25zdCByZXF1ZXN0SW50ZXJjZXB0aW9uID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+ICh0aGlzLiNyZXNvbHZlUmVxdWVzdFByb21pc2UgPSByZXNvbHZlKSk7XG4gICAgY29uc3QgZXZlbnQgPSBkaXNwYXRjaChcInR1cmJvOmJlZm9yZS1mZXRjaC1yZXF1ZXN0XCIsIHtcbiAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICBkZXRhaWw6IHtcbiAgICAgICAgZmV0Y2hPcHRpb25zLFxuICAgICAgICB1cmw6IHRoaXMudXJsLFxuICAgICAgICByZXN1bWU6IHRoaXMuI3Jlc29sdmVSZXF1ZXN0UHJvbWlzZVxuICAgICAgfSxcbiAgICAgIHRhcmdldDogdGhpcy50YXJnZXRcbiAgICB9KTtcbiAgICB0aGlzLnVybCA9IGV2ZW50LmRldGFpbC51cmw7XG4gICAgaWYgKGV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIGF3YWl0IHJlcXVlc3RJbnRlcmNlcHRpb247XG5cbiAgICByZXR1cm4gZXZlbnRcbiAgfVxuXG4gICN3aWxsRGVsZWdhdGVFcnJvckhhbmRsaW5nKGVycm9yKSB7XG4gICAgY29uc3QgZXZlbnQgPSBkaXNwYXRjaChcInR1cmJvOmZldGNoLXJlcXVlc3QtZXJyb3JcIiwge1xuICAgICAgdGFyZ2V0OiB0aGlzLnRhcmdldCxcbiAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICBkZXRhaWw6IHsgcmVxdWVzdDogdGhpcywgZXJyb3I6IGVycm9yIH1cbiAgICB9KTtcblxuICAgIHJldHVybiAhZXZlbnQuZGVmYXVsdFByZXZlbnRlZFxuICB9XG59XG5cbmZ1bmN0aW9uIGlzU2FmZShmZXRjaE1ldGhvZCkge1xuICByZXR1cm4gZmV0Y2hNZXRob2RGcm9tU3RyaW5nKGZldGNoTWV0aG9kKSA9PSBGZXRjaE1ldGhvZC5nZXRcbn1cblxuZnVuY3Rpb24gYnVpbGRSZXNvdXJjZUFuZEJvZHkocmVzb3VyY2UsIG1ldGhvZCwgcmVxdWVzdEJvZHksIGVuY3R5cGUpIHtcbiAgY29uc3Qgc2VhcmNoUGFyYW1zID1cbiAgICBBcnJheS5mcm9tKHJlcXVlc3RCb2R5KS5sZW5ndGggPiAwID8gbmV3IFVSTFNlYXJjaFBhcmFtcyhlbnRyaWVzRXhjbHVkaW5nRmlsZXMocmVxdWVzdEJvZHkpKSA6IHJlc291cmNlLnNlYXJjaFBhcmFtcztcblxuICBpZiAoaXNTYWZlKG1ldGhvZCkpIHtcbiAgICByZXR1cm4gW21lcmdlSW50b1VSTFNlYXJjaFBhcmFtcyhyZXNvdXJjZSwgc2VhcmNoUGFyYW1zKSwgbnVsbF1cbiAgfSBlbHNlIGlmIChlbmN0eXBlID09IEZldGNoRW5jdHlwZS51cmxFbmNvZGVkKSB7XG4gICAgcmV0dXJuIFtyZXNvdXJjZSwgc2VhcmNoUGFyYW1zXVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBbcmVzb3VyY2UsIHJlcXVlc3RCb2R5XVxuICB9XG59XG5cbmZ1bmN0aW9uIGVudHJpZXNFeGNsdWRpbmdGaWxlcyhyZXF1ZXN0Qm9keSkge1xuICBjb25zdCBlbnRyaWVzID0gW107XG5cbiAgZm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIHJlcXVlc3RCb2R5KSB7XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRmlsZSkgY29udGludWVcbiAgICBlbHNlIGVudHJpZXMucHVzaChbbmFtZSwgdmFsdWVdKTtcbiAgfVxuXG4gIHJldHVybiBlbnRyaWVzXG59XG5cbmZ1bmN0aW9uIG1lcmdlSW50b1VSTFNlYXJjaFBhcmFtcyh1cmwsIHJlcXVlc3RCb2R5KSB7XG4gIGNvbnN0IHNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoZW50cmllc0V4Y2x1ZGluZ0ZpbGVzKHJlcXVlc3RCb2R5KSk7XG5cbiAgdXJsLnNlYXJjaCA9IHNlYXJjaFBhcmFtcy50b1N0cmluZygpO1xuXG4gIHJldHVybiB1cmxcbn1cblxuY2xhc3MgQXBwZWFyYW5jZU9ic2VydmVyIHtcbiAgc3RhcnRlZCA9IGZhbHNlXG5cbiAgY29uc3RydWN0b3IoZGVsZWdhdGUsIGVsZW1lbnQpIHtcbiAgICB0aGlzLmRlbGVnYXRlID0gZGVsZWdhdGU7XG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLmludGVyc2VjdGlvbk9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKHRoaXMuaW50ZXJzZWN0KTtcbiAgfVxuXG4gIHN0YXJ0KCkge1xuICAgIGlmICghdGhpcy5zdGFydGVkKSB7XG4gICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgdGhpcy5pbnRlcnNlY3Rpb25PYnNlcnZlci5vYnNlcnZlKHRoaXMuZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgc3RvcCgpIHtcbiAgICBpZiAodGhpcy5zdGFydGVkKSB7XG4gICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuaW50ZXJzZWN0aW9uT2JzZXJ2ZXIudW5vYnNlcnZlKHRoaXMuZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgaW50ZXJzZWN0ID0gKGVudHJpZXMpID0+IHtcbiAgICBjb25zdCBsYXN0RW50cnkgPSBlbnRyaWVzLnNsaWNlKC0xKVswXTtcbiAgICBpZiAobGFzdEVudHJ5Py5pc0ludGVyc2VjdGluZykge1xuICAgICAgdGhpcy5kZWxlZ2F0ZS5lbGVtZW50QXBwZWFyZWRJblZpZXdwb3J0KHRoaXMuZWxlbWVudCk7XG4gICAgfVxuICB9XG59XG5cbmNsYXNzIFN0cmVhbU1lc3NhZ2Uge1xuICBzdGF0aWMgY29udGVudFR5cGUgPSBcInRleHQvdm5kLnR1cmJvLXN0cmVhbS5odG1sXCJcblxuICBzdGF0aWMgd3JhcChtZXNzYWdlKSB7XG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlID09IFwic3RyaW5nXCIpIHtcbiAgICAgIHJldHVybiBuZXcgdGhpcyhjcmVhdGVEb2N1bWVudEZyYWdtZW50KG1lc3NhZ2UpKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbWVzc2FnZVxuICAgIH1cbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGZyYWdtZW50KSB7XG4gICAgdGhpcy5mcmFnbWVudCA9IGltcG9ydFN0cmVhbUVsZW1lbnRzKGZyYWdtZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbXBvcnRTdHJlYW1FbGVtZW50cyhmcmFnbWVudCkge1xuICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZnJhZ21lbnQucXVlcnlTZWxlY3RvckFsbChcInR1cmJvLXN0cmVhbVwiKSkge1xuICAgIGNvbnN0IHN0cmVhbUVsZW1lbnQgPSBkb2N1bWVudC5pbXBvcnROb2RlKGVsZW1lbnQsIHRydWUpO1xuXG4gICAgZm9yIChjb25zdCBpbmVydFNjcmlwdEVsZW1lbnQgb2Ygc3RyZWFtRWxlbWVudC50ZW1wbGF0ZUVsZW1lbnQuY29udGVudC5xdWVyeVNlbGVjdG9yQWxsKFwic2NyaXB0XCIpKSB7XG4gICAgICBpbmVydFNjcmlwdEVsZW1lbnQucmVwbGFjZVdpdGgoYWN0aXZhdGVTY3JpcHRFbGVtZW50KGluZXJ0U2NyaXB0RWxlbWVudCkpO1xuICAgIH1cblxuICAgIGVsZW1lbnQucmVwbGFjZVdpdGgoc3RyZWFtRWxlbWVudCk7XG4gIH1cblxuICByZXR1cm4gZnJhZ21lbnRcbn1cblxuY29uc3QgUFJFRkVUQ0hfREVMQVkgPSAxMDA7XG5cbmNsYXNzIFByZWZldGNoQ2FjaGUge1xuICAjcHJlZmV0Y2hUaW1lb3V0ID0gbnVsbFxuICAjcHJlZmV0Y2hlZCA9IG51bGxcblxuICBnZXQodXJsKSB7XG4gICAgaWYgKHRoaXMuI3ByZWZldGNoZWQgJiYgdGhpcy4jcHJlZmV0Y2hlZC51cmwgPT09IHVybCAmJiB0aGlzLiNwcmVmZXRjaGVkLmV4cGlyZSA+IERhdGUubm93KCkpIHtcbiAgICAgIHJldHVybiB0aGlzLiNwcmVmZXRjaGVkLnJlcXVlc3RcbiAgICB9XG4gIH1cblxuICBzZXRMYXRlcih1cmwsIHJlcXVlc3QsIHR0bCkge1xuICAgIHRoaXMuY2xlYXIoKTtcblxuICAgIHRoaXMuI3ByZWZldGNoVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgcmVxdWVzdC5wZXJmb3JtKCk7XG4gICAgICB0aGlzLnNldCh1cmwsIHJlcXVlc3QsIHR0bCk7XG4gICAgICB0aGlzLiNwcmVmZXRjaFRpbWVvdXQgPSBudWxsO1xuICAgIH0sIFBSRUZFVENIX0RFTEFZKTtcbiAgfVxuXG4gIHNldCh1cmwsIHJlcXVlc3QsIHR0bCkge1xuICAgIHRoaXMuI3ByZWZldGNoZWQgPSB7IHVybCwgcmVxdWVzdCwgZXhwaXJlOiBuZXcgRGF0ZShuZXcgRGF0ZSgpLmdldFRpbWUoKSArIHR0bCkgfTtcbiAgfVxuXG4gIGNsZWFyKCkge1xuICAgIGlmICh0aGlzLiNwcmVmZXRjaFRpbWVvdXQpIGNsZWFyVGltZW91dCh0aGlzLiNwcmVmZXRjaFRpbWVvdXQpO1xuICAgIHRoaXMuI3ByZWZldGNoZWQgPSBudWxsO1xuICB9XG59XG5cbmNvbnN0IGNhY2hlVHRsID0gMTAgKiAxMDAwO1xuY29uc3QgcHJlZmV0Y2hDYWNoZSA9IG5ldyBQcmVmZXRjaENhY2hlKCk7XG5cbmNvbnN0IEZvcm1TdWJtaXNzaW9uU3RhdGUgPSB7XG4gIGluaXRpYWxpemVkOiBcImluaXRpYWxpemVkXCIsXG4gIHJlcXVlc3Rpbmc6IFwicmVxdWVzdGluZ1wiLFxuICB3YWl0aW5nOiBcIndhaXRpbmdcIixcbiAgcmVjZWl2aW5nOiBcInJlY2VpdmluZ1wiLFxuICBzdG9wcGluZzogXCJzdG9wcGluZ1wiLFxuICBzdG9wcGVkOiBcInN0b3BwZWRcIlxufTtcblxuY2xhc3MgRm9ybVN1Ym1pc3Npb24ge1xuICBzdGF0ZSA9IEZvcm1TdWJtaXNzaW9uU3RhdGUuaW5pdGlhbGl6ZWRcblxuICBzdGF0aWMgY29uZmlybU1ldGhvZChtZXNzYWdlKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjb25maXJtKG1lc3NhZ2UpKVxuICB9XG5cbiAgY29uc3RydWN0b3IoZGVsZWdhdGUsIGZvcm1FbGVtZW50LCBzdWJtaXR0ZXIsIG11c3RSZWRpcmVjdCA9IGZhbHNlKSB7XG4gICAgY29uc3QgbWV0aG9kID0gZ2V0TWV0aG9kKGZvcm1FbGVtZW50LCBzdWJtaXR0ZXIpO1xuICAgIGNvbnN0IGFjdGlvbiA9IGdldEFjdGlvbihnZXRGb3JtQWN0aW9uKGZvcm1FbGVtZW50LCBzdWJtaXR0ZXIpLCBtZXRob2QpO1xuICAgIGNvbnN0IGJvZHkgPSBidWlsZEZvcm1EYXRhKGZvcm1FbGVtZW50LCBzdWJtaXR0ZXIpO1xuICAgIGNvbnN0IGVuY3R5cGUgPSBnZXRFbmN0eXBlKGZvcm1FbGVtZW50LCBzdWJtaXR0ZXIpO1xuXG4gICAgdGhpcy5kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xuICAgIHRoaXMuZm9ybUVsZW1lbnQgPSBmb3JtRWxlbWVudDtcbiAgICB0aGlzLnN1Ym1pdHRlciA9IHN1Ym1pdHRlcjtcbiAgICB0aGlzLmZldGNoUmVxdWVzdCA9IG5ldyBGZXRjaFJlcXVlc3QodGhpcywgbWV0aG9kLCBhY3Rpb24sIGJvZHksIGZvcm1FbGVtZW50LCBlbmN0eXBlKTtcbiAgICB0aGlzLm11c3RSZWRpcmVjdCA9IG11c3RSZWRpcmVjdDtcbiAgfVxuXG4gIGdldCBtZXRob2QoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hSZXF1ZXN0Lm1ldGhvZFxuICB9XG5cbiAgc2V0IG1ldGhvZCh2YWx1ZSkge1xuICAgIHRoaXMuZmV0Y2hSZXF1ZXN0Lm1ldGhvZCA9IHZhbHVlO1xuICB9XG5cbiAgZ2V0IGFjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaFJlcXVlc3QudXJsLnRvU3RyaW5nKClcbiAgfVxuXG4gIHNldCBhY3Rpb24odmFsdWUpIHtcbiAgICB0aGlzLmZldGNoUmVxdWVzdC51cmwgPSBleHBhbmRVUkwodmFsdWUpO1xuICB9XG5cbiAgZ2V0IGJvZHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hSZXF1ZXN0LmJvZHlcbiAgfVxuXG4gIGdldCBlbmN0eXBlKCkge1xuICAgIHJldHVybiB0aGlzLmZldGNoUmVxdWVzdC5lbmN0eXBlXG4gIH1cblxuICBnZXQgaXNTYWZlKCkge1xuICAgIHJldHVybiB0aGlzLmZldGNoUmVxdWVzdC5pc1NhZmVcbiAgfVxuXG4gIGdldCBsb2NhdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5mZXRjaFJlcXVlc3QudXJsXG4gIH1cblxuICAvLyBUaGUgc3VibWlzc2lvbiBwcm9jZXNzXG5cbiAgYXN5bmMgc3RhcnQoKSB7XG4gICAgY29uc3QgeyBpbml0aWFsaXplZCwgcmVxdWVzdGluZyB9ID0gRm9ybVN1Ym1pc3Npb25TdGF0ZTtcbiAgICBjb25zdCBjb25maXJtYXRpb25NZXNzYWdlID0gZ2V0QXR0cmlidXRlKFwiZGF0YS10dXJiby1jb25maXJtXCIsIHRoaXMuc3VibWl0dGVyLCB0aGlzLmZvcm1FbGVtZW50KTtcblxuICAgIGlmICh0eXBlb2YgY29uZmlybWF0aW9uTWVzc2FnZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgY29uc3QgY29uZmlybU1ldGhvZCA9IHR5cGVvZiBjb25maWcuZm9ybXMuY29uZmlybSA9PT0gXCJmdW5jdGlvblwiID9cbiAgICAgICAgY29uZmlnLmZvcm1zLmNvbmZpcm0gOlxuICAgICAgICBGb3JtU3VibWlzc2lvbi5jb25maXJtTWV0aG9kO1xuXG4gICAgICBjb25zdCBhbnN3ZXIgPSBhd2FpdCBjb25maXJtTWV0aG9kKGNvbmZpcm1hdGlvbk1lc3NhZ2UsIHRoaXMuZm9ybUVsZW1lbnQsIHRoaXMuc3VibWl0dGVyKTtcbiAgICAgIGlmICghYW5zd2VyKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLnN0YXRlID09IGluaXRpYWxpemVkKSB7XG4gICAgICB0aGlzLnN0YXRlID0gcmVxdWVzdGluZztcbiAgICAgIHJldHVybiB0aGlzLmZldGNoUmVxdWVzdC5wZXJmb3JtKClcbiAgICB9XG4gIH1cblxuICBzdG9wKCkge1xuICAgIGNvbnN0IHsgc3RvcHBpbmcsIHN0b3BwZWQgfSA9IEZvcm1TdWJtaXNzaW9uU3RhdGU7XG4gICAgaWYgKHRoaXMuc3RhdGUgIT0gc3RvcHBpbmcgJiYgdGhpcy5zdGF0ZSAhPSBzdG9wcGVkKSB7XG4gICAgICB0aGlzLnN0YXRlID0gc3RvcHBpbmc7XG4gICAgICB0aGlzLmZldGNoUmVxdWVzdC5jYW5jZWwoKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG5cbiAgLy8gRmV0Y2ggcmVxdWVzdCBkZWxlZ2F0ZVxuXG4gIHByZXBhcmVSZXF1ZXN0KHJlcXVlc3QpIHtcbiAgICBpZiAoIXJlcXVlc3QuaXNTYWZlKSB7XG4gICAgICBjb25zdCB0b2tlbiA9IGdldENvb2tpZVZhbHVlKGdldE1ldGFDb250ZW50KFwiY3NyZi1wYXJhbVwiKSkgfHwgZ2V0TWV0YUNvbnRlbnQoXCJjc3JmLXRva2VuXCIpO1xuICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgIHJlcXVlc3QuaGVhZGVyc1tcIlgtQ1NSRi1Ub2tlblwiXSA9IHRva2VuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLnJlcXVlc3RBY2NlcHRzVHVyYm9TdHJlYW1SZXNwb25zZShyZXF1ZXN0KSkge1xuICAgICAgcmVxdWVzdC5hY2NlcHRSZXNwb25zZVR5cGUoU3RyZWFtTWVzc2FnZS5jb250ZW50VHlwZSk7XG4gICAgfVxuICB9XG5cbiAgcmVxdWVzdFN0YXJ0ZWQoX3JlcXVlc3QpIHtcbiAgICB0aGlzLnN0YXRlID0gRm9ybVN1Ym1pc3Npb25TdGF0ZS53YWl0aW5nO1xuICAgIGlmICh0aGlzLnN1Ym1pdHRlcikgY29uZmlnLmZvcm1zLnN1Ym1pdHRlci5iZWZvcmVTdWJtaXQodGhpcy5zdWJtaXR0ZXIpO1xuICAgIHRoaXMuc2V0U3VibWl0c1dpdGgoKTtcbiAgICBtYXJrQXNCdXN5KHRoaXMuZm9ybUVsZW1lbnQpO1xuICAgIGRpc3BhdGNoKFwidHVyYm86c3VibWl0LXN0YXJ0XCIsIHtcbiAgICAgIHRhcmdldDogdGhpcy5mb3JtRWxlbWVudCxcbiAgICAgIGRldGFpbDogeyBmb3JtU3VibWlzc2lvbjogdGhpcyB9XG4gICAgfSk7XG4gICAgdGhpcy5kZWxlZ2F0ZS5mb3JtU3VibWlzc2lvblN0YXJ0ZWQodGhpcyk7XG4gIH1cblxuICByZXF1ZXN0UHJldmVudGVkSGFuZGxpbmdSZXNwb25zZShyZXF1ZXN0LCByZXNwb25zZSkge1xuICAgIHByZWZldGNoQ2FjaGUuY2xlYXIoKTtcblxuICAgIHRoaXMucmVzdWx0ID0geyBzdWNjZXNzOiByZXNwb25zZS5zdWNjZWVkZWQsIGZldGNoUmVzcG9uc2U6IHJlc3BvbnNlIH07XG4gIH1cblxuICByZXF1ZXN0U3VjY2VlZGVkV2l0aFJlc3BvbnNlKHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gICAgaWYgKHJlc3BvbnNlLmNsaWVudEVycm9yIHx8IHJlc3BvbnNlLnNlcnZlckVycm9yKSB7XG4gICAgICB0aGlzLmRlbGVnYXRlLmZvcm1TdWJtaXNzaW9uRmFpbGVkV2l0aFJlc3BvbnNlKHRoaXMsIHJlc3BvbnNlKTtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHByZWZldGNoQ2FjaGUuY2xlYXIoKTtcblxuICAgIGlmICh0aGlzLnJlcXVlc3RNdXN0UmVkaXJlY3QocmVxdWVzdCkgJiYgcmVzcG9uc2VTdWNjZWVkZWRXaXRob3V0UmVkaXJlY3QocmVzcG9uc2UpKSB7XG4gICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihcIkZvcm0gcmVzcG9uc2VzIG11c3QgcmVkaXJlY3QgdG8gYW5vdGhlciBsb2NhdGlvblwiKTtcbiAgICAgIHRoaXMuZGVsZWdhdGUuZm9ybVN1Ym1pc3Npb25FcnJvcmVkKHRoaXMsIGVycm9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGF0ZSA9IEZvcm1TdWJtaXNzaW9uU3RhdGUucmVjZWl2aW5nO1xuICAgICAgdGhpcy5yZXN1bHQgPSB7IHN1Y2Nlc3M6IHRydWUsIGZldGNoUmVzcG9uc2U6IHJlc3BvbnNlIH07XG4gICAgICB0aGlzLmRlbGVnYXRlLmZvcm1TdWJtaXNzaW9uU3VjY2VlZGVkV2l0aFJlc3BvbnNlKHRoaXMsIHJlc3BvbnNlKTtcbiAgICB9XG4gIH1cblxuICByZXF1ZXN0RmFpbGVkV2l0aFJlc3BvbnNlKHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gICAgdGhpcy5yZXN1bHQgPSB7IHN1Y2Nlc3M6IGZhbHNlLCBmZXRjaFJlc3BvbnNlOiByZXNwb25zZSB9O1xuICAgIHRoaXMuZGVsZWdhdGUuZm9ybVN1Ym1pc3Npb25GYWlsZWRXaXRoUmVzcG9uc2UodGhpcywgcmVzcG9uc2UpO1xuICB9XG5cbiAgcmVxdWVzdEVycm9yZWQocmVxdWVzdCwgZXJyb3IpIHtcbiAgICB0aGlzLnJlc3VsdCA9IHsgc3VjY2VzczogZmFsc2UsIGVycm9yIH07XG4gICAgdGhpcy5kZWxlZ2F0ZS5mb3JtU3VibWlzc2lvbkVycm9yZWQodGhpcywgZXJyb3IpO1xuICB9XG5cbiAgcmVxdWVzdEZpbmlzaGVkKF9yZXF1ZXN0KSB7XG4gICAgdGhpcy5zdGF0ZSA9IEZvcm1TdWJtaXNzaW9uU3RhdGUuc3RvcHBlZDtcbiAgICBpZiAodGhpcy5zdWJtaXR0ZXIpIGNvbmZpZy5mb3Jtcy5zdWJtaXR0ZXIuYWZ0ZXJTdWJtaXQodGhpcy5zdWJtaXR0ZXIpO1xuICAgIHRoaXMucmVzZXRTdWJtaXR0ZXJUZXh0KCk7XG4gICAgY2xlYXJCdXN5U3RhdGUodGhpcy5mb3JtRWxlbWVudCk7XG4gICAgZGlzcGF0Y2goXCJ0dXJibzpzdWJtaXQtZW5kXCIsIHtcbiAgICAgIHRhcmdldDogdGhpcy5mb3JtRWxlbWVudCxcbiAgICAgIGRldGFpbDogeyBmb3JtU3VibWlzc2lvbjogdGhpcywgLi4udGhpcy5yZXN1bHQgfVxuICAgIH0pO1xuICAgIHRoaXMuZGVsZWdhdGUuZm9ybVN1Ym1pc3Npb25GaW5pc2hlZCh0aGlzKTtcbiAgfVxuXG4gIC8vIFByaXZhdGVcblxuICBzZXRTdWJtaXRzV2l0aCgpIHtcbiAgICBpZiAoIXRoaXMuc3VibWl0dGVyIHx8ICF0aGlzLnN1Ym1pdHNXaXRoKSByZXR1cm5cblxuICAgIGlmICh0aGlzLnN1Ym1pdHRlci5tYXRjaGVzKFwiYnV0dG9uXCIpKSB7XG4gICAgICB0aGlzLm9yaWdpbmFsU3VibWl0VGV4dCA9IHRoaXMuc3VibWl0dGVyLmlubmVySFRNTDtcbiAgICAgIHRoaXMuc3VibWl0dGVyLmlubmVySFRNTCA9IHRoaXMuc3VibWl0c1dpdGg7XG4gICAgfSBlbHNlIGlmICh0aGlzLnN1Ym1pdHRlci5tYXRjaGVzKFwiaW5wdXRcIikpIHtcbiAgICAgIGNvbnN0IGlucHV0ID0gdGhpcy5zdWJtaXR0ZXI7XG4gICAgICB0aGlzLm9yaWdpbmFsU3VibWl0VGV4dCA9IGlucHV0LnZhbHVlO1xuICAgICAgaW5wdXQudmFsdWUgPSB0aGlzLnN1Ym1pdHNXaXRoO1xuICAgIH1cbiAgfVxuXG4gIHJlc2V0U3VibWl0dGVyVGV4dCgpIHtcbiAgICBpZiAoIXRoaXMuc3VibWl0dGVyIHx8ICF0aGlzLm9yaWdpbmFsU3VibWl0VGV4dCkgcmV0dXJuXG5cbiAgICBpZiAodGhpcy5zdWJtaXR0ZXIubWF0Y2hlcyhcImJ1dHRvblwiKSkge1xuICAgICAgdGhpcy5zdWJtaXR0ZXIuaW5uZXJIVE1MID0gdGhpcy5vcmlnaW5hbFN1Ym1pdFRleHQ7XG4gICAgfSBlbHNlIGlmICh0aGlzLnN1Ym1pdHRlci5tYXRjaGVzKFwiaW5wdXRcIikpIHtcbiAgICAgIGNvbnN0IGlucHV0ID0gdGhpcy5zdWJtaXR0ZXI7XG4gICAgICBpbnB1dC52YWx1ZSA9IHRoaXMub3JpZ2luYWxTdWJtaXRUZXh0O1xuICAgIH1cbiAgfVxuXG4gIHJlcXVlc3RNdXN0UmVkaXJlY3QocmVxdWVzdCkge1xuICAgIHJldHVybiAhcmVxdWVzdC5pc1NhZmUgJiYgdGhpcy5tdXN0UmVkaXJlY3RcbiAgfVxuXG4gIHJlcXVlc3RBY2NlcHRzVHVyYm9TdHJlYW1SZXNwb25zZShyZXF1ZXN0KSB7XG4gICAgcmV0dXJuICFyZXF1ZXN0LmlzU2FmZSB8fCBoYXNBdHRyaWJ1dGUoXCJkYXRhLXR1cmJvLXN0cmVhbVwiLCB0aGlzLnN1Ym1pdHRlciwgdGhpcy5mb3JtRWxlbWVudClcbiAgfVxuXG4gIGdldCBzdWJtaXRzV2l0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdWJtaXR0ZXI/LmdldEF0dHJpYnV0ZShcImRhdGEtdHVyYm8tc3VibWl0cy13aXRoXCIpXG4gIH1cbn1cblxuZnVuY3Rpb24gYnVpbGRGb3JtRGF0YShmb3JtRWxlbWVudCwgc3VibWl0dGVyKSB7XG4gIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKGZvcm1FbGVtZW50KTtcbiAgY29uc3QgbmFtZSA9IHN1Ym1pdHRlcj8uZ2V0QXR0cmlidXRlKFwibmFtZVwiKTtcbiAgY29uc3QgdmFsdWUgPSBzdWJtaXR0ZXI/LmdldEF0dHJpYnV0ZShcInZhbHVlXCIpO1xuXG4gIGlmIChuYW1lKSB7XG4gICAgZm9ybURhdGEuYXBwZW5kKG5hbWUsIHZhbHVlIHx8IFwiXCIpO1xuICB9XG5cbiAgcmV0dXJuIGZvcm1EYXRhXG59XG5cbmZ1bmN0aW9uIGdldENvb2tpZVZhbHVlKGNvb2tpZU5hbWUpIHtcbiAgaWYgKGNvb2tpZU5hbWUgIT0gbnVsbCkge1xuICAgIGNvbnN0IGNvb2tpZXMgPSBkb2N1bWVudC5jb29raWUgPyBkb2N1bWVudC5jb29raWUuc3BsaXQoXCI7IFwiKSA6IFtdO1xuICAgIGNvbnN0IGNvb2tpZSA9IGNvb2tpZXMuZmluZCgoY29va2llKSA9PiBjb29raWUuc3RhcnRzV2l0aChjb29raWVOYW1lKSk7XG4gICAgaWYgKGNvb2tpZSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBjb29raWUuc3BsaXQoXCI9XCIpLnNsaWNlKDEpLmpvaW4oXCI9XCIpO1xuICAgICAgcmV0dXJuIHZhbHVlID8gZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKSA6IHVuZGVmaW5lZFxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXNwb25zZVN1Y2NlZWRlZFdpdGhvdXRSZWRpcmVjdChyZXNwb25zZSkge1xuICByZXR1cm4gcmVzcG9uc2Uuc3RhdHVzQ29kZSA9PSAyMDAgJiYgIXJlc3BvbnNlLnJlZGlyZWN0ZWRcbn1cblxuZnVuY3Rpb24gZ2V0Rm9ybUFjdGlvbihmb3JtRWxlbWVudCwgc3VibWl0dGVyKSB7XG4gIGNvbnN0IGZvcm1FbGVtZW50QWN0aW9uID0gdHlwZW9mIGZvcm1FbGVtZW50LmFjdGlvbiA9PT0gXCJzdHJpbmdcIiA/IGZvcm1FbGVtZW50LmFjdGlvbiA6IG51bGw7XG5cbiAgaWYgKHN1Ym1pdHRlcj8uaGFzQXR0cmlidXRlKFwiZm9ybWFjdGlvblwiKSkge1xuICAgIHJldHVybiBzdWJtaXR0ZXIuZ2V0QXR0cmlidXRlKFwiZm9ybWFjdGlvblwiKSB8fCBcIlwiXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZvcm1FbGVtZW50LmdldEF0dHJpYnV0ZShcImFjdGlvblwiKSB8fCBmb3JtRWxlbWVudEFjdGlvbiB8fCBcIlwiXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0QWN0aW9uKGZvcm1BY3Rpb24sIGZldGNoTWV0aG9kKSB7XG4gIGNvbnN0IGFjdGlvbiA9IGV4cGFuZFVSTChmb3JtQWN0aW9uKTtcblxuICBpZiAoaXNTYWZlKGZldGNoTWV0aG9kKSkge1xuICAgIGFjdGlvbi5zZWFyY2ggPSBcIlwiO1xuICB9XG5cbiAgcmV0dXJuIGFjdGlvblxufVxuXG5mdW5jdGlvbiBnZXRNZXRob2QoZm9ybUVsZW1lbnQsIHN1Ym1pdHRlcikge1xuICBjb25zdCBtZXRob2QgPSBzdWJtaXR0ZXI/LmdldEF0dHJpYnV0ZShcImZvcm1tZXRob2RcIikgfHwgZm9ybUVsZW1lbnQuZ2V0QXR0cmlidXRlKFwibWV0aG9kXCIpIHx8IFwiXCI7XG4gIHJldHVybiBmZXRjaE1ldGhvZEZyb21TdHJpbmcobWV0aG9kLnRvTG93ZXJDYXNlKCkpIHx8IEZldGNoTWV0aG9kLmdldFxufVxuXG5mdW5jdGlvbiBnZXRFbmN0eXBlKGZvcm1FbGVtZW50LCBzdWJtaXR0ZXIpIHtcbiAgcmV0dXJuIGZldGNoRW5jdHlwZUZyb21TdHJpbmcoc3VibWl0dGVyPy5nZXRBdHRyaWJ1dGUoXCJmb3JtZW5jdHlwZVwiKSB8fCBmb3JtRWxlbWVudC5lbmN0eXBlKVxufVxuXG5jbGFzcyBTbmFwc2hvdCB7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQpIHtcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICB9XG5cbiAgZ2V0IGFjdGl2ZUVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudC5vd25lckRvY3VtZW50LmFjdGl2ZUVsZW1lbnRcbiAgfVxuXG4gIGdldCBjaGlsZHJlbigpIHtcbiAgICByZXR1cm4gWy4uLnRoaXMuZWxlbWVudC5jaGlsZHJlbl1cbiAgfVxuXG4gIGhhc0FuY2hvcihhbmNob3IpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRFbGVtZW50Rm9yQW5jaG9yKGFuY2hvcikgIT0gbnVsbFxuICB9XG5cbiAgZ2V0RWxlbWVudEZvckFuY2hvcihhbmNob3IpIHtcbiAgICByZXR1cm4gYW5jaG9yID8gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoYFtpZD0nJHthbmNob3J9J10sIGFbbmFtZT0nJHthbmNob3J9J11gKSA6IG51bGxcbiAgfVxuXG4gIGdldCBpc0Nvbm5lY3RlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50LmlzQ29ubmVjdGVkXG4gIH1cblxuICBnZXQgZmlyc3RBdXRvZm9jdXNhYmxlRWxlbWVudCgpIHtcbiAgICByZXR1cm4gcXVlcnlBdXRvZm9jdXNhYmxlRWxlbWVudCh0aGlzLmVsZW1lbnQpXG4gIH1cblxuICBnZXQgcGVybWFuZW50RWxlbWVudHMoKSB7XG4gICAgcmV0dXJuIHF1ZXJ5UGVybWFuZW50RWxlbWVudHNBbGwodGhpcy5lbGVtZW50KVxuICB9XG5cbiAgZ2V0UGVybWFuZW50RWxlbWVudEJ5SWQoaWQpIHtcbiAgICByZXR1cm4gZ2V0UGVybWFuZW50RWxlbWVudEJ5SWQodGhpcy5lbGVtZW50LCBpZClcbiAgfVxuXG4gIGdldFBlcm1hbmVudEVsZW1lbnRNYXBGb3JTbmFwc2hvdChzbmFwc2hvdCkge1xuICAgIGNvbnN0IHBlcm1hbmVudEVsZW1lbnRNYXAgPSB7fTtcblxuICAgIGZvciAoY29uc3QgY3VycmVudFBlcm1hbmVudEVsZW1lbnQgb2YgdGhpcy5wZXJtYW5lbnRFbGVtZW50cykge1xuICAgICAgY29uc3QgeyBpZCB9ID0gY3VycmVudFBlcm1hbmVudEVsZW1lbnQ7XG4gICAgICBjb25zdCBuZXdQZXJtYW5lbnRFbGVtZW50ID0gc25hcHNob3QuZ2V0UGVybWFuZW50RWxlbWVudEJ5SWQoaWQpO1xuICAgICAgaWYgKG5ld1Blcm1hbmVudEVsZW1lbnQpIHtcbiAgICAgICAgcGVybWFuZW50RWxlbWVudE1hcFtpZF0gPSBbY3VycmVudFBlcm1hbmVudEVsZW1lbnQsIG5ld1Blcm1hbmVudEVsZW1lbnRdO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwZXJtYW5lbnRFbGVtZW50TWFwXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UGVybWFuZW50RWxlbWVudEJ5SWQobm9kZSwgaWQpIHtcbiAgcmV0dXJuIG5vZGUucXVlcnlTZWxlY3RvcihgIyR7aWR9W2RhdGEtdHVyYm8tcGVybWFuZW50XWApXG59XG5cbmZ1bmN0aW9uIHF1ZXJ5UGVybWFuZW50RWxlbWVudHNBbGwobm9kZSkge1xuICByZXR1cm4gbm9kZS5xdWVyeVNlbGVjdG9yQWxsKFwiW2lkXVtkYXRhLXR1cmJvLXBlcm1hbmVudF1cIilcbn1cblxuY2xhc3MgRm9ybVN1Ym1pdE9ic2VydmVyIHtcbiAgc3RhcnRlZCA9IGZhbHNlXG5cbiAgY29uc3RydWN0b3IoZGVsZWdhdGUsIGV2ZW50VGFyZ2V0KSB7XG4gICAgdGhpcy5kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xuICAgIHRoaXMuZXZlbnRUYXJnZXQgPSBldmVudFRhcmdldDtcbiAgfVxuXG4gIHN0YXJ0KCkge1xuICAgIGlmICghdGhpcy5zdGFydGVkKSB7XG4gICAgICB0aGlzLmV2ZW50VGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJzdWJtaXRcIiwgdGhpcy5zdWJtaXRDYXB0dXJlZCwgdHJ1ZSk7XG4gICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHN0b3AoKSB7XG4gICAgaWYgKHRoaXMuc3RhcnRlZCkge1xuICAgICAgdGhpcy5ldmVudFRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKFwic3VibWl0XCIsIHRoaXMuc3VibWl0Q2FwdHVyZWQsIHRydWUpO1xuICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgc3VibWl0Q2FwdHVyZWQgPSAoKSA9PiB7XG4gICAgdGhpcy5ldmVudFRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKFwic3VibWl0XCIsIHRoaXMuc3VibWl0QnViYmxlZCwgZmFsc2UpO1xuICAgIHRoaXMuZXZlbnRUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihcInN1Ym1pdFwiLCB0aGlzLnN1Ym1pdEJ1YmJsZWQsIGZhbHNlKTtcbiAgfVxuXG4gIHN1Ym1pdEJ1YmJsZWQgPSAoZXZlbnQpID0+IHtcbiAgICBpZiAoIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgIGNvbnN0IGZvcm0gPSBldmVudC50YXJnZXQgaW5zdGFuY2VvZiBIVE1MRm9ybUVsZW1lbnQgPyBldmVudC50YXJnZXQgOiB1bmRlZmluZWQ7XG4gICAgICBjb25zdCBzdWJtaXR0ZXIgPSBldmVudC5zdWJtaXR0ZXIgfHwgdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoXG4gICAgICAgIGZvcm0gJiZcbiAgICAgICAgc3VibWlzc2lvbkRvZXNOb3REaXNtaXNzRGlhbG9nKGZvcm0sIHN1Ym1pdHRlcikgJiZcbiAgICAgICAgc3VibWlzc2lvbkRvZXNOb3RUYXJnZXRJRnJhbWUoZm9ybSwgc3VibWl0dGVyKSAmJlxuICAgICAgICB0aGlzLmRlbGVnYXRlLndpbGxTdWJtaXRGb3JtKGZvcm0sIHN1Ym1pdHRlcilcbiAgICAgICkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZS5mb3JtU3VibWl0dGVkKGZvcm0sIHN1Ym1pdHRlcik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN1Ym1pc3Npb25Eb2VzTm90RGlzbWlzc0RpYWxvZyhmb3JtLCBzdWJtaXR0ZXIpIHtcbiAgY29uc3QgbWV0aG9kID0gc3VibWl0dGVyPy5nZXRBdHRyaWJ1dGUoXCJmb3JtbWV0aG9kXCIpIHx8IGZvcm0uZ2V0QXR0cmlidXRlKFwibWV0aG9kXCIpO1xuXG4gIHJldHVybiBtZXRob2QgIT0gXCJkaWFsb2dcIlxufVxuXG5mdW5jdGlvbiBzdWJtaXNzaW9uRG9lc05vdFRhcmdldElGcmFtZShmb3JtLCBzdWJtaXR0ZXIpIHtcbiAgY29uc3QgdGFyZ2V0ID0gc3VibWl0dGVyPy5nZXRBdHRyaWJ1dGUoXCJmb3JtdGFyZ2V0XCIpIHx8IGZvcm0uZ2V0QXR0cmlidXRlKFwidGFyZ2V0XCIpO1xuXG4gIHJldHVybiBkb2VzTm90VGFyZ2V0SUZyYW1lKHRhcmdldClcbn1cblxuY2xhc3MgVmlldyB7XG4gICNyZXNvbHZlUmVuZGVyUHJvbWlzZSA9IChfdmFsdWUpID0+IHt9XG4gICNyZXNvbHZlSW50ZXJjZXB0aW9uUHJvbWlzZSA9IChfdmFsdWUpID0+IHt9XG5cbiAgY29uc3RydWN0b3IoZGVsZWdhdGUsIGVsZW1lbnQpIHtcbiAgICB0aGlzLmRlbGVnYXRlID0gZGVsZWdhdGU7XG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgfVxuXG4gIC8vIFNjcm9sbGluZ1xuXG4gIHNjcm9sbFRvQW5jaG9yKGFuY2hvcikge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLnNuYXBzaG90LmdldEVsZW1lbnRGb3JBbmNob3IoYW5jaG9yKTtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdGhpcy5zY3JvbGxUb0VsZW1lbnQoZWxlbWVudCk7XG4gICAgICB0aGlzLmZvY3VzRWxlbWVudChlbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zY3JvbGxUb1Bvc2l0aW9uKHsgeDogMCwgeTogMCB9KTtcbiAgICB9XG4gIH1cblxuICBzY3JvbGxUb0FuY2hvckZyb21Mb2NhdGlvbihsb2NhdGlvbikge1xuICAgIHRoaXMuc2Nyb2xsVG9BbmNob3IoZ2V0QW5jaG9yKGxvY2F0aW9uKSk7XG4gIH1cblxuICBzY3JvbGxUb0VsZW1lbnQoZWxlbWVudCkge1xuICAgIGVsZW1lbnQuc2Nyb2xsSW50b1ZpZXcoKTtcbiAgfVxuXG4gIGZvY3VzRWxlbWVudChlbGVtZW50KSB7XG4gICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgaWYgKGVsZW1lbnQuaGFzQXR0cmlidXRlKFwidGFiaW5kZXhcIikpIHtcbiAgICAgICAgZWxlbWVudC5mb2N1cygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJ0YWJpbmRleFwiLCBcIi0xXCIpO1xuICAgICAgICBlbGVtZW50LmZvY3VzKCk7XG4gICAgICAgIGVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwidGFiaW5kZXhcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgc2Nyb2xsVG9Qb3NpdGlvbih7IHgsIHkgfSkge1xuICAgIHRoaXMuc2Nyb2xsUm9vdC5zY3JvbGxUbyh4LCB5KTtcbiAgfVxuXG4gIHNjcm9sbFRvVG9wKCkge1xuICAgIHRoaXMuc2Nyb2xsVG9Qb3NpdGlvbih7IHg6IDAsIHk6IDAgfSk7XG4gIH1cblxuICBnZXQgc2Nyb2xsUm9vdCgpIHtcbiAgICByZXR1cm4gd2luZG93XG4gIH1cblxuICAvLyBSZW5kZXJpbmdcblxuICBhc3luYyByZW5kZXIocmVuZGVyZXIpIHtcbiAgICBjb25zdCB7IGlzUHJldmlldywgc2hvdWxkUmVuZGVyLCB3aWxsUmVuZGVyLCBuZXdTbmFwc2hvdDogc25hcHNob3QgfSA9IHJlbmRlcmVyO1xuXG4gICAgLy8gQSB3b3JrYXJvdW5kIHRvIGlnbm9yZSB0cmFja2VkIGVsZW1lbnQgbWlzbWF0Y2ggcmVsb2FkcyB3aGVuIHBlcmZvcm1pbmdcbiAgICAvLyBhIHByb21vdGVkIFZpc2l0IGZyb20gYSBmcmFtZSBuYXZpZ2F0aW9uXG4gICAgY29uc3Qgc2hvdWxkSW52YWxpZGF0ZSA9IHdpbGxSZW5kZXI7XG5cbiAgICBpZiAoc2hvdWxkUmVuZGVyKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLnJlbmRlclByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gKHRoaXMuI3Jlc29sdmVSZW5kZXJQcm9taXNlID0gcmVzb2x2ZSkpO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIGF3YWl0IHRoaXMucHJlcGFyZVRvUmVuZGVyU25hcHNob3QocmVuZGVyZXIpO1xuXG4gICAgICAgIGNvbnN0IHJlbmRlckludGVyY2VwdGlvbiA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiAodGhpcy4jcmVzb2x2ZUludGVyY2VwdGlvblByb21pc2UgPSByZXNvbHZlKSk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7IHJlc3VtZTogdGhpcy4jcmVzb2x2ZUludGVyY2VwdGlvblByb21pc2UsIHJlbmRlcjogdGhpcy5yZW5kZXJlci5yZW5kZXJFbGVtZW50LCByZW5kZXJNZXRob2Q6IHRoaXMucmVuZGVyZXIucmVuZGVyTWV0aG9kIH07XG4gICAgICAgIGNvbnN0IGltbWVkaWF0ZVJlbmRlciA9IHRoaXMuZGVsZWdhdGUuYWxsb3dzSW1tZWRpYXRlUmVuZGVyKHNuYXBzaG90LCBvcHRpb25zKTtcbiAgICAgICAgaWYgKCFpbW1lZGlhdGVSZW5kZXIpIGF3YWl0IHJlbmRlckludGVyY2VwdGlvbjtcblxuICAgICAgICBhd2FpdCB0aGlzLnJlbmRlclNuYXBzaG90KHJlbmRlcmVyKTtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZS52aWV3UmVuZGVyZWRTbmFwc2hvdChzbmFwc2hvdCwgaXNQcmV2aWV3LCB0aGlzLnJlbmRlcmVyLnJlbmRlck1ldGhvZCk7XG4gICAgICAgIHRoaXMuZGVsZWdhdGUucHJlbG9hZE9uTG9hZExpbmtzRm9yVmlldyh0aGlzLmVsZW1lbnQpO1xuICAgICAgICB0aGlzLmZpbmlzaFJlbmRlcmluZ1NuYXBzaG90KHJlbmRlcmVyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnJlbmRlcmVyO1xuICAgICAgICB0aGlzLiNyZXNvbHZlUmVuZGVyUHJvbWlzZSh1bmRlZmluZWQpO1xuICAgICAgICBkZWxldGUgdGhpcy5yZW5kZXJQcm9taXNlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoc2hvdWxkSW52YWxpZGF0ZSkge1xuICAgICAgdGhpcy5pbnZhbGlkYXRlKHJlbmRlcmVyLnJlbG9hZFJlYXNvbik7XG4gICAgfVxuICB9XG5cbiAgaW52YWxpZGF0ZShyZWFzb24pIHtcbiAgICB0aGlzLmRlbGVnYXRlLnZpZXdJbnZhbGlkYXRlZChyZWFzb24pO1xuICB9XG5cbiAgYXN5bmMgcHJlcGFyZVRvUmVuZGVyU25hcHNob3QocmVuZGVyZXIpIHtcbiAgICB0aGlzLm1hcmtBc1ByZXZpZXcocmVuZGVyZXIuaXNQcmV2aWV3KTtcbiAgICBhd2FpdCByZW5kZXJlci5wcmVwYXJlVG9SZW5kZXIoKTtcbiAgfVxuXG4gIG1hcmtBc1ByZXZpZXcoaXNQcmV2aWV3KSB7XG4gICAgaWYgKGlzUHJldmlldykge1xuICAgICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZShcImRhdGEtdHVyYm8tcHJldmlld1wiLCBcIlwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcImRhdGEtdHVyYm8tcHJldmlld1wiKTtcbiAgICB9XG4gIH1cblxuICBtYXJrVmlzaXREaXJlY3Rpb24oZGlyZWN0aW9uKSB7XG4gICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZShcImRhdGEtdHVyYm8tdmlzaXQtZGlyZWN0aW9uXCIsIGRpcmVjdGlvbik7XG4gIH1cblxuICB1bm1hcmtWaXNpdERpcmVjdGlvbigpIHtcbiAgICB0aGlzLmVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwiZGF0YS10dXJiby12aXNpdC1kaXJlY3Rpb25cIik7XG4gIH1cblxuICBhc3luYyByZW5kZXJTbmFwc2hvdChyZW5kZXJlcikge1xuICAgIGF3YWl0IHJlbmRlcmVyLnJlbmRlcigpO1xuICB9XG5cbiAgZmluaXNoUmVuZGVyaW5nU25hcHNob3QocmVuZGVyZXIpIHtcbiAgICByZW5kZXJlci5maW5pc2hSZW5kZXJpbmcoKTtcbiAgfVxufVxuXG5jbGFzcyBGcmFtZVZpZXcgZXh0ZW5kcyBWaWV3IHtcbiAgbWlzc2luZygpIHtcbiAgICB0aGlzLmVsZW1lbnQuaW5uZXJIVE1MID0gYDxzdHJvbmcgY2xhc3M9XCJ0dXJiby1mcmFtZS1lcnJvclwiPkNvbnRlbnQgbWlzc2luZzwvc3Ryb25nPmA7XG4gIH1cblxuICBnZXQgc25hcHNob3QoKSB7XG4gICAgcmV0dXJuIG5ldyBTbmFwc2hvdCh0aGlzLmVsZW1lbnQpXG4gIH1cbn1cblxuY2xhc3MgTGlua0ludGVyY2VwdG9yIHtcbiAgY29uc3RydWN0b3IoZGVsZWdhdGUsIGVsZW1lbnQpIHtcbiAgICB0aGlzLmRlbGVnYXRlID0gZGVsZWdhdGU7XG4gICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgfVxuXG4gIHN0YXJ0KCkge1xuICAgIHRoaXMuZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5jbGlja0J1YmJsZWQpO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ0dXJibzpjbGlja1wiLCB0aGlzLmxpbmtDbGlja2VkKTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidHVyYm86YmVmb3JlLXZpc2l0XCIsIHRoaXMud2lsbFZpc2l0KTtcbiAgfVxuXG4gIHN0b3AoKSB7XG4gICAgdGhpcy5lbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLmNsaWNrQnViYmxlZCk7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInR1cmJvOmNsaWNrXCIsIHRoaXMubGlua0NsaWNrZWQpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0dXJibzpiZWZvcmUtdmlzaXRcIiwgdGhpcy53aWxsVmlzaXQpO1xuICB9XG5cbiAgY2xpY2tCdWJibGVkID0gKGV2ZW50KSA9PiB7XG4gICAgaWYgKHRoaXMuY2xpY2tFdmVudElzU2lnbmlmaWNhbnQoZXZlbnQpKSB7XG4gICAgICB0aGlzLmNsaWNrRXZlbnQgPSBldmVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIHRoaXMuY2xpY2tFdmVudDtcbiAgICB9XG4gIH1cblxuICBsaW5rQ2xpY2tlZCA9IChldmVudCkgPT4ge1xuICAgIGlmICh0aGlzLmNsaWNrRXZlbnQgJiYgdGhpcy5jbGlja0V2ZW50SXNTaWduaWZpY2FudChldmVudCkpIHtcbiAgICAgIGlmICh0aGlzLmRlbGVnYXRlLnNob3VsZEludGVyY2VwdExpbmtDbGljayhldmVudC50YXJnZXQsIGV2ZW50LmRldGFpbC51cmwsIGV2ZW50LmRldGFpbC5vcmlnaW5hbEV2ZW50KSkge1xuICAgICAgICB0aGlzLmNsaWNrRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZS5saW5rQ2xpY2tJbnRlcmNlcHRlZChldmVudC50YXJnZXQsIGV2ZW50LmRldGFpbC51cmwsIGV2ZW50LmRldGFpbC5vcmlnaW5hbEV2ZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZGVsZXRlIHRoaXMuY2xpY2tFdmVudDtcbiAgfVxuXG4gIHdpbGxWaXNpdCA9IChfZXZlbnQpID0+IHtcbiAgICBkZWxldGUgdGhpcy5jbGlja0V2ZW50O1xuICB9XG5cbiAgY2xpY2tFdmVudElzU2lnbmlmaWNhbnQoZXZlbnQpIHtcbiAgICBjb25zdCB0YXJnZXQgPSBldmVudC5jb21wb3NlZCA/IGV2ZW50LnRhcmdldD8ucGFyZW50RWxlbWVudCA6IGV2ZW50LnRhcmdldDtcbiAgICBjb25zdCBlbGVtZW50ID0gZmluZExpbmtGcm9tQ2xpY2tUYXJnZXQodGFyZ2V0KSB8fCB0YXJnZXQ7XG5cbiAgICByZXR1cm4gZWxlbWVudCBpbnN0YW5jZW9mIEVsZW1lbnQgJiYgZWxlbWVudC5jbG9zZXN0KFwidHVyYm8tZnJhbWUsIGh0bWxcIikgPT0gdGhpcy5lbGVtZW50XG4gIH1cbn1cblxuY2xhc3MgTGlua0NsaWNrT2JzZXJ2ZXIge1xuICBzdGFydGVkID0gZmFsc2VcblxuICBjb25zdHJ1Y3RvcihkZWxlZ2F0ZSwgZXZlbnRUYXJnZXQpIHtcbiAgICB0aGlzLmRlbGVnYXRlID0gZGVsZWdhdGU7XG4gICAgdGhpcy5ldmVudFRhcmdldCA9IGV2ZW50VGFyZ2V0O1xuICB9XG5cbiAgc3RhcnQoKSB7XG4gICAgaWYgKCF0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgIHRoaXMuZXZlbnRUYXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuY2xpY2tDYXB0dXJlZCwgdHJ1ZSk7XG4gICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHN0b3AoKSB7XG4gICAgaWYgKHRoaXMuc3RhcnRlZCkge1xuICAgICAgdGhpcy5ldmVudFRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5jbGlja0NhcHR1cmVkLCB0cnVlKTtcbiAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGNsaWNrQ2FwdHVyZWQgPSAoKSA9PiB7XG4gICAgdGhpcy5ldmVudFRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy5jbGlja0J1YmJsZWQsIGZhbHNlKTtcbiAgICB0aGlzLmV2ZW50VGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCB0aGlzLmNsaWNrQnViYmxlZCwgZmFsc2UpO1xuICB9XG5cbiAgY2xpY2tCdWJibGVkID0gKGV2ZW50KSA9PiB7XG4gICAgaWYgKGV2ZW50IGluc3RhbmNlb2YgTW91c2VFdmVudCAmJiB0aGlzLmNsaWNrRXZlbnRJc1NpZ25pZmljYW50KGV2ZW50KSkge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gKGV2ZW50LmNvbXBvc2VkUGF0aCAmJiBldmVudC5jb21wb3NlZFBhdGgoKVswXSkgfHwgZXZlbnQudGFyZ2V0O1xuICAgICAgY29uc3QgbGluayA9IGZpbmRMaW5rRnJvbUNsaWNrVGFyZ2V0KHRhcmdldCk7XG4gICAgICBpZiAobGluayAmJiBkb2VzTm90VGFyZ2V0SUZyYW1lKGxpbmsudGFyZ2V0KSkge1xuICAgICAgICBjb25zdCBsb2NhdGlvbiA9IGdldExvY2F0aW9uRm9yTGluayhsaW5rKTtcbiAgICAgICAgaWYgKHRoaXMuZGVsZWdhdGUud2lsbEZvbGxvd0xpbmtUb0xvY2F0aW9uKGxpbmssIGxvY2F0aW9uLCBldmVudCkpIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIHRoaXMuZGVsZWdhdGUuZm9sbG93ZWRMaW5rVG9Mb2NhdGlvbihsaW5rLCBsb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjbGlja0V2ZW50SXNTaWduaWZpY2FudChldmVudCkge1xuICAgIHJldHVybiAhKFxuICAgICAgKGV2ZW50LnRhcmdldCAmJiBldmVudC50YXJnZXQuaXNDb250ZW50RWRpdGFibGUpIHx8XG4gICAgICBldmVudC5kZWZhdWx0UHJldmVudGVkIHx8XG4gICAgICBldmVudC53aGljaCA+IDEgfHxcbiAgICAgIGV2ZW50LmFsdEtleSB8fFxuICAgICAgZXZlbnQuY3RybEtleSB8fFxuICAgICAgZXZlbnQubWV0YUtleSB8fFxuICAgICAgZXZlbnQuc2hpZnRLZXlcbiAgICApXG4gIH1cbn1cblxuY2xhc3MgRm9ybUxpbmtDbGlja09ic2VydmVyIHtcbiAgY29uc3RydWN0b3IoZGVsZWdhdGUsIGVsZW1lbnQpIHtcbiAgICB0aGlzLmRlbGVnYXRlID0gZGVsZWdhdGU7XG4gICAgdGhpcy5saW5rSW50ZXJjZXB0b3IgPSBuZXcgTGlua0NsaWNrT2JzZXJ2ZXIodGhpcywgZWxlbWVudCk7XG4gIH1cblxuICBzdGFydCgpIHtcbiAgICB0aGlzLmxpbmtJbnRlcmNlcHRvci5zdGFydCgpO1xuICB9XG5cbiAgc3RvcCgpIHtcbiAgICB0aGlzLmxpbmtJbnRlcmNlcHRvci5zdG9wKCk7XG4gIH1cblxuICAvLyBMaW5rIGhvdmVyIG9ic2VydmVyIGRlbGVnYXRlXG5cbiAgY2FuUHJlZmV0Y2hSZXF1ZXN0VG9Mb2NhdGlvbihsaW5rLCBsb2NhdGlvbikge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcHJlZmV0Y2hBbmRDYWNoZVJlcXVlc3RUb0xvY2F0aW9uKGxpbmssIGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvLyBMaW5rIGNsaWNrIG9ic2VydmVyIGRlbGVnYXRlXG5cbiAgd2lsbEZvbGxvd0xpbmtUb0xvY2F0aW9uKGxpbmssIGxvY2F0aW9uLCBvcmlnaW5hbEV2ZW50KSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMuZGVsZWdhdGUud2lsbFN1Ym1pdEZvcm1MaW5rVG9Mb2NhdGlvbihsaW5rLCBsb2NhdGlvbiwgb3JpZ2luYWxFdmVudCkgJiZcbiAgICAgIChsaW5rLmhhc0F0dHJpYnV0ZShcImRhdGEtdHVyYm8tbWV0aG9kXCIpIHx8IGxpbmsuaGFzQXR0cmlidXRlKFwiZGF0YS10dXJiby1zdHJlYW1cIikpXG4gICAgKVxuICB9XG5cbiAgZm9sbG93ZWRMaW5rVG9Mb2NhdGlvbihsaW5rLCBsb2NhdGlvbikge1xuICAgIGNvbnN0IGZvcm0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZm9ybVwiKTtcblxuICAgIGNvbnN0IHR5cGUgPSBcImhpZGRlblwiO1xuICAgIGZvciAoY29uc3QgW25hbWUsIHZhbHVlXSBvZiBsb2NhdGlvbi5zZWFyY2hQYXJhbXMpIHtcbiAgICAgIGZvcm0uYXBwZW5kKE9iamVjdC5hc3NpZ24oZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpLCB7IHR5cGUsIG5hbWUsIHZhbHVlIH0pKTtcbiAgICB9XG5cbiAgICBjb25zdCBhY3Rpb24gPSBPYmplY3QuYXNzaWduKGxvY2F0aW9uLCB7IHNlYXJjaDogXCJcIiB9KTtcbiAgICBmb3JtLnNldEF0dHJpYnV0ZShcImRhdGEtdHVyYm9cIiwgXCJ0cnVlXCIpO1xuICAgIGZvcm0uc2V0QXR0cmlidXRlKFwiYWN0aW9uXCIsIGFjdGlvbi5ocmVmKTtcbiAgICBmb3JtLnNldEF0dHJpYnV0ZShcImhpZGRlblwiLCBcIlwiKTtcblxuICAgIGNvbnN0IG1ldGhvZCA9IGxpbmsuZ2V0QXR0cmlidXRlKFwiZGF0YS10dXJiby1tZXRob2RcIik7XG4gICAgaWYgKG1ldGhvZCkgZm9ybS5zZXRBdHRyaWJ1dGUoXCJtZXRob2RcIiwgbWV0aG9kKTtcblxuICAgIGNvbnN0IHR1cmJvRnJhbWUgPSBsaW5rLmdldEF0dHJpYnV0ZShcImRhdGEtdHVyYm8tZnJhbWVcIik7XG4gICAgaWYgKHR1cmJvRnJhbWUpIGZvcm0uc2V0QXR0cmlidXRlKFwiZGF0YS10dXJiby1mcmFtZVwiLCB0dXJib0ZyYW1lKTtcblxuICAgIGNvbnN0IHR1cmJvQWN0aW9uID0gZ2V0VmlzaXRBY3Rpb24obGluayk7XG4gICAgaWYgKHR1cmJvQWN0aW9uKSBmb3JtLnNldEF0dHJpYnV0ZShcImRhdGEtdHVyYm8tYWN0aW9uXCIsIHR1cmJvQWN0aW9uKTtcblxuICAgIGNvbnN0IHR1cmJvQ29uZmlybSA9IGxpbmsuZ2V0QXR0cmlidXRlKFwiZGF0YS10dXJiby1jb25maXJtXCIpO1xuICAgIGlmICh0dXJib0NvbmZpcm0pIGZvcm0uc2V0QXR0cmlidXRlKFwiZGF0YS10dXJiby1jb25maXJtXCIsIHR1cmJvQ29uZmlybSk7XG5cbiAgICBjb25zdCB0dXJib1N0cmVhbSA9IGxpbmsuaGFzQXR0cmlidXRlKFwiZGF0YS10dXJiby1zdHJlYW1cIik7XG4gICAgaWYgKHR1cmJvU3RyZWFtKSBmb3JtLnNldEF0dHJpYnV0ZShcImRhdGEtdHVyYm8tc3RyZWFtXCIsIFwiXCIpO1xuXG4gICAgdGhpcy5kZWxlZ2F0ZS5zdWJtaXR0ZWRGb3JtTGlua1RvTG9jYXRpb24obGluaywgbG9jYXRpb24sIGZvcm0pO1xuXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmb3JtKTtcbiAgICBmb3JtLmFkZEV2ZW50TGlzdGVuZXIoXCJ0dXJibzpzdWJtaXQtZW5kXCIsICgpID0+IGZvcm0ucmVtb3ZlKCksIHsgb25jZTogdHJ1ZSB9KTtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gZm9ybS5yZXF1ZXN0U3VibWl0KCkpO1xuICB9XG59XG5cbmNsYXNzIEJhcmRvIHtcbiAgc3RhdGljIGFzeW5jIHByZXNlcnZpbmdQZXJtYW5lbnRFbGVtZW50cyhkZWxlZ2F0ZSwgcGVybWFuZW50RWxlbWVudE1hcCwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBiYXJkbyA9IG5ldyB0aGlzKGRlbGVnYXRlLCBwZXJtYW5lbnRFbGVtZW50TWFwKTtcbiAgICBiYXJkby5lbnRlcigpO1xuICAgIGF3YWl0IGNhbGxiYWNrKCk7XG4gICAgYmFyZG8ubGVhdmUoKTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGRlbGVnYXRlLCBwZXJtYW5lbnRFbGVtZW50TWFwKSB7XG4gICAgdGhpcy5kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xuICAgIHRoaXMucGVybWFuZW50RWxlbWVudE1hcCA9IHBlcm1hbmVudEVsZW1lbnRNYXA7XG4gIH1cblxuICBlbnRlcigpIHtcbiAgICBmb3IgKGNvbnN0IGlkIGluIHRoaXMucGVybWFuZW50RWxlbWVudE1hcCkge1xuICAgICAgY29uc3QgW2N1cnJlbnRQZXJtYW5lbnRFbGVtZW50LCBuZXdQZXJtYW5lbnRFbGVtZW50XSA9IHRoaXMucGVybWFuZW50RWxlbWVudE1hcFtpZF07XG4gICAgICB0aGlzLmRlbGVnYXRlLmVudGVyaW5nQmFyZG8oY3VycmVudFBlcm1hbmVudEVsZW1lbnQsIG5ld1Blcm1hbmVudEVsZW1lbnQpO1xuICAgICAgdGhpcy5yZXBsYWNlTmV3UGVybWFuZW50RWxlbWVudFdpdGhQbGFjZWhvbGRlcihuZXdQZXJtYW5lbnRFbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICBsZWF2ZSgpIHtcbiAgICBmb3IgKGNvbnN0IGlkIGluIHRoaXMucGVybWFuZW50RWxlbWVudE1hcCkge1xuICAgICAgY29uc3QgW2N1cnJlbnRQZXJtYW5lbnRFbGVtZW50XSA9IHRoaXMucGVybWFuZW50RWxlbWVudE1hcFtpZF07XG4gICAgICB0aGlzLnJlcGxhY2VDdXJyZW50UGVybWFuZW50RWxlbWVudFdpdGhDbG9uZShjdXJyZW50UGVybWFuZW50RWxlbWVudCk7XG4gICAgICB0aGlzLnJlcGxhY2VQbGFjZWhvbGRlcldpdGhQZXJtYW5lbnRFbGVtZW50KGN1cnJlbnRQZXJtYW5lbnRFbGVtZW50KTtcbiAgICAgIHRoaXMuZGVsZWdhdGUubGVhdmluZ0JhcmRvKGN1cnJlbnRQZXJtYW5lbnRFbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXBsYWNlTmV3UGVybWFuZW50RWxlbWVudFdpdGhQbGFjZWhvbGRlcihwZXJtYW5lbnRFbGVtZW50KSB7XG4gICAgY29uc3QgcGxhY2Vob2xkZXIgPSBjcmVhdGVQbGFjZWhvbGRlckZvclBlcm1hbmVudEVsZW1lbnQocGVybWFuZW50RWxlbWVudCk7XG4gICAgcGVybWFuZW50RWxlbWVudC5yZXBsYWNlV2l0aChwbGFjZWhvbGRlcik7XG4gIH1cblxuICByZXBsYWNlQ3VycmVudFBlcm1hbmVudEVsZW1lbnRXaXRoQ2xvbmUocGVybWFuZW50RWxlbWVudCkge1xuICAgIGNvbnN0IGNsb25lID0gcGVybWFuZW50RWxlbWVudC5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgcGVybWFuZW50RWxlbWVudC5yZXBsYWNlV2l0aChjbG9uZSk7XG4gIH1cblxuICByZXBsYWNlUGxhY2Vob2xkZXJXaXRoUGVybWFuZW50RWxlbWVudChwZXJtYW5lbnRFbGVtZW50KSB7XG4gICAgY29uc3QgcGxhY2Vob2xkZXIgPSB0aGlzLmdldFBsYWNlaG9sZGVyQnlJZChwZXJtYW5lbnRFbGVtZW50LmlkKTtcbiAgICBwbGFjZWhvbGRlcj8ucmVwbGFjZVdpdGgocGVybWFuZW50RWxlbWVudCk7XG4gIH1cblxuICBnZXRQbGFjZWhvbGRlckJ5SWQoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5wbGFjZWhvbGRlcnMuZmluZCgoZWxlbWVudCkgPT4gZWxlbWVudC5jb250ZW50ID09IGlkKVxuICB9XG5cbiAgZ2V0IHBsYWNlaG9sZGVycygpIHtcbiAgICByZXR1cm4gWy4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJtZXRhW25hbWU9dHVyYm8tcGVybWFuZW50LXBsYWNlaG9sZGVyXVtjb250ZW50XVwiKV1cbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVQbGFjZWhvbGRlckZvclBlcm1hbmVudEVsZW1lbnQocGVybWFuZW50RWxlbWVudCkge1xuICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm1ldGFcIik7XG4gIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwibmFtZVwiLCBcInR1cmJvLXBlcm1hbmVudC1wbGFjZWhvbGRlclwiKTtcbiAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJjb250ZW50XCIsIHBlcm1hbmVudEVsZW1lbnQuaWQpO1xuICByZXR1cm4gZWxlbWVudFxufVxuXG5jbGFzcyBSZW5kZXJlciB7XG4gICNhY3RpdmVFbGVtZW50ID0gbnVsbFxuXG4gIHN0YXRpYyByZW5kZXJFbGVtZW50KGN1cnJlbnRFbGVtZW50LCBuZXdFbGVtZW50KSB7XG4gICAgLy8gQWJzdHJhY3QgbWV0aG9kXG4gIH1cblxuICBjb25zdHJ1Y3RvcihjdXJyZW50U25hcHNob3QsIG5ld1NuYXBzaG90LCBpc1ByZXZpZXcsIHdpbGxSZW5kZXIgPSB0cnVlKSB7XG4gICAgdGhpcy5jdXJyZW50U25hcHNob3QgPSBjdXJyZW50U25hcHNob3Q7XG4gICAgdGhpcy5uZXdTbmFwc2hvdCA9IG5ld1NuYXBzaG90O1xuICAgIHRoaXMuaXNQcmV2aWV3ID0gaXNQcmV2aWV3O1xuICAgIHRoaXMud2lsbFJlbmRlciA9IHdpbGxSZW5kZXI7XG4gICAgdGhpcy5yZW5kZXJFbGVtZW50ID0gdGhpcy5jb25zdHJ1Y3Rvci5yZW5kZXJFbGVtZW50O1xuICAgIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+ICh0aGlzLnJlc29sdmluZ0Z1bmN0aW9ucyA9IHsgcmVzb2x2ZSwgcmVqZWN0IH0pKTtcbiAgfVxuXG4gIGdldCBzaG91bGRSZW5kZXIoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGdldCBzaG91bGRBdXRvZm9jdXMoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGdldCByZWxvYWRSZWFzb24oKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBwcmVwYXJlVG9SZW5kZXIoKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgLy8gQWJzdHJhY3QgbWV0aG9kXG4gIH1cblxuICBmaW5pc2hSZW5kZXJpbmcoKSB7XG4gICAgaWYgKHRoaXMucmVzb2x2aW5nRnVuY3Rpb25zKSB7XG4gICAgICB0aGlzLnJlc29sdmluZ0Z1bmN0aW9ucy5yZXNvbHZlKCk7XG4gICAgICBkZWxldGUgdGhpcy5yZXNvbHZpbmdGdW5jdGlvbnM7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgcHJlc2VydmluZ1Blcm1hbmVudEVsZW1lbnRzKGNhbGxiYWNrKSB7XG4gICAgYXdhaXQgQmFyZG8ucHJlc2VydmluZ1Blcm1hbmVudEVsZW1lbnRzKHRoaXMsIHRoaXMucGVybWFuZW50RWxlbWVudE1hcCwgY2FsbGJhY2spO1xuICB9XG5cbiAgZm9jdXNGaXJzdEF1dG9mb2N1c2FibGVFbGVtZW50KCkge1xuICAgIGlmICh0aGlzLnNob3VsZEF1dG9mb2N1cykge1xuICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuY29ubmVjdGVkU25hcHNob3QuZmlyc3RBdXRvZm9jdXNhYmxlRWxlbWVudDtcbiAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQuZm9jdXMoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBCYXJkbyBkZWxlZ2F0ZVxuXG4gIGVudGVyaW5nQmFyZG8oY3VycmVudFBlcm1hbmVudEVsZW1lbnQpIHtcbiAgICBpZiAodGhpcy4jYWN0aXZlRWxlbWVudCkgcmV0dXJuXG5cbiAgICBpZiAoY3VycmVudFBlcm1hbmVudEVsZW1lbnQuY29udGFpbnModGhpcy5jdXJyZW50U25hcHNob3QuYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgIHRoaXMuI2FjdGl2ZUVsZW1lbnQgPSB0aGlzLmN1cnJlbnRTbmFwc2hvdC5hY3RpdmVFbGVtZW50O1xuICAgIH1cbiAgfVxuXG4gIGxlYXZpbmdCYXJkbyhjdXJyZW50UGVybWFuZW50RWxlbWVudCkge1xuICAgIGlmIChjdXJyZW50UGVybWFuZW50RWxlbWVudC5jb250YWlucyh0aGlzLiNhY3RpdmVFbGVtZW50KSAmJiB0aGlzLiNhY3RpdmVFbGVtZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgIHRoaXMuI2FjdGl2ZUVsZW1lbnQuZm9jdXMoKTtcblxuICAgICAgdGhpcy4jYWN0aXZlRWxlbWVudCA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGNvbm5lY3RlZFNuYXBzaG90KCkge1xuICAgIHJldHVybiB0aGlzLm5ld1NuYXBzaG90LmlzQ29ubmVjdGVkID8gdGhpcy5uZXdTbmFwc2hvdCA6IHRoaXMuY3VycmVudFNuYXBzaG90XG4gIH1cblxuICBnZXQgY3VycmVudEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudFNuYXBzaG90LmVsZW1lbnRcbiAgfVxuXG4gIGdldCBuZXdFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLm5ld1NuYXBzaG90LmVsZW1lbnRcbiAgfVxuXG4gIGdldCBwZXJtYW5lbnRFbGVtZW50TWFwKCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRTbmFwc2hvdC5nZXRQZXJtYW5lbnRFbGVtZW50TWFwRm9yU25hcHNob3QodGhpcy5uZXdTbmFwc2hvdClcbiAgfVxuXG4gIGdldCByZW5kZXJNZXRob2QoKSB7XG4gICAgcmV0dXJuIFwicmVwbGFjZVwiXG4gIH1cbn1cblxuY2xhc3MgRnJhbWVSZW5kZXJlciBleHRlbmRzIFJlbmRlcmVyIHtcbiAgc3RhdGljIHJlbmRlckVsZW1lbnQoY3VycmVudEVsZW1lbnQsIG5ld0VsZW1lbnQpIHtcbiAgICBjb25zdCBkZXN0aW5hdGlvblJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICBkZXN0aW5hdGlvblJhbmdlLnNlbGVjdE5vZGVDb250ZW50cyhjdXJyZW50RWxlbWVudCk7XG4gICAgZGVzdGluYXRpb25SYW5nZS5kZWxldGVDb250ZW50cygpO1xuXG4gICAgY29uc3QgZnJhbWVFbGVtZW50ID0gbmV3RWxlbWVudDtcbiAgICBjb25zdCBzb3VyY2VSYW5nZSA9IGZyYW1lRWxlbWVudC5vd25lckRvY3VtZW50Py5jcmVhdGVSYW5nZSgpO1xuICAgIGlmIChzb3VyY2VSYW5nZSkge1xuICAgICAgc291cmNlUmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKGZyYW1lRWxlbWVudCk7XG4gICAgICBjdXJyZW50RWxlbWVudC5hcHBlbmRDaGlsZChzb3VyY2VSYW5nZS5leHRyYWN0Q29udGVudHMoKSk7XG4gICAgfVxuICB9XG5cbiAgY29uc3RydWN0b3IoZGVsZWdhdGUsIGN1cnJlbnRTbmFwc2hvdCwgbmV3U25hcHNob3QsIHJlbmRlckVsZW1lbnQsIGlzUHJldmlldywgd2lsbFJlbmRlciA9IHRydWUpIHtcbiAgICBzdXBlcihjdXJyZW50U25hcHNob3QsIG5ld1NuYXBzaG90LCByZW5kZXJFbGVtZW50LCBpc1ByZXZpZXcsIHdpbGxSZW5kZXIpO1xuICAgIHRoaXMuZGVsZWdhdGUgPSBkZWxlZ2F0ZTtcbiAgfVxuXG4gIGdldCBzaG91bGRSZW5kZXIoKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIGFzeW5jIHJlbmRlcigpIHtcbiAgICBhd2FpdCBuZXh0UmVwYWludCgpO1xuICAgIHRoaXMucHJlc2VydmluZ1Blcm1hbmVudEVsZW1lbnRzKCgpID0+IHtcbiAgICAgIHRoaXMubG9hZEZyYW1lRWxlbWVudCgpO1xuICAgIH0pO1xuICAgIHRoaXMuc2Nyb2xsRnJhbWVJbnRvVmlldygpO1xuICAgIGF3YWl0IG5leHRSZXBhaW50KCk7XG4gICAgdGhpcy5mb2N1c0ZpcnN0QXV0b2ZvY3VzYWJsZUVsZW1lbnQoKTtcbiAgICBhd2FpdCBuZXh0UmVwYWludCgpO1xuICAgIHRoaXMuYWN0aXZhdGVTY3JpcHRFbGVtZW50cygpO1xuICB9XG5cbiAgbG9hZEZyYW1lRWxlbWVudCgpIHtcbiAgICB0aGlzLmRlbGVnYXRlLndpbGxSZW5kZXJGcmFtZSh0aGlzLmN1cnJlbnRFbGVtZW50LCB0aGlzLm5ld0VsZW1lbnQpO1xuICAgIHRoaXMucmVuZGVyRWxlbWVudCh0aGlzLmN1cnJlbnRFbGVtZW50LCB0aGlzLm5ld0VsZW1lbnQpO1xuICB9XG5cbiAgc2Nyb2xsRnJhbWVJbnRvVmlldygpIHtcbiAgICBpZiAodGhpcy5jdXJyZW50RWxlbWVudC5hdXRvc2Nyb2xsIHx8IHRoaXMubmV3RWxlbWVudC5hdXRvc2Nyb2xsKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5jdXJyZW50RWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZDtcbiAgICAgIGNvbnN0IGJsb2NrID0gcmVhZFNjcm9sbExvZ2ljYWxQb3NpdGlvbih0aGlzLmN1cnJlbnRFbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtYXV0b3Njcm9sbC1ibG9ja1wiKSwgXCJlbmRcIik7XG4gICAgICBjb25zdCBiZWhhdmlvciA9IHJlYWRTY3JvbGxCZWhhdmlvcih0aGlzLmN1cnJlbnRFbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtYXV0b3Njcm9sbC1iZWhhdmlvclwiKSwgXCJhdXRvXCIpO1xuXG4gICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICBlbGVtZW50LnNjcm9sbEludG9WaWV3KHsgYmxvY2ssIGJlaGF2aW9yIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIGFjdGl2YXRlU2NyaXB0RWxlbWVudHMoKSB7XG4gICAgZm9yIChjb25zdCBpbmVydFNjcmlwdEVsZW1lbnQgb2YgdGhpcy5uZXdTY3JpcHRFbGVtZW50cykge1xuICAgICAgY29uc3QgYWN0aXZhdGVkU2NyaXB0RWxlbWVudCA9IGFjdGl2YXRlU2NyaXB0RWxlbWVudChpbmVydFNjcmlwdEVsZW1lbnQpO1xuICAgICAgaW5lcnRTY3JpcHRFbGVtZW50LnJlcGxhY2VXaXRoKGFjdGl2YXRlZFNjcmlwdEVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIGdldCBuZXdTY3JpcHRFbGVtZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50RWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFwic2NyaXB0XCIpXG4gIH1cbn1cblxuZnVuY3Rpb24gcmVhZFNjcm9sbExvZ2ljYWxQb3NpdGlvbih2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBcImVuZFwiIHx8IHZhbHVlID09IFwic3RhcnRcIiB8fCB2YWx1ZSA9PSBcImNlbnRlclwiIHx8IHZhbHVlID09IFwibmVhcmVzdFwiKSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGRlZmF1bHRWYWx1ZVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlYWRTY3JvbGxCZWhhdmlvcih2YWx1ZSwgZGVmYXVsdFZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PSBcImF1dG9cIiB8fCB2YWx1ZSA9PSBcInNtb290aFwiKSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGRlZmF1bHRWYWx1ZVxuICB9XG59XG5cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gQ29uZmlnSGVhZFxuICpcbiAqIEBwcm9wZXJ0eSB7J21lcmdlJyB8ICdhcHBlbmQnIHwgJ21vcnBoJyB8ICdub25lJ30gW3N0eWxlXVxuICogQHByb3BlcnR5IHtib29sZWFufSBbYmxvY2tdXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtpZ25vcmVdXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKEVsZW1lbnQpOiBib29sZWFufSBbc2hvdWxkUHJlc2VydmVdXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKEVsZW1lbnQpOiBib29sZWFufSBbc2hvdWxkUmVBcHBlbmRdXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKEVsZW1lbnQpOiBib29sZWFufSBbc2hvdWxkUmVtb3ZlXVxuICogQHByb3BlcnR5IHtmdW5jdGlvbihFbGVtZW50LCB7YWRkZWQ6IE5vZGVbXSwga2VwdDogRWxlbWVudFtdLCByZW1vdmVkOiBFbGVtZW50W119KTogdm9pZH0gW2FmdGVySGVhZE1vcnBoZWRdXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBDb25maWdDYWxsYmFja3NcbiAqXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKE5vZGUpOiBib29sZWFufSBbYmVmb3JlTm9kZUFkZGVkXVxuICogQHByb3BlcnR5IHtmdW5jdGlvbihOb2RlKTogdm9pZH0gW2FmdGVyTm9kZUFkZGVkXVxuICogQHByb3BlcnR5IHtmdW5jdGlvbihFbGVtZW50LCBOb2RlKTogYm9vbGVhbn0gW2JlZm9yZU5vZGVNb3JwaGVkXVxuICogQHByb3BlcnR5IHtmdW5jdGlvbihFbGVtZW50LCBOb2RlKTogdm9pZH0gW2FmdGVyTm9kZU1vcnBoZWRdXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKEVsZW1lbnQpOiBib29sZWFufSBbYmVmb3JlTm9kZVJlbW92ZWRdXG4gKiBAcHJvcGVydHkge2Z1bmN0aW9uKEVsZW1lbnQpOiB2b2lkfSBbYWZ0ZXJOb2RlUmVtb3ZlZF1cbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb24oc3RyaW5nLCBFbGVtZW50LCBcInVwZGF0ZVwiIHwgXCJyZW1vdmVcIik6IGJvb2xlYW59IFtiZWZvcmVBdHRyaWJ1dGVVcGRhdGVkXVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gQ29uZmlnXG4gKlxuICogQHByb3BlcnR5IHsnb3V0ZXJIVE1MJyB8ICdpbm5lckhUTUwnfSBbbW9ycGhTdHlsZV1cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2lnbm9yZUFjdGl2ZV1cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2lnbm9yZUFjdGl2ZVZhbHVlXVxuICogQHByb3BlcnR5IHtib29sZWFufSBbcmVzdG9yZUZvY3VzXVxuICogQHByb3BlcnR5IHtDb25maWdDYWxsYmFja3N9IFtjYWxsYmFja3NdXG4gKiBAcHJvcGVydHkge0NvbmZpZ0hlYWR9IFtoZWFkXVxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge2Z1bmN0aW9ufSBOb09wXG4gKlxuICogQHJldHVybnMge3ZvaWR9XG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBDb25maWdIZWFkSW50ZXJuYWxcbiAqXG4gKiBAcHJvcGVydHkgeydtZXJnZScgfCAnYXBwZW5kJyB8ICdtb3JwaCcgfCAnbm9uZSd9IHN0eWxlXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtibG9ja11cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2lnbm9yZV1cbiAqIEBwcm9wZXJ0eSB7KGZ1bmN0aW9uKEVsZW1lbnQpOiBib29sZWFuKSB8IE5vT3B9IHNob3VsZFByZXNlcnZlXG4gKiBAcHJvcGVydHkgeyhmdW5jdGlvbihFbGVtZW50KTogYm9vbGVhbikgfCBOb09wfSBzaG91bGRSZUFwcGVuZFxuICogQHByb3BlcnR5IHsoZnVuY3Rpb24oRWxlbWVudCk6IGJvb2xlYW4pIHwgTm9PcH0gc2hvdWxkUmVtb3ZlXG4gKiBAcHJvcGVydHkgeyhmdW5jdGlvbihFbGVtZW50LCB7YWRkZWQ6IE5vZGVbXSwga2VwdDogRWxlbWVudFtdLCByZW1vdmVkOiBFbGVtZW50W119KTogdm9pZCkgfCBOb09wfSBhZnRlckhlYWRNb3JwaGVkXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7b2JqZWN0fSBDb25maWdDYWxsYmFja3NJbnRlcm5hbFxuICpcbiAqIEBwcm9wZXJ0eSB7KGZ1bmN0aW9uKE5vZGUpOiBib29sZWFuKSB8IE5vT3B9IGJlZm9yZU5vZGVBZGRlZFxuICogQHByb3BlcnR5IHsoZnVuY3Rpb24oTm9kZSk6IHZvaWQpIHwgTm9PcH0gYWZ0ZXJOb2RlQWRkZWRcbiAqIEBwcm9wZXJ0eSB7KGZ1bmN0aW9uKE5vZGUsIE5vZGUpOiBib29sZWFuKSB8IE5vT3B9IGJlZm9yZU5vZGVNb3JwaGVkXG4gKiBAcHJvcGVydHkgeyhmdW5jdGlvbihOb2RlLCBOb2RlKTogdm9pZCkgfCBOb09wfSBhZnRlck5vZGVNb3JwaGVkXG4gKiBAcHJvcGVydHkgeyhmdW5jdGlvbihOb2RlKTogYm9vbGVhbikgfCBOb09wfSBiZWZvcmVOb2RlUmVtb3ZlZFxuICogQHByb3BlcnR5IHsoZnVuY3Rpb24oTm9kZSk6IHZvaWQpIHwgTm9PcH0gYWZ0ZXJOb2RlUmVtb3ZlZFxuICogQHByb3BlcnR5IHsoZnVuY3Rpb24oc3RyaW5nLCBFbGVtZW50LCBcInVwZGF0ZVwiIHwgXCJyZW1vdmVcIik6IGJvb2xlYW4pIHwgTm9PcH0gYmVmb3JlQXR0cmlidXRlVXBkYXRlZFxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gQ29uZmlnSW50ZXJuYWxcbiAqXG4gKiBAcHJvcGVydHkgeydvdXRlckhUTUwnIHwgJ2lubmVySFRNTCd9IG1vcnBoU3R5bGVcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2lnbm9yZUFjdGl2ZV1cbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gW2lnbm9yZUFjdGl2ZVZhbHVlXVxuICogQHByb3BlcnR5IHtib29sZWFufSBbcmVzdG9yZUZvY3VzXVxuICogQHByb3BlcnR5IHtDb25maWdDYWxsYmFja3NJbnRlcm5hbH0gY2FsbGJhY2tzXG4gKiBAcHJvcGVydHkge0NvbmZpZ0hlYWRJbnRlcm5hbH0gaGVhZFxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge09iamVjdH0gSWRTZXRzXG4gKiBAcHJvcGVydHkge1NldDxzdHJpbmc+fSBwZXJzaXN0ZW50SWRzXG4gKiBAcHJvcGVydHkge01hcDxOb2RlLCBTZXQ8c3RyaW5nPj59IGlkTWFwXG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7RnVuY3Rpb259IE1vcnBoXG4gKlxuICogQHBhcmFtIHtFbGVtZW50IHwgRG9jdW1lbnR9IG9sZE5vZGVcbiAqIEBwYXJhbSB7RWxlbWVudCB8IE5vZGUgfCBIVE1MQ29sbGVjdGlvbiB8IE5vZGVbXSB8IHN0cmluZyB8IG51bGx9IG5ld0NvbnRlbnRcbiAqIEBwYXJhbSB7Q29uZmlnfSBbY29uZmlnXVxuICogQHJldHVybnMge3VuZGVmaW5lZCB8IE5vZGVbXX1cbiAqL1xuXG4vLyBiYXNlIElJRkUgdG8gZGVmaW5lIGlkaW9tb3JwaFxuLyoqXG4gKlxuICogQHR5cGUge3tkZWZhdWx0czogQ29uZmlnSW50ZXJuYWwsIG1vcnBoOiBNb3JwaH19XG4gKi9cbnZhciBJZGlvbW9ycGggPSAoZnVuY3Rpb24gKCkge1xuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7b2JqZWN0fSBNb3JwaENvbnRleHRcbiAgICpcbiAgICogQHByb3BlcnR5IHtFbGVtZW50fSB0YXJnZXRcbiAgICogQHByb3BlcnR5IHtFbGVtZW50fSBuZXdDb250ZW50XG4gICAqIEBwcm9wZXJ0eSB7Q29uZmlnSW50ZXJuYWx9IGNvbmZpZ1xuICAgKiBAcHJvcGVydHkge0NvbmZpZ0ludGVybmFsWydtb3JwaFN0eWxlJ119IG1vcnBoU3R5bGVcbiAgICogQHByb3BlcnR5IHtDb25maWdJbnRlcm5hbFsnaWdub3JlQWN0aXZlJ119IGlnbm9yZUFjdGl2ZVxuICAgKiBAcHJvcGVydHkge0NvbmZpZ0ludGVybmFsWydpZ25vcmVBY3RpdmVWYWx1ZSddfSBpZ25vcmVBY3RpdmVWYWx1ZVxuICAgKiBAcHJvcGVydHkge0NvbmZpZ0ludGVybmFsWydyZXN0b3JlRm9jdXMnXX0gcmVzdG9yZUZvY3VzXG4gICAqIEBwcm9wZXJ0eSB7TWFwPE5vZGUsIFNldDxzdHJpbmc+Pn0gaWRNYXBcbiAgICogQHByb3BlcnR5IHtTZXQ8c3RyaW5nPn0gcGVyc2lzdGVudElkc1xuICAgKiBAcHJvcGVydHkge0NvbmZpZ0ludGVybmFsWydjYWxsYmFja3MnXX0gY2FsbGJhY2tzXG4gICAqIEBwcm9wZXJ0eSB7Q29uZmlnSW50ZXJuYWxbJ2hlYWQnXX0gaGVhZFxuICAgKiBAcHJvcGVydHkge0hUTUxEaXZFbGVtZW50fSBwYW50cnlcbiAgICovXG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBBTkQgTk9XIElUIEJFR0lOUy4uLlxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5cbiAgY29uc3Qgbm9PcCA9ICgpID0+IHt9O1xuICAvKipcbiAgICogRGVmYXVsdCBjb25maWd1cmF0aW9uIHZhbHVlcywgdXBkYXRhYmxlIGJ5IHVzZXJzIG5vd1xuICAgKiBAdHlwZSB7Q29uZmlnSW50ZXJuYWx9XG4gICAqL1xuICBjb25zdCBkZWZhdWx0cyA9IHtcbiAgICBtb3JwaFN0eWxlOiBcIm91dGVySFRNTFwiLFxuICAgIGNhbGxiYWNrczoge1xuICAgICAgYmVmb3JlTm9kZUFkZGVkOiBub09wLFxuICAgICAgYWZ0ZXJOb2RlQWRkZWQ6IG5vT3AsXG4gICAgICBiZWZvcmVOb2RlTW9ycGhlZDogbm9PcCxcbiAgICAgIGFmdGVyTm9kZU1vcnBoZWQ6IG5vT3AsXG4gICAgICBiZWZvcmVOb2RlUmVtb3ZlZDogbm9PcCxcbiAgICAgIGFmdGVyTm9kZVJlbW92ZWQ6IG5vT3AsXG4gICAgICBiZWZvcmVBdHRyaWJ1dGVVcGRhdGVkOiBub09wLFxuICAgIH0sXG4gICAgaGVhZDoge1xuICAgICAgc3R5bGU6IFwibWVyZ2VcIixcbiAgICAgIHNob3VsZFByZXNlcnZlOiAoZWx0KSA9PiBlbHQuZ2V0QXR0cmlidXRlKFwiaW0tcHJlc2VydmVcIikgPT09IFwidHJ1ZVwiLFxuICAgICAgc2hvdWxkUmVBcHBlbmQ6IChlbHQpID0+IGVsdC5nZXRBdHRyaWJ1dGUoXCJpbS1yZS1hcHBlbmRcIikgPT09IFwidHJ1ZVwiLFxuICAgICAgc2hvdWxkUmVtb3ZlOiBub09wLFxuICAgICAgYWZ0ZXJIZWFkTW9ycGhlZDogbm9PcCxcbiAgICB9LFxuICAgIHJlc3RvcmVGb2N1czogdHJ1ZSxcbiAgfTtcblxuICAvKipcbiAgICogQ29yZSBpZGlvbW9ycGggZnVuY3Rpb24gZm9yIG1vcnBoaW5nIG9uZSBET00gdHJlZSB0byBhbm90aGVyXG4gICAqXG4gICAqIEBwYXJhbSB7RWxlbWVudCB8IERvY3VtZW50fSBvbGROb2RlXG4gICAqIEBwYXJhbSB7RWxlbWVudCB8IE5vZGUgfCBIVE1MQ29sbGVjdGlvbiB8IE5vZGVbXSB8IHN0cmluZyB8IG51bGx9IG5ld0NvbnRlbnRcbiAgICogQHBhcmFtIHtDb25maWd9IFtjb25maWddXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPE5vZGVbXT4gfCBOb2RlW119XG4gICAqL1xuICBmdW5jdGlvbiBtb3JwaChvbGROb2RlLCBuZXdDb250ZW50LCBjb25maWcgPSB7fSkge1xuICAgIG9sZE5vZGUgPSBub3JtYWxpemVFbGVtZW50KG9sZE5vZGUpO1xuICAgIGNvbnN0IG5ld05vZGUgPSBub3JtYWxpemVQYXJlbnQobmV3Q29udGVudCk7XG4gICAgY29uc3QgY3R4ID0gY3JlYXRlTW9ycGhDb250ZXh0KG9sZE5vZGUsIG5ld05vZGUsIGNvbmZpZyk7XG5cbiAgICBjb25zdCBtb3JwaGVkTm9kZXMgPSBzYXZlQW5kUmVzdG9yZUZvY3VzKGN0eCwgKCkgPT4ge1xuICAgICAgcmV0dXJuIHdpdGhIZWFkQmxvY2tpbmcoXG4gICAgICAgIGN0eCxcbiAgICAgICAgb2xkTm9kZSxcbiAgICAgICAgbmV3Tm9kZSxcbiAgICAgICAgLyoqIEBwYXJhbSB7TW9ycGhDb250ZXh0fSBjdHggKi8gKGN0eCkgPT4ge1xuICAgICAgICAgIGlmIChjdHgubW9ycGhTdHlsZSA9PT0gXCJpbm5lckhUTUxcIikge1xuICAgICAgICAgICAgbW9ycGhDaGlsZHJlbihjdHgsIG9sZE5vZGUsIG5ld05vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIEFycmF5LmZyb20ob2xkTm9kZS5jaGlsZE5vZGVzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG1vcnBoT3V0ZXJIVE1MKGN0eCwgb2xkTm9kZSwgbmV3Tm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGN0eC5wYW50cnkucmVtb3ZlKCk7XG4gICAgcmV0dXJuIG1vcnBoZWROb2RlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3JwaCBqdXN0IHRoZSBvdXRlckhUTUwgb2YgdGhlIG9sZE5vZGUgdG8gdGhlIG5ld0NvbnRlbnRcbiAgICogV2UgaGF2ZSB0byBiZSBjYXJlZnVsIGJlY2F1c2UgdGhlIG9sZE5vZGUgY291bGQgaGF2ZSBzaWJsaW5ncyB3aGljaCBuZWVkIHRvIGJlIHVudG91Y2hlZFxuICAgKiBAcGFyYW0ge01vcnBoQ29udGV4dH0gY3R4XG4gICAqIEBwYXJhbSB7RWxlbWVudH0gb2xkTm9kZVxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5ld05vZGVcbiAgICogQHJldHVybnMge05vZGVbXX1cbiAgICovXG4gIGZ1bmN0aW9uIG1vcnBoT3V0ZXJIVE1MKGN0eCwgb2xkTm9kZSwgbmV3Tm9kZSkge1xuICAgIGNvbnN0IG9sZFBhcmVudCA9IG5vcm1hbGl6ZVBhcmVudChvbGROb2RlKTtcblxuICAgIC8vIGJhc2lzIGZvciBjYWx1bGF0aW5nIHdoaWNoIG5vZGVzIHdlcmUgbW9ycGhlZFxuICAgIC8vIHNpbmNlIHRoZXJlIG1heSBiZSB1bm1vcnBoZWQgc2libGluZyBub2Rlc1xuICAgIGxldCBjaGlsZE5vZGVzID0gQXJyYXkuZnJvbShvbGRQYXJlbnQuY2hpbGROb2Rlcyk7XG4gICAgY29uc3QgaW5kZXggPSBjaGlsZE5vZGVzLmluZGV4T2Yob2xkTm9kZSk7XG4gICAgLy8gaG93IG1hbnkgZWxlbWVudHMgYXJlIHRvIHRoZSByaWdodCBvZiB0aGUgb2xkTm9kZVxuICAgIGNvbnN0IHJpZ2h0TWFyZ2luID0gY2hpbGROb2Rlcy5sZW5ndGggLSAoaW5kZXggKyAxKTtcblxuICAgIG1vcnBoQ2hpbGRyZW4oXG4gICAgICBjdHgsXG4gICAgICBvbGRQYXJlbnQsXG4gICAgICBuZXdOb2RlLFxuICAgICAgLy8gdGhlc2UgdHdvIG9wdGlvbmFsIHBhcmFtcyBhcmUgdGhlIHNlY3JldCBzYXVjZVxuICAgICAgb2xkTm9kZSwgLy8gc3RhcnQgcG9pbnQgZm9yIGl0ZXJhdGlvblxuICAgICAgb2xkTm9kZS5uZXh0U2libGluZywgLy8gZW5kIHBvaW50IGZvciBpdGVyYXRpb25cbiAgICApO1xuXG4gICAgLy8gcmV0dXJuIGp1c3QgdGhlIG1vcnBoZWQgbm9kZXNcbiAgICBjaGlsZE5vZGVzID0gQXJyYXkuZnJvbShvbGRQYXJlbnQuY2hpbGROb2Rlcyk7XG4gICAgcmV0dXJuIGNoaWxkTm9kZXMuc2xpY2UoaW5kZXgsIGNoaWxkTm9kZXMubGVuZ3RoIC0gcmlnaHRNYXJnaW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7TW9ycGhDb250ZXh0fSBjdHhcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAgICogQHJldHVybnMge1Byb21pc2U8Tm9kZVtdPiB8IE5vZGVbXX1cbiAgICovXG4gIGZ1bmN0aW9uIHNhdmVBbmRSZXN0b3JlRm9jdXMoY3R4LCBmbikge1xuICAgIGlmICghY3R4LmNvbmZpZy5yZXN0b3JlRm9jdXMpIHJldHVybiBmbigpO1xuICAgIGxldCBhY3RpdmVFbGVtZW50ID1cbiAgICAgIC8qKiBAdHlwZSB7SFRNTElucHV0RWxlbWVudHxIVE1MVGV4dEFyZWFFbGVtZW50fG51bGx9ICovIChcbiAgICAgICAgZG9jdW1lbnQuYWN0aXZlRWxlbWVudFxuICAgICAgKTtcblxuICAgIC8vIGRvbid0IGJvdGhlciBpZiB0aGUgYWN0aXZlIGVsZW1lbnQgaXMgbm90IGFuIGlucHV0IG9yIHRleHRhcmVhXG4gICAgaWYgKFxuICAgICAgIShcbiAgICAgICAgYWN0aXZlRWxlbWVudCBpbnN0YW5jZW9mIEhUTUxJbnB1dEVsZW1lbnQgfHxcbiAgICAgICAgYWN0aXZlRWxlbWVudCBpbnN0YW5jZW9mIEhUTUxUZXh0QXJlYUVsZW1lbnRcbiAgICAgIClcbiAgICApIHtcbiAgICAgIHJldHVybiBmbigpO1xuICAgIH1cblxuICAgIGNvbnN0IHsgaWQ6IGFjdGl2ZUVsZW1lbnRJZCwgc2VsZWN0aW9uU3RhcnQsIHNlbGVjdGlvbkVuZCB9ID0gYWN0aXZlRWxlbWVudDtcblxuICAgIGNvbnN0IHJlc3VsdHMgPSBmbigpO1xuXG4gICAgaWYgKGFjdGl2ZUVsZW1lbnRJZCAmJiBhY3RpdmVFbGVtZW50SWQgIT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ/LmlkKSB7XG4gICAgICBhY3RpdmVFbGVtZW50ID0gY3R4LnRhcmdldC5xdWVyeVNlbGVjdG9yKGAjJHthY3RpdmVFbGVtZW50SWR9YCk7XG4gICAgICBhY3RpdmVFbGVtZW50Py5mb2N1cygpO1xuICAgIH1cbiAgICBpZiAoYWN0aXZlRWxlbWVudCAmJiAhYWN0aXZlRWxlbWVudC5zZWxlY3Rpb25FbmQgJiYgc2VsZWN0aW9uRW5kKSB7XG4gICAgICBhY3RpdmVFbGVtZW50LnNldFNlbGVjdGlvblJhbmdlKHNlbGVjdGlvblN0YXJ0LCBzZWxlY3Rpb25FbmQpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG5cbiAgY29uc3QgbW9ycGhDaGlsZHJlbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyB0aGUgY29yZSBhbGdvcml0aG0gZm9yIG1hdGNoaW5nIHVwIGNoaWxkcmVuLiAgVGhlIGlkZWEgaXMgdG8gdXNlIGlkIHNldHMgdG8gdHJ5IHRvIG1hdGNoIHVwXG4gICAgICogbm9kZXMgYXMgZmFpdGhmdWxseSBhcyBwb3NzaWJsZS4gIFdlIGdyZWVkaWx5IG1hdGNoLCB3aGljaCBhbGxvd3MgdXMgdG8ga2VlcCB0aGUgYWxnb3JpdGhtIGZhc3QsIGJ1dFxuICAgICAqIGJ5IHVzaW5nIGlkIHNldHMsIHdlIGFyZSBhYmxlIHRvIGJldHRlciBtYXRjaCB1cCB3aXRoIGNvbnRlbnQgZGVlcGVyIGluIHRoZSBET00uXG4gICAgICpcbiAgICAgKiBCYXNpYyBhbGdvcml0aG06XG4gICAgICogLSBmb3IgZWFjaCBub2RlIGluIHRoZSBuZXcgY29udGVudDpcbiAgICAgKiAgIC0gc2VhcmNoIHNlbGYgYW5kIHNpYmxpbmdzIGZvciBhbiBpZCBzZXQgbWF0Y2gsIGZhbGxpbmcgYmFjayB0byBhIHNvZnQgbWF0Y2hcbiAgICAgKiAgIC0gaWYgbWF0Y2ggZm91bmRcbiAgICAgKiAgICAgLSByZW1vdmUgYW55IG5vZGVzIHVwIHRvIHRoZSBtYXRjaDpcbiAgICAgKiAgICAgICAtIHBhbnRyeSBwZXJzaXN0ZW50IG5vZGVzXG4gICAgICogICAgICAgLSBkZWxldGUgdGhlIHJlc3RcbiAgICAgKiAgICAgLSBtb3JwaCB0aGUgbWF0Y2hcbiAgICAgKiAgIC0gZWxzaWYgbm8gbWF0Y2ggZm91bmQsIGFuZCBub2RlIGlzIHBlcnNpc3RlbnRcbiAgICAgKiAgICAgLSBmaW5kIGl0cyBtYXRjaCBieSBxdWVyeWluZyB0aGUgb2xkIHJvb3QgKGZ1dHVyZSkgYW5kIHBhbnRyeSAocGFzdClcbiAgICAgKiAgICAgLSBtb3ZlIGl0IGFuZCBpdHMgY2hpbGRyZW4gaGVyZVxuICAgICAqICAgICAtIG1vcnBoIGl0XG4gICAgICogICAtIGVsc2VcbiAgICAgKiAgICAgLSBjcmVhdGUgYSBuZXcgbm9kZSBmcm9tIHNjcmF0Y2ggYXMgYSBsYXN0IHJlc3VsdFxuICAgICAqXG4gICAgICogQHBhcmFtIHtNb3JwaENvbnRleHR9IGN0eCB0aGUgbWVyZ2UgY29udGV4dFxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gb2xkUGFyZW50IHRoZSBvbGQgY29udGVudCB0aGF0IHdlIGFyZSBtZXJnaW5nIHRoZSBuZXcgY29udGVudCBpbnRvXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBuZXdQYXJlbnQgdGhlIHBhcmVudCBlbGVtZW50IG9mIHRoZSBuZXcgY29udGVudFxuICAgICAqIEBwYXJhbSB7Tm9kZXxudWxsfSBbaW5zZXJ0aW9uUG9pbnRdIHRoZSBwb2ludCBpbiB0aGUgRE9NIHdlIHN0YXJ0IG1vcnBoaW5nIGF0IChkZWZhdWx0cyB0byBmaXJzdCBjaGlsZClcbiAgICAgKiBAcGFyYW0ge05vZGV8bnVsbH0gW2VuZFBvaW50XSB0aGUgcG9pbnQgaW4gdGhlIERPTSB3ZSBzdG9wIG1vcnBoaW5nIGF0IChkZWZhdWx0cyB0byBhZnRlciBsYXN0IGNoaWxkKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1vcnBoQ2hpbGRyZW4oXG4gICAgICBjdHgsXG4gICAgICBvbGRQYXJlbnQsXG4gICAgICBuZXdQYXJlbnQsXG4gICAgICBpbnNlcnRpb25Qb2ludCA9IG51bGwsXG4gICAgICBlbmRQb2ludCA9IG51bGwsXG4gICAgKSB7XG4gICAgICAvLyBub3JtYWxpemVcbiAgICAgIGlmIChcbiAgICAgICAgb2xkUGFyZW50IGluc3RhbmNlb2YgSFRNTFRlbXBsYXRlRWxlbWVudCAmJlxuICAgICAgICBuZXdQYXJlbnQgaW5zdGFuY2VvZiBIVE1MVGVtcGxhdGVFbGVtZW50XG4gICAgICApIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZSB3ZSBjYW4gcHJldGVuZCB0aGUgRG9jdW1lbnRGcmFnbWVudCBpcyBhbiBFbGVtZW50XG4gICAgICAgIG9sZFBhcmVudCA9IG9sZFBhcmVudC5jb250ZW50O1xuICAgICAgICAvLyBAdHMtaWdub3JlIGRpdHRvXG4gICAgICAgIG5ld1BhcmVudCA9IG5ld1BhcmVudC5jb250ZW50O1xuICAgICAgfVxuICAgICAgaW5zZXJ0aW9uUG9pbnQgfHw9IG9sZFBhcmVudC5maXJzdENoaWxkO1xuXG4gICAgICAvLyBydW4gdGhyb3VnaCBhbGwgdGhlIG5ldyBjb250ZW50XG4gICAgICBmb3IgKGNvbnN0IG5ld0NoaWxkIG9mIG5ld1BhcmVudC5jaGlsZE5vZGVzKSB7XG4gICAgICAgIC8vIG9uY2Ugd2UgcmVhY2ggdGhlIGVuZCBvZiB0aGUgb2xkIHBhcmVudCBjb250ZW50IHNraXAgdG8gdGhlIGVuZCBhbmQgaW5zZXJ0IHRoZSByZXN0XG4gICAgICAgIGlmIChpbnNlcnRpb25Qb2ludCAmJiBpbnNlcnRpb25Qb2ludCAhPSBlbmRQb2ludCkge1xuICAgICAgICAgIGNvbnN0IGJlc3RNYXRjaCA9IGZpbmRCZXN0TWF0Y2goXG4gICAgICAgICAgICBjdHgsXG4gICAgICAgICAgICBuZXdDaGlsZCxcbiAgICAgICAgICAgIGluc2VydGlvblBvaW50LFxuICAgICAgICAgICAgZW5kUG9pbnQsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoYmVzdE1hdGNoKSB7XG4gICAgICAgICAgICAvLyBpZiB0aGUgbm9kZSB0byBtb3JwaCBpcyBub3QgYXQgdGhlIGluc2VydGlvbiBwb2ludCB0aGVuIHJlbW92ZS9tb3ZlIHVwIHRvIGl0XG4gICAgICAgICAgICBpZiAoYmVzdE1hdGNoICE9PSBpbnNlcnRpb25Qb2ludCkge1xuICAgICAgICAgICAgICByZW1vdmVOb2Rlc0JldHdlZW4oY3R4LCBpbnNlcnRpb25Qb2ludCwgYmVzdE1hdGNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1vcnBoTm9kZShiZXN0TWF0Y2gsIG5ld0NoaWxkLCBjdHgpO1xuICAgICAgICAgICAgaW5zZXJ0aW9uUG9pbnQgPSBiZXN0TWF0Y2gubmV4dFNpYmxpbmc7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aGUgbWF0Y2hpbmcgbm9kZSBpcyBlbHNld2hlcmUgaW4gdGhlIG9yaWdpbmFsIGNvbnRlbnRcbiAgICAgICAgaWYgKG5ld0NoaWxkIGluc3RhbmNlb2YgRWxlbWVudCAmJiBjdHgucGVyc2lzdGVudElkcy5oYXMobmV3Q2hpbGQuaWQpKSB7XG4gICAgICAgICAgLy8gbW92ZSBpdCBhbmQgYWxsIGl0cyBjaGlsZHJlbiBoZXJlIGFuZCBtb3JwaFxuICAgICAgICAgIGNvbnN0IG1vdmVkQ2hpbGQgPSBtb3ZlQmVmb3JlQnlJZChcbiAgICAgICAgICAgIG9sZFBhcmVudCxcbiAgICAgICAgICAgIG5ld0NoaWxkLmlkLFxuICAgICAgICAgICAgaW5zZXJ0aW9uUG9pbnQsXG4gICAgICAgICAgICBjdHgsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBtb3JwaE5vZGUobW92ZWRDaGlsZCwgbmV3Q2hpbGQsIGN0eCk7XG4gICAgICAgICAgaW5zZXJ0aW9uUG9pbnQgPSBtb3ZlZENoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbGFzdCByZXNvcnQ6IGluc2VydCB0aGUgbmV3IG5vZGUgZnJvbSBzY3JhdGNoXG4gICAgICAgIGNvbnN0IGluc2VydGVkTm9kZSA9IGNyZWF0ZU5vZGUoXG4gICAgICAgICAgb2xkUGFyZW50LFxuICAgICAgICAgIG5ld0NoaWxkLFxuICAgICAgICAgIGluc2VydGlvblBvaW50LFxuICAgICAgICAgIGN0eCxcbiAgICAgICAgKTtcbiAgICAgICAgLy8gY291bGQgYmUgbnVsbCBpZiBiZWZvcmVOb2RlQWRkZWQgcHJldmVudGVkIGluc2VydGlvblxuICAgICAgICBpZiAoaW5zZXJ0ZWROb2RlKSB7XG4gICAgICAgICAgaW5zZXJ0aW9uUG9pbnQgPSBpbnNlcnRlZE5vZGUubmV4dFNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gcmVtb3ZlIGFueSByZW1haW5pbmcgb2xkIG5vZGVzIHRoYXQgZGlkbid0IG1hdGNoIHVwIHdpdGggbmV3IGNvbnRlbnRcbiAgICAgIHdoaWxlIChpbnNlcnRpb25Qb2ludCAmJiBpbnNlcnRpb25Qb2ludCAhPSBlbmRQb2ludCkge1xuICAgICAgICBjb25zdCB0ZW1wTm9kZSA9IGluc2VydGlvblBvaW50O1xuICAgICAgICBpbnNlcnRpb25Qb2ludCA9IGluc2VydGlvblBvaW50Lm5leHRTaWJsaW5nO1xuICAgICAgICByZW1vdmVOb2RlKGN0eCwgdGVtcE5vZGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgcGVyZm9ybXMgdGhlIGFjdGlvbiBvZiBpbnNlcnRpbmcgYSBuZXcgbm9kZSB3aGlsZSBoYW5kbGluZyBzaXR1YXRpb25zIHdoZXJlIHRoZSBub2RlIGNvbnRhaW5zXG4gICAgICogZWxlbWVudHMgd2l0aCBwZXJzaXN0ZW50IGlkcyBhbmQgcG9zc2libGUgc3RhdGUgaW5mbyB3ZSBjYW4gc3RpbGwgcHJlc2VydmUgYnkgbW92aW5nIGluIGFuZCB0aGVuIG1vcnBoaW5nXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IG9sZFBhcmVudFxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbmV3Q2hpbGRcbiAgICAgKiBAcGFyYW0ge05vZGV8bnVsbH0gaW5zZXJ0aW9uUG9pbnRcbiAgICAgKiBAcGFyYW0ge01vcnBoQ29udGV4dH0gY3R4XG4gICAgICogQHJldHVybnMge05vZGV8bnVsbH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVOb2RlKG9sZFBhcmVudCwgbmV3Q2hpbGQsIGluc2VydGlvblBvaW50LCBjdHgpIHtcbiAgICAgIGlmIChjdHguY2FsbGJhY2tzLmJlZm9yZU5vZGVBZGRlZChuZXdDaGlsZCkgPT09IGZhbHNlKSByZXR1cm4gbnVsbDtcbiAgICAgIGlmIChjdHguaWRNYXAuaGFzKG5ld0NoaWxkKSkge1xuICAgICAgICAvLyBub2RlIGhhcyBjaGlsZHJlbiB3aXRoIGlkcyB3aXRoIHBvc3NpYmxlIHN0YXRlIHNvIGNyZWF0ZSBhIGR1bW15IGVsdCBvZiBzYW1lIHR5cGUgYW5kIGFwcGx5IGZ1bGwgbW9ycGggYWxnb3JpdGhtXG4gICAgICAgIGNvbnN0IG5ld0VtcHR5Q2hpbGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxuICAgICAgICAgIC8qKiBAdHlwZSB7RWxlbWVudH0gKi8gKG5ld0NoaWxkKS50YWdOYW1lLFxuICAgICAgICApO1xuICAgICAgICBvbGRQYXJlbnQuaW5zZXJ0QmVmb3JlKG5ld0VtcHR5Q2hpbGQsIGluc2VydGlvblBvaW50KTtcbiAgICAgICAgbW9ycGhOb2RlKG5ld0VtcHR5Q2hpbGQsIG5ld0NoaWxkLCBjdHgpO1xuICAgICAgICBjdHguY2FsbGJhY2tzLmFmdGVyTm9kZUFkZGVkKG5ld0VtcHR5Q2hpbGQpO1xuICAgICAgICByZXR1cm4gbmV3RW1wdHlDaGlsZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG9wdGltaXNhdGlvbjogbm8gaWQgc3RhdGUgdG8gcHJlc2VydmUgc28gd2UgY2FuIGp1c3QgaW5zZXJ0IGEgY2xvbmUgb2YgdGhlIG5ld0NoaWxkIGFuZCBpdHMgZGVzY2VuZGFudHNcbiAgICAgICAgY29uc3QgbmV3Q2xvbmVkQ2hpbGQgPSBkb2N1bWVudC5pbXBvcnROb2RlKG5ld0NoaWxkLCB0cnVlKTsgLy8gaW1wb3J0Tm9kZSB0byBub3QgbXV0YXRlIG5ld1BhcmVudFxuICAgICAgICBvbGRQYXJlbnQuaW5zZXJ0QmVmb3JlKG5ld0Nsb25lZENoaWxkLCBpbnNlcnRpb25Qb2ludCk7XG4gICAgICAgIGN0eC5jYWxsYmFja3MuYWZ0ZXJOb2RlQWRkZWQobmV3Q2xvbmVkQ2hpbGQpO1xuICAgICAgICByZXR1cm4gbmV3Q2xvbmVkQ2hpbGQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAgIC8vIE1hdGNoaW5nIEZ1bmN0aW9uc1xuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICBjb25zdCBmaW5kQmVzdE1hdGNoID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8qKlxuICAgICAgICogU2NhbnMgZm9yd2FyZCBmcm9tIHRoZSBzdGFydFBvaW50IHRvIHRoZSBlbmRQb2ludCBsb29raW5nIGZvciBhIG1hdGNoXG4gICAgICAgKiBmb3IgdGhlIG5vZGUuIEl0IGxvb2tzIGZvciBhbiBpZCBzZXQgbWF0Y2ggZmlyc3QsIHRoZW4gYSBzb2Z0IG1hdGNoLlxuICAgICAgICogV2UgYWJvcnQgc29mdG1hdGNoaW5nIGlmIHdlIGZpbmQgdHdvIGZ1dHVyZSBzb2Z0IG1hdGNoZXMsIHRvIHJlZHVjZSBjaHVybi5cbiAgICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgICAgICogQHBhcmFtIHtNb3JwaENvbnRleHR9IGN0eFxuICAgICAgICogQHBhcmFtIHtOb2RlIHwgbnVsbH0gc3RhcnRQb2ludFxuICAgICAgICogQHBhcmFtIHtOb2RlIHwgbnVsbH0gZW5kUG9pbnRcbiAgICAgICAqIEByZXR1cm5zIHtOb2RlIHwgbnVsbH1cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gZmluZEJlc3RNYXRjaChjdHgsIG5vZGUsIHN0YXJ0UG9pbnQsIGVuZFBvaW50KSB7XG4gICAgICAgIGxldCBzb2Z0TWF0Y2ggPSBudWxsO1xuICAgICAgICBsZXQgbmV4dFNpYmxpbmcgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgICBsZXQgc2libGluZ1NvZnRNYXRjaENvdW50ID0gMDtcblxuICAgICAgICBsZXQgY3Vyc29yID0gc3RhcnRQb2ludDtcbiAgICAgICAgd2hpbGUgKGN1cnNvciAmJiBjdXJzb3IgIT0gZW5kUG9pbnQpIHtcbiAgICAgICAgICAvLyBzb2Z0IG1hdGNoaW5nIGlzIGEgcHJlcmVxdWlzaXRlIGZvciBpZCBzZXQgbWF0Y2hpbmdcbiAgICAgICAgICBpZiAoaXNTb2Z0TWF0Y2goY3Vyc29yLCBub2RlKSkge1xuICAgICAgICAgICAgaWYgKGlzSWRTZXRNYXRjaChjdHgsIGN1cnNvciwgbm9kZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGN1cnNvcjsgLy8gZm91bmQgYW4gaWQgc2V0IG1hdGNoLCB3ZSdyZSBkb25lIVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyB3ZSBoYXZlbid0IHlldCBzYXZlZCBhIHNvZnQgbWF0Y2ggZmFsbGJhY2tcbiAgICAgICAgICAgIGlmIChzb2Z0TWF0Y2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gdGhlIGN1cnJlbnQgc29mdCBtYXRjaCB3aWxsIGhhcmQgbWF0Y2ggc29tZXRoaW5nIGVsc2UgaW4gdGhlIGZ1dHVyZSwgbGVhdmUgaXRcbiAgICAgICAgICAgICAgaWYgKCFjdHguaWRNYXAuaGFzKGN1cnNvcikpIHtcbiAgICAgICAgICAgICAgICAvLyBzYXZlIHRoaXMgYXMgdGhlIGZhbGxiYWNrIGlmIHdlIGdldCB0aHJvdWdoIHRoZSBsb29wIHdpdGhvdXQgZmluZGluZyBhIGhhcmQgbWF0Y2hcbiAgICAgICAgICAgICAgICBzb2Z0TWF0Y2ggPSBjdXJzb3I7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgc29mdE1hdGNoID09PSBudWxsICYmXG4gICAgICAgICAgICBuZXh0U2libGluZyAmJlxuICAgICAgICAgICAgaXNTb2Z0TWF0Y2goY3Vyc29yLCBuZXh0U2libGluZylcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIC8vIFRoZSBuZXh0IG5ldyBub2RlIGhhcyBhIHNvZnQgbWF0Y2ggd2l0aCB0aGlzIG5vZGUsIHNvXG4gICAgICAgICAgICAvLyBpbmNyZW1lbnQgdGhlIGNvdW50IG9mIGZ1dHVyZSBzb2Z0IG1hdGNoZXNcbiAgICAgICAgICAgIHNpYmxpbmdTb2Z0TWF0Y2hDb3VudCsrO1xuICAgICAgICAgICAgbmV4dFNpYmxpbmcgPSBuZXh0U2libGluZy5uZXh0U2libGluZztcblxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIHR3byBmdXR1cmUgc29mdCBtYXRjaGVzLCBibG9jayBzb2Z0IG1hdGNoaW5nIGZvciB0aGlzIG5vZGUgdG8gYWxsb3dcbiAgICAgICAgICAgIC8vIGZ1dHVyZSBzaWJsaW5ncyB0byBzb2Z0IG1hdGNoLiBUaGlzIGlzIHRvIHJlZHVjZSBjaHVybiBpbiB0aGUgRE9NIHdoZW4gYW4gZWxlbWVudFxuICAgICAgICAgICAgLy8gaXMgcHJlcGVuZGVkLlxuICAgICAgICAgICAgaWYgKHNpYmxpbmdTb2Z0TWF0Y2hDb3VudCA+PSAyKSB7XG4gICAgICAgICAgICAgIHNvZnRNYXRjaCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBpZiB0aGUgY3VycmVudCBub2RlIGNvbnRhaW5zIGFjdGl2ZSBlbGVtZW50LCBzdG9wIGxvb2tpbmcgZm9yIGJldHRlciBmdXR1cmUgbWF0Y2hlcyxcbiAgICAgICAgICAvLyBiZWNhdXNlIGlmIG9uZSBpcyBmb3VuZCwgdGhpcyBub2RlIHdpbGwgYmUgbW92ZWQgdG8gdGhlIHBhbnRyeSwgcmVwYXJlbnRpbmcgaXQgYW5kIHRodXMgbG9zaW5nIGZvY3VzXG4gICAgICAgICAgaWYgKGN1cnNvci5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KSkgYnJlYWs7XG5cbiAgICAgICAgICBjdXJzb3IgPSBjdXJzb3IubmV4dFNpYmxpbmc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gc29mdE1hdGNoIHx8IG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8qKlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7TW9ycGhDb250ZXh0fSBjdHhcbiAgICAgICAqIEBwYXJhbSB7Tm9kZX0gb2xkTm9kZVxuICAgICAgICogQHBhcmFtIHtOb2RlfSBuZXdOb2RlXG4gICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24gaXNJZFNldE1hdGNoKGN0eCwgb2xkTm9kZSwgbmV3Tm9kZSkge1xuICAgICAgICBsZXQgb2xkU2V0ID0gY3R4LmlkTWFwLmdldChvbGROb2RlKTtcbiAgICAgICAgbGV0IG5ld1NldCA9IGN0eC5pZE1hcC5nZXQobmV3Tm9kZSk7XG5cbiAgICAgICAgaWYgKCFuZXdTZXQgfHwgIW9sZFNldCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAgIGZvciAoY29uc3QgaWQgb2Ygb2xkU2V0KSB7XG4gICAgICAgICAgLy8gYSBwb3RlbnRpYWwgbWF0Y2ggaXMgYW4gaWQgaW4gdGhlIG5ldyBhbmQgb2xkIG5vZGVzIHRoYXRcbiAgICAgICAgICAvLyBoYXMgbm90IGFscmVhZHkgYmVlbiBtZXJnZWQgaW50byB0aGUgRE9NXG4gICAgICAgICAgLy8gQnV0IHRoZSBuZXdOb2RlIGNvbnRlbnQgd2UgY2FsbCB0aGlzIG9uIGhhcyBub3QgYmVlblxuICAgICAgICAgIC8vIG1lcmdlZCB5ZXQgYW5kIHdlIGRvbid0IGFsbG93IGR1cGxpY2F0ZSBJRHMgc28gaXQgaXMgc2ltcGxlXG4gICAgICAgICAgaWYgKG5ld1NldC5oYXMoaWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvKipcbiAgICAgICAqXG4gICAgICAgKiBAcGFyYW0ge05vZGV9IG9sZE5vZGVcbiAgICAgICAqIEBwYXJhbSB7Tm9kZX0gbmV3Tm9kZVxuICAgICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIGlzU29mdE1hdGNoKG9sZE5vZGUsIG5ld05vZGUpIHtcbiAgICAgICAgLy8gb2sgdG8gY2FzdDogaWYgb25lIGlzIG5vdCBlbGVtZW50LCBgaWRgIGFuZCBgdGFnTmFtZWAgd2lsbCBiZSB1bmRlZmluZWQgYW5kIHdlJ2xsIGp1c3QgY29tcGFyZSB0aGF0LlxuICAgICAgICBjb25zdCBvbGRFbHQgPSAvKiogQHR5cGUge0VsZW1lbnR9ICovIChvbGROb2RlKTtcbiAgICAgICAgY29uc3QgbmV3RWx0ID0gLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAobmV3Tm9kZSk7XG5cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBvbGRFbHQubm9kZVR5cGUgPT09IG5ld0VsdC5ub2RlVHlwZSAmJlxuICAgICAgICAgIG9sZEVsdC50YWdOYW1lID09PSBuZXdFbHQudGFnTmFtZSAmJlxuICAgICAgICAgIC8vIElmIG9sZEVsdCBoYXMgYW4gYGlkYCB3aXRoIHBvc3NpYmxlIHN0YXRlIGFuZCBpdCBkb2Vzbid0IG1hdGNoIG5ld0VsdC5pZCB0aGVuIGF2b2lkIG1vcnBoaW5nLlxuICAgICAgICAgIC8vIFdlJ2xsIHN0aWxsIG1hdGNoIGFuIGFub255bW91cyBub2RlIHdpdGggYW4gSURlZCBuZXdFbHQsIHRob3VnaCwgYmVjYXVzZSBpZiBpdCBnb3QgdGhpcyBmYXIsXG4gICAgICAgICAgLy8gaXRzIG5vdCBwZXJzaXN0ZW50LCBhbmQgbmV3IG5vZGVzIGNhbid0IGhhdmUgYW55IGhpZGRlbiBzdGF0ZS5cbiAgICAgICAgICAoIW9sZEVsdC5pZCB8fCBvbGRFbHQuaWQgPT09IG5ld0VsdC5pZClcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZpbmRCZXN0TWF0Y2g7XG4gICAgfSkoKTtcblxuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgICAvLyBET00gTWFuaXB1bGF0aW9uIEZ1bmN0aW9uc1xuICAgIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAgIC8qKlxuICAgICAqIEdldHMgcmlkIG9mIGFuIHVud2FudGVkIERPTSBub2RlOyBzdHJhdGVneSBkZXBlbmRzIG9uIG5hdHVyZSBvZiBpdHMgcmV1c2U6XG4gICAgICogLSBQZXJzaXN0ZW50IG5vZGVzIHdpbGwgYmUgbW92ZWQgdG8gdGhlIHBhbnRyeSBmb3IgbGF0ZXIgcmV1c2VcbiAgICAgKiAtIE90aGVyIG5vZGVzIHdpbGwgaGF2ZSB0aGVpciBob29rcyBjYWxsZWQsIGFuZCB0aGVuIGFyZSByZW1vdmVkXG4gICAgICogQHBhcmFtIHtNb3JwaENvbnRleHR9IGN0eFxuICAgICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlbW92ZU5vZGUoY3R4LCBub2RlKSB7XG4gICAgICAvLyBhcmUgd2UgZ29pbmcgdG8gaWQgc2V0IG1hdGNoIHRoaXMgbGF0ZXI/XG4gICAgICBpZiAoY3R4LmlkTWFwLmhhcyhub2RlKSkge1xuICAgICAgICAvLyBza2lwIGNhbGxiYWNrcyBhbmQgbW92ZSB0byBwYW50cnlcbiAgICAgICAgbW92ZUJlZm9yZShjdHgucGFudHJ5LCBub2RlLCBudWxsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJlbW92ZSBmb3IgcmVhbHNpZXNcbiAgICAgICAgaWYgKGN0eC5jYWxsYmFja3MuYmVmb3JlTm9kZVJlbW92ZWQobm9kZSkgPT09IGZhbHNlKSByZXR1cm47XG4gICAgICAgIG5vZGUucGFyZW50Tm9kZT8ucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICAgIGN0eC5jYWxsYmFja3MuYWZ0ZXJOb2RlUmVtb3ZlZChub2RlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgbm9kZXMgYmV0d2VlbiB0aGUgc3RhcnQgYW5kIGVuZCBub2Rlc1xuICAgICAqIEBwYXJhbSB7TW9ycGhDb250ZXh0fSBjdHhcbiAgICAgKiBAcGFyYW0ge05vZGV9IHN0YXJ0SW5jbHVzaXZlXG4gICAgICogQHBhcmFtIHtOb2RlfSBlbmRFeGNsdXNpdmVcbiAgICAgKiBAcmV0dXJucyB7Tm9kZXxudWxsfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlbW92ZU5vZGVzQmV0d2VlbihjdHgsIHN0YXJ0SW5jbHVzaXZlLCBlbmRFeGNsdXNpdmUpIHtcbiAgICAgIC8qKiBAdHlwZSB7Tm9kZSB8IG51bGx9ICovXG4gICAgICBsZXQgY3Vyc29yID0gc3RhcnRJbmNsdXNpdmU7XG4gICAgICAvLyByZW1vdmUgbm9kZXMgdW50aWwgdGhlIGVuZEV4Y2x1c2l2ZSBub2RlXG4gICAgICB3aGlsZSAoY3Vyc29yICYmIGN1cnNvciAhPT0gZW5kRXhjbHVzaXZlKSB7XG4gICAgICAgIGxldCB0ZW1wTm9kZSA9IC8qKiBAdHlwZSB7Tm9kZX0gKi8gKGN1cnNvcik7XG4gICAgICAgIGN1cnNvciA9IGN1cnNvci5uZXh0U2libGluZztcbiAgICAgICAgcmVtb3ZlTm9kZShjdHgsIHRlbXBOb2RlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjdXJzb3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VhcmNoIGZvciBhbiBlbGVtZW50IGJ5IGlkIHdpdGhpbiB0aGUgZG9jdW1lbnQgYW5kIHBhbnRyeSwgYW5kIG1vdmUgaXQgdXNpbmcgbW92ZUJlZm9yZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gcGFyZW50Tm9kZSAtIFRoZSBwYXJlbnQgbm9kZSB0byB3aGljaCB0aGUgZWxlbWVudCB3aWxsIGJlIG1vdmVkLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZCAtIFRoZSBJRCBvZiB0aGUgZWxlbWVudCB0byBiZSBtb3ZlZC5cbiAgICAgKiBAcGFyYW0ge05vZGUgfCBudWxsfSBhZnRlciAtIFRoZSByZWZlcmVuY2Ugbm9kZSB0byBpbnNlcnQgdGhlIGVsZW1lbnQgYmVmb3JlLlxuICAgICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgYG51bGxgLCB0aGUgZWxlbWVudCBpcyBhcHBlbmRlZCBhcyB0aGUgbGFzdCBjaGlsZC5cbiAgICAgKiBAcGFyYW0ge01vcnBoQ29udGV4dH0gY3R4XG4gICAgICogQHJldHVybnMge0VsZW1lbnR9IFRoZSBmb3VuZCBlbGVtZW50XG4gICAgICovXG4gICAgZnVuY3Rpb24gbW92ZUJlZm9yZUJ5SWQocGFyZW50Tm9kZSwgaWQsIGFmdGVyLCBjdHgpIHtcbiAgICAgIGNvbnN0IHRhcmdldCA9XG4gICAgICAgIC8qKiBAdHlwZSB7RWxlbWVudH0gLSB3aWxsIGFsd2F5cyBiZSBmb3VuZCAqL1xuICAgICAgICAoXG4gICAgICAgICAgY3R4LnRhcmdldC5xdWVyeVNlbGVjdG9yKGAjJHtpZH1gKSB8fFxuICAgICAgICAgICAgY3R4LnBhbnRyeS5xdWVyeVNlbGVjdG9yKGAjJHtpZH1gKVxuICAgICAgICApO1xuICAgICAgcmVtb3ZlRWxlbWVudEZyb21BbmNlc3RvcnNJZE1hcHModGFyZ2V0LCBjdHgpO1xuICAgICAgbW92ZUJlZm9yZShwYXJlbnROb2RlLCB0YXJnZXQsIGFmdGVyKTtcbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbiBlbGVtZW50IGZyb20gaXRzIGFuY2VzdG9ycycgaWQgbWFwcy4gVGhpcyBpcyBuZWVkZWQgd2hlbiBhbiBlbGVtZW50IGlzIG1vdmVkIGZyb20gdGhlXG4gICAgICogXCJmdXR1cmVcIiB2aWEgYG1vdmVCZWZvcmVJZGAuIE90aGVyd2lzZSwgaXRzIGVyc3R3aGlsZSBhbmNlc3RvcnMgY291bGQgYmUgbWlzdGFrZW5seSBtb3ZlZCB0byB0aGVcbiAgICAgKiBwYW50cnkgcmF0aGVyIHRoYW4gYmVpbmcgZGVsZXRlZCwgcHJldmVudGluZyB0aGVpciByZW1vdmFsIGhvb2tzIGZyb20gYmVpbmcgY2FsbGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC0gZWxlbWVudCB0byByZW1vdmUgZnJvbSBpdHMgYW5jZXN0b3JzJyBpZCBtYXBzXG4gICAgICogQHBhcmFtIHtNb3JwaENvbnRleHR9IGN0eFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlbW92ZUVsZW1lbnRGcm9tQW5jZXN0b3JzSWRNYXBzKGVsZW1lbnQsIGN0eCkge1xuICAgICAgY29uc3QgaWQgPSBlbGVtZW50LmlkO1xuICAgICAgLyoqIEB0cy1pZ25vcmUgLSBzYWZlIHRvIGxvb3AgaW4gdGhpcyB3YXkgKiovXG4gICAgICB3aGlsZSAoKGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGUpKSB7XG4gICAgICAgIGxldCBpZFNldCA9IGN0eC5pZE1hcC5nZXQoZWxlbWVudCk7XG4gICAgICAgIGlmIChpZFNldCkge1xuICAgICAgICAgIGlkU2V0LmRlbGV0ZShpZCk7XG4gICAgICAgICAgaWYgKCFpZFNldC5zaXplKSB7XG4gICAgICAgICAgICBjdHguaWRNYXAuZGVsZXRlKGVsZW1lbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1vdmVzIGFuIGVsZW1lbnQgYmVmb3JlIGFub3RoZXIgZWxlbWVudCB3aXRoaW4gdGhlIHNhbWUgcGFyZW50LlxuICAgICAqIFVzZXMgdGhlIHByb3Bvc2VkIGBtb3ZlQmVmb3JlYCBBUEkgaWYgYXZhaWxhYmxlIChhbmQgd29ya2luZyksIG90aGVyd2lzZSBmYWxscyBiYWNrIHRvIGBpbnNlcnRCZWZvcmVgLlxuICAgICAqIFRoaXMgaXMgZXNzZW50aWFseSBhIGZvcndhcmQtY29tcGF0IHdyYXBwZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IHBhcmVudE5vZGUgLSBUaGUgcGFyZW50IG5vZGUgY29udGFpbmluZyB0aGUgYWZ0ZXIgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge05vZGV9IGVsZW1lbnQgLSBUaGUgZWxlbWVudCB0byBiZSBtb3ZlZC5cbiAgICAgKiBAcGFyYW0ge05vZGUgfCBudWxsfSBhZnRlciAtIFRoZSByZWZlcmVuY2Ugbm9kZSB0byBpbnNlcnQgYGVsZW1lbnRgIGJlZm9yZS5cbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIGBudWxsYCwgYGVsZW1lbnRgIGlzIGFwcGVuZGVkIGFzIHRoZSBsYXN0IGNoaWxkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1vdmVCZWZvcmUocGFyZW50Tm9kZSwgZWxlbWVudCwgYWZ0ZXIpIHtcbiAgICAgIC8vIEB0cy1pZ25vcmUgLSB1c2UgcHJvcG9zZWQgbW92ZUJlZm9yZSBmZWF0dXJlXG4gICAgICBpZiAocGFyZW50Tm9kZS5tb3ZlQmVmb3JlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gQHRzLWlnbm9yZSAtIHVzZSBwcm9wb3NlZCBtb3ZlQmVmb3JlIGZlYXR1cmVcbiAgICAgICAgICBwYXJlbnROb2RlLm1vdmVCZWZvcmUoZWxlbWVudCwgYWZ0ZXIpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gZmFsbCBiYWNrIHRvIGluc2VydEJlZm9yZSBhcyBzb21lIGJyb3dzZXJzIG1heSBmYWlsIG9uIG1vdmVCZWZvcmUgd2hlbiB0cnlpbmcgdG8gbW92ZSBEb20gZGlzY29ubmVjdGVkIG5vZGVzIHRvIHBhbnRyeVxuICAgICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsZW1lbnQsIGFmdGVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWxlbWVudCwgYWZ0ZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBtb3JwaENoaWxkcmVuO1xuICB9KSgpO1xuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gU2luZ2xlIE5vZGUgTW9ycGhpbmcgQ29kZVxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIGNvbnN0IG1vcnBoTm9kZSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtOb2RlfSBvbGROb2RlIHJvb3Qgbm9kZSB0byBtZXJnZSBjb250ZW50IGludG9cbiAgICAgKiBAcGFyYW0ge05vZGV9IG5ld0NvbnRlbnQgbmV3IGNvbnRlbnQgdG8gbWVyZ2VcbiAgICAgKiBAcGFyYW0ge01vcnBoQ29udGV4dH0gY3R4IHRoZSBtZXJnZSBjb250ZXh0XG4gICAgICogQHJldHVybnMge05vZGUgfCBudWxsfSB0aGUgZWxlbWVudCB0aGF0IGVuZGVkIHVwIGluIHRoZSBET01cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtb3JwaE5vZGUob2xkTm9kZSwgbmV3Q29udGVudCwgY3R4KSB7XG4gICAgICBpZiAoY3R4Lmlnbm9yZUFjdGl2ZSAmJiBvbGROb2RlID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50KSB7XG4gICAgICAgIC8vIGRvbid0IG1vcnBoIGZvY3VzZWQgZWxlbWVudFxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKGN0eC5jYWxsYmFja3MuYmVmb3JlTm9kZU1vcnBoZWQob2xkTm9kZSwgbmV3Q29udGVudCkgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBvbGROb2RlO1xuICAgICAgfVxuXG4gICAgICBpZiAob2xkTm9kZSBpbnN0YW5jZW9mIEhUTUxIZWFkRWxlbWVudCAmJiBjdHguaGVhZC5pZ25vcmUpIDsgZWxzZSBpZiAoXG4gICAgICAgIG9sZE5vZGUgaW5zdGFuY2VvZiBIVE1MSGVhZEVsZW1lbnQgJiZcbiAgICAgICAgY3R4LmhlYWQuc3R5bGUgIT09IFwibW9ycGhcIlxuICAgICAgKSB7XG4gICAgICAgIC8vIG9rIHRvIGNhc3Q6IGlmIG5ld0NvbnRlbnQgd2Fzbid0IGFsc28gYSA8aGVhZD4sIGl0IHdvdWxkJ3ZlIGdvdCBjYXVnaHQgaW4gdGhlIGAhaXNTb2Z0TWF0Y2hgIGJyYW5jaCBhYm92ZVxuICAgICAgICBoYW5kbGVIZWFkRWxlbWVudChcbiAgICAgICAgICBvbGROb2RlLFxuICAgICAgICAgIC8qKiBAdHlwZSB7SFRNTEhlYWRFbGVtZW50fSAqLyAobmV3Q29udGVudCksXG4gICAgICAgICAgY3R4LFxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbW9ycGhBdHRyaWJ1dGVzKG9sZE5vZGUsIG5ld0NvbnRlbnQsIGN0eCk7XG4gICAgICAgIGlmICghaWdub3JlVmFsdWVPZkFjdGl2ZUVsZW1lbnQob2xkTm9kZSwgY3R4KSkge1xuICAgICAgICAgIC8vIEB0cy1pZ25vcmUgbmV3Q29udGVudCBjYW4gYmUgYSBub2RlIGhlcmUgYmVjYXVzZSAuZmlyc3RDaGlsZCB3aWxsIGJlIG51bGxcbiAgICAgICAgICBtb3JwaENoaWxkcmVuKGN0eCwgb2xkTm9kZSwgbmV3Q29udGVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGN0eC5jYWxsYmFja3MuYWZ0ZXJOb2RlTW9ycGhlZChvbGROb2RlLCBuZXdDb250ZW50KTtcbiAgICAgIHJldHVybiBvbGROb2RlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHN5bmNzIHRoZSBvbGROb2RlIHRvIHRoZSBuZXdOb2RlLCBjb3B5aW5nIG92ZXIgYWxsIGF0dHJpYnV0ZXMgYW5kXG4gICAgICogaW5uZXIgZWxlbWVudCBzdGF0ZSBmcm9tIHRoZSBuZXdOb2RlIHRvIHRoZSBvbGROb2RlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IG9sZE5vZGUgdGhlIG5vZGUgdG8gY29weSBhdHRyaWJ1dGVzICYgc3RhdGUgdG9cbiAgICAgKiBAcGFyYW0ge05vZGV9IG5ld05vZGUgdGhlIG5vZGUgdG8gY29weSBhdHRyaWJ1dGVzICYgc3RhdGUgZnJvbVxuICAgICAqIEBwYXJhbSB7TW9ycGhDb250ZXh0fSBjdHggdGhlIG1lcmdlIGNvbnRleHRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtb3JwaEF0dHJpYnV0ZXMob2xkTm9kZSwgbmV3Tm9kZSwgY3R4KSB7XG4gICAgICBsZXQgdHlwZSA9IG5ld05vZGUubm9kZVR5cGU7XG5cbiAgICAgIC8vIGlmIGlzIGFuIGVsZW1lbnQgdHlwZSwgc3luYyB0aGUgYXR0cmlidXRlcyBmcm9tIHRoZVxuICAgICAgLy8gbmV3IG5vZGUgaW50byB0aGUgbmV3IG5vZGVcbiAgICAgIGlmICh0eXBlID09PSAxIC8qIGVsZW1lbnQgdHlwZSAqLykge1xuICAgICAgICBjb25zdCBvbGRFbHQgPSAvKiogQHR5cGUge0VsZW1lbnR9ICovIChvbGROb2RlKTtcbiAgICAgICAgY29uc3QgbmV3RWx0ID0gLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAobmV3Tm9kZSk7XG5cbiAgICAgICAgY29uc3Qgb2xkQXR0cmlidXRlcyA9IG9sZEVsdC5hdHRyaWJ1dGVzO1xuICAgICAgICBjb25zdCBuZXdBdHRyaWJ1dGVzID0gbmV3RWx0LmF0dHJpYnV0ZXM7XG4gICAgICAgIGZvciAoY29uc3QgbmV3QXR0cmlidXRlIG9mIG5ld0F0dHJpYnV0ZXMpIHtcbiAgICAgICAgICBpZiAoaWdub3JlQXR0cmlidXRlKG5ld0F0dHJpYnV0ZS5uYW1lLCBvbGRFbHQsIFwidXBkYXRlXCIsIGN0eCkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob2xkRWx0LmdldEF0dHJpYnV0ZShuZXdBdHRyaWJ1dGUubmFtZSkgIT09IG5ld0F0dHJpYnV0ZS52YWx1ZSkge1xuICAgICAgICAgICAgb2xkRWx0LnNldEF0dHJpYnV0ZShuZXdBdHRyaWJ1dGUubmFtZSwgbmV3QXR0cmlidXRlLnZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gaXRlcmF0ZSBiYWNrd2FyZHMgdG8gYXZvaWQgc2tpcHBpbmcgb3ZlciBpdGVtcyB3aGVuIGEgZGVsZXRlIG9jY3Vyc1xuICAgICAgICBmb3IgKGxldCBpID0gb2xkQXR0cmlidXRlcy5sZW5ndGggLSAxOyAwIDw9IGk7IGktLSkge1xuICAgICAgICAgIGNvbnN0IG9sZEF0dHJpYnV0ZSA9IG9sZEF0dHJpYnV0ZXNbaV07XG5cbiAgICAgICAgICAvLyB0b0F0dHJpYnV0ZXMgaXMgYSBsaXZlIE5hbWVkTm9kZU1hcCwgc28gaXRlcmF0aW9uK211dGF0aW9uIGlzIHVuc2FmZVxuICAgICAgICAgIC8vIGUuZy4gY3VzdG9tIGVsZW1lbnQgYXR0cmlidXRlIGNhbGxiYWNrcyBjYW4gcmVtb3ZlIG90aGVyIGF0dHJpYnV0ZXNcbiAgICAgICAgICBpZiAoIW9sZEF0dHJpYnV0ZSkgY29udGludWU7XG5cbiAgICAgICAgICBpZiAoIW5ld0VsdC5oYXNBdHRyaWJ1dGUob2xkQXR0cmlidXRlLm5hbWUpKSB7XG4gICAgICAgICAgICBpZiAoaWdub3JlQXR0cmlidXRlKG9sZEF0dHJpYnV0ZS5uYW1lLCBvbGRFbHQsIFwicmVtb3ZlXCIsIGN0eCkpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvbGRFbHQucmVtb3ZlQXR0cmlidXRlKG9sZEF0dHJpYnV0ZS5uYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlnbm9yZVZhbHVlT2ZBY3RpdmVFbGVtZW50KG9sZEVsdCwgY3R4KSkge1xuICAgICAgICAgIHN5bmNJbnB1dFZhbHVlKG9sZEVsdCwgbmV3RWx0LCBjdHgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHN5bmMgdGV4dCBub2Rlc1xuICAgICAgaWYgKHR5cGUgPT09IDggLyogY29tbWVudCAqLyB8fCB0eXBlID09PSAzIC8qIHRleHQgKi8pIHtcbiAgICAgICAgaWYgKG9sZE5vZGUubm9kZVZhbHVlICE9PSBuZXdOb2RlLm5vZGVWYWx1ZSkge1xuICAgICAgICAgIG9sZE5vZGUubm9kZVZhbHVlID0gbmV3Tm9kZS5ub2RlVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBOQjogbWFueSBib3RoYW5zIGRpZWQgdG8gYnJpbmcgdXMgaW5mb3JtYXRpb246XG4gICAgICpcbiAgICAgKiAgaHR0cHM6Ly9naXRodWIuY29tL3BhdHJpY2stc3RlZWxlLWlkZW0vbW9ycGhkb20vYmxvYi9tYXN0ZXIvc3JjL3NwZWNpYWxFbEhhbmRsZXJzLmpzXG4gICAgICogIGh0dHBzOi8vZ2l0aHViLmNvbS9jaG9vanMvbmFub21vcnBoL2Jsb2IvbWFzdGVyL2xpYi9tb3JwaC5qc0wxMTNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gb2xkRWxlbWVudCB0aGUgZWxlbWVudCB0byBzeW5jIHRoZSBpbnB1dCB2YWx1ZSB0b1xuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gbmV3RWxlbWVudCB0aGUgZWxlbWVudCB0byBzeW5jIHRoZSBpbnB1dCB2YWx1ZSBmcm9tXG4gICAgICogQHBhcmFtIHtNb3JwaENvbnRleHR9IGN0eCB0aGUgbWVyZ2UgY29udGV4dFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN5bmNJbnB1dFZhbHVlKG9sZEVsZW1lbnQsIG5ld0VsZW1lbnQsIGN0eCkge1xuICAgICAgaWYgKFxuICAgICAgICBvbGRFbGVtZW50IGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCAmJlxuICAgICAgICBuZXdFbGVtZW50IGluc3RhbmNlb2YgSFRNTElucHV0RWxlbWVudCAmJlxuICAgICAgICBuZXdFbGVtZW50LnR5cGUgIT09IFwiZmlsZVwiXG4gICAgICApIHtcbiAgICAgICAgbGV0IG5ld1ZhbHVlID0gbmV3RWxlbWVudC52YWx1ZTtcbiAgICAgICAgbGV0IG9sZFZhbHVlID0gb2xkRWxlbWVudC52YWx1ZTtcblxuICAgICAgICAvLyBzeW5jIGJvb2xlYW4gYXR0cmlidXRlc1xuICAgICAgICBzeW5jQm9vbGVhbkF0dHJpYnV0ZShvbGRFbGVtZW50LCBuZXdFbGVtZW50LCBcImNoZWNrZWRcIiwgY3R4KTtcbiAgICAgICAgc3luY0Jvb2xlYW5BdHRyaWJ1dGUob2xkRWxlbWVudCwgbmV3RWxlbWVudCwgXCJkaXNhYmxlZFwiLCBjdHgpO1xuXG4gICAgICAgIGlmICghbmV3RWxlbWVudC5oYXNBdHRyaWJ1dGUoXCJ2YWx1ZVwiKSkge1xuICAgICAgICAgIGlmICghaWdub3JlQXR0cmlidXRlKFwidmFsdWVcIiwgb2xkRWxlbWVudCwgXCJyZW1vdmVcIiwgY3R4KSkge1xuICAgICAgICAgICAgb2xkRWxlbWVudC52YWx1ZSA9IFwiXCI7XG4gICAgICAgICAgICBvbGRFbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcInZhbHVlXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChvbGRWYWx1ZSAhPT0gbmV3VmFsdWUpIHtcbiAgICAgICAgICBpZiAoIWlnbm9yZUF0dHJpYnV0ZShcInZhbHVlXCIsIG9sZEVsZW1lbnQsIFwidXBkYXRlXCIsIGN0eCkpIHtcbiAgICAgICAgICAgIG9sZEVsZW1lbnQuc2V0QXR0cmlidXRlKFwidmFsdWVcIiwgbmV3VmFsdWUpO1xuICAgICAgICAgICAgb2xkRWxlbWVudC52YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOiBRVUVTVElPTigxY2cpOiB0aGlzIHVzZWQgdG8gb25seSBjaGVjayBgbmV3RWxlbWVudGAgdW5saWtlIHRoZSBvdGhlciBicmFuY2hlcyAtLSB3aHk/XG4gICAgICAgIC8vIGRpZCBJIGJyZWFrIHNvbWV0aGluZz9cbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIG9sZEVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MT3B0aW9uRWxlbWVudCAmJlxuICAgICAgICBuZXdFbGVtZW50IGluc3RhbmNlb2YgSFRNTE9wdGlvbkVsZW1lbnRcbiAgICAgICkge1xuICAgICAgICBzeW5jQm9vbGVhbkF0dHJpYnV0ZShvbGRFbGVtZW50LCBuZXdFbGVtZW50LCBcInNlbGVjdGVkXCIsIGN0eCk7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBvbGRFbGVtZW50IGluc3RhbmNlb2YgSFRNTFRleHRBcmVhRWxlbWVudCAmJlxuICAgICAgICBuZXdFbGVtZW50IGluc3RhbmNlb2YgSFRNTFRleHRBcmVhRWxlbWVudFxuICAgICAgKSB7XG4gICAgICAgIGxldCBuZXdWYWx1ZSA9IG5ld0VsZW1lbnQudmFsdWU7XG4gICAgICAgIGxldCBvbGRWYWx1ZSA9IG9sZEVsZW1lbnQudmFsdWU7XG4gICAgICAgIGlmIChpZ25vcmVBdHRyaWJ1dGUoXCJ2YWx1ZVwiLCBvbGRFbGVtZW50LCBcInVwZGF0ZVwiLCBjdHgpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXdWYWx1ZSAhPT0gb2xkVmFsdWUpIHtcbiAgICAgICAgICBvbGRFbGVtZW50LnZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFxuICAgICAgICAgIG9sZEVsZW1lbnQuZmlyc3RDaGlsZCAmJlxuICAgICAgICAgIG9sZEVsZW1lbnQuZmlyc3RDaGlsZC5ub2RlVmFsdWUgIT09IG5ld1ZhbHVlXG4gICAgICAgICkge1xuICAgICAgICAgIG9sZEVsZW1lbnQuZmlyc3RDaGlsZC5ub2RlVmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gb2xkRWxlbWVudCBlbGVtZW50IHRvIHdyaXRlIHRoZSB2YWx1ZSB0b1xuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gbmV3RWxlbWVudCBlbGVtZW50IHRvIHJlYWQgdGhlIHZhbHVlIGZyb21cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlTmFtZSB0aGUgYXR0cmlidXRlIG5hbWVcbiAgICAgKiBAcGFyYW0ge01vcnBoQ29udGV4dH0gY3R4IHRoZSBtZXJnZSBjb250ZXh0XG4gICAgICovXG4gICAgZnVuY3Rpb24gc3luY0Jvb2xlYW5BdHRyaWJ1dGUob2xkRWxlbWVudCwgbmV3RWxlbWVudCwgYXR0cmlidXRlTmFtZSwgY3R4KSB7XG4gICAgICAvLyBAdHMtaWdub3JlIHRoaXMgZnVuY3Rpb24gaXMgb25seSB1c2VkIG9uIGJvb2xlYW4gYXR0cnMgdGhhdCBhcmUgcmVmbGVjdGVkIGFzIGRvbSBwcm9wZXJ0aWVzXG4gICAgICBjb25zdCBuZXdMaXZlVmFsdWUgPSBuZXdFbGVtZW50W2F0dHJpYnV0ZU5hbWVdLFxuICAgICAgICAvLyBAdHMtaWdub3JlIGRpdHRvXG4gICAgICAgIG9sZExpdmVWYWx1ZSA9IG9sZEVsZW1lbnRbYXR0cmlidXRlTmFtZV07XG4gICAgICBpZiAobmV3TGl2ZVZhbHVlICE9PSBvbGRMaXZlVmFsdWUpIHtcbiAgICAgICAgY29uc3QgaWdub3JlVXBkYXRlID0gaWdub3JlQXR0cmlidXRlKFxuICAgICAgICAgIGF0dHJpYnV0ZU5hbWUsXG4gICAgICAgICAgb2xkRWxlbWVudCxcbiAgICAgICAgICBcInVwZGF0ZVwiLFxuICAgICAgICAgIGN0eCxcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKCFpZ25vcmVVcGRhdGUpIHtcbiAgICAgICAgICAvLyB1cGRhdGUgYXR0cmlidXRlJ3MgYXNzb2NpYXRlZCBET00gcHJvcGVydHlcbiAgICAgICAgICAvLyBAdHMtaWdub3JlIHRoaXMgZnVuY3Rpb24gaXMgb25seSB1c2VkIG9uIGJvb2xlYW4gYXR0cnMgdGhhdCBhcmUgcmVmbGVjdGVkIGFzIGRvbSBwcm9wZXJ0aWVzXG4gICAgICAgICAgb2xkRWxlbWVudFthdHRyaWJ1dGVOYW1lXSA9IG5ld0VsZW1lbnRbYXR0cmlidXRlTmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld0xpdmVWYWx1ZSkge1xuICAgICAgICAgIGlmICghaWdub3JlVXBkYXRlKSB7XG4gICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0dsb3NzYXJ5L0Jvb2xlYW4vSFRNTFxuICAgICAgICAgICAgLy8gdGhpcyBpcyB0aGUgY29ycmVjdCB3YXkgdG8gc2V0IGEgYm9vbGVhbiBhdHRyaWJ1dGUgdG8gXCJ0cnVlXCJcbiAgICAgICAgICAgIG9sZEVsZW1lbnQuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsIFwiXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIWlnbm9yZUF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCBvbGRFbGVtZW50LCBcInJlbW92ZVwiLCBjdHgpKSB7XG4gICAgICAgICAgICBvbGRFbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gYXR0ciB0aGUgYXR0cmlidXRlIHRvIGJlIG11dGF0ZWRcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnQgdGhlIGVsZW1lbnQgdGhhdCBpcyBnb2luZyB0byBiZSB1cGRhdGVkXG4gICAgICogQHBhcmFtIHtcInVwZGF0ZVwiIHwgXCJyZW1vdmVcIn0gdXBkYXRlVHlwZVxuICAgICAqIEBwYXJhbSB7TW9ycGhDb250ZXh0fSBjdHggdGhlIG1lcmdlIGNvbnRleHRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgYXR0cmlidXRlIHNob3VsZCBiZSBpZ25vcmVkLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpZ25vcmVBdHRyaWJ1dGUoYXR0ciwgZWxlbWVudCwgdXBkYXRlVHlwZSwgY3R4KSB7XG4gICAgICBpZiAoXG4gICAgICAgIGF0dHIgPT09IFwidmFsdWVcIiAmJlxuICAgICAgICBjdHguaWdub3JlQWN0aXZlVmFsdWUgJiZcbiAgICAgICAgZWxlbWVudCA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudFxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIChcbiAgICAgICAgY3R4LmNhbGxiYWNrcy5iZWZvcmVBdHRyaWJ1dGVVcGRhdGVkKGF0dHIsIGVsZW1lbnQsIHVwZGF0ZVR5cGUpID09PVxuICAgICAgICBmYWxzZVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge05vZGV9IHBvc3NpYmxlQWN0aXZlRWxlbWVudFxuICAgICAqIEBwYXJhbSB7TW9ycGhDb250ZXh0fSBjdHhcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpZ25vcmVWYWx1ZU9mQWN0aXZlRWxlbWVudChwb3NzaWJsZUFjdGl2ZUVsZW1lbnQsIGN0eCkge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgISFjdHguaWdub3JlQWN0aXZlVmFsdWUgJiZcbiAgICAgICAgcG9zc2libGVBY3RpdmVFbGVtZW50ID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50ICYmXG4gICAgICAgIHBvc3NpYmxlQWN0aXZlRWxlbWVudCAhPT0gZG9jdW1lbnQuYm9keVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbW9ycGhOb2RlO1xuICB9KSgpO1xuXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgLy8gSGVhZCBNYW5hZ2VtZW50IEZ1bmN0aW9uc1xuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8qKlxuICAgKiBAcGFyYW0ge01vcnBoQ29udGV4dH0gY3R4XG4gICAqIEBwYXJhbSB7RWxlbWVudH0gb2xkTm9kZVxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5ld05vZGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2tcbiAgICogQHJldHVybnMge05vZGVbXSB8IFByb21pc2U8Tm9kZVtdPn1cbiAgICovXG4gIGZ1bmN0aW9uIHdpdGhIZWFkQmxvY2tpbmcoY3R4LCBvbGROb2RlLCBuZXdOb2RlLCBjYWxsYmFjaykge1xuICAgIGlmIChjdHguaGVhZC5ibG9jaykge1xuICAgICAgY29uc3Qgb2xkSGVhZCA9IG9sZE5vZGUucXVlcnlTZWxlY3RvcihcImhlYWRcIik7XG4gICAgICBjb25zdCBuZXdIZWFkID0gbmV3Tm9kZS5xdWVyeVNlbGVjdG9yKFwiaGVhZFwiKTtcbiAgICAgIGlmIChvbGRIZWFkICYmIG5ld0hlYWQpIHtcbiAgICAgICAgY29uc3QgcHJvbWlzZXMgPSBoYW5kbGVIZWFkRWxlbWVudChvbGRIZWFkLCBuZXdIZWFkLCBjdHgpO1xuICAgICAgICAvLyB3aGVuIGhlYWQgcHJvbWlzZXMgcmVzb2x2ZSwgcHJvY2VlZCBpZ25vcmluZyB0aGUgaGVhZCB0YWdcbiAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKS50aGVuKCgpID0+IHtcbiAgICAgICAgICBjb25zdCBuZXdDdHggPSBPYmplY3QuYXNzaWduKGN0eCwge1xuICAgICAgICAgICAgaGVhZDoge1xuICAgICAgICAgICAgICBibG9jazogZmFsc2UsXG4gICAgICAgICAgICAgIGlnbm9yZTogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ld0N0eCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBqdXN0IHByb2NlZWQgaWYgd2Ugbm90IGhlYWQgYmxvY2tpbmdcbiAgICByZXR1cm4gY2FsbGJhY2soY3R4KTtcbiAgfVxuXG4gIC8qKlxuICAgKiAgVGhlIEhFQUQgdGFnIGNhbiBiZSBoYW5kbGVkIHNwZWNpYWxseSwgZWl0aGVyIHcvIGEgJ21lcmdlJyBvciAnYXBwZW5kJyBzdHlsZVxuICAgKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IG9sZEhlYWRcbiAgICogQHBhcmFtIHtFbGVtZW50fSBuZXdIZWFkXG4gICAqIEBwYXJhbSB7TW9ycGhDb250ZXh0fSBjdHhcbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD5bXX1cbiAgICovXG4gIGZ1bmN0aW9uIGhhbmRsZUhlYWRFbGVtZW50KG9sZEhlYWQsIG5ld0hlYWQsIGN0eCkge1xuICAgIGxldCBhZGRlZCA9IFtdO1xuICAgIGxldCByZW1vdmVkID0gW107XG4gICAgbGV0IHByZXNlcnZlZCA9IFtdO1xuICAgIGxldCBub2Rlc1RvQXBwZW5kID0gW107XG5cbiAgICAvLyBwdXQgYWxsIG5ldyBoZWFkIGVsZW1lbnRzIGludG8gYSBNYXAsIGJ5IHRoZWlyIG91dGVySFRNTFxuICAgIGxldCBzcmNUb05ld0hlYWROb2RlcyA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IG5ld0hlYWRDaGlsZCBvZiBuZXdIZWFkLmNoaWxkcmVuKSB7XG4gICAgICBzcmNUb05ld0hlYWROb2Rlcy5zZXQobmV3SGVhZENoaWxkLm91dGVySFRNTCwgbmV3SGVhZENoaWxkKTtcbiAgICB9XG5cbiAgICAvLyBmb3IgZWFjaCBlbHQgaW4gdGhlIGN1cnJlbnQgaGVhZFxuICAgIGZvciAoY29uc3QgY3VycmVudEhlYWRFbHQgb2Ygb2xkSGVhZC5jaGlsZHJlbikge1xuICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgaGVhZCBlbGVtZW50IGlzIGluIHRoZSBtYXBcbiAgICAgIGxldCBpbk5ld0NvbnRlbnQgPSBzcmNUb05ld0hlYWROb2Rlcy5oYXMoY3VycmVudEhlYWRFbHQub3V0ZXJIVE1MKTtcbiAgICAgIGxldCBpc1JlQXBwZW5kZWQgPSBjdHguaGVhZC5zaG91bGRSZUFwcGVuZChjdXJyZW50SGVhZEVsdCk7XG4gICAgICBsZXQgaXNQcmVzZXJ2ZWQgPSBjdHguaGVhZC5zaG91bGRQcmVzZXJ2ZShjdXJyZW50SGVhZEVsdCk7XG4gICAgICBpZiAoaW5OZXdDb250ZW50IHx8IGlzUHJlc2VydmVkKSB7XG4gICAgICAgIGlmIChpc1JlQXBwZW5kZWQpIHtcbiAgICAgICAgICAvLyByZW1vdmUgdGhlIGN1cnJlbnQgdmVyc2lvbiBhbmQgbGV0IHRoZSBuZXcgdmVyc2lvbiByZXBsYWNlIGl0IGFuZCByZS1leGVjdXRlXG4gICAgICAgICAgcmVtb3ZlZC5wdXNoKGN1cnJlbnRIZWFkRWx0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyB0aGlzIGVsZW1lbnQgYWxyZWFkeSBleGlzdHMgYW5kIHNob3VsZCBub3QgYmUgcmUtYXBwZW5kZWQsIHNvIHJlbW92ZSBpdCBmcm9tXG4gICAgICAgICAgLy8gdGhlIG5ldyBjb250ZW50IG1hcCwgcHJlc2VydmluZyBpdCBpbiB0aGUgRE9NXG4gICAgICAgICAgc3JjVG9OZXdIZWFkTm9kZXMuZGVsZXRlKGN1cnJlbnRIZWFkRWx0Lm91dGVySFRNTCk7XG4gICAgICAgICAgcHJlc2VydmVkLnB1c2goY3VycmVudEhlYWRFbHQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY3R4LmhlYWQuc3R5bGUgPT09IFwiYXBwZW5kXCIpIHtcbiAgICAgICAgICAvLyB3ZSBhcmUgYXBwZW5kaW5nIGFuZCB0aGlzIGV4aXN0aW5nIGVsZW1lbnQgaXMgbm90IG5ldyBjb250ZW50XG4gICAgICAgICAgLy8gc28gaWYgYW5kIG9ubHkgaWYgaXQgaXMgbWFya2VkIGZvciByZS1hcHBlbmQgZG8gd2UgZG8gYW55dGhpbmdcbiAgICAgICAgICBpZiAoaXNSZUFwcGVuZGVkKSB7XG4gICAgICAgICAgICByZW1vdmVkLnB1c2goY3VycmVudEhlYWRFbHQpO1xuICAgICAgICAgICAgbm9kZXNUb0FwcGVuZC5wdXNoKGN1cnJlbnRIZWFkRWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gaWYgdGhpcyBpcyBhIG1lcmdlLCB3ZSByZW1vdmUgdGhpcyBjb250ZW50IHNpbmNlIGl0IGlzIG5vdCBpbiB0aGUgbmV3IGhlYWRcbiAgICAgICAgICBpZiAoY3R4LmhlYWQuc2hvdWxkUmVtb3ZlKGN1cnJlbnRIZWFkRWx0KSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJlbW92ZWQucHVzaChjdXJyZW50SGVhZEVsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUHVzaCB0aGUgcmVtYWluaW5nIG5ldyBoZWFkIGVsZW1lbnRzIGluIHRoZSBNYXAgaW50byB0aGVcbiAgICAvLyBub2RlcyB0byBhcHBlbmQgdG8gdGhlIGhlYWQgdGFnXG4gICAgbm9kZXNUb0FwcGVuZC5wdXNoKC4uLnNyY1RvTmV3SGVhZE5vZGVzLnZhbHVlcygpKTtcblxuICAgIGxldCBwcm9taXNlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgbmV3Tm9kZSBvZiBub2Rlc1RvQXBwZW5kKSB7XG4gICAgICAvLyBUT0RPOiBUaGlzIGNvdWxkIHRoZW9yZXRpY2FsbHkgYmUgbnVsbCwgYmFzZWQgb24gdHlwZVxuICAgICAgbGV0IG5ld0VsdCA9IC8qKiBAdHlwZSB7Q2hpbGROb2RlfSAqLyAoXG4gICAgICAgIGRvY3VtZW50LmNyZWF0ZVJhbmdlKCkuY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50KG5ld05vZGUub3V0ZXJIVE1MKVxuICAgICAgICAgIC5maXJzdENoaWxkXG4gICAgICApO1xuICAgICAgaWYgKGN0eC5jYWxsYmFja3MuYmVmb3JlTm9kZUFkZGVkKG5ld0VsdCkgIT09IGZhbHNlKSB7XG4gICAgICAgIGlmIChcbiAgICAgICAgICAoXCJocmVmXCIgaW4gbmV3RWx0ICYmIG5ld0VsdC5ocmVmKSB8fFxuICAgICAgICAgIChcInNyY1wiIGluIG5ld0VsdCAmJiBuZXdFbHQuc3JjKVxuICAgICAgICApIHtcbiAgICAgICAgICAvKiogQHR5cGUgeyhyZXN1bHQ/OiBhbnkpID0+IHZvaWR9ICovIGxldCByZXNvbHZlO1xuICAgICAgICAgIGxldCBwcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKF9yZXNvbHZlKSB7XG4gICAgICAgICAgICByZXNvbHZlID0gX3Jlc29sdmU7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbmV3RWx0LmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwcm9taXNlcy5wdXNoKHByb21pc2UpO1xuICAgICAgICB9XG4gICAgICAgIG9sZEhlYWQuYXBwZW5kQ2hpbGQobmV3RWx0KTtcbiAgICAgICAgY3R4LmNhbGxiYWNrcy5hZnRlck5vZGVBZGRlZChuZXdFbHQpO1xuICAgICAgICBhZGRlZC5wdXNoKG5ld0VsdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGFsbCByZW1vdmVkIGVsZW1lbnRzLCBhZnRlciB3ZSBoYXZlIGFwcGVuZGVkIHRoZSBuZXcgZWxlbWVudHMgdG8gYXZvaWRcbiAgICAvLyBhZGRpdGlvbmFsIG5ldHdvcmsgcmVxdWVzdHMgZm9yIHRoaW5ncyBsaWtlIHN0eWxlIHNoZWV0c1xuICAgIGZvciAoY29uc3QgcmVtb3ZlZEVsZW1lbnQgb2YgcmVtb3ZlZCkge1xuICAgICAgaWYgKGN0eC5jYWxsYmFja3MuYmVmb3JlTm9kZVJlbW92ZWQocmVtb3ZlZEVsZW1lbnQpICE9PSBmYWxzZSkge1xuICAgICAgICBvbGRIZWFkLnJlbW92ZUNoaWxkKHJlbW92ZWRFbGVtZW50KTtcbiAgICAgICAgY3R4LmNhbGxiYWNrcy5hZnRlck5vZGVSZW1vdmVkKHJlbW92ZWRFbGVtZW50KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjdHguaGVhZC5hZnRlckhlYWRNb3JwaGVkKG9sZEhlYWQsIHtcbiAgICAgIGFkZGVkOiBhZGRlZCxcbiAgICAgIGtlcHQ6IHByZXNlcnZlZCxcbiAgICAgIHJlbW92ZWQ6IHJlbW92ZWQsXG4gICAgfSk7XG4gICAgcmV0dXJuIHByb21pc2VzO1xuICB9XG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBDcmVhdGUgTW9ycGggQ29udGV4dCBGdW5jdGlvbnNcbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICBjb25zdCBjcmVhdGVNb3JwaENvbnRleHQgPSAoZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBvbGROb2RlXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBuZXdDb250ZW50XG4gICAgICogQHBhcmFtIHtDb25maWd9IGNvbmZpZ1xuICAgICAqIEByZXR1cm5zIHtNb3JwaENvbnRleHR9XG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlTW9ycGhDb250ZXh0KG9sZE5vZGUsIG5ld0NvbnRlbnQsIGNvbmZpZykge1xuICAgICAgY29uc3QgeyBwZXJzaXN0ZW50SWRzLCBpZE1hcCB9ID0gY3JlYXRlSWRNYXBzKG9sZE5vZGUsIG5ld0NvbnRlbnQpO1xuXG4gICAgICBjb25zdCBtZXJnZWRDb25maWcgPSBtZXJnZURlZmF1bHRzKGNvbmZpZyk7XG4gICAgICBjb25zdCBtb3JwaFN0eWxlID0gbWVyZ2VkQ29uZmlnLm1vcnBoU3R5bGUgfHwgXCJvdXRlckhUTUxcIjtcbiAgICAgIGlmICghW1wiaW5uZXJIVE1MXCIsIFwib3V0ZXJIVE1MXCJdLmluY2x1ZGVzKG1vcnBoU3R5bGUpKSB7XG4gICAgICAgIHRocm93IGBEbyBub3QgdW5kZXJzdGFuZCBob3cgdG8gbW9ycGggc3R5bGUgJHttb3JwaFN0eWxlfWA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRhcmdldDogb2xkTm9kZSxcbiAgICAgICAgbmV3Q29udGVudDogbmV3Q29udGVudCxcbiAgICAgICAgY29uZmlnOiBtZXJnZWRDb25maWcsXG4gICAgICAgIG1vcnBoU3R5bGU6IG1vcnBoU3R5bGUsXG4gICAgICAgIGlnbm9yZUFjdGl2ZTogbWVyZ2VkQ29uZmlnLmlnbm9yZUFjdGl2ZSxcbiAgICAgICAgaWdub3JlQWN0aXZlVmFsdWU6IG1lcmdlZENvbmZpZy5pZ25vcmVBY3RpdmVWYWx1ZSxcbiAgICAgICAgcmVzdG9yZUZvY3VzOiBtZXJnZWRDb25maWcucmVzdG9yZUZvY3VzLFxuICAgICAgICBpZE1hcDogaWRNYXAsXG4gICAgICAgIHBlcnNpc3RlbnRJZHM6IHBlcnNpc3RlbnRJZHMsXG4gICAgICAgIHBhbnRyeTogY3JlYXRlUGFudHJ5KCksXG4gICAgICAgIGNhbGxiYWNrczogbWVyZ2VkQ29uZmlnLmNhbGxiYWNrcyxcbiAgICAgICAgaGVhZDogbWVyZ2VkQ29uZmlnLmhlYWQsXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlZXAgbWVyZ2VzIHRoZSBjb25maWcgb2JqZWN0IGFuZCB0aGUgSWRpb21vcnBoLmRlZmF1bHRzIG9iamVjdCB0b1xuICAgICAqIHByb2R1Y2UgYSBmaW5hbCBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgICAqIEBwYXJhbSB7Q29uZmlnfSBjb25maWdcbiAgICAgKiBAcmV0dXJucyB7Q29uZmlnSW50ZXJuYWx9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVyZ2VEZWZhdWx0cyhjb25maWcpIHtcbiAgICAgIGxldCBmaW5hbENvbmZpZyA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRzKTtcblxuICAgICAgLy8gY29weSB0b3AgbGV2ZWwgc3R1ZmYgaW50byBmaW5hbCBjb25maWdcbiAgICAgIE9iamVjdC5hc3NpZ24oZmluYWxDb25maWcsIGNvbmZpZyk7XG5cbiAgICAgIC8vIGNvcHkgY2FsbGJhY2tzIGludG8gZmluYWwgY29uZmlnIChkbyB0aGlzIHRvIGRlZXAgbWVyZ2UgdGhlIGNhbGxiYWNrcylcbiAgICAgIGZpbmFsQ29uZmlnLmNhbGxiYWNrcyA9IE9iamVjdC5hc3NpZ24oXG4gICAgICAgIHt9LFxuICAgICAgICBkZWZhdWx0cy5jYWxsYmFja3MsXG4gICAgICAgIGNvbmZpZy5jYWxsYmFja3MsXG4gICAgICApO1xuXG4gICAgICAvLyBjb3B5IGhlYWQgY29uZmlnIGludG8gZmluYWwgY29uZmlnICAoZG8gdGhpcyB0byBkZWVwIG1lcmdlIHRoZSBoZWFkKVxuICAgICAgZmluYWxDb25maWcuaGVhZCA9IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRzLmhlYWQsIGNvbmZpZy5oZWFkKTtcblxuICAgICAgcmV0dXJuIGZpbmFsQ29uZmlnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIHtIVE1MRGl2RWxlbWVudH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVQYW50cnkoKSB7XG4gICAgICBjb25zdCBwYW50cnkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgcGFudHJ5LmhpZGRlbiA9IHRydWU7XG4gICAgICBkb2N1bWVudC5ib2R5Lmluc2VydEFkamFjZW50RWxlbWVudChcImFmdGVyZW5kXCIsIHBhbnRyeSk7XG4gICAgICByZXR1cm4gcGFudHJ5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYWxsIGVsZW1lbnRzIHdpdGggYW4gSUQgY29udGFpbmVkIHdpdGhpbiB0aGUgcm9vdCBlbGVtZW50IGFuZCBpdHMgZGVzY2VuZGFudHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gcm9vdFxuICAgICAqIEByZXR1cm5zIHtFbGVtZW50W119XG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZElkRWxlbWVudHMocm9vdCkge1xuICAgICAgbGV0IGVsZW1lbnRzID0gQXJyYXkuZnJvbShyb290LnF1ZXJ5U2VsZWN0b3JBbGwoXCJbaWRdXCIpKTtcbiAgICAgIGlmIChyb290LmlkKSB7XG4gICAgICAgIGVsZW1lbnRzLnB1c2gocm9vdCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZWxlbWVudHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBib3R0b20tdXAgYWxnb3JpdGhtIHRoYXQgcG9wdWxhdGVzIGEgbWFwIG9mIEVsZW1lbnQgLT4gSWRTZXQuXG4gICAgICogVGhlIGlkU2V0IGZvciBhIGdpdmVuIGVsZW1lbnQgaXMgdGhlIHNldCBvZiBhbGwgSURzIGNvbnRhaW5lZCB3aXRoaW4gaXRzIHN1YnRyZWUuXG4gICAgICogQXMgYW4gb3B0aW16YXRpb24sIHdlIGZpbHRlciB0aGVzZSBJRHMgdGhyb3VnaCB0aGUgZ2l2ZW4gbGlzdCBvZiBwZXJzaXN0ZW50IElEcyxcbiAgICAgKiBiZWNhdXNlIHdlIGRvbid0IG5lZWQgdG8gYm90aGVyIGNvbnNpZGVyaW5nIElEZWQgZWxlbWVudHMgdGhhdCB3b24ndCBiZSBpbiB0aGUgbmV3IGNvbnRlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge01hcDxOb2RlLCBTZXQ8c3RyaW5nPj59IGlkTWFwXG4gICAgICogQHBhcmFtIHtTZXQ8c3RyaW5nPn0gcGVyc2lzdGVudElkc1xuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gcm9vdFxuICAgICAqIEBwYXJhbSB7RWxlbWVudFtdfSBlbGVtZW50c1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBvcHVsYXRlSWRNYXBXaXRoVHJlZShpZE1hcCwgcGVyc2lzdGVudElkcywgcm9vdCwgZWxlbWVudHMpIHtcbiAgICAgIGZvciAoY29uc3QgZWx0IG9mIGVsZW1lbnRzKSB7XG4gICAgICAgIGlmIChwZXJzaXN0ZW50SWRzLmhhcyhlbHQuaWQpKSB7XG4gICAgICAgICAgLyoqIEB0eXBlIHtFbGVtZW50fG51bGx9ICovXG4gICAgICAgICAgbGV0IGN1cnJlbnQgPSBlbHQ7XG4gICAgICAgICAgLy8gd2FsayB1cCB0aGUgcGFyZW50IGhpZXJhcmNoeSBvZiB0aGF0IGVsZW1lbnQsIGFkZGluZyB0aGUgaWRcbiAgICAgICAgICAvLyBvZiBlbGVtZW50IHRvIHRoZSBwYXJlbnQncyBpZCBzZXRcbiAgICAgICAgICB3aGlsZSAoY3VycmVudCkge1xuICAgICAgICAgICAgbGV0IGlkU2V0ID0gaWRNYXAuZ2V0KGN1cnJlbnQpO1xuICAgICAgICAgICAgLy8gaWYgdGhlIGlkIHNldCBkb2Vzbid0IGV4aXN0LCBjcmVhdGUgaXQgYW5kIGluc2VydCBpdCBpbiB0aGUgbWFwXG4gICAgICAgICAgICBpZiAoaWRTZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICBpZFNldCA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgICAgaWRNYXAuc2V0KGN1cnJlbnQsIGlkU2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlkU2V0LmFkZChlbHQuaWQpO1xuXG4gICAgICAgICAgICBpZiAoY3VycmVudCA9PT0gcm9vdCkgYnJlYWs7XG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnRFbGVtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gY29tcHV0ZXMgYSBtYXAgb2Ygbm9kZXMgdG8gYWxsIGlkcyBjb250YWluZWQgd2l0aGluIHRoYXQgbm9kZSAoaW5jbHVzaXZlIG9mIHRoZVxuICAgICAqIG5vZGUpLiAgVGhpcyBtYXAgY2FuIGJlIHVzZWQgdG8gYXNrIGlmIHR3byBub2RlcyBoYXZlIGludGVyc2VjdGluZyBzZXRzIG9mIGlkcywgd2hpY2ggYWxsb3dzXG4gICAgICogZm9yIGEgbG9vc2VyIGRlZmluaXRpb24gb2YgXCJtYXRjaGluZ1wiIHRoYW4gdHJhZGl0aW9uIGlkIG1hdGNoaW5nLCBhbmQgYWxsb3dzIGNoaWxkIG5vZGVzXG4gICAgICogdG8gY29udHJpYnV0ZSB0byBhIHBhcmVudCBub2RlcyBtYXRjaGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gb2xkQ29udGVudCAgdGhlIG9sZCBjb250ZW50IHRoYXQgd2lsbCBiZSBtb3JwaGVkXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBuZXdDb250ZW50ICB0aGUgbmV3IGNvbnRlbnQgdG8gbW9ycGggdG9cbiAgICAgKiBAcmV0dXJucyB7SWRTZXRzfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUlkTWFwcyhvbGRDb250ZW50LCBuZXdDb250ZW50KSB7XG4gICAgICBjb25zdCBvbGRJZEVsZW1lbnRzID0gZmluZElkRWxlbWVudHMob2xkQ29udGVudCk7XG4gICAgICBjb25zdCBuZXdJZEVsZW1lbnRzID0gZmluZElkRWxlbWVudHMobmV3Q29udGVudCk7XG5cbiAgICAgIGNvbnN0IHBlcnNpc3RlbnRJZHMgPSBjcmVhdGVQZXJzaXN0ZW50SWRzKG9sZElkRWxlbWVudHMsIG5ld0lkRWxlbWVudHMpO1xuXG4gICAgICAvKiogQHR5cGUge01hcDxOb2RlLCBTZXQ8c3RyaW5nPj59ICovXG4gICAgICBsZXQgaWRNYXAgPSBuZXcgTWFwKCk7XG4gICAgICBwb3B1bGF0ZUlkTWFwV2l0aFRyZWUoaWRNYXAsIHBlcnNpc3RlbnRJZHMsIG9sZENvbnRlbnQsIG9sZElkRWxlbWVudHMpO1xuXG4gICAgICAvKiogQHRzLWlnbm9yZSAtIGlmIG5ld0NvbnRlbnQgaXMgYSBkdWNrLXR5cGVkIHBhcmVudCwgcGFzcyBpdHMgc2luZ2xlIGNoaWxkIG5vZGUgYXMgdGhlIHJvb3QgdG8gaGFsdCB1cHdhcmRzIGl0ZXJhdGlvbiAqL1xuICAgICAgY29uc3QgbmV3Um9vdCA9IG5ld0NvbnRlbnQuX19pZGlvbW9ycGhSb290IHx8IG5ld0NvbnRlbnQ7XG4gICAgICBwb3B1bGF0ZUlkTWFwV2l0aFRyZWUoaWRNYXAsIHBlcnNpc3RlbnRJZHMsIG5ld1Jvb3QsIG5ld0lkRWxlbWVudHMpO1xuXG4gICAgICByZXR1cm4geyBwZXJzaXN0ZW50SWRzLCBpZE1hcCB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gY29tcHV0ZXMgdGhlIHNldCBvZiBpZHMgdGhhdCBwZXJzaXN0IGJldHdlZW4gdGhlIHR3byBjb250ZW50cyBleGNsdWRpbmcgZHVwbGljYXRlc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtFbGVtZW50W119IG9sZElkRWxlbWVudHNcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnRbXX0gbmV3SWRFbGVtZW50c1xuICAgICAqIEByZXR1cm5zIHtTZXQ8c3RyaW5nPn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVQZXJzaXN0ZW50SWRzKG9sZElkRWxlbWVudHMsIG5ld0lkRWxlbWVudHMpIHtcbiAgICAgIGxldCBkdXBsaWNhdGVJZHMgPSBuZXcgU2V0KCk7XG5cbiAgICAgIC8qKiBAdHlwZSB7TWFwPHN0cmluZywgc3RyaW5nPn0gKi9cbiAgICAgIGxldCBvbGRJZFRhZ05hbWVNYXAgPSBuZXcgTWFwKCk7XG4gICAgICBmb3IgKGNvbnN0IHsgaWQsIHRhZ05hbWUgfSBvZiBvbGRJZEVsZW1lbnRzKSB7XG4gICAgICAgIGlmIChvbGRJZFRhZ05hbWVNYXAuaGFzKGlkKSkge1xuICAgICAgICAgIGR1cGxpY2F0ZUlkcy5hZGQoaWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9sZElkVGFnTmFtZU1hcC5zZXQoaWQsIHRhZ05hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxldCBwZXJzaXN0ZW50SWRzID0gbmV3IFNldCgpO1xuICAgICAgZm9yIChjb25zdCB7IGlkLCB0YWdOYW1lIH0gb2YgbmV3SWRFbGVtZW50cykge1xuICAgICAgICBpZiAocGVyc2lzdGVudElkcy5oYXMoaWQpKSB7XG4gICAgICAgICAgZHVwbGljYXRlSWRzLmFkZChpZCk7XG4gICAgICAgIH0gZWxzZSBpZiAob2xkSWRUYWdOYW1lTWFwLmdldChpZCkgPT09IHRhZ05hbWUpIHtcbiAgICAgICAgICBwZXJzaXN0ZW50SWRzLmFkZChpZCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2tpcCBpZiB0YWcgdHlwZXMgbWlzbWF0Y2ggYmVjYXVzZSBpdHMgbm90IHBvc3NpYmxlIHRvIG1vcnBoIG9uZSB0YWcgaW50byBhbm90aGVyXG4gICAgICB9XG5cbiAgICAgIGZvciAoY29uc3QgaWQgb2YgZHVwbGljYXRlSWRzKSB7XG4gICAgICAgIHBlcnNpc3RlbnRJZHMuZGVsZXRlKGlkKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwZXJzaXN0ZW50SWRzO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVNb3JwaENvbnRleHQ7XG4gIH0pKCk7XG5cbiAgLy89PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICAvLyBIVE1MIE5vcm1hbGl6YXRpb24gRnVuY3Rpb25zXG4gIC8vPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAgY29uc3QgeyBub3JtYWxpemVFbGVtZW50LCBub3JtYWxpemVQYXJlbnQgfSA9IChmdW5jdGlvbiAoKSB7XG4gICAgLyoqIEB0eXBlIHtXZWFrU2V0PE5vZGU+fSAqL1xuICAgIGNvbnN0IGdlbmVyYXRlZEJ5SWRpb21vcnBoID0gbmV3IFdlYWtTZXQoKTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbGVtZW50IHwgRG9jdW1lbnR9IGNvbnRlbnRcbiAgICAgKiBAcmV0dXJucyB7RWxlbWVudH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBub3JtYWxpemVFbGVtZW50KGNvbnRlbnQpIHtcbiAgICAgIGlmIChjb250ZW50IGluc3RhbmNlb2YgRG9jdW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bGwgfCBzdHJpbmcgfCBOb2RlIHwgSFRNTENvbGxlY3Rpb24gfCBOb2RlW10gfCBEb2N1bWVudCAmIHtnZW5lcmF0ZWRCeUlkaW9tb3JwaDpib29sZWFufX0gbmV3Q29udGVudFxuICAgICAqIEByZXR1cm5zIHtFbGVtZW50fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZVBhcmVudChuZXdDb250ZW50KSB7XG4gICAgICBpZiAobmV3Q29udGVudCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpOyAvLyBkdW1teSBwYXJlbnQgZWxlbWVudFxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbmV3Q29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gbm9ybWFsaXplUGFyZW50KHBhcnNlQ29udGVudChuZXdDb250ZW50KSk7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICBnZW5lcmF0ZWRCeUlkaW9tb3JwaC5oYXMoLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAobmV3Q29udGVudCkpXG4gICAgICApIHtcbiAgICAgICAgLy8gdGhlIHRlbXBsYXRlIHRhZyBjcmVhdGVkIGJ5IGlkaW9tb3JwaCBwYXJzaW5nIGNhbiBzZXJ2ZSBhcyBhIGR1bW15IHBhcmVudFxuICAgICAgICByZXR1cm4gLyoqIEB0eXBlIHtFbGVtZW50fSAqLyAobmV3Q29udGVudCk7XG4gICAgICB9IGVsc2UgaWYgKG5ld0NvbnRlbnQgaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgICAgIGlmIChuZXdDb250ZW50LnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAvLyB3ZSBjYW4ndCB1c2UgdGhlIHBhcmVudCBkaXJlY3RseSBiZWNhdXNlIG5ld0NvbnRlbnQgbWF5IGhhdmUgc2libGluZ3NcbiAgICAgICAgICAvLyB0aGF0IHdlIGRvbid0IHdhbnQgaW4gdGhlIG1vcnBoLCBhbmQgcmVwYXJlbnRpbmcgbWlnaHQgYmUgZXhwZW5zaXZlIChUT0RPIGlzIGl0PyksXG4gICAgICAgICAgLy8gc28gd2UgY3JlYXRlIGEgZHVjay10eXBlZCBwYXJlbnQgbm9kZSBpbnN0ZWFkLlxuICAgICAgICAgIHJldHVybiBjcmVhdGVEdWNrVHlwZWRQYXJlbnQobmV3Q29udGVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gYSBzaW5nbGUgbm9kZSBpcyBhZGRlZCBhcyBhIGNoaWxkIHRvIGEgZHVtbXkgcGFyZW50XG4gICAgICAgICAgY29uc3QgZHVtbXlQYXJlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgIGR1bW15UGFyZW50LmFwcGVuZChuZXdDb250ZW50KTtcbiAgICAgICAgICByZXR1cm4gZHVtbXlQYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGFsbCBub2RlcyBpbiB0aGUgYXJyYXkgb3IgSFRNTEVsZW1lbnQgY29sbGVjdGlvbiBhcmUgY29uc29saWRhdGVkIHVuZGVyXG4gICAgICAgIC8vIGEgc2luZ2xlIGR1bW15IHBhcmVudCBlbGVtZW50XG4gICAgICAgIGNvbnN0IGR1bW15UGFyZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgZm9yIChjb25zdCBlbHQgb2YgWy4uLm5ld0NvbnRlbnRdKSB7XG4gICAgICAgICAgZHVtbXlQYXJlbnQuYXBwZW5kKGVsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGR1bW15UGFyZW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmYWtlIGR1Y2stdHlwZWQgcGFyZW50IGVsZW1lbnQgdG8gd3JhcCBhIHNpbmdsZSBub2RlLCB3aXRob3V0IGFjdHVhbGx5IHJlcGFyZW50aW5nIGl0LlxuICAgICAqIFwiSWYgaXQgd2Fsa3MgbGlrZSBhIGR1Y2ssIGFuZCBxdWFja3MgbGlrZSBhIGR1Y2ssIHRoZW4gaXQgbXVzdCBiZSBhIGR1Y2shXCIgLS0gSmFtZXMgV2hpdGNvbWIgUmlsZXkgKDE4NDnigJMxOTE2KVxuICAgICAqXG4gICAgICogQHBhcmFtIHtOb2RlfSBuZXdDb250ZW50XG4gICAgICogQHJldHVybnMge0VsZW1lbnR9XG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlRHVja1R5cGVkUGFyZW50KG5ld0NvbnRlbnQpIHtcbiAgICAgIHJldHVybiAvKiogQHR5cGUge0VsZW1lbnR9ICovIChcbiAgICAgICAgLyoqIEB0eXBlIHt1bmtub3dufSAqLyAoe1xuICAgICAgICAgIGNoaWxkTm9kZXM6IFtuZXdDb250ZW50XSxcbiAgICAgICAgICAvKiogQHRzLWlnbm9yZSAtIGNvdmVyIHlvdXIgZXllcyBmb3IgYSBtaW51dGUsIHRzYyAqL1xuICAgICAgICAgIHF1ZXJ5U2VsZWN0b3JBbGw6IChzKSA9PiB7XG4gICAgICAgICAgICAvKiogQHRzLWlnbm9yZSAqL1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudHMgPSBuZXdDb250ZW50LnF1ZXJ5U2VsZWN0b3JBbGwocyk7XG4gICAgICAgICAgICAvKiogQHRzLWlnbm9yZSAqL1xuICAgICAgICAgICAgcmV0dXJuIG5ld0NvbnRlbnQubWF0Y2hlcyhzKSA/IFtuZXdDb250ZW50LCAuLi5lbGVtZW50c10gOiBlbGVtZW50cztcbiAgICAgICAgICB9LFxuICAgICAgICAgIC8qKiBAdHMtaWdub3JlICovXG4gICAgICAgICAgaW5zZXJ0QmVmb3JlOiAobiwgcikgPT4gbmV3Q29udGVudC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShuLCByKSxcbiAgICAgICAgICAvKiogQHRzLWlnbm9yZSAqL1xuICAgICAgICAgIG1vdmVCZWZvcmU6IChuLCByKSA9PiBuZXdDb250ZW50LnBhcmVudE5vZGUubW92ZUJlZm9yZShuLCByKSxcbiAgICAgICAgICAvLyBmb3IgbGF0ZXIgdXNlIHdpdGggcG9wdWxhdGVJZE1hcFdpdGhUcmVlIHRvIGhhbHQgdXB3YXJkcyBpdGVyYXRpb25cbiAgICAgICAgICBnZXQgX19pZGlvbW9ycGhSb290KCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ld0NvbnRlbnQ7XG4gICAgICAgICAgfSxcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3Q29udGVudFxuICAgICAqIEByZXR1cm5zIHtOb2RlIHwgbnVsbCB8IERvY3VtZW50RnJhZ21lbnR9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFyc2VDb250ZW50KG5ld0NvbnRlbnQpIHtcbiAgICAgIGxldCBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKCk7XG5cbiAgICAgIC8vIHJlbW92ZSBzdmdzIHRvIGF2b2lkIGZhbHNlLXBvc2l0aXZlIG1hdGNoZXMgb24gaGVhZCwgZXRjLlxuICAgICAgbGV0IGNvbnRlbnRXaXRoU3Znc1JlbW92ZWQgPSBuZXdDb250ZW50LnJlcGxhY2UoXG4gICAgICAgIC88c3ZnKFxcc1tePl0qPnw+KShbXFxzXFxTXSo/KTxcXC9zdmc+L2dpbSxcbiAgICAgICAgXCJcIixcbiAgICAgICk7XG5cbiAgICAgIC8vIGlmIHRoZSBuZXdDb250ZW50IGNvbnRhaW5zIGEgaHRtbCwgaGVhZCBvciBib2R5IHRhZywgd2UgY2FuIHNpbXBseSBwYXJzZSBpdCB3L28gd3JhcHBpbmdcbiAgICAgIGlmIChcbiAgICAgICAgY29udGVudFdpdGhTdmdzUmVtb3ZlZC5tYXRjaCgvPFxcL2h0bWw+LykgfHxcbiAgICAgICAgY29udGVudFdpdGhTdmdzUmVtb3ZlZC5tYXRjaCgvPFxcL2hlYWQ+LykgfHxcbiAgICAgICAgY29udGVudFdpdGhTdmdzUmVtb3ZlZC5tYXRjaCgvPFxcL2JvZHk+LylcbiAgICAgICkge1xuICAgICAgICBsZXQgY29udGVudCA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcobmV3Q29udGVudCwgXCJ0ZXh0L2h0bWxcIik7XG4gICAgICAgIC8vIGlmIGl0IGlzIGEgZnVsbCBIVE1MIGRvY3VtZW50LCByZXR1cm4gdGhlIGRvY3VtZW50IGl0c2VsZiBhcyB0aGUgcGFyZW50IGNvbnRhaW5lclxuICAgICAgICBpZiAoY29udGVudFdpdGhTdmdzUmVtb3ZlZC5tYXRjaCgvPFxcL2h0bWw+LykpIHtcbiAgICAgICAgICBnZW5lcmF0ZWRCeUlkaW9tb3JwaC5hZGQoY29udGVudCk7XG4gICAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gb3RoZXJ3aXNlIHJldHVybiB0aGUgaHRtbCBlbGVtZW50IGFzIHRoZSBwYXJlbnQgY29udGFpbmVyXG4gICAgICAgICAgbGV0IGh0bWxFbGVtZW50ID0gY29udGVudC5maXJzdENoaWxkO1xuICAgICAgICAgIGlmIChodG1sRWxlbWVudCkge1xuICAgICAgICAgICAgZ2VuZXJhdGVkQnlJZGlvbW9ycGguYWRkKGh0bWxFbGVtZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGh0bWxFbGVtZW50O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBpZiBpdCBpcyBwYXJ0aWFsIEhUTUwsIHdyYXAgaXQgaW4gYSB0ZW1wbGF0ZSB0YWcgdG8gcHJvdmlkZSBhIHBhcmVudCBlbGVtZW50IGFuZCBhbHNvIHRvIGhlbHBcbiAgICAgICAgLy8gZGVhbCB3aXRoIHRvdWNoeSB0YWdzIGxpa2UgdHIsIHRib2R5LCBldGMuXG4gICAgICAgIGxldCByZXNwb25zZURvYyA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcoXG4gICAgICAgICAgXCI8Ym9keT48dGVtcGxhdGU+XCIgKyBuZXdDb250ZW50ICsgXCI8L3RlbXBsYXRlPjwvYm9keT5cIixcbiAgICAgICAgICBcInRleHQvaHRtbFwiLFxuICAgICAgICApO1xuICAgICAgICBsZXQgY29udGVudCA9IC8qKiBAdHlwZSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gKi8gKFxuICAgICAgICAgIHJlc3BvbnNlRG9jLmJvZHkucXVlcnlTZWxlY3RvcihcInRlbXBsYXRlXCIpXG4gICAgICAgICkuY29udGVudDtcbiAgICAgICAgZ2VuZXJhdGVkQnlJZGlvbW9ycGguYWRkKGNvbnRlbnQpO1xuICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4geyBub3JtYWxpemVFbGVtZW50LCBub3JtYWxpemVQYXJlbnQgfTtcbiAgfSkoKTtcblxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFRoaXMgaXMgd2hhdCBlbmRzIHVwIGJlY29taW5nIHRoZSBJZGlvbW9ycGggZ2xvYmFsIG9iamVjdFxuICAvLz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIHJldHVybiB7XG4gICAgbW9ycGgsXG4gICAgZGVmYXVsdHMsXG4gIH07XG59KSgpO1xuXG5mdW5jdGlvbiBtb3JwaEVsZW1lbnRzKGN1cnJlbnRFbGVtZW50LCBuZXdFbGVtZW50LCB7IGNhbGxiYWNrcywgLi4ub3B0aW9ucyB9ID0ge30pIHtcbiAgSWRpb21vcnBoLm1vcnBoKGN1cnJlbnRFbGVtZW50LCBuZXdFbGVtZW50LCB7XG4gICAgLi4ub3B0aW9ucyxcbiAgICBjYWxsYmFja3M6IG5ldyBEZWZhdWx0SWRpb21vcnBoQ2FsbGJhY2tzKGNhbGxiYWNrcylcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIG1vcnBoQ2hpbGRyZW4oY3VycmVudEVsZW1lbnQsIG5ld0VsZW1lbnQpIHtcbiAgbW9ycGhFbGVtZW50cyhjdXJyZW50RWxlbWVudCwgbmV3RWxlbWVudC5jaGlsZE5vZGVzLCB7XG4gICAgbW9ycGhTdHlsZTogXCJpbm5lckhUTUxcIlxuICB9KTtcbn1cblxuY2xhc3MgRGVmYXVsdElkaW9tb3JwaENhbGxiYWNrcyB7XG4gICNiZWZvcmVOb2RlTW9ycGhlZFxuXG4gIGNvbnN0cnVjdG9yKHsgYmVmb3JlTm9kZU1vcnBoZWQgfSA9IHt9KSB7XG4gICAgdGhpcy4jYmVmb3JlTm9kZU1vcnBoZWQgPSBiZWZvcmVOb2RlTW9ycGhlZCB8fCAoKCkgPT4gdHJ1ZSk7XG4gIH1cblxuICBiZWZvcmVOb2RlQWRkZWQgPSAobm9kZSkgPT4ge1xuICAgIHJldHVybiAhKG5vZGUuaWQgJiYgbm9kZS5oYXNBdHRyaWJ1dGUoXCJkYXRhLXR1cmJvLXBlcm1hbmVudFwiKSAmJiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChub2RlLmlkKSlcbiAgfVxuXG4gIGJlZm9yZU5vZGVNb3JwaGVkID0gKGN1cnJlbnRFbGVtZW50LCBuZXdFbGVtZW50KSA9PiB7XG4gICAgaWYgKGN1cnJlbnRFbGVtZW50IGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgaWYgKCFjdXJyZW50RWxlbWVudC5oYXNBdHRyaWJ1dGUoXCJkYXRhLXR1cmJvLXBlcm1hbmVudFwiKSAmJiB0aGlzLiNiZWZvcmVOb2RlTW9ycGhlZChjdXJyZW50RWxlbWVudCwgbmV3RWxlbWVudCkpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBkaXNwYXRjaChcInR1cmJvOmJlZm9yZS1tb3JwaC1lbGVtZW50XCIsIHtcbiAgICAgICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgICAgIHRhcmdldDogY3VycmVudEVsZW1lbnQsXG4gICAgICAgICAgZGV0YWlsOiB7IGN1cnJlbnRFbGVtZW50LCBuZXdFbGVtZW50IH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuICFldmVudC5kZWZhdWx0UHJldmVudGVkXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBiZWZvcmVBdHRyaWJ1dGVVcGRhdGVkID0gKGF0dHJpYnV0ZU5hbWUsIHRhcmdldCwgbXV0YXRpb25UeXBlKSA9PiB7XG4gICAgY29uc3QgZXZlbnQgPSBkaXNwYXRjaChcInR1cmJvOmJlZm9yZS1tb3JwaC1hdHRyaWJ1dGVcIiwge1xuICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgIHRhcmdldCxcbiAgICAgIGRldGFpbDogeyBhdHRyaWJ1dGVOYW1lLCBtdXRhdGlvblR5cGUgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuICFldmVudC5kZWZhdWx0UHJldmVudGVkXG4gIH1cblxuICBiZWZvcmVOb2RlUmVtb3ZlZCA9IChub2RlKSA9PiB7XG4gICAgcmV0dXJuIHRoaXMuYmVmb3JlTm9kZU1vcnBoZWQobm9kZSlcbiAgfVxuXG4gIGFmdGVyTm9kZU1vcnBoZWQgPSAoY3VycmVudEVsZW1lbnQsIG5ld0VsZW1lbnQpID0+IHtcbiAgICBpZiAoY3VycmVudEVsZW1lbnQgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICBkaXNwYXRjaChcInR1cmJvOm1vcnBoLWVsZW1lbnRcIiwge1xuICAgICAgICB0YXJnZXQ6IGN1cnJlbnRFbGVtZW50LFxuICAgICAgICBkZXRhaWw6IHsgY3VycmVudEVsZW1lbnQsIG5ld0VsZW1lbnQgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cbmNsYXNzIE1vcnBoaW5nRnJhbWVSZW5kZXJlciBleHRlbmRzIEZyYW1lUmVuZGVyZXIge1xuICBzdGF0aWMgcmVuZGVyRWxlbWVudChjdXJyZW50RWxlbWVudCwgbmV3RWxlbWVudCkge1xuICAgIGRpc3BhdGNoKFwidHVyYm86YmVmb3JlLWZyYW1lLW1vcnBoXCIsIHtcbiAgICAgIHRhcmdldDogY3VycmVudEVsZW1lbnQsXG4gICAgICBkZXRhaWw6IHsgY3VycmVudEVsZW1lbnQsIG5ld0VsZW1lbnQgfVxuICAgIH0pO1xuXG4gICAgbW9ycGhDaGlsZHJlbihjdXJyZW50RWxlbWVudCwgbmV3RWxlbWVudCk7XG4gIH1cblxuICBhc3luYyBwcmVzZXJ2aW5nUGVybWFuZW50RWxlbWVudHMoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gYXdhaXQgY2FsbGJhY2soKVxuICB9XG59XG5cbmNsYXNzIFByb2dyZXNzQmFyIHtcbiAgc3RhdGljIGFuaW1hdGlvbkR1cmF0aW9uID0gMzAwIC8qbXMqL1xuXG4gIHN0YXRpYyBnZXQgZGVmYXVsdENTUygpIHtcbiAgICByZXR1cm4gdW5pbmRlbnRgXG4gICAgICAudHVyYm8tcHJvZ3Jlc3MtYmFyIHtcbiAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICBkaXNwbGF5OiBibG9jaztcbiAgICAgICAgdG9wOiAwO1xuICAgICAgICBsZWZ0OiAwO1xuICAgICAgICBoZWlnaHQ6IDNweDtcbiAgICAgICAgYmFja2dyb3VuZDogIzAwNzZmZjtcbiAgICAgICAgei1pbmRleDogMjE0NzQ4MzY0NztcbiAgICAgICAgdHJhbnNpdGlvbjpcbiAgICAgICAgICB3aWR0aCAke1Byb2dyZXNzQmFyLmFuaW1hdGlvbkR1cmF0aW9ufW1zIGVhc2Utb3V0LFxuICAgICAgICAgIG9wYWNpdHkgJHtQcm9ncmVzc0Jhci5hbmltYXRpb25EdXJhdGlvbiAvIDJ9bXMgJHtQcm9ncmVzc0Jhci5hbmltYXRpb25EdXJhdGlvbiAvIDJ9bXMgZWFzZS1pbjtcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCAwLCAwKTtcbiAgICAgIH1cbiAgICBgXG4gIH1cblxuICBoaWRpbmcgPSBmYWxzZVxuICB2YWx1ZSA9IDBcbiAgdmlzaWJsZSA9IGZhbHNlXG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5zdHlsZXNoZWV0RWxlbWVudCA9IHRoaXMuY3JlYXRlU3R5bGVzaGVldEVsZW1lbnQoKTtcbiAgICB0aGlzLnByb2dyZXNzRWxlbWVudCA9IHRoaXMuY3JlYXRlUHJvZ3Jlc3NFbGVtZW50KCk7XG4gICAgdGhpcy5pbnN0YWxsU3R5bGVzaGVldEVsZW1lbnQoKTtcbiAgICB0aGlzLnNldFZhbHVlKDApO1xuICB9XG5cbiAgc2hvdygpIHtcbiAgICBpZiAoIXRoaXMudmlzaWJsZSkge1xuICAgICAgdGhpcy52aXNpYmxlID0gdHJ1ZTtcbiAgICAgIHRoaXMuaW5zdGFsbFByb2dyZXNzRWxlbWVudCgpO1xuICAgICAgdGhpcy5zdGFydFRyaWNrbGluZygpO1xuICAgIH1cbiAgfVxuXG4gIGhpZGUoKSB7XG4gICAgaWYgKHRoaXMudmlzaWJsZSAmJiAhdGhpcy5oaWRpbmcpIHtcbiAgICAgIHRoaXMuaGlkaW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMuZmFkZVByb2dyZXNzRWxlbWVudCgoKSA9PiB7XG4gICAgICAgIHRoaXMudW5pbnN0YWxsUHJvZ3Jlc3NFbGVtZW50KCk7XG4gICAgICAgIHRoaXMuc3RvcFRyaWNrbGluZygpO1xuICAgICAgICB0aGlzLnZpc2libGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oaWRpbmcgPSBmYWxzZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHNldFZhbHVlKHZhbHVlKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMucmVmcmVzaCgpO1xuICB9XG5cbiAgLy8gUHJpdmF0ZVxuXG4gIGluc3RhbGxTdHlsZXNoZWV0RWxlbWVudCgpIHtcbiAgICBkb2N1bWVudC5oZWFkLmluc2VydEJlZm9yZSh0aGlzLnN0eWxlc2hlZXRFbGVtZW50LCBkb2N1bWVudC5oZWFkLmZpcnN0Q2hpbGQpO1xuICB9XG5cbiAgaW5zdGFsbFByb2dyZXNzRWxlbWVudCgpIHtcbiAgICB0aGlzLnByb2dyZXNzRWxlbWVudC5zdHlsZS53aWR0aCA9IFwiMFwiO1xuICAgIHRoaXMucHJvZ3Jlc3NFbGVtZW50LnN0eWxlLm9wYWNpdHkgPSBcIjFcIjtcbiAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuaW5zZXJ0QmVmb3JlKHRoaXMucHJvZ3Jlc3NFbGVtZW50LCBkb2N1bWVudC5ib2R5KTtcbiAgICB0aGlzLnJlZnJlc2goKTtcbiAgfVxuXG4gIGZhZGVQcm9ncmVzc0VsZW1lbnQoY2FsbGJhY2spIHtcbiAgICB0aGlzLnByb2dyZXNzRWxlbWVudC5zdHlsZS5vcGFjaXR5ID0gXCIwXCI7XG4gICAgc2V0VGltZW91dChjYWxsYmFjaywgUHJvZ3Jlc3NCYXIuYW5pbWF0aW9uRHVyYXRpb24gKiAxLjUpO1xuICB9XG5cbiAgdW5pbnN0YWxsUHJvZ3Jlc3NFbGVtZW50KCkge1xuICAgIGlmICh0aGlzLnByb2dyZXNzRWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQucmVtb3ZlQ2hpbGQodGhpcy5wcm9ncmVzc0VsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXJ0VHJpY2tsaW5nKCkge1xuICAgIGlmICghdGhpcy50cmlja2xlSW50ZXJ2YWwpIHtcbiAgICAgIHRoaXMudHJpY2tsZUludGVydmFsID0gd2luZG93LnNldEludGVydmFsKHRoaXMudHJpY2tsZSwgUHJvZ3Jlc3NCYXIuYW5pbWF0aW9uRHVyYXRpb24pO1xuICAgIH1cbiAgfVxuXG4gIHN0b3BUcmlja2xpbmcoKSB7XG4gICAgd2luZG93LmNsZWFySW50ZXJ2YWwodGhpcy50cmlja2xlSW50ZXJ2YWwpO1xuICAgIGRlbGV0ZSB0aGlzLnRyaWNrbGVJbnRlcnZhbDtcbiAgfVxuXG4gIHRyaWNrbGUgPSAoKSA9PiB7XG4gICAgdGhpcy5zZXRWYWx1ZSh0aGlzLnZhbHVlICsgTWF0aC5yYW5kb20oKSAvIDEwMCk7XG4gIH1cblxuICByZWZyZXNoKCkge1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLnByb2dyZXNzRWxlbWVudC5zdHlsZS53aWR0aCA9IGAkezEwICsgdGhpcy52YWx1ZSAqIDkwfSVgO1xuICAgIH0pO1xuICB9XG5cbiAgY3JlYXRlU3R5bGVzaGVldEVsZW1lbnQoKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICBlbGVtZW50LnR5cGUgPSBcInRleHQvY3NzXCI7XG4gICAgZWxlbWVudC50ZXh0Q29udGVudCA9IFByb2dyZXNzQmFyLmRlZmF1bHRDU1M7XG4gICAgY29uc3QgY3NwTm9uY2UgPSBnZXRDc3BOb25jZSgpO1xuICAgIGlmIChjc3BOb25jZSkge1xuICAgICAgZWxlbWVudC5ub25jZSA9IGNzcE5vbmNlO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudFxuICB9XG5cbiAgY3JlYXRlUHJvZ3Jlc3NFbGVtZW50KCkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gXCJ0dXJiby1wcm9ncmVzcy1iYXJcIjtcbiAgICByZXR1cm4gZWxlbWVudFxuICB9XG59XG5cbmNsYXNzIEhlYWRTbmFwc2hvdCBleHRlbmRzIFNuYXBzaG90IHtcbiAgZGV0YWlsc0J5T3V0ZXJIVE1MID0gdGhpcy5jaGlsZHJlblxuICAgIC5maWx0ZXIoKGVsZW1lbnQpID0+ICFlbGVtZW50SXNOb3NjcmlwdChlbGVtZW50KSlcbiAgICAubWFwKChlbGVtZW50KSA9PiBlbGVtZW50V2l0aG91dE5vbmNlKGVsZW1lbnQpKVxuICAgIC5yZWR1Y2UoKHJlc3VsdCwgZWxlbWVudCkgPT4ge1xuICAgICAgY29uc3QgeyBvdXRlckhUTUwgfSA9IGVsZW1lbnQ7XG4gICAgICBjb25zdCBkZXRhaWxzID1cbiAgICAgICAgb3V0ZXJIVE1MIGluIHJlc3VsdFxuICAgICAgICAgID8gcmVzdWx0W291dGVySFRNTF1cbiAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgdHlwZTogZWxlbWVudFR5cGUoZWxlbWVudCksXG4gICAgICAgICAgICAgIHRyYWNrZWQ6IGVsZW1lbnRJc1RyYWNrZWQoZWxlbWVudCksXG4gICAgICAgICAgICAgIGVsZW1lbnRzOiBbXVxuICAgICAgICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLnJlc3VsdCxcbiAgICAgICAgW291dGVySFRNTF06IHtcbiAgICAgICAgICAuLi5kZXRhaWxzLFxuICAgICAgICAgIGVsZW1lbnRzOiBbLi4uZGV0YWlscy5lbGVtZW50cywgZWxlbWVudF1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHt9KVxuXG4gIGdldCB0cmFja2VkRWxlbWVudFNpZ25hdHVyZSgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5kZXRhaWxzQnlPdXRlckhUTUwpXG4gICAgICAuZmlsdGVyKChvdXRlckhUTUwpID0+IHRoaXMuZGV0YWlsc0J5T3V0ZXJIVE1MW291dGVySFRNTF0udHJhY2tlZClcbiAgICAgIC5qb2luKFwiXCIpXG4gIH1cblxuICBnZXRTY3JpcHRFbGVtZW50c05vdEluU25hcHNob3Qoc25hcHNob3QpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRFbGVtZW50c01hdGNoaW5nVHlwZU5vdEluU25hcHNob3QoXCJzY3JpcHRcIiwgc25hcHNob3QpXG4gIH1cblxuICBnZXRTdHlsZXNoZWV0RWxlbWVudHNOb3RJblNuYXBzaG90KHNuYXBzaG90KSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RWxlbWVudHNNYXRjaGluZ1R5cGVOb3RJblNuYXBzaG90KFwic3R5bGVzaGVldFwiLCBzbmFwc2hvdClcbiAgfVxuXG4gIGdldEVsZW1lbnRzTWF0Y2hpbmdUeXBlTm90SW5TbmFwc2hvdChtYXRjaGVkVHlwZSwgc25hcHNob3QpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5kZXRhaWxzQnlPdXRlckhUTUwpXG4gICAgICAuZmlsdGVyKChvdXRlckhUTUwpID0+ICEob3V0ZXJIVE1MIGluIHNuYXBzaG90LmRldGFpbHNCeU91dGVySFRNTCkpXG4gICAgICAubWFwKChvdXRlckhUTUwpID0+IHRoaXMuZGV0YWlsc0J5T3V0ZXJIVE1MW291dGVySFRNTF0pXG4gICAgICAuZmlsdGVyKCh7IHR5cGUgfSkgPT4gdHlwZSA9PSBtYXRjaGVkVHlwZSlcbiAgICAgIC5tYXAoKHsgZWxlbWVudHM6IFtlbGVtZW50XSB9KSA9PiBlbGVtZW50KVxuICB9XG5cbiAgZ2V0IHByb3Zpc2lvbmFsRWxlbWVudHMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuZGV0YWlsc0J5T3V0ZXJIVE1MKS5yZWR1Y2UoKHJlc3VsdCwgb3V0ZXJIVE1MKSA9PiB7XG4gICAgICBjb25zdCB7IHR5cGUsIHRyYWNrZWQsIGVsZW1lbnRzIH0gPSB0aGlzLmRldGFpbHNCeU91dGVySFRNTFtvdXRlckhUTUxdO1xuICAgICAgaWYgKHR5cGUgPT0gbnVsbCAmJiAhdHJhY2tlZCkge1xuICAgICAgICByZXR1cm4gWy4uLnJlc3VsdCwgLi4uZWxlbWVudHNdXG4gICAgICB9IGVsc2UgaWYgKGVsZW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgcmV0dXJuIFsuLi5yZXN1bHQsIC4uLmVsZW1lbnRzLnNsaWNlKDEpXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdFxuICAgICAgfVxuICAgIH0sIFtdKVxuICB9XG5cbiAgZ2V0TWV0YVZhbHVlKG5hbWUpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5maW5kTWV0YUVsZW1lbnRCeU5hbWUobmFtZSk7XG4gICAgcmV0dXJuIGVsZW1lbnQgPyBlbGVtZW50LmdldEF0dHJpYnV0ZShcImNvbnRlbnRcIikgOiBudWxsXG4gIH1cblxuICBmaW5kTWV0YUVsZW1lbnRCeU5hbWUobmFtZSkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmRldGFpbHNCeU91dGVySFRNTCkucmVkdWNlKChyZXN1bHQsIG91dGVySFRNTCkgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICBlbGVtZW50czogW2VsZW1lbnRdXG4gICAgICB9ID0gdGhpcy5kZXRhaWxzQnlPdXRlckhUTUxbb3V0ZXJIVE1MXTtcbiAgICAgIHJldHVybiBlbGVtZW50SXNNZXRhRWxlbWVudFdpdGhOYW1lKGVsZW1lbnQsIG5hbWUpID8gZWxlbWVudCA6IHJlc3VsdFxuICAgIH0sIHVuZGVmaW5lZCB8IHVuZGVmaW5lZClcbiAgfVxufVxuXG5mdW5jdGlvbiBlbGVtZW50VHlwZShlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50SXNTY3JpcHQoZWxlbWVudCkpIHtcbiAgICByZXR1cm4gXCJzY3JpcHRcIlxuICB9IGVsc2UgaWYgKGVsZW1lbnRJc1N0eWxlc2hlZXQoZWxlbWVudCkpIHtcbiAgICByZXR1cm4gXCJzdHlsZXNoZWV0XCJcbiAgfVxufVxuXG5mdW5jdGlvbiBlbGVtZW50SXNUcmFja2VkKGVsZW1lbnQpIHtcbiAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS10dXJiby10cmFja1wiKSA9PSBcInJlbG9hZFwiXG59XG5cbmZ1bmN0aW9uIGVsZW1lbnRJc1NjcmlwdChlbGVtZW50KSB7XG4gIGNvbnN0IHRhZ05hbWUgPSBlbGVtZW50LmxvY2FsTmFtZTtcbiAgcmV0dXJuIHRhZ05hbWUgPT0gXCJzY3JpcHRcIlxufVxuXG5mdW5jdGlvbiBlbGVtZW50SXNOb3NjcmlwdChlbGVtZW50KSB7XG4gIGNvbnN0IHRhZ05hbWUgPSBlbGVtZW50LmxvY2FsTmFtZTtcbiAgcmV0dXJuIHRhZ05hbWUgPT0gXCJub3NjcmlwdFwiXG59XG5cbmZ1bmN0aW9uIGVsZW1lbnRJc1N0eWxlc2hlZXQoZWxlbWVudCkge1xuICBjb25zdCB0YWdOYW1lID0gZWxlbWVudC5sb2NhbE5hbWU7XG4gIHJldHVybiB0YWdOYW1lID09IFwic3R5bGVcIiB8fCAodGFnTmFtZSA9PSBcImxpbmtcIiAmJiBlbGVtZW50LmdldEF0dHJpYnV0ZShcInJlbFwiKSA9PSBcInN0eWxlc2hlZXRcIilcbn1cblxuZnVuY3Rpb24gZWxlbWVudElzTWV0YUVsZW1lbnRXaXRoTmFtZShlbGVtZW50LCBuYW1lKSB7XG4gIGNvbnN0IHRhZ05hbWUgPSBlbGVtZW50LmxvY2FsTmFtZTtcbiAgcmV0dXJuIHRhZ05hbWUgPT0gXCJtZXRhXCIgJiYgZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJuYW1lXCIpID09IG5hbWVcbn1cblxuZnVuY3Rpb24gZWxlbWVudFdpdGhvdXROb25jZShlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZShcIm5vbmNlXCIpKSB7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJub25jZVwiLCBcIlwiKTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50XG59XG5cbmNsYXNzIFBhZ2VTbmFwc2hvdCBleHRlbmRzIFNuYXBzaG90IHtcbiAgc3RhdGljIGZyb21IVE1MU3RyaW5nKGh0bWwgPSBcIlwiKSB7XG4gICAgcmV0dXJuIHRoaXMuZnJvbURvY3VtZW50KHBhcnNlSFRNTERvY3VtZW50KGh0bWwpKVxuICB9XG5cbiAgc3RhdGljIGZyb21FbGVtZW50KGVsZW1lbnQpIHtcbiAgICByZXR1cm4gdGhpcy5mcm9tRG9jdW1lbnQoZWxlbWVudC5vd25lckRvY3VtZW50KVxuICB9XG5cbiAgc3RhdGljIGZyb21Eb2N1bWVudCh7IGRvY3VtZW50RWxlbWVudCwgYm9keSwgaGVhZCB9KSB7XG4gICAgcmV0dXJuIG5ldyB0aGlzKGRvY3VtZW50RWxlbWVudCwgYm9keSwgbmV3IEhlYWRTbmFwc2hvdChoZWFkKSlcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGRvY3VtZW50RWxlbWVudCwgYm9keSwgaGVhZFNuYXBzaG90KSB7XG4gICAgc3VwZXIoYm9keSk7XG4gICAgdGhpcy5kb2N1bWVudEVsZW1lbnQgPSBkb2N1bWVudEVsZW1lbnQ7XG4gICAgdGhpcy5oZWFkU25hcHNob3QgPSBoZWFkU25hcHNob3Q7XG4gIH1cblxuICBjbG9uZSgpIHtcbiAgICBjb25zdCBjbG9uZWRFbGVtZW50ID0gdGhpcy5lbGVtZW50LmNsb25lTm9kZSh0cnVlKTtcblxuICAgIGNvbnN0IHNlbGVjdEVsZW1lbnRzID0gdGhpcy5lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJzZWxlY3RcIik7XG4gICAgY29uc3QgY2xvbmVkU2VsZWN0RWxlbWVudHMgPSBjbG9uZWRFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJzZWxlY3RcIik7XG5cbiAgICBmb3IgKGNvbnN0IFtpbmRleCwgc291cmNlXSBvZiBzZWxlY3RFbGVtZW50cy5lbnRyaWVzKCkpIHtcbiAgICAgIGNvbnN0IGNsb25lID0gY2xvbmVkU2VsZWN0RWxlbWVudHNbaW5kZXhdO1xuICAgICAgZm9yIChjb25zdCBvcHRpb24gb2YgY2xvbmUuc2VsZWN0ZWRPcHRpb25zKSBvcHRpb24uc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIHNvdXJjZS5zZWxlY3RlZE9wdGlvbnMpIGNsb25lLm9wdGlvbnNbb3B0aW9uLmluZGV4XS5zZWxlY3RlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBjbG9uZWRQYXNzd29yZElucHV0IG9mIGNsb25lZEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbdHlwZT1cInBhc3N3b3JkXCJdJykpIHtcbiAgICAgIGNsb25lZFBhc3N3b3JkSW5wdXQudmFsdWUgPSBcIlwiO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUGFnZVNuYXBzaG90KHRoaXMuZG9jdW1lbnRFbGVtZW50LCBjbG9uZWRFbGVtZW50LCB0aGlzLmhlYWRTbmFwc2hvdClcbiAgfVxuXG4gIGdldCBsYW5nKCkge1xuICAgIHJldHVybiB0aGlzLmRvY3VtZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJsYW5nXCIpXG4gIH1cblxuICBnZXQgaGVhZEVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGVhZFNuYXBzaG90LmVsZW1lbnRcbiAgfVxuXG4gIGdldCByb290TG9jYXRpb24oKSB7XG4gICAgY29uc3Qgcm9vdCA9IHRoaXMuZ2V0U2V0dGluZyhcInJvb3RcIikgPz8gXCIvXCI7XG4gICAgcmV0dXJuIGV4cGFuZFVSTChyb290KVxuICB9XG5cbiAgZ2V0IGNhY2hlQ29udHJvbFZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLmdldFNldHRpbmcoXCJjYWNoZS1jb250cm9sXCIpXG4gIH1cblxuICBnZXQgaXNQcmV2aWV3YWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jYWNoZUNvbnRyb2xWYWx1ZSAhPSBcIm5vLXByZXZpZXdcIlxuICB9XG5cbiAgZ2V0IGlzQ2FjaGVhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmNhY2hlQ29udHJvbFZhbHVlICE9IFwibm8tY2FjaGVcIlxuICB9XG5cbiAgZ2V0IGlzVmlzaXRhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLmdldFNldHRpbmcoXCJ2aXNpdC1jb250cm9sXCIpICE9IFwicmVsb2FkXCJcbiAgfVxuXG4gIGdldCBwcmVmZXJzVmlld1RyYW5zaXRpb25zKCkge1xuICAgIHJldHVybiB0aGlzLmhlYWRTbmFwc2hvdC5nZXRNZXRhVmFsdWUoXCJ2aWV3LXRyYW5zaXRpb25cIikgPT09IFwic2FtZS1vcmlnaW5cIlxuICB9XG5cbiAgZ2V0IHNob3VsZE1vcnBoUGFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTZXR0aW5nKFwicmVmcmVzaC1tZXRob2RcIikgPT09IFwibW9ycGhcIlxuICB9XG5cbiAgZ2V0IHNob3VsZFByZXNlcnZlU2Nyb2xsUG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U2V0dGluZyhcInJlZnJlc2gtc2Nyb2xsXCIpID09PSBcInByZXNlcnZlXCJcbiAgfVxuXG4gIC8vIFByaXZhdGVcblxuICBnZXRTZXR0aW5nKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5oZWFkU25hcHNob3QuZ2V0TWV0YVZhbHVlKGB0dXJiby0ke25hbWV9YClcbiAgfVxufVxuXG5jbGFzcyBWaWV3VHJhbnNpdGlvbmVyIHtcbiAgI3ZpZXdUcmFuc2l0aW9uU3RhcnRlZCA9IGZhbHNlXG4gICNsYXN0T3BlcmF0aW9uID0gUHJvbWlzZS5yZXNvbHZlKClcblxuICByZW5kZXJDaGFuZ2UodXNlVmlld1RyYW5zaXRpb24sIHJlbmRlcikge1xuICAgIGlmICh1c2VWaWV3VHJhbnNpdGlvbiAmJiB0aGlzLnZpZXdUcmFuc2l0aW9uc0F2YWlsYWJsZSAmJiAhdGhpcy4jdmlld1RyYW5zaXRpb25TdGFydGVkKSB7XG4gICAgICB0aGlzLiN2aWV3VHJhbnNpdGlvblN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgdGhpcy4jbGFzdE9wZXJhdGlvbiA9IHRoaXMuI2xhc3RPcGVyYXRpb24udGhlbihhc3luYyAoKSA9PiB7XG4gICAgICAgIGF3YWl0IGRvY3VtZW50LnN0YXJ0Vmlld1RyYW5zaXRpb24ocmVuZGVyKS5maW5pc2hlZDtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNsYXN0T3BlcmF0aW9uID0gdGhpcy4jbGFzdE9wZXJhdGlvbi50aGVuKHJlbmRlcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuI2xhc3RPcGVyYXRpb25cbiAgfVxuXG4gIGdldCB2aWV3VHJhbnNpdGlvbnNBdmFpbGFibGUoKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LnN0YXJ0Vmlld1RyYW5zaXRpb25cbiAgfVxufVxuXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgYWN0aW9uOiBcImFkdmFuY2VcIixcbiAgaGlzdG9yeUNoYW5nZWQ6IGZhbHNlLFxuICB2aXNpdENhY2hlZFNuYXBzaG90OiAoKSA9PiB7fSxcbiAgd2lsbFJlbmRlcjogdHJ1ZSxcbiAgdXBkYXRlSGlzdG9yeTogdHJ1ZSxcbiAgc2hvdWxkQ2FjaGVTbmFwc2hvdDogdHJ1ZSxcbiAgYWNjZXB0c1N0cmVhbVJlc3BvbnNlOiBmYWxzZVxufTtcblxuY29uc3QgVGltaW5nTWV0cmljID0ge1xuICB2aXNpdFN0YXJ0OiBcInZpc2l0U3RhcnRcIixcbiAgcmVxdWVzdFN0YXJ0OiBcInJlcXVlc3RTdGFydFwiLFxuICByZXF1ZXN0RW5kOiBcInJlcXVlc3RFbmRcIixcbiAgdmlzaXRFbmQ6IFwidmlzaXRFbmRcIlxufTtcblxuY29uc3QgVmlzaXRTdGF0ZSA9IHtcbiAgaW5pdGlhbGl6ZWQ6IFwiaW5pdGlhbGl6ZWRcIixcbiAgc3RhcnRlZDogXCJzdGFydGVkXCIsXG4gIGNhbmNlbGVkOiBcImNhbmNlbGVkXCIsXG4gIGZhaWxlZDogXCJmYWlsZWRcIixcbiAgY29tcGxldGVkOiBcImNvbXBsZXRlZFwiXG59O1xuXG5jb25zdCBTeXN0ZW1TdGF0dXNDb2RlID0ge1xuICBuZXR3b3JrRmFpbHVyZTogMCxcbiAgdGltZW91dEZhaWx1cmU6IC0xLFxuICBjb250ZW50VHlwZU1pc21hdGNoOiAtMlxufTtcblxuY29uc3QgRGlyZWN0aW9uID0ge1xuICBhZHZhbmNlOiBcImZvcndhcmRcIixcbiAgcmVzdG9yZTogXCJiYWNrXCIsXG4gIHJlcGxhY2U6IFwibm9uZVwiXG59O1xuXG5jbGFzcyBWaXNpdCB7XG4gIGlkZW50aWZpZXIgPSB1dWlkKCkgLy8gUmVxdWlyZWQgYnkgdHVyYm8taW9zXG4gIHRpbWluZ01ldHJpY3MgPSB7fVxuXG4gIGZvbGxvd2VkUmVkaXJlY3QgPSBmYWxzZVxuICBoaXN0b3J5Q2hhbmdlZCA9IGZhbHNlXG4gIHNjcm9sbGVkID0gZmFsc2VcbiAgc2hvdWxkQ2FjaGVTbmFwc2hvdCA9IHRydWVcbiAgYWNjZXB0c1N0cmVhbVJlc3BvbnNlID0gZmFsc2VcbiAgc25hcHNob3RDYWNoZWQgPSBmYWxzZVxuICBzdGF0ZSA9IFZpc2l0U3RhdGUuaW5pdGlhbGl6ZWRcbiAgdmlld1RyYW5zaXRpb25lciA9IG5ldyBWaWV3VHJhbnNpdGlvbmVyKClcblxuICBjb25zdHJ1Y3RvcihkZWxlZ2F0ZSwgbG9jYXRpb24sIHJlc3RvcmF0aW9uSWRlbnRpZmllciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xuICAgIHRoaXMubG9jYXRpb24gPSBsb2NhdGlvbjtcbiAgICB0aGlzLnJlc3RvcmF0aW9uSWRlbnRpZmllciA9IHJlc3RvcmF0aW9uSWRlbnRpZmllciB8fCB1dWlkKCk7XG5cbiAgICBjb25zdCB7XG4gICAgICBhY3Rpb24sXG4gICAgICBoaXN0b3J5Q2hhbmdlZCxcbiAgICAgIHJlZmVycmVyLFxuICAgICAgc25hcHNob3QsXG4gICAgICBzbmFwc2hvdEhUTUwsXG4gICAgICByZXNwb25zZSxcbiAgICAgIHZpc2l0Q2FjaGVkU25hcHNob3QsXG4gICAgICB3aWxsUmVuZGVyLFxuICAgICAgdXBkYXRlSGlzdG9yeSxcbiAgICAgIHNob3VsZENhY2hlU25hcHNob3QsXG4gICAgICBhY2NlcHRzU3RyZWFtUmVzcG9uc2UsXG4gICAgICBkaXJlY3Rpb25cbiAgICB9ID0ge1xuICAgICAgLi4uZGVmYXVsdE9wdGlvbnMsXG4gICAgICAuLi5vcHRpb25zXG4gICAgfTtcbiAgICB0aGlzLmFjdGlvbiA9IGFjdGlvbjtcbiAgICB0aGlzLmhpc3RvcnlDaGFuZ2VkID0gaGlzdG9yeUNoYW5nZWQ7XG4gICAgdGhpcy5yZWZlcnJlciA9IHJlZmVycmVyO1xuICAgIHRoaXMuc25hcHNob3QgPSBzbmFwc2hvdDtcbiAgICB0aGlzLnNuYXBzaG90SFRNTCA9IHNuYXBzaG90SFRNTDtcbiAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgdGhpcy5pc1NhbWVQYWdlID0gdGhpcy5kZWxlZ2F0ZS5sb2NhdGlvbldpdGhBY3Rpb25Jc1NhbWVQYWdlKHRoaXMubG9jYXRpb24sIHRoaXMuYWN0aW9uKTtcbiAgICB0aGlzLmlzUGFnZVJlZnJlc2ggPSB0aGlzLnZpZXcuaXNQYWdlUmVmcmVzaCh0aGlzKTtcbiAgICB0aGlzLnZpc2l0Q2FjaGVkU25hcHNob3QgPSB2aXNpdENhY2hlZFNuYXBzaG90O1xuICAgIHRoaXMud2lsbFJlbmRlciA9IHdpbGxSZW5kZXI7XG4gICAgdGhpcy51cGRhdGVIaXN0b3J5ID0gdXBkYXRlSGlzdG9yeTtcbiAgICB0aGlzLnNjcm9sbGVkID0gIXdpbGxSZW5kZXI7XG4gICAgdGhpcy5zaG91bGRDYWNoZVNuYXBzaG90ID0gc2hvdWxkQ2FjaGVTbmFwc2hvdDtcbiAgICB0aGlzLmFjY2VwdHNTdHJlYW1SZXNwb25zZSA9IGFjY2VwdHNTdHJlYW1SZXNwb25zZTtcbiAgICB0aGlzLmRpcmVjdGlvbiA9IGRpcmVjdGlvbiB8fCBEaXJlY3Rpb25bYWN0aW9uXTtcbiAgfVxuXG4gIGdldCBhZGFwdGVyKCkge1xuICAgIHJldHVybiB0aGlzLmRlbGVnYXRlLmFkYXB0ZXJcbiAgfVxuXG4gIGdldCB2aWV3KCkge1xuICAgIHJldHVybiB0aGlzLmRlbGVnYXRlLnZpZXdcbiAgfVxuXG4gIGdldCBoaXN0b3J5KCkge1xuICAgIHJldHVybiB0aGlzLmRlbGVnYXRlLmhpc3RvcnlcbiAgfVxuXG4gIGdldCByZXN0b3JhdGlvbkRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGlzdG9yeS5nZXRSZXN0b3JhdGlvbkRhdGFGb3JJZGVudGlmaWVyKHRoaXMucmVzdG9yYXRpb25JZGVudGlmaWVyKVxuICB9XG5cbiAgZ2V0IHNpbGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1NhbWVQYWdlXG4gIH1cblxuICBzdGFydCgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PSBWaXNpdFN0YXRlLmluaXRpYWxpemVkKSB7XG4gICAgICB0aGlzLnJlY29yZFRpbWluZ01ldHJpYyhUaW1pbmdNZXRyaWMudmlzaXRTdGFydCk7XG4gICAgICB0aGlzLnN0YXRlID0gVmlzaXRTdGF0ZS5zdGFydGVkO1xuICAgICAgdGhpcy5hZGFwdGVyLnZpc2l0U3RhcnRlZCh0aGlzKTtcbiAgICAgIHRoaXMuZGVsZWdhdGUudmlzaXRTdGFydGVkKHRoaXMpO1xuICAgIH1cbiAgfVxuXG4gIGNhbmNlbCgpIHtcbiAgICBpZiAodGhpcy5zdGF0ZSA9PSBWaXNpdFN0YXRlLnN0YXJ0ZWQpIHtcbiAgICAgIGlmICh0aGlzLnJlcXVlc3QpIHtcbiAgICAgICAgdGhpcy5yZXF1ZXN0LmNhbmNlbCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5jYW5jZWxSZW5kZXIoKTtcbiAgICAgIHRoaXMuc3RhdGUgPSBWaXNpdFN0YXRlLmNhbmNlbGVkO1xuICAgIH1cbiAgfVxuXG4gIGNvbXBsZXRlKCkge1xuICAgIGlmICh0aGlzLnN0YXRlID09IFZpc2l0U3RhdGUuc3RhcnRlZCkge1xuICAgICAgdGhpcy5yZWNvcmRUaW1pbmdNZXRyaWMoVGltaW5nTWV0cmljLnZpc2l0RW5kKTtcbiAgICAgIHRoaXMuYWRhcHRlci52aXNpdENvbXBsZXRlZCh0aGlzKTtcbiAgICAgIHRoaXMuc3RhdGUgPSBWaXNpdFN0YXRlLmNvbXBsZXRlZDtcbiAgICAgIHRoaXMuZm9sbG93UmVkaXJlY3QoKTtcblxuICAgICAgaWYgKCF0aGlzLmZvbGxvd2VkUmVkaXJlY3QpIHtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZS52aXNpdENvbXBsZXRlZCh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmYWlsKCkge1xuICAgIGlmICh0aGlzLnN0YXRlID09IFZpc2l0U3RhdGUuc3RhcnRlZCkge1xuICAgICAgdGhpcy5zdGF0ZSA9IFZpc2l0U3RhdGUuZmFpbGVkO1xuICAgICAgdGhpcy5hZGFwdGVyLnZpc2l0RmFpbGVkKHRoaXMpO1xuICAgICAgdGhpcy5kZWxlZ2F0ZS52aXNpdENvbXBsZXRlZCh0aGlzKTtcbiAgICB9XG4gIH1cblxuICBjaGFuZ2VIaXN0b3J5KCkge1xuICAgIGlmICghdGhpcy5oaXN0b3J5Q2hhbmdlZCAmJiB0aGlzLnVwZGF0ZUhpc3RvcnkpIHtcbiAgICAgIGNvbnN0IGFjdGlvbkZvckhpc3RvcnkgPSB0aGlzLmxvY2F0aW9uLmhyZWYgPT09IHRoaXMucmVmZXJyZXI/LmhyZWYgPyBcInJlcGxhY2VcIiA6IHRoaXMuYWN0aW9uO1xuICAgICAgY29uc3QgbWV0aG9kID0gZ2V0SGlzdG9yeU1ldGhvZEZvckFjdGlvbihhY3Rpb25Gb3JIaXN0b3J5KTtcbiAgICAgIHRoaXMuaGlzdG9yeS51cGRhdGUobWV0aG9kLCB0aGlzLmxvY2F0aW9uLCB0aGlzLnJlc3RvcmF0aW9uSWRlbnRpZmllcik7XG4gICAgICB0aGlzLmhpc3RvcnlDaGFuZ2VkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpc3N1ZVJlcXVlc3QoKSB7XG4gICAgaWYgKHRoaXMuaGFzUHJlbG9hZGVkUmVzcG9uc2UoKSkge1xuICAgICAgdGhpcy5zaW11bGF0ZVJlcXVlc3QoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuc2hvdWxkSXNzdWVSZXF1ZXN0KCkgJiYgIXRoaXMucmVxdWVzdCkge1xuICAgICAgdGhpcy5yZXF1ZXN0ID0gbmV3IEZldGNoUmVxdWVzdCh0aGlzLCBGZXRjaE1ldGhvZC5nZXQsIHRoaXMubG9jYXRpb24pO1xuICAgICAgdGhpcy5yZXF1ZXN0LnBlcmZvcm0oKTtcbiAgICB9XG4gIH1cblxuICBzaW11bGF0ZVJlcXVlc3QoKSB7XG4gICAgaWYgKHRoaXMucmVzcG9uc2UpIHtcbiAgICAgIHRoaXMuc3RhcnRSZXF1ZXN0KCk7XG4gICAgICB0aGlzLnJlY29yZFJlc3BvbnNlKCk7XG4gICAgICB0aGlzLmZpbmlzaFJlcXVlc3QoKTtcbiAgICB9XG4gIH1cblxuICBzdGFydFJlcXVlc3QoKSB7XG4gICAgdGhpcy5yZWNvcmRUaW1pbmdNZXRyaWMoVGltaW5nTWV0cmljLnJlcXVlc3RTdGFydCk7XG4gICAgdGhpcy5hZGFwdGVyLnZpc2l0UmVxdWVzdFN0YXJ0ZWQodGhpcyk7XG4gIH1cblxuICByZWNvcmRSZXNwb25zZShyZXNwb25zZSA9IHRoaXMucmVzcG9uc2UpIHtcbiAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgaWYgKHJlc3BvbnNlKSB7XG4gICAgICBjb25zdCB7IHN0YXR1c0NvZGUgfSA9IHJlc3BvbnNlO1xuICAgICAgaWYgKGlzU3VjY2Vzc2Z1bChzdGF0dXNDb2RlKSkge1xuICAgICAgICB0aGlzLmFkYXB0ZXIudmlzaXRSZXF1ZXN0Q29tcGxldGVkKHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyLnZpc2l0UmVxdWVzdEZhaWxlZFdpdGhTdGF0dXNDb2RlKHRoaXMsIHN0YXR1c0NvZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZpbmlzaFJlcXVlc3QoKSB7XG4gICAgdGhpcy5yZWNvcmRUaW1pbmdNZXRyaWMoVGltaW5nTWV0cmljLnJlcXVlc3RFbmQpO1xuICAgIHRoaXMuYWRhcHRlci52aXNpdFJlcXVlc3RGaW5pc2hlZCh0aGlzKTtcbiAgfVxuXG4gIGxvYWRSZXNwb25zZSgpIHtcbiAgICBpZiAodGhpcy5yZXNwb25zZSkge1xuICAgICAgY29uc3QgeyBzdGF0dXNDb2RlLCByZXNwb25zZUhUTUwgfSA9IHRoaXMucmVzcG9uc2U7XG4gICAgICB0aGlzLnJlbmRlcihhc3luYyAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnNob3VsZENhY2hlU25hcHNob3QpIHRoaXMuY2FjaGVTbmFwc2hvdCgpO1xuICAgICAgICBpZiAodGhpcy52aWV3LnJlbmRlclByb21pc2UpIGF3YWl0IHRoaXMudmlldy5yZW5kZXJQcm9taXNlO1xuXG4gICAgICAgIGlmIChpc1N1Y2Nlc3NmdWwoc3RhdHVzQ29kZSkgJiYgcmVzcG9uc2VIVE1MICE9IG51bGwpIHtcbiAgICAgICAgICBjb25zdCBzbmFwc2hvdCA9IFBhZ2VTbmFwc2hvdC5mcm9tSFRNTFN0cmluZyhyZXNwb25zZUhUTUwpO1xuICAgICAgICAgIGF3YWl0IHRoaXMucmVuZGVyUGFnZVNuYXBzaG90KHNuYXBzaG90LCBmYWxzZSk7XG5cbiAgICAgICAgICB0aGlzLmFkYXB0ZXIudmlzaXRSZW5kZXJlZCh0aGlzKTtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy52aWV3LnJlbmRlckVycm9yKFBhZ2VTbmFwc2hvdC5mcm9tSFRNTFN0cmluZyhyZXNwb25zZUhUTUwpLCB0aGlzKTtcbiAgICAgICAgICB0aGlzLmFkYXB0ZXIudmlzaXRSZW5kZXJlZCh0aGlzKTtcbiAgICAgICAgICB0aGlzLmZhaWwoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0Q2FjaGVkU25hcHNob3QoKSB7XG4gICAgY29uc3Qgc25hcHNob3QgPSB0aGlzLnZpZXcuZ2V0Q2FjaGVkU25hcHNob3RGb3JMb2NhdGlvbih0aGlzLmxvY2F0aW9uKSB8fCB0aGlzLmdldFByZWxvYWRlZFNuYXBzaG90KCk7XG5cbiAgICBpZiAoc25hcHNob3QgJiYgKCFnZXRBbmNob3IodGhpcy5sb2NhdGlvbikgfHwgc25hcHNob3QuaGFzQW5jaG9yKGdldEFuY2hvcih0aGlzLmxvY2F0aW9uKSkpKSB7XG4gICAgICBpZiAodGhpcy5hY3Rpb24gPT0gXCJyZXN0b3JlXCIgfHwgc25hcHNob3QuaXNQcmV2aWV3YWJsZSkge1xuICAgICAgICByZXR1cm4gc25hcHNob3RcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBnZXRQcmVsb2FkZWRTbmFwc2hvdCgpIHtcbiAgICBpZiAodGhpcy5zbmFwc2hvdEhUTUwpIHtcbiAgICAgIHJldHVybiBQYWdlU25hcHNob3QuZnJvbUhUTUxTdHJpbmcodGhpcy5zbmFwc2hvdEhUTUwpXG4gICAgfVxuICB9XG5cbiAgaGFzQ2FjaGVkU25hcHNob3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q2FjaGVkU25hcHNob3QoKSAhPSBudWxsXG4gIH1cblxuICBsb2FkQ2FjaGVkU25hcHNob3QoKSB7XG4gICAgY29uc3Qgc25hcHNob3QgPSB0aGlzLmdldENhY2hlZFNuYXBzaG90KCk7XG4gICAgaWYgKHNuYXBzaG90KSB7XG4gICAgICBjb25zdCBpc1ByZXZpZXcgPSB0aGlzLnNob3VsZElzc3VlUmVxdWVzdCgpO1xuICAgICAgdGhpcy5yZW5kZXIoYXN5bmMgKCkgPT4ge1xuICAgICAgICB0aGlzLmNhY2hlU25hcHNob3QoKTtcbiAgICAgICAgaWYgKHRoaXMuaXNTYW1lUGFnZSB8fCB0aGlzLmlzUGFnZVJlZnJlc2gpIHtcbiAgICAgICAgICB0aGlzLmFkYXB0ZXIudmlzaXRSZW5kZXJlZCh0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodGhpcy52aWV3LnJlbmRlclByb21pc2UpIGF3YWl0IHRoaXMudmlldy5yZW5kZXJQcm9taXNlO1xuXG4gICAgICAgICAgYXdhaXQgdGhpcy5yZW5kZXJQYWdlU25hcHNob3Qoc25hcHNob3QsIGlzUHJldmlldyk7XG5cbiAgICAgICAgICB0aGlzLmFkYXB0ZXIudmlzaXRSZW5kZXJlZCh0aGlzKTtcbiAgICAgICAgICBpZiAoIWlzUHJldmlldykge1xuICAgICAgICAgICAgdGhpcy5jb21wbGV0ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgZm9sbG93UmVkaXJlY3QoKSB7XG4gICAgaWYgKHRoaXMucmVkaXJlY3RlZFRvTG9jYXRpb24gJiYgIXRoaXMuZm9sbG93ZWRSZWRpcmVjdCAmJiB0aGlzLnJlc3BvbnNlPy5yZWRpcmVjdGVkKSB7XG4gICAgICB0aGlzLmFkYXB0ZXIudmlzaXRQcm9wb3NlZFRvTG9jYXRpb24odGhpcy5yZWRpcmVjdGVkVG9Mb2NhdGlvbiwge1xuICAgICAgICBhY3Rpb246IFwicmVwbGFjZVwiLFxuICAgICAgICByZXNwb25zZTogdGhpcy5yZXNwb25zZSxcbiAgICAgICAgc2hvdWxkQ2FjaGVTbmFwc2hvdDogZmFsc2UsXG4gICAgICAgIHdpbGxSZW5kZXI6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZm9sbG93ZWRSZWRpcmVjdCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgZ29Ub1NhbWVQYWdlQW5jaG9yKCkge1xuICAgIGlmICh0aGlzLmlzU2FtZVBhZ2UpIHtcbiAgICAgIHRoaXMucmVuZGVyKGFzeW5jICgpID0+IHtcbiAgICAgICAgdGhpcy5jYWNoZVNuYXBzaG90KCk7XG4gICAgICAgIHRoaXMucGVyZm9ybVNjcm9sbCgpO1xuICAgICAgICB0aGlzLmNoYW5nZUhpc3RvcnkoKTtcbiAgICAgICAgdGhpcy5hZGFwdGVyLnZpc2l0UmVuZGVyZWQodGhpcyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvLyBGZXRjaCByZXF1ZXN0IGRlbGVnYXRlXG5cbiAgcHJlcGFyZVJlcXVlc3QocmVxdWVzdCkge1xuICAgIGlmICh0aGlzLmFjY2VwdHNTdHJlYW1SZXNwb25zZSkge1xuICAgICAgcmVxdWVzdC5hY2NlcHRSZXNwb25zZVR5cGUoU3RyZWFtTWVzc2FnZS5jb250ZW50VHlwZSk7XG4gICAgfVxuICB9XG5cbiAgcmVxdWVzdFN0YXJ0ZWQoKSB7XG4gICAgdGhpcy5zdGFydFJlcXVlc3QoKTtcbiAgfVxuXG4gIHJlcXVlc3RQcmV2ZW50ZWRIYW5kbGluZ1Jlc3BvbnNlKF9yZXF1ZXN0LCBfcmVzcG9uc2UpIHt9XG5cbiAgYXN5bmMgcmVxdWVzdFN1Y2NlZWRlZFdpdGhSZXNwb25zZShyZXF1ZXN0LCByZXNwb25zZSkge1xuICAgIGNvbnN0IHJlc3BvbnNlSFRNTCA9IGF3YWl0IHJlc3BvbnNlLnJlc3BvbnNlSFRNTDtcbiAgICBjb25zdCB7IHJlZGlyZWN0ZWQsIHN0YXR1c0NvZGUgfSA9IHJlc3BvbnNlO1xuICAgIGlmIChyZXNwb25zZUhUTUwgPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnJlY29yZFJlc3BvbnNlKHtcbiAgICAgICAgc3RhdHVzQ29kZTogU3lzdGVtU3RhdHVzQ29kZS5jb250ZW50VHlwZU1pc21hdGNoLFxuICAgICAgICByZWRpcmVjdGVkXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZWRpcmVjdGVkVG9Mb2NhdGlvbiA9IHJlc3BvbnNlLnJlZGlyZWN0ZWQgPyByZXNwb25zZS5sb2NhdGlvbiA6IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMucmVjb3JkUmVzcG9uc2UoeyBzdGF0dXNDb2RlOiBzdGF0dXNDb2RlLCByZXNwb25zZUhUTUwsIHJlZGlyZWN0ZWQgfSk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgcmVxdWVzdEZhaWxlZFdpdGhSZXNwb25zZShyZXF1ZXN0LCByZXNwb25zZSkge1xuICAgIGNvbnN0IHJlc3BvbnNlSFRNTCA9IGF3YWl0IHJlc3BvbnNlLnJlc3BvbnNlSFRNTDtcbiAgICBjb25zdCB7IHJlZGlyZWN0ZWQsIHN0YXR1c0NvZGUgfSA9IHJlc3BvbnNlO1xuICAgIGlmIChyZXNwb25zZUhUTUwgPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLnJlY29yZFJlc3BvbnNlKHtcbiAgICAgICAgc3RhdHVzQ29kZTogU3lzdGVtU3RhdHVzQ29kZS5jb250ZW50VHlwZU1pc21hdGNoLFxuICAgICAgICByZWRpcmVjdGVkXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZWNvcmRSZXNwb25zZSh7IHN0YXR1c0NvZGU6IHN0YXR1c0NvZGUsIHJlc3BvbnNlSFRNTCwgcmVkaXJlY3RlZCB9KTtcbiAgICB9XG4gIH1cblxuICByZXF1ZXN0RXJyb3JlZChfcmVxdWVzdCwgX2Vycm9yKSB7XG4gICAgdGhpcy5yZWNvcmRSZXNwb25zZSh7XG4gICAgICBzdGF0dXNDb2RlOiBTeXN0ZW1TdGF0dXNDb2RlLm5ldHdvcmtGYWlsdXJlLFxuICAgICAgcmVkaXJlY3RlZDogZmFsc2VcbiAgICB9KTtcbiAgfVxuXG4gIHJlcXVlc3RGaW5pc2hlZCgpIHtcbiAgICB0aGlzLmZpbmlzaFJlcXVlc3QoKTtcbiAgfVxuXG4gIC8vIFNjcm9sbGluZ1xuXG4gIHBlcmZvcm1TY3JvbGwoKSB7XG4gICAgaWYgKCF0aGlzLnNjcm9sbGVkICYmICF0aGlzLnZpZXcuZm9yY2VSZWxvYWRlZCAmJiAhdGhpcy52aWV3LnNob3VsZFByZXNlcnZlU2Nyb2xsUG9zaXRpb24odGhpcykpIHtcbiAgICAgIGlmICh0aGlzLmFjdGlvbiA9PSBcInJlc3RvcmVcIikge1xuICAgICAgICB0aGlzLnNjcm9sbFRvUmVzdG9yZWRQb3NpdGlvbigpIHx8IHRoaXMuc2Nyb2xsVG9BbmNob3IoKSB8fCB0aGlzLnZpZXcuc2Nyb2xsVG9Ub3AoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsVG9BbmNob3IoKSB8fCB0aGlzLnZpZXcuc2Nyb2xsVG9Ub3AoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlzU2FtZVBhZ2UpIHtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZS52aXNpdFNjcm9sbGVkVG9TYW1lUGFnZUxvY2F0aW9uKHRoaXMudmlldy5sYXN0UmVuZGVyZWRMb2NhdGlvbiwgdGhpcy5sb2NhdGlvbik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2Nyb2xsZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHNjcm9sbFRvUmVzdG9yZWRQb3NpdGlvbigpIHtcbiAgICBjb25zdCB7IHNjcm9sbFBvc2l0aW9uIH0gPSB0aGlzLnJlc3RvcmF0aW9uRGF0YTtcbiAgICBpZiAoc2Nyb2xsUG9zaXRpb24pIHtcbiAgICAgIHRoaXMudmlldy5zY3JvbGxUb1Bvc2l0aW9uKHNjcm9sbFBvc2l0aW9uKTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG5cbiAgc2Nyb2xsVG9BbmNob3IoKSB7XG4gICAgY29uc3QgYW5jaG9yID0gZ2V0QW5jaG9yKHRoaXMubG9jYXRpb24pO1xuICAgIGlmIChhbmNob3IgIT0gbnVsbCkge1xuICAgICAgdGhpcy52aWV3LnNjcm9sbFRvQW5jaG9yKGFuY2hvcik7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIC8vIEluc3RydW1lbnRhdGlvblxuXG4gIHJlY29yZFRpbWluZ01ldHJpYyhtZXRyaWMpIHtcbiAgICB0aGlzLnRpbWluZ01ldHJpY3NbbWV0cmljXSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICB9XG5cbiAgZ2V0VGltaW5nTWV0cmljcygpIHtcbiAgICByZXR1cm4geyAuLi50aGlzLnRpbWluZ01ldHJpY3MgfVxuICB9XG5cbiAgLy8gUHJpdmF0ZVxuXG4gIGhhc1ByZWxvYWRlZFJlc3BvbnNlKCkge1xuICAgIHJldHVybiB0eXBlb2YgdGhpcy5yZXNwb25zZSA9PSBcIm9iamVjdFwiXG4gIH1cblxuICBzaG91bGRJc3N1ZVJlcXVlc3QoKSB7XG4gICAgaWYgKHRoaXMuaXNTYW1lUGFnZSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSBlbHNlIGlmICh0aGlzLmFjdGlvbiA9PSBcInJlc3RvcmVcIikge1xuICAgICAgcmV0dXJuICF0aGlzLmhhc0NhY2hlZFNuYXBzaG90KClcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMud2lsbFJlbmRlclxuICAgIH1cbiAgfVxuXG4gIGNhY2hlU25hcHNob3QoKSB7XG4gICAgaWYgKCF0aGlzLnNuYXBzaG90Q2FjaGVkKSB7XG4gICAgICB0aGlzLnZpZXcuY2FjaGVTbmFwc2hvdCh0aGlzLnNuYXBzaG90KS50aGVuKChzbmFwc2hvdCkgPT4gc25hcHNob3QgJiYgdGhpcy52aXNpdENhY2hlZFNuYXBzaG90KHNuYXBzaG90KSk7XG4gICAgICB0aGlzLnNuYXBzaG90Q2FjaGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBhc3luYyByZW5kZXIoY2FsbGJhY2spIHtcbiAgICB0aGlzLmNhbmNlbFJlbmRlcigpO1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICB0aGlzLmZyYW1lID1cbiAgICAgICAgZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSBcImhpZGRlblwiID8gc2V0VGltZW91dCgoKSA9PiByZXNvbHZlKCksIDApIDogcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHJlc29sdmUoKSk7XG4gICAgfSk7XG4gICAgYXdhaXQgY2FsbGJhY2soKTtcbiAgICBkZWxldGUgdGhpcy5mcmFtZTtcbiAgfVxuXG4gIGFzeW5jIHJlbmRlclBhZ2VTbmFwc2hvdChzbmFwc2hvdCwgaXNQcmV2aWV3KSB7XG4gICAgYXdhaXQgdGhpcy52aWV3VHJhbnNpdGlvbmVyLnJlbmRlckNoYW5nZSh0aGlzLnZpZXcuc2hvdWxkVHJhbnNpdGlvblRvKHNuYXBzaG90KSwgYXN5bmMgKCkgPT4ge1xuICAgICAgYXdhaXQgdGhpcy52aWV3LnJlbmRlclBhZ2Uoc25hcHNob3QsIGlzUHJldmlldywgdGhpcy53aWxsUmVuZGVyLCB0aGlzKTtcbiAgICAgIHRoaXMucGVyZm9ybVNjcm9sbCgpO1xuICAgIH0pO1xuICB9XG5cbiAgY2FuY2VsUmVuZGVyKCkge1xuICAgIGlmICh0aGlzLmZyYW1lKSB7XG4gICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmZyYW1lKTtcbiAgICAgIGRlbGV0ZSB0aGlzLmZyYW1lO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc1N1Y2Nlc3NmdWwoc3RhdHVzQ29kZSkge1xuICByZXR1cm4gc3RhdHVzQ29kZSA+PSAyMDAgJiYgc3RhdHVzQ29kZSA8IDMwMFxufVxuXG5jbGFzcyBCcm93c2VyQWRhcHRlciB7XG4gIHByb2dyZXNzQmFyID0gbmV3IFByb2dyZXNzQmFyKClcblxuICBjb25zdHJ1Y3RvcihzZXNzaW9uKSB7XG4gICAgdGhpcy5zZXNzaW9uID0gc2Vzc2lvbjtcbiAgfVxuXG4gIHZpc2l0UHJvcG9zZWRUb0xvY2F0aW9uKGxvY2F0aW9uLCBvcHRpb25zKSB7XG4gICAgaWYgKGxvY2F0aW9uSXNWaXNpdGFibGUobG9jYXRpb24sIHRoaXMubmF2aWdhdG9yLnJvb3RMb2NhdGlvbikpIHtcbiAgICAgIHRoaXMubmF2aWdhdG9yLnN0YXJ0VmlzaXQobG9jYXRpb24sIG9wdGlvbnM/LnJlc3RvcmF0aW9uSWRlbnRpZmllciB8fCB1dWlkKCksIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IGxvY2F0aW9uLnRvU3RyaW5nKCk7XG4gICAgfVxuICB9XG5cbiAgdmlzaXRTdGFydGVkKHZpc2l0KSB7XG4gICAgdGhpcy5sb2NhdGlvbiA9IHZpc2l0LmxvY2F0aW9uO1xuICAgIHZpc2l0LmxvYWRDYWNoZWRTbmFwc2hvdCgpO1xuICAgIHZpc2l0Lmlzc3VlUmVxdWVzdCgpO1xuICAgIHZpc2l0LmdvVG9TYW1lUGFnZUFuY2hvcigpO1xuICB9XG5cbiAgdmlzaXRSZXF1ZXN0U3RhcnRlZCh2aXNpdCkge1xuICAgIHRoaXMucHJvZ3Jlc3NCYXIuc2V0VmFsdWUoMCk7XG4gICAgaWYgKHZpc2l0Lmhhc0NhY2hlZFNuYXBzaG90KCkgfHwgdmlzaXQuYWN0aW9uICE9IFwicmVzdG9yZVwiKSB7XG4gICAgICB0aGlzLnNob3dWaXNpdFByb2dyZXNzQmFyQWZ0ZXJEZWxheSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNob3dQcm9ncmVzc0JhcigpO1xuICAgIH1cbiAgfVxuXG4gIHZpc2l0UmVxdWVzdENvbXBsZXRlZCh2aXNpdCkge1xuICAgIHZpc2l0LmxvYWRSZXNwb25zZSgpO1xuICB9XG5cbiAgdmlzaXRSZXF1ZXN0RmFpbGVkV2l0aFN0YXR1c0NvZGUodmlzaXQsIHN0YXR1c0NvZGUpIHtcbiAgICBzd2l0Y2ggKHN0YXR1c0NvZGUpIHtcbiAgICAgIGNhc2UgU3lzdGVtU3RhdHVzQ29kZS5uZXR3b3JrRmFpbHVyZTpcbiAgICAgIGNhc2UgU3lzdGVtU3RhdHVzQ29kZS50aW1lb3V0RmFpbHVyZTpcbiAgICAgIGNhc2UgU3lzdGVtU3RhdHVzQ29kZS5jb250ZW50VHlwZU1pc21hdGNoOlxuICAgICAgICByZXR1cm4gdGhpcy5yZWxvYWQoe1xuICAgICAgICAgIHJlYXNvbjogXCJyZXF1ZXN0X2ZhaWxlZFwiLFxuICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgIHN0YXR1c0NvZGVcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdmlzaXQubG9hZFJlc3BvbnNlKClcbiAgICB9XG4gIH1cblxuICB2aXNpdFJlcXVlc3RGaW5pc2hlZChfdmlzaXQpIHt9XG5cbiAgdmlzaXRDb21wbGV0ZWQoX3Zpc2l0KSB7XG4gICAgdGhpcy5wcm9ncmVzc0Jhci5zZXRWYWx1ZSgxKTtcbiAgICB0aGlzLmhpZGVWaXNpdFByb2dyZXNzQmFyKCk7XG4gIH1cblxuICBwYWdlSW52YWxpZGF0ZWQocmVhc29uKSB7XG4gICAgdGhpcy5yZWxvYWQocmVhc29uKTtcbiAgfVxuXG4gIHZpc2l0RmFpbGVkKF92aXNpdCkge1xuICAgIHRoaXMucHJvZ3Jlc3NCYXIuc2V0VmFsdWUoMSk7XG4gICAgdGhpcy5oaWRlVmlzaXRQcm9ncmVzc0JhcigpO1xuICB9XG5cbiAgdmlzaXRSZW5kZXJlZChfdmlzaXQpIHt9XG5cbiAgLy8gTGluayBwcmVmZXRjaGluZ1xuXG4gIGxpbmtQcmVmZXRjaGluZ0lzRW5hYmxlZEZvckxvY2F0aW9uKGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIC8vIEZvcm0gU3VibWlzc2lvbiBEZWxlZ2F0ZVxuXG4gIGZvcm1TdWJtaXNzaW9uU3RhcnRlZChfZm9ybVN1Ym1pc3Npb24pIHtcbiAgICB0aGlzLnByb2dyZXNzQmFyLnNldFZhbHVlKDApO1xuICAgIHRoaXMuc2hvd0Zvcm1Qcm9ncmVzc0JhckFmdGVyRGVsYXkoKTtcbiAgfVxuXG4gIGZvcm1TdWJtaXNzaW9uRmluaXNoZWQoX2Zvcm1TdWJtaXNzaW9uKSB7XG4gICAgdGhpcy5wcm9ncmVzc0Jhci5zZXRWYWx1ZSgxKTtcbiAgICB0aGlzLmhpZGVGb3JtUHJvZ3Jlc3NCYXIoKTtcbiAgfVxuXG4gIC8vIFByaXZhdGVcblxuICBzaG93VmlzaXRQcm9ncmVzc0JhckFmdGVyRGVsYXkoKSB7XG4gICAgdGhpcy52aXNpdFByb2dyZXNzQmFyVGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KHRoaXMuc2hvd1Byb2dyZXNzQmFyLCB0aGlzLnNlc3Npb24ucHJvZ3Jlc3NCYXJEZWxheSk7XG4gIH1cblxuICBoaWRlVmlzaXRQcm9ncmVzc0JhcigpIHtcbiAgICB0aGlzLnByb2dyZXNzQmFyLmhpZGUoKTtcbiAgICBpZiAodGhpcy52aXNpdFByb2dyZXNzQmFyVGltZW91dCAhPSBudWxsKSB7XG4gICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMudmlzaXRQcm9ncmVzc0JhclRpbWVvdXQpO1xuICAgICAgZGVsZXRlIHRoaXMudmlzaXRQcm9ncmVzc0JhclRpbWVvdXQ7XG4gICAgfVxuICB9XG5cbiAgc2hvd0Zvcm1Qcm9ncmVzc0JhckFmdGVyRGVsYXkoKSB7XG4gICAgaWYgKHRoaXMuZm9ybVByb2dyZXNzQmFyVGltZW91dCA9PSBudWxsKSB7XG4gICAgICB0aGlzLmZvcm1Qcm9ncmVzc0JhclRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCh0aGlzLnNob3dQcm9ncmVzc0JhciwgdGhpcy5zZXNzaW9uLnByb2dyZXNzQmFyRGVsYXkpO1xuICAgIH1cbiAgfVxuXG4gIGhpZGVGb3JtUHJvZ3Jlc3NCYXIoKSB7XG4gICAgdGhpcy5wcm9ncmVzc0Jhci5oaWRlKCk7XG4gICAgaWYgKHRoaXMuZm9ybVByb2dyZXNzQmFyVGltZW91dCAhPSBudWxsKSB7XG4gICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuZm9ybVByb2dyZXNzQmFyVGltZW91dCk7XG4gICAgICBkZWxldGUgdGhpcy5mb3JtUHJvZ3Jlc3NCYXJUaW1lb3V0O1xuICAgIH1cbiAgfVxuXG4gIHNob3dQcm9ncmVzc0JhciA9ICgpID0+IHtcbiAgICB0aGlzLnByb2dyZXNzQmFyLnNob3coKTtcbiAgfVxuXG4gIHJlbG9hZChyZWFzb24pIHtcbiAgICBkaXNwYXRjaChcInR1cmJvOnJlbG9hZFwiLCB7IGRldGFpbDogcmVhc29uIH0pO1xuXG4gICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSB0aGlzLmxvY2F0aW9uPy50b1N0cmluZygpIHx8IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICB9XG5cbiAgZ2V0IG5hdmlnYXRvcigpIHtcbiAgICByZXR1cm4gdGhpcy5zZXNzaW9uLm5hdmlnYXRvclxuICB9XG59XG5cbmNsYXNzIENhY2hlT2JzZXJ2ZXIge1xuICBzZWxlY3RvciA9IFwiW2RhdGEtdHVyYm8tdGVtcG9yYXJ5XVwiXG4gIGRlcHJlY2F0ZWRTZWxlY3RvciA9IFwiW2RhdGEtdHVyYm8tY2FjaGU9ZmFsc2VdXCJcblxuICBzdGFydGVkID0gZmFsc2VcblxuICBzdGFydCgpIHtcbiAgICBpZiAoIXRoaXMuc3RhcnRlZCkge1xuICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIoXCJ0dXJibzpiZWZvcmUtY2FjaGVcIiwgdGhpcy5yZW1vdmVUZW1wb3JhcnlFbGVtZW50cywgZmFsc2UpO1xuICAgIH1cbiAgfVxuXG4gIHN0b3AoKSB7XG4gICAgaWYgKHRoaXMuc3RhcnRlZCkge1xuICAgICAgdGhpcy5zdGFydGVkID0gZmFsc2U7XG4gICAgICByZW1vdmVFdmVudExpc3RlbmVyKFwidHVyYm86YmVmb3JlLWNhY2hlXCIsIHRoaXMucmVtb3ZlVGVtcG9yYXJ5RWxlbWVudHMsIGZhbHNlKTtcbiAgICB9XG4gIH1cblxuICByZW1vdmVUZW1wb3JhcnlFbGVtZW50cyA9IChfZXZlbnQpID0+IHtcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdGhpcy50ZW1wb3JhcnlFbGVtZW50cykge1xuICAgICAgZWxlbWVudC5yZW1vdmUoKTtcbiAgICB9XG4gIH1cblxuICBnZXQgdGVtcG9yYXJ5RWxlbWVudHMoKSB7XG4gICAgcmV0dXJuIFsuLi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHRoaXMuc2VsZWN0b3IpLCAuLi50aGlzLnRlbXBvcmFyeUVsZW1lbnRzV2l0aERlcHJlY2F0aW9uXVxuICB9XG5cbiAgZ2V0IHRlbXBvcmFyeUVsZW1lbnRzV2l0aERlcHJlY2F0aW9uKCkge1xuICAgIGNvbnN0IGVsZW1lbnRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCh0aGlzLmRlcHJlY2F0ZWRTZWxlY3Rvcik7XG5cbiAgICBpZiAoZWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGBUaGUgJHt0aGlzLmRlcHJlY2F0ZWRTZWxlY3Rvcn0gc2VsZWN0b3IgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uIFVzZSAke3RoaXMuc2VsZWN0b3J9IGluc3RlYWQuYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gWy4uLmVsZW1lbnRzXVxuICB9XG59XG5cbmNsYXNzIEZyYW1lUmVkaXJlY3RvciB7XG4gIGNvbnN0cnVjdG9yKHNlc3Npb24sIGVsZW1lbnQpIHtcbiAgICB0aGlzLnNlc3Npb24gPSBzZXNzaW9uO1xuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5saW5rSW50ZXJjZXB0b3IgPSBuZXcgTGlua0ludGVyY2VwdG9yKHRoaXMsIGVsZW1lbnQpO1xuICAgIHRoaXMuZm9ybVN1Ym1pdE9ic2VydmVyID0gbmV3IEZvcm1TdWJtaXRPYnNlcnZlcih0aGlzLCBlbGVtZW50KTtcbiAgfVxuXG4gIHN0YXJ0KCkge1xuICAgIHRoaXMubGlua0ludGVyY2VwdG9yLnN0YXJ0KCk7XG4gICAgdGhpcy5mb3JtU3VibWl0T2JzZXJ2ZXIuc3RhcnQoKTtcbiAgfVxuXG4gIHN0b3AoKSB7XG4gICAgdGhpcy5saW5rSW50ZXJjZXB0b3Iuc3RvcCgpO1xuICAgIHRoaXMuZm9ybVN1Ym1pdE9ic2VydmVyLnN0b3AoKTtcbiAgfVxuXG4gIC8vIExpbmsgaW50ZXJjZXB0b3IgZGVsZWdhdGVcblxuICBzaG91bGRJbnRlcmNlcHRMaW5rQ2xpY2soZWxlbWVudCwgX2xvY2F0aW9uLCBfZXZlbnQpIHtcbiAgICByZXR1cm4gdGhpcy4jc2hvdWxkUmVkaXJlY3QoZWxlbWVudClcbiAgfVxuXG4gIGxpbmtDbGlja0ludGVyY2VwdGVkKGVsZW1lbnQsIHVybCwgZXZlbnQpIHtcbiAgICBjb25zdCBmcmFtZSA9IHRoaXMuI2ZpbmRGcmFtZUVsZW1lbnQoZWxlbWVudCk7XG4gICAgaWYgKGZyYW1lKSB7XG4gICAgICBmcmFtZS5kZWxlZ2F0ZS5saW5rQ2xpY2tJbnRlcmNlcHRlZChlbGVtZW50LCB1cmwsIGV2ZW50KTtcbiAgICB9XG4gIH1cblxuICAvLyBGb3JtIHN1Ym1pdCBvYnNlcnZlciBkZWxlZ2F0ZVxuXG4gIHdpbGxTdWJtaXRGb3JtKGVsZW1lbnQsIHN1Ym1pdHRlcikge1xuICAgIHJldHVybiAoXG4gICAgICBlbGVtZW50LmNsb3Nlc3QoXCJ0dXJiby1mcmFtZVwiKSA9PSBudWxsICYmXG4gICAgICB0aGlzLiNzaG91bGRTdWJtaXQoZWxlbWVudCwgc3VibWl0dGVyKSAmJlxuICAgICAgdGhpcy4jc2hvdWxkUmVkaXJlY3QoZWxlbWVudCwgc3VibWl0dGVyKVxuICAgIClcbiAgfVxuXG4gIGZvcm1TdWJtaXR0ZWQoZWxlbWVudCwgc3VibWl0dGVyKSB7XG4gICAgY29uc3QgZnJhbWUgPSB0aGlzLiNmaW5kRnJhbWVFbGVtZW50KGVsZW1lbnQsIHN1Ym1pdHRlcik7XG4gICAgaWYgKGZyYW1lKSB7XG4gICAgICBmcmFtZS5kZWxlZ2F0ZS5mb3JtU3VibWl0dGVkKGVsZW1lbnQsIHN1Ym1pdHRlcik7XG4gICAgfVxuICB9XG5cbiAgI3Nob3VsZFN1Ym1pdChmb3JtLCBzdWJtaXR0ZXIpIHtcbiAgICBjb25zdCBhY3Rpb24gPSBnZXRBY3Rpb24kMShmb3JtLCBzdWJtaXR0ZXIpO1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLmVsZW1lbnQub3duZXJEb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBtZXRhW25hbWU9XCJ0dXJiby1yb290XCJdYCk7XG4gICAgY29uc3Qgcm9vdExvY2F0aW9uID0gZXhwYW5kVVJMKG1ldGE/LmNvbnRlbnQgPz8gXCIvXCIpO1xuXG4gICAgcmV0dXJuIHRoaXMuI3Nob3VsZFJlZGlyZWN0KGZvcm0sIHN1Ym1pdHRlcikgJiYgbG9jYXRpb25Jc1Zpc2l0YWJsZShhY3Rpb24sIHJvb3RMb2NhdGlvbilcbiAgfVxuXG4gICNzaG91bGRSZWRpcmVjdChlbGVtZW50LCBzdWJtaXR0ZXIpIHtcbiAgICBjb25zdCBpc05hdmlnYXRhYmxlID1cbiAgICAgIGVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRm9ybUVsZW1lbnRcbiAgICAgICAgPyB0aGlzLnNlc3Npb24uc3VibWlzc2lvbklzTmF2aWdhdGFibGUoZWxlbWVudCwgc3VibWl0dGVyKVxuICAgICAgICA6IHRoaXMuc2Vzc2lvbi5lbGVtZW50SXNOYXZpZ2F0YWJsZShlbGVtZW50KTtcblxuICAgIGlmIChpc05hdmlnYXRhYmxlKSB7XG4gICAgICBjb25zdCBmcmFtZSA9IHRoaXMuI2ZpbmRGcmFtZUVsZW1lbnQoZWxlbWVudCwgc3VibWl0dGVyKTtcbiAgICAgIHJldHVybiBmcmFtZSA/IGZyYW1lICE9IGVsZW1lbnQuY2xvc2VzdChcInR1cmJvLWZyYW1lXCIpIDogZmFsc2VcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuICB9XG5cbiAgI2ZpbmRGcmFtZUVsZW1lbnQoZWxlbWVudCwgc3VibWl0dGVyKSB7XG4gICAgY29uc3QgaWQgPSBzdWJtaXR0ZXI/LmdldEF0dHJpYnV0ZShcImRhdGEtdHVyYm8tZnJhbWVcIikgfHwgZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXR1cmJvLWZyYW1lXCIpO1xuICAgIGlmIChpZCAmJiBpZCAhPSBcIl90b3BcIikge1xuICAgICAgY29uc3QgZnJhbWUgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihgIyR7aWR9Om5vdChbZGlzYWJsZWRdKWApO1xuICAgICAgaWYgKGZyYW1lIGluc3RhbmNlb2YgRnJhbWVFbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBmcmFtZVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBIaXN0b3J5IHtcbiAgbG9jYXRpb25cbiAgcmVzdG9yYXRpb25JZGVudGlmaWVyID0gdXVpZCgpXG4gIHJlc3RvcmF0aW9uRGF0YSA9IHt9XG4gIHN0YXJ0ZWQgPSBmYWxzZVxuICBwYWdlTG9hZGVkID0gZmFsc2VcbiAgY3VycmVudEluZGV4ID0gMFxuXG4gIGNvbnN0cnVjdG9yKGRlbGVnYXRlKSB7XG4gICAgdGhpcy5kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xuICB9XG5cbiAgc3RhcnQoKSB7XG4gICAgaWYgKCF0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIoXCJwb3BzdGF0ZVwiLCB0aGlzLm9uUG9wU3RhdGUsIGZhbHNlKTtcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIHRoaXMub25QYWdlTG9hZCwgZmFsc2UpO1xuICAgICAgdGhpcy5jdXJyZW50SW5kZXggPSBoaXN0b3J5LnN0YXRlPy50dXJibz8ucmVzdG9yYXRpb25JbmRleCB8fCAwO1xuICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMucmVwbGFjZShuZXcgVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKSk7XG4gICAgfVxuICB9XG5cbiAgc3RvcCgpIHtcbiAgICBpZiAodGhpcy5zdGFydGVkKSB7XG4gICAgICByZW1vdmVFdmVudExpc3RlbmVyKFwicG9wc3RhdGVcIiwgdGhpcy5vblBvcFN0YXRlLCBmYWxzZSk7XG4gICAgICByZW1vdmVFdmVudExpc3RlbmVyKFwibG9hZFwiLCB0aGlzLm9uUGFnZUxvYWQsIGZhbHNlKTtcbiAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHB1c2gobG9jYXRpb24sIHJlc3RvcmF0aW9uSWRlbnRpZmllcikge1xuICAgIHRoaXMudXBkYXRlKGhpc3RvcnkucHVzaFN0YXRlLCBsb2NhdGlvbiwgcmVzdG9yYXRpb25JZGVudGlmaWVyKTtcbiAgfVxuXG4gIHJlcGxhY2UobG9jYXRpb24sIHJlc3RvcmF0aW9uSWRlbnRpZmllcikge1xuICAgIHRoaXMudXBkYXRlKGhpc3RvcnkucmVwbGFjZVN0YXRlLCBsb2NhdGlvbiwgcmVzdG9yYXRpb25JZGVudGlmaWVyKTtcbiAgfVxuXG4gIHVwZGF0ZShtZXRob2QsIGxvY2F0aW9uLCByZXN0b3JhdGlvbklkZW50aWZpZXIgPSB1dWlkKCkpIHtcbiAgICBpZiAobWV0aG9kID09PSBoaXN0b3J5LnB1c2hTdGF0ZSkgKyt0aGlzLmN1cnJlbnRJbmRleDtcblxuICAgIGNvbnN0IHN0YXRlID0geyB0dXJibzogeyByZXN0b3JhdGlvbklkZW50aWZpZXIsIHJlc3RvcmF0aW9uSW5kZXg6IHRoaXMuY3VycmVudEluZGV4IH0gfTtcbiAgICBtZXRob2QuY2FsbChoaXN0b3J5LCBzdGF0ZSwgXCJcIiwgbG9jYXRpb24uaHJlZik7XG4gICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgIHRoaXMucmVzdG9yYXRpb25JZGVudGlmaWVyID0gcmVzdG9yYXRpb25JZGVudGlmaWVyO1xuICB9XG5cbiAgLy8gUmVzdG9yYXRpb24gZGF0YVxuXG4gIGdldFJlc3RvcmF0aW9uRGF0YUZvcklkZW50aWZpZXIocmVzdG9yYXRpb25JZGVudGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMucmVzdG9yYXRpb25EYXRhW3Jlc3RvcmF0aW9uSWRlbnRpZmllcl0gfHwge31cbiAgfVxuXG4gIHVwZGF0ZVJlc3RvcmF0aW9uRGF0YShhZGRpdGlvbmFsRGF0YSkge1xuICAgIGNvbnN0IHsgcmVzdG9yYXRpb25JZGVudGlmaWVyIH0gPSB0aGlzO1xuICAgIGNvbnN0IHJlc3RvcmF0aW9uRGF0YSA9IHRoaXMucmVzdG9yYXRpb25EYXRhW3Jlc3RvcmF0aW9uSWRlbnRpZmllcl07XG4gICAgdGhpcy5yZXN0b3JhdGlvbkRhdGFbcmVzdG9yYXRpb25JZGVudGlmaWVyXSA9IHtcbiAgICAgIC4uLnJlc3RvcmF0aW9uRGF0YSxcbiAgICAgIC4uLmFkZGl0aW9uYWxEYXRhXG4gICAgfTtcbiAgfVxuXG4gIC8vIFNjcm9sbCByZXN0b3JhdGlvblxuXG4gIGFzc3VtZUNvbnRyb2xPZlNjcm9sbFJlc3RvcmF0aW9uKCkge1xuICAgIGlmICghdGhpcy5wcmV2aW91c1Njcm9sbFJlc3RvcmF0aW9uKSB7XG4gICAgICB0aGlzLnByZXZpb3VzU2Nyb2xsUmVzdG9yYXRpb24gPSBoaXN0b3J5LnNjcm9sbFJlc3RvcmF0aW9uID8/IFwiYXV0b1wiO1xuICAgICAgaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbiA9IFwibWFudWFsXCI7XG4gICAgfVxuICB9XG5cbiAgcmVsaW5xdWlzaENvbnRyb2xPZlNjcm9sbFJlc3RvcmF0aW9uKCkge1xuICAgIGlmICh0aGlzLnByZXZpb3VzU2Nyb2xsUmVzdG9yYXRpb24pIHtcbiAgICAgIGhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSB0aGlzLnByZXZpb3VzU2Nyb2xsUmVzdG9yYXRpb247XG4gICAgICBkZWxldGUgdGhpcy5wcmV2aW91c1Njcm9sbFJlc3RvcmF0aW9uO1xuICAgIH1cbiAgfVxuXG4gIC8vIEV2ZW50IGhhbmRsZXJzXG5cbiAgb25Qb3BTdGF0ZSA9IChldmVudCkgPT4ge1xuICAgIGlmICh0aGlzLnNob3VsZEhhbmRsZVBvcFN0YXRlKCkpIHtcbiAgICAgIGNvbnN0IHsgdHVyYm8gfSA9IGV2ZW50LnN0YXRlIHx8IHt9O1xuICAgICAgaWYgKHR1cmJvKSB7XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSBuZXcgVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcbiAgICAgICAgY29uc3QgeyByZXN0b3JhdGlvbklkZW50aWZpZXIsIHJlc3RvcmF0aW9uSW5kZXggfSA9IHR1cmJvO1xuICAgICAgICB0aGlzLnJlc3RvcmF0aW9uSWRlbnRpZmllciA9IHJlc3RvcmF0aW9uSWRlbnRpZmllcjtcbiAgICAgICAgY29uc3QgZGlyZWN0aW9uID0gcmVzdG9yYXRpb25JbmRleCA+IHRoaXMuY3VycmVudEluZGV4ID8gXCJmb3J3YXJkXCIgOiBcImJhY2tcIjtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZS5oaXN0b3J5UG9wcGVkVG9Mb2NhdGlvbldpdGhSZXN0b3JhdGlvbklkZW50aWZpZXJBbmREaXJlY3Rpb24odGhpcy5sb2NhdGlvbiwgcmVzdG9yYXRpb25JZGVudGlmaWVyLCBkaXJlY3Rpb24pO1xuICAgICAgICB0aGlzLmN1cnJlbnRJbmRleCA9IHJlc3RvcmF0aW9uSW5kZXg7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgb25QYWdlTG9hZCA9IGFzeW5jIChfZXZlbnQpID0+IHtcbiAgICBhd2FpdCBuZXh0TWljcm90YXNrKCk7XG4gICAgdGhpcy5wYWdlTG9hZGVkID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIFByaXZhdGVcblxuICBzaG91bGRIYW5kbGVQb3BTdGF0ZSgpIHtcbiAgICAvLyBTYWZhcmkgZGlzcGF0Y2hlcyBhIHBvcHN0YXRlIGV2ZW50IGFmdGVyIHdpbmRvdydzIGxvYWQgZXZlbnQsIGlnbm9yZSBpdFxuICAgIHJldHVybiB0aGlzLnBhZ2VJc0xvYWRlZCgpXG4gIH1cblxuICBwYWdlSXNMb2FkZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFnZUxvYWRlZCB8fCBkb2N1bWVudC5yZWFkeVN0YXRlID09IFwiY29tcGxldGVcIlxuICB9XG59XG5cbmNsYXNzIExpbmtQcmVmZXRjaE9ic2VydmVyIHtcbiAgc3RhcnRlZCA9IGZhbHNlXG4gICNwcmVmZXRjaGVkTGluayA9IG51bGxcblxuICBjb25zdHJ1Y3RvcihkZWxlZ2F0ZSwgZXZlbnRUYXJnZXQpIHtcbiAgICB0aGlzLmRlbGVnYXRlID0gZGVsZWdhdGU7XG4gICAgdGhpcy5ldmVudFRhcmdldCA9IGV2ZW50VGFyZ2V0O1xuICB9XG5cbiAgc3RhcnQoKSB7XG4gICAgaWYgKHRoaXMuc3RhcnRlZCkgcmV0dXJuXG5cbiAgICBpZiAodGhpcy5ldmVudFRhcmdldC5yZWFkeVN0YXRlID09PSBcImxvYWRpbmdcIikge1xuICAgICAgdGhpcy5ldmVudFRhcmdldC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCB0aGlzLiNlbmFibGUsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jZW5hYmxlKCk7XG4gICAgfVxuICB9XG5cbiAgc3RvcCgpIHtcbiAgICBpZiAoIXRoaXMuc3RhcnRlZCkgcmV0dXJuXG5cbiAgICB0aGlzLmV2ZW50VGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWVudGVyXCIsIHRoaXMuI3RyeVRvUHJlZmV0Y2hSZXF1ZXN0LCB7XG4gICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuZXZlbnRUYXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgdGhpcy4jY2FuY2VsUmVxdWVzdElmT2Jzb2xldGUsIHtcbiAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICBwYXNzaXZlOiB0cnVlXG4gICAgfSk7XG5cbiAgICB0aGlzLmV2ZW50VGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0dXJibzpiZWZvcmUtZmV0Y2gtcmVxdWVzdFwiLCB0aGlzLiN0cnlUb1VzZVByZWZldGNoZWRSZXF1ZXN0LCB0cnVlKTtcbiAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gICNlbmFibGUgPSAoKSA9PiB7XG4gICAgdGhpcy5ldmVudFRhcmdldC5hZGRFdmVudExpc3RlbmVyKFwibW91c2VlbnRlclwiLCB0aGlzLiN0cnlUb1ByZWZldGNoUmVxdWVzdCwge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgIHBhc3NpdmU6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLmV2ZW50VGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIHRoaXMuI2NhbmNlbFJlcXVlc3RJZk9ic29sZXRlLCB7XG4gICAgICBjYXB0dXJlOiB0cnVlLFxuICAgICAgcGFzc2l2ZTogdHJ1ZVxuICAgIH0pO1xuXG4gICAgdGhpcy5ldmVudFRhcmdldC5hZGRFdmVudExpc3RlbmVyKFwidHVyYm86YmVmb3JlLWZldGNoLXJlcXVlc3RcIiwgdGhpcy4jdHJ5VG9Vc2VQcmVmZXRjaGVkUmVxdWVzdCwgdHJ1ZSk7XG4gICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcbiAgfVxuXG4gICN0cnlUb1ByZWZldGNoUmVxdWVzdCA9IChldmVudCkgPT4ge1xuICAgIGlmIChnZXRNZXRhQ29udGVudChcInR1cmJvLXByZWZldGNoXCIpID09PSBcImZhbHNlXCIpIHJldHVyblxuXG4gICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgIGNvbnN0IGlzTGluayA9IHRhcmdldC5tYXRjaGVzICYmIHRhcmdldC5tYXRjaGVzKFwiYVtocmVmXTpub3QoW3RhcmdldF49X10pOm5vdChbZG93bmxvYWRdKVwiKTtcblxuICAgIGlmIChpc0xpbmsgJiYgdGhpcy4jaXNQcmVmZXRjaGFibGUodGFyZ2V0KSkge1xuICAgICAgY29uc3QgbGluayA9IHRhcmdldDtcbiAgICAgIGNvbnN0IGxvY2F0aW9uID0gZ2V0TG9jYXRpb25Gb3JMaW5rKGxpbmspO1xuXG4gICAgICBpZiAodGhpcy5kZWxlZ2F0ZS5jYW5QcmVmZXRjaFJlcXVlc3RUb0xvY2F0aW9uKGxpbmssIGxvY2F0aW9uKSkge1xuICAgICAgICB0aGlzLiNwcmVmZXRjaGVkTGluayA9IGxpbms7XG5cbiAgICAgICAgY29uc3QgZmV0Y2hSZXF1ZXN0ID0gbmV3IEZldGNoUmVxdWVzdChcbiAgICAgICAgICB0aGlzLFxuICAgICAgICAgIEZldGNoTWV0aG9kLmdldCxcbiAgICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgICBuZXcgVVJMU2VhcmNoUGFyYW1zKCksXG4gICAgICAgICAgdGFyZ2V0XG4gICAgICAgICk7XG5cbiAgICAgICAgcHJlZmV0Y2hDYWNoZS5zZXRMYXRlcihsb2NhdGlvbi50b1N0cmluZygpLCBmZXRjaFJlcXVlc3QsIHRoaXMuI2NhY2hlVHRsKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAjY2FuY2VsUmVxdWVzdElmT2Jzb2xldGUgPSAoZXZlbnQpID0+IHtcbiAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSB0aGlzLiNwcmVmZXRjaGVkTGluaykgdGhpcy4jY2FuY2VsUHJlZmV0Y2hSZXF1ZXN0KCk7XG4gIH1cblxuICAjY2FuY2VsUHJlZmV0Y2hSZXF1ZXN0ID0gKCkgPT4ge1xuICAgIHByZWZldGNoQ2FjaGUuY2xlYXIoKTtcbiAgICB0aGlzLiNwcmVmZXRjaGVkTGluayA9IG51bGw7XG4gIH1cblxuICAjdHJ5VG9Vc2VQcmVmZXRjaGVkUmVxdWVzdCA9IChldmVudCkgPT4ge1xuICAgIGlmIChldmVudC50YXJnZXQudGFnTmFtZSAhPT0gXCJGT1JNXCIgJiYgZXZlbnQuZGV0YWlsLmZldGNoT3B0aW9ucy5tZXRob2QgPT09IFwiR0VUXCIpIHtcbiAgICAgIGNvbnN0IGNhY2hlZCA9IHByZWZldGNoQ2FjaGUuZ2V0KGV2ZW50LmRldGFpbC51cmwudG9TdHJpbmcoKSk7XG5cbiAgICAgIGlmIChjYWNoZWQpIHtcbiAgICAgICAgLy8gVXNlciBjbGlja2VkIGxpbmssIHVzZSBjYWNoZSByZXNwb25zZVxuICAgICAgICBldmVudC5kZXRhaWwuZmV0Y2hSZXF1ZXN0ID0gY2FjaGVkO1xuICAgICAgfVxuXG4gICAgICBwcmVmZXRjaENhY2hlLmNsZWFyKCk7XG4gICAgfVxuICB9XG5cbiAgcHJlcGFyZVJlcXVlc3QocmVxdWVzdCkge1xuICAgIGNvbnN0IGxpbmsgPSByZXF1ZXN0LnRhcmdldDtcblxuICAgIHJlcXVlc3QuaGVhZGVyc1tcIlgtU2VjLVB1cnBvc2VcIl0gPSBcInByZWZldGNoXCI7XG5cbiAgICBjb25zdCB0dXJib0ZyYW1lID0gbGluay5jbG9zZXN0KFwidHVyYm8tZnJhbWVcIik7XG4gICAgY29uc3QgdHVyYm9GcmFtZVRhcmdldCA9IGxpbmsuZ2V0QXR0cmlidXRlKFwiZGF0YS10dXJiby1mcmFtZVwiKSB8fCB0dXJib0ZyYW1lPy5nZXRBdHRyaWJ1dGUoXCJ0YXJnZXRcIikgfHwgdHVyYm9GcmFtZT8uaWQ7XG5cbiAgICBpZiAodHVyYm9GcmFtZVRhcmdldCAmJiB0dXJib0ZyYW1lVGFyZ2V0ICE9PSBcIl90b3BcIikge1xuICAgICAgcmVxdWVzdC5oZWFkZXJzW1wiVHVyYm8tRnJhbWVcIl0gPSB0dXJib0ZyYW1lVGFyZ2V0O1xuICAgIH1cbiAgfVxuXG4gIC8vIEZldGNoIHJlcXVlc3QgaW50ZXJmYWNlXG5cbiAgcmVxdWVzdFN1Y2NlZWRlZFdpdGhSZXNwb25zZSgpIHt9XG5cbiAgcmVxdWVzdFN0YXJ0ZWQoZmV0Y2hSZXF1ZXN0KSB7fVxuXG4gIHJlcXVlc3RFcnJvcmVkKGZldGNoUmVxdWVzdCkge31cblxuICByZXF1ZXN0RmluaXNoZWQoZmV0Y2hSZXF1ZXN0KSB7fVxuXG4gIHJlcXVlc3RQcmV2ZW50ZWRIYW5kbGluZ1Jlc3BvbnNlKGZldGNoUmVxdWVzdCwgZmV0Y2hSZXNwb25zZSkge31cblxuICByZXF1ZXN0RmFpbGVkV2l0aFJlc3BvbnNlKGZldGNoUmVxdWVzdCwgZmV0Y2hSZXNwb25zZSkge31cblxuICBnZXQgI2NhY2hlVHRsKCkge1xuICAgIHJldHVybiBOdW1iZXIoZ2V0TWV0YUNvbnRlbnQoXCJ0dXJiby1wcmVmZXRjaC1jYWNoZS10aW1lXCIpKSB8fCBjYWNoZVR0bFxuICB9XG5cbiAgI2lzUHJlZmV0Y2hhYmxlKGxpbmspIHtcbiAgICBjb25zdCBocmVmID0gbGluay5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpO1xuXG4gICAgaWYgKCFocmVmKSByZXR1cm4gZmFsc2VcblxuICAgIGlmICh1bmZldGNoYWJsZUxpbmsobGluaykpIHJldHVybiBmYWxzZVxuICAgIGlmIChsaW5rVG9UaGVTYW1lUGFnZShsaW5rKSkgcmV0dXJuIGZhbHNlXG4gICAgaWYgKGxpbmtPcHRzT3V0KGxpbmspKSByZXR1cm4gZmFsc2VcbiAgICBpZiAobm9uU2FmZUxpbmsobGluaykpIHJldHVybiBmYWxzZVxuICAgIGlmIChldmVudFByZXZlbnRlZChsaW5rKSkgcmV0dXJuIGZhbHNlXG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG59XG5cbmNvbnN0IHVuZmV0Y2hhYmxlTGluayA9IChsaW5rKSA9PiB7XG4gIHJldHVybiBsaW5rLm9yaWdpbiAhPT0gZG9jdW1lbnQubG9jYXRpb24ub3JpZ2luIHx8ICFbXCJodHRwOlwiLCBcImh0dHBzOlwiXS5pbmNsdWRlcyhsaW5rLnByb3RvY29sKSB8fCBsaW5rLmhhc0F0dHJpYnV0ZShcInRhcmdldFwiKVxufTtcblxuY29uc3QgbGlua1RvVGhlU2FtZVBhZ2UgPSAobGluaykgPT4ge1xuICByZXR1cm4gKGxpbmsucGF0aG5hbWUgKyBsaW5rLnNlYXJjaCA9PT0gZG9jdW1lbnQubG9jYXRpb24ucGF0aG5hbWUgKyBkb2N1bWVudC5sb2NhdGlvbi5zZWFyY2gpIHx8IGxpbmsuaHJlZi5zdGFydHNXaXRoKFwiI1wiKVxufTtcblxuY29uc3QgbGlua09wdHNPdXQgPSAobGluaykgPT4ge1xuICBpZiAobGluay5nZXRBdHRyaWJ1dGUoXCJkYXRhLXR1cmJvLXByZWZldGNoXCIpID09PSBcImZhbHNlXCIpIHJldHVybiB0cnVlXG4gIGlmIChsaW5rLmdldEF0dHJpYnV0ZShcImRhdGEtdHVyYm9cIikgPT09IFwiZmFsc2VcIikgcmV0dXJuIHRydWVcblxuICBjb25zdCB0dXJib1ByZWZldGNoUGFyZW50ID0gZmluZENsb3Nlc3RSZWN1cnNpdmVseShsaW5rLCBcIltkYXRhLXR1cmJvLXByZWZldGNoXVwiKTtcbiAgaWYgKHR1cmJvUHJlZmV0Y2hQYXJlbnQgJiYgdHVyYm9QcmVmZXRjaFBhcmVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXR1cmJvLXByZWZldGNoXCIpID09PSBcImZhbHNlXCIpIHJldHVybiB0cnVlXG5cbiAgcmV0dXJuIGZhbHNlXG59O1xuXG5jb25zdCBub25TYWZlTGluayA9IChsaW5rKSA9PiB7XG4gIGNvbnN0IHR1cmJvTWV0aG9kID0gbGluay5nZXRBdHRyaWJ1dGUoXCJkYXRhLXR1cmJvLW1ldGhvZFwiKTtcbiAgaWYgKHR1cmJvTWV0aG9kICYmIHR1cmJvTWV0aG9kLnRvTG93ZXJDYXNlKCkgIT09IFwiZ2V0XCIpIHJldHVybiB0cnVlXG5cbiAgaWYgKGlzVUpTKGxpbmspKSByZXR1cm4gdHJ1ZVxuICBpZiAobGluay5oYXNBdHRyaWJ1dGUoXCJkYXRhLXR1cmJvLWNvbmZpcm1cIikpIHJldHVybiB0cnVlXG4gIGlmIChsaW5rLmhhc0F0dHJpYnV0ZShcImRhdGEtdHVyYm8tc3RyZWFtXCIpKSByZXR1cm4gdHJ1ZVxuXG4gIHJldHVybiBmYWxzZVxufTtcblxuY29uc3QgaXNVSlMgPSAobGluaykgPT4ge1xuICByZXR1cm4gbGluay5oYXNBdHRyaWJ1dGUoXCJkYXRhLXJlbW90ZVwiKSB8fCBsaW5rLmhhc0F0dHJpYnV0ZShcImRhdGEtYmVoYXZpb3JcIikgfHwgbGluay5oYXNBdHRyaWJ1dGUoXCJkYXRhLWNvbmZpcm1cIikgfHwgbGluay5oYXNBdHRyaWJ1dGUoXCJkYXRhLW1ldGhvZFwiKVxufTtcblxuY29uc3QgZXZlbnRQcmV2ZW50ZWQgPSAobGluaykgPT4ge1xuICBjb25zdCBldmVudCA9IGRpc3BhdGNoKFwidHVyYm86YmVmb3JlLXByZWZldGNoXCIsIHsgdGFyZ2V0OiBsaW5rLCBjYW5jZWxhYmxlOiB0cnVlIH0pO1xuICByZXR1cm4gZXZlbnQuZGVmYXVsdFByZXZlbnRlZFxufTtcblxuY2xhc3MgTmF2aWdhdG9yIHtcbiAgY29uc3RydWN0b3IoZGVsZWdhdGUpIHtcbiAgICB0aGlzLmRlbGVnYXRlID0gZGVsZWdhdGU7XG4gIH1cblxuICBwcm9wb3NlVmlzaXQobG9jYXRpb24sIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmICh0aGlzLmRlbGVnYXRlLmFsbG93c1Zpc2l0aW5nTG9jYXRpb25XaXRoQWN0aW9uKGxvY2F0aW9uLCBvcHRpb25zLmFjdGlvbikpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUudmlzaXRQcm9wb3NlZFRvTG9jYXRpb24obG9jYXRpb24sIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXJ0VmlzaXQobG9jYXRhYmxlLCByZXN0b3JhdGlvbklkZW50aWZpZXIsIG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuc3RvcCgpO1xuICAgIHRoaXMuY3VycmVudFZpc2l0ID0gbmV3IFZpc2l0KHRoaXMsIGV4cGFuZFVSTChsb2NhdGFibGUpLCByZXN0b3JhdGlvbklkZW50aWZpZXIsIHtcbiAgICAgIHJlZmVycmVyOiB0aGlzLmxvY2F0aW9uLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH0pO1xuICAgIHRoaXMuY3VycmVudFZpc2l0LnN0YXJ0KCk7XG4gIH1cblxuICBzdWJtaXRGb3JtKGZvcm0sIHN1Ym1pdHRlcikge1xuICAgIHRoaXMuc3RvcCgpO1xuICAgIHRoaXMuZm9ybVN1Ym1pc3Npb24gPSBuZXcgRm9ybVN1Ym1pc3Npb24odGhpcywgZm9ybSwgc3VibWl0dGVyLCB0cnVlKTtcblxuICAgIHRoaXMuZm9ybVN1Ym1pc3Npb24uc3RhcnQoKTtcbiAgfVxuXG4gIHN0b3AoKSB7XG4gICAgaWYgKHRoaXMuZm9ybVN1Ym1pc3Npb24pIHtcbiAgICAgIHRoaXMuZm9ybVN1Ym1pc3Npb24uc3RvcCgpO1xuICAgICAgZGVsZXRlIHRoaXMuZm9ybVN1Ym1pc3Npb247XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuY3VycmVudFZpc2l0KSB7XG4gICAgICB0aGlzLmN1cnJlbnRWaXNpdC5jYW5jZWwoKTtcbiAgICAgIGRlbGV0ZSB0aGlzLmN1cnJlbnRWaXNpdDtcbiAgICB9XG4gIH1cblxuICBnZXQgYWRhcHRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZS5hZGFwdGVyXG4gIH1cblxuICBnZXQgdmlldygpIHtcbiAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZS52aWV3XG4gIH1cblxuICBnZXQgcm9vdExvY2F0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnZpZXcuc25hcHNob3Qucm9vdExvY2F0aW9uXG4gIH1cblxuICBnZXQgaGlzdG9yeSgpIHtcbiAgICByZXR1cm4gdGhpcy5kZWxlZ2F0ZS5oaXN0b3J5XG4gIH1cblxuICAvLyBGb3JtIHN1Ym1pc3Npb24gZGVsZWdhdGVcblxuICBmb3JtU3VibWlzc2lvblN0YXJ0ZWQoZm9ybVN1Ym1pc3Npb24pIHtcbiAgICAvLyBOb3QgYWxsIGFkYXB0ZXJzIGltcGxlbWVudCBmb3JtU3VibWlzc2lvblN0YXJ0ZWRcbiAgICBpZiAodHlwZW9mIHRoaXMuYWRhcHRlci5mb3JtU3VibWlzc2lvblN0YXJ0ZWQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhpcy5hZGFwdGVyLmZvcm1TdWJtaXNzaW9uU3RhcnRlZChmb3JtU3VibWlzc2lvbik7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgZm9ybVN1Ym1pc3Npb25TdWNjZWVkZWRXaXRoUmVzcG9uc2UoZm9ybVN1Ym1pc3Npb24sIGZldGNoUmVzcG9uc2UpIHtcbiAgICBpZiAoZm9ybVN1Ym1pc3Npb24gPT0gdGhpcy5mb3JtU3VibWlzc2lvbikge1xuICAgICAgY29uc3QgcmVzcG9uc2VIVE1MID0gYXdhaXQgZmV0Y2hSZXNwb25zZS5yZXNwb25zZUhUTUw7XG4gICAgICBpZiAocmVzcG9uc2VIVE1MKSB7XG4gICAgICAgIGNvbnN0IHNob3VsZENhY2hlU25hcHNob3QgPSBmb3JtU3VibWlzc2lvbi5pc1NhZmU7XG4gICAgICAgIGlmICghc2hvdWxkQ2FjaGVTbmFwc2hvdCkge1xuICAgICAgICAgIHRoaXMudmlldy5jbGVhclNuYXBzaG90Q2FjaGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHsgc3RhdHVzQ29kZSwgcmVkaXJlY3RlZCB9ID0gZmV0Y2hSZXNwb25zZTtcbiAgICAgICAgY29uc3QgYWN0aW9uID0gdGhpcy4jZ2V0QWN0aW9uRm9yRm9ybVN1Ym1pc3Npb24oZm9ybVN1Ym1pc3Npb24sIGZldGNoUmVzcG9uc2UpO1xuICAgICAgICBjb25zdCB2aXNpdE9wdGlvbnMgPSB7XG4gICAgICAgICAgYWN0aW9uLFxuICAgICAgICAgIHNob3VsZENhY2hlU25hcHNob3QsXG4gICAgICAgICAgcmVzcG9uc2U6IHsgc3RhdHVzQ29kZSwgcmVzcG9uc2VIVE1MLCByZWRpcmVjdGVkIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wcm9wb3NlVmlzaXQoZmV0Y2hSZXNwb25zZS5sb2NhdGlvbiwgdmlzaXRPcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhc3luYyBmb3JtU3VibWlzc2lvbkZhaWxlZFdpdGhSZXNwb25zZShmb3JtU3VibWlzc2lvbiwgZmV0Y2hSZXNwb25zZSkge1xuICAgIGNvbnN0IHJlc3BvbnNlSFRNTCA9IGF3YWl0IGZldGNoUmVzcG9uc2UucmVzcG9uc2VIVE1MO1xuXG4gICAgaWYgKHJlc3BvbnNlSFRNTCkge1xuICAgICAgY29uc3Qgc25hcHNob3QgPSBQYWdlU25hcHNob3QuZnJvbUhUTUxTdHJpbmcocmVzcG9uc2VIVE1MKTtcbiAgICAgIGlmIChmZXRjaFJlc3BvbnNlLnNlcnZlckVycm9yKSB7XG4gICAgICAgIGF3YWl0IHRoaXMudmlldy5yZW5kZXJFcnJvcihzbmFwc2hvdCwgdGhpcy5jdXJyZW50VmlzaXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXdhaXQgdGhpcy52aWV3LnJlbmRlclBhZ2Uoc25hcHNob3QsIGZhbHNlLCB0cnVlLCB0aGlzLmN1cnJlbnRWaXNpdCk7XG4gICAgICB9XG4gICAgICBpZighc25hcHNob3Quc2hvdWxkUHJlc2VydmVTY3JvbGxQb3NpdGlvbikge1xuICAgICAgICB0aGlzLnZpZXcuc2Nyb2xsVG9Ub3AoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudmlldy5jbGVhclNuYXBzaG90Q2FjaGUoKTtcbiAgICB9XG4gIH1cblxuICBmb3JtU3VibWlzc2lvbkVycm9yZWQoZm9ybVN1Ym1pc3Npb24sIGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gIH1cblxuICBmb3JtU3VibWlzc2lvbkZpbmlzaGVkKGZvcm1TdWJtaXNzaW9uKSB7XG4gICAgLy8gTm90IGFsbCBhZGFwdGVycyBpbXBsZW1lbnQgZm9ybVN1Ym1pc3Npb25GaW5pc2hlZFxuICAgIGlmICh0eXBlb2YgdGhpcy5hZGFwdGVyLmZvcm1TdWJtaXNzaW9uRmluaXNoZWQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgdGhpcy5hZGFwdGVyLmZvcm1TdWJtaXNzaW9uRmluaXNoZWQoZm9ybVN1Ym1pc3Npb24pO1xuICAgIH1cbiAgfVxuXG4gIC8vIExpbmsgcHJlZmV0Y2hpbmdcblxuICBsaW5rUHJlZmV0Y2hpbmdJc0VuYWJsZWRGb3JMb2NhdGlvbihsb2NhdGlvbikge1xuICAgIC8vIE5vdCBhbGwgYWRhcHRlcnMgaW1wbGVtZW50IGxpbmtQcmVmZXRjaGluZ0lzRW5hYmxlZEZvckxvY2F0aW9uXG4gICAgaWYgKHR5cGVvZiB0aGlzLmFkYXB0ZXIubGlua1ByZWZldGNoaW5nSXNFbmFibGVkRm9yTG9jYXRpb24gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgcmV0dXJuIHRoaXMuYWRhcHRlci5saW5rUHJlZmV0Y2hpbmdJc0VuYWJsZWRGb3JMb2NhdGlvbihsb2NhdGlvbilcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgLy8gVmlzaXQgZGVsZWdhdGVcblxuICB2aXNpdFN0YXJ0ZWQodmlzaXQpIHtcbiAgICB0aGlzLmRlbGVnYXRlLnZpc2l0U3RhcnRlZCh2aXNpdCk7XG4gIH1cblxuICB2aXNpdENvbXBsZXRlZCh2aXNpdCkge1xuICAgIHRoaXMuZGVsZWdhdGUudmlzaXRDb21wbGV0ZWQodmlzaXQpO1xuICAgIGRlbGV0ZSB0aGlzLmN1cnJlbnRWaXNpdDtcbiAgfVxuXG4gIGxvY2F0aW9uV2l0aEFjdGlvbklzU2FtZVBhZ2UobG9jYXRpb24sIGFjdGlvbikge1xuICAgIGNvbnN0IGFuY2hvciA9IGdldEFuY2hvcihsb2NhdGlvbik7XG4gICAgY29uc3QgY3VycmVudEFuY2hvciA9IGdldEFuY2hvcih0aGlzLnZpZXcubGFzdFJlbmRlcmVkTG9jYXRpb24pO1xuICAgIGNvbnN0IGlzUmVzdG9yYXRpb25Ub1RvcCA9IGFjdGlvbiA9PT0gXCJyZXN0b3JlXCIgJiYgdHlwZW9mIGFuY2hvciA9PT0gXCJ1bmRlZmluZWRcIjtcblxuICAgIHJldHVybiAoXG4gICAgICBhY3Rpb24gIT09IFwicmVwbGFjZVwiICYmXG4gICAgICBnZXRSZXF1ZXN0VVJMKGxvY2F0aW9uKSA9PT0gZ2V0UmVxdWVzdFVSTCh0aGlzLnZpZXcubGFzdFJlbmRlcmVkTG9jYXRpb24pICYmXG4gICAgICAoaXNSZXN0b3JhdGlvblRvVG9wIHx8IChhbmNob3IgIT0gbnVsbCAmJiBhbmNob3IgIT09IGN1cnJlbnRBbmNob3IpKVxuICAgIClcbiAgfVxuXG4gIHZpc2l0U2Nyb2xsZWRUb1NhbWVQYWdlTG9jYXRpb24ob2xkVVJMLCBuZXdVUkwpIHtcbiAgICB0aGlzLmRlbGVnYXRlLnZpc2l0U2Nyb2xsZWRUb1NhbWVQYWdlTG9jYXRpb24ob2xkVVJMLCBuZXdVUkwpO1xuICB9XG5cbiAgLy8gVmlzaXRzXG5cbiAgZ2V0IGxvY2F0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmhpc3RvcnkubG9jYXRpb25cbiAgfVxuXG4gIGdldCByZXN0b3JhdGlvbklkZW50aWZpZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGlzdG9yeS5yZXN0b3JhdGlvbklkZW50aWZpZXJcbiAgfVxuXG4gICNnZXRBY3Rpb25Gb3JGb3JtU3VibWlzc2lvbihmb3JtU3VibWlzc2lvbiwgZmV0Y2hSZXNwb25zZSkge1xuICAgIGNvbnN0IHsgc3VibWl0dGVyLCBmb3JtRWxlbWVudCB9ID0gZm9ybVN1Ym1pc3Npb247XG4gICAgcmV0dXJuIGdldFZpc2l0QWN0aW9uKHN1Ym1pdHRlciwgZm9ybUVsZW1lbnQpIHx8IHRoaXMuI2dldERlZmF1bHRBY3Rpb24oZmV0Y2hSZXNwb25zZSlcbiAgfVxuXG4gICNnZXREZWZhdWx0QWN0aW9uKGZldGNoUmVzcG9uc2UpIHtcbiAgICBjb25zdCBzYW1lTG9jYXRpb25SZWRpcmVjdCA9IGZldGNoUmVzcG9uc2UucmVkaXJlY3RlZCAmJiBmZXRjaFJlc3BvbnNlLmxvY2F0aW9uLmhyZWYgPT09IHRoaXMubG9jYXRpb24/LmhyZWY7XG4gICAgcmV0dXJuIHNhbWVMb2NhdGlvblJlZGlyZWN0ID8gXCJyZXBsYWNlXCIgOiBcImFkdmFuY2VcIlxuICB9XG59XG5cbmNvbnN0IFBhZ2VTdGFnZSA9IHtcbiAgaW5pdGlhbDogMCxcbiAgbG9hZGluZzogMSxcbiAgaW50ZXJhY3RpdmU6IDIsXG4gIGNvbXBsZXRlOiAzXG59O1xuXG5jbGFzcyBQYWdlT2JzZXJ2ZXIge1xuICBzdGFnZSA9IFBhZ2VTdGFnZS5pbml0aWFsXG4gIHN0YXJ0ZWQgPSBmYWxzZVxuXG4gIGNvbnN0cnVjdG9yKGRlbGVnYXRlKSB7XG4gICAgdGhpcy5kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xuICB9XG5cbiAgc3RhcnQoKSB7XG4gICAgaWYgKCF0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgIGlmICh0aGlzLnN0YWdlID09IFBhZ2VTdGFnZS5pbml0aWFsKSB7XG4gICAgICAgIHRoaXMuc3RhZ2UgPSBQYWdlU3RhZ2UubG9hZGluZztcbiAgICAgIH1cbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJyZWFkeXN0YXRlY2hhbmdlXCIsIHRoaXMuaW50ZXJwcmV0UmVhZHlTdGF0ZSwgZmFsc2UpO1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcihcInBhZ2VoaWRlXCIsIHRoaXMucGFnZVdpbGxVbmxvYWQsIGZhbHNlKTtcbiAgICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgc3RvcCgpIHtcbiAgICBpZiAodGhpcy5zdGFydGVkKSB7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVhZHlzdGF0ZWNoYW5nZVwiLCB0aGlzLmludGVycHJldFJlYWR5U3RhdGUsIGZhbHNlKTtcbiAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwYWdlaGlkZVwiLCB0aGlzLnBhZ2VXaWxsVW5sb2FkLCBmYWxzZSk7XG4gICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpbnRlcnByZXRSZWFkeVN0YXRlID0gKCkgPT4ge1xuICAgIGNvbnN0IHsgcmVhZHlTdGF0ZSB9ID0gdGhpcztcbiAgICBpZiAocmVhZHlTdGF0ZSA9PSBcImludGVyYWN0aXZlXCIpIHtcbiAgICAgIHRoaXMucGFnZUlzSW50ZXJhY3RpdmUoKTtcbiAgICB9IGVsc2UgaWYgKHJlYWR5U3RhdGUgPT0gXCJjb21wbGV0ZVwiKSB7XG4gICAgICB0aGlzLnBhZ2VJc0NvbXBsZXRlKCk7XG4gICAgfVxuICB9XG5cbiAgcGFnZUlzSW50ZXJhY3RpdmUoKSB7XG4gICAgaWYgKHRoaXMuc3RhZ2UgPT0gUGFnZVN0YWdlLmxvYWRpbmcpIHtcbiAgICAgIHRoaXMuc3RhZ2UgPSBQYWdlU3RhZ2UuaW50ZXJhY3RpdmU7XG4gICAgICB0aGlzLmRlbGVnYXRlLnBhZ2VCZWNhbWVJbnRlcmFjdGl2ZSgpO1xuICAgIH1cbiAgfVxuXG4gIHBhZ2VJc0NvbXBsZXRlKCkge1xuICAgIHRoaXMucGFnZUlzSW50ZXJhY3RpdmUoKTtcbiAgICBpZiAodGhpcy5zdGFnZSA9PSBQYWdlU3RhZ2UuaW50ZXJhY3RpdmUpIHtcbiAgICAgIHRoaXMuc3RhZ2UgPSBQYWdlU3RhZ2UuY29tcGxldGU7XG4gICAgICB0aGlzLmRlbGVnYXRlLnBhZ2VMb2FkZWQoKTtcbiAgICB9XG4gIH1cblxuICBwYWdlV2lsbFVubG9hZCA9ICgpID0+IHtcbiAgICB0aGlzLmRlbGVnYXRlLnBhZ2VXaWxsVW5sb2FkKCk7XG4gIH1cblxuICBnZXQgcmVhZHlTdGF0ZSgpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQucmVhZHlTdGF0ZVxuICB9XG59XG5cbmNsYXNzIFNjcm9sbE9ic2VydmVyIHtcbiAgc3RhcnRlZCA9IGZhbHNlXG5cbiAgY29uc3RydWN0b3IoZGVsZWdhdGUpIHtcbiAgICB0aGlzLmRlbGVnYXRlID0gZGVsZWdhdGU7XG4gIH1cblxuICBzdGFydCgpIHtcbiAgICBpZiAoIXRoaXMuc3RhcnRlZCkge1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLm9uU2Nyb2xsLCBmYWxzZSk7XG4gICAgICB0aGlzLm9uU2Nyb2xsKCk7XG4gICAgICB0aGlzLnN0YXJ0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHN0b3AoKSB7XG4gICAgaWYgKHRoaXMuc3RhcnRlZCkge1xuICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihcInNjcm9sbFwiLCB0aGlzLm9uU2Nyb2xsLCBmYWxzZSk7XG4gICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBvblNjcm9sbCA9ICgpID0+IHtcbiAgICB0aGlzLnVwZGF0ZVBvc2l0aW9uKHsgeDogd2luZG93LnBhZ2VYT2Zmc2V0LCB5OiB3aW5kb3cucGFnZVlPZmZzZXQgfSk7XG4gIH1cblxuICAvLyBQcml2YXRlXG5cbiAgdXBkYXRlUG9zaXRpb24ocG9zaXRpb24pIHtcbiAgICB0aGlzLmRlbGVnYXRlLnNjcm9sbFBvc2l0aW9uQ2hhbmdlZChwb3NpdGlvbik7XG4gIH1cbn1cblxuY2xhc3MgU3RyZWFtTWVzc2FnZVJlbmRlcmVyIHtcbiAgcmVuZGVyKHsgZnJhZ21lbnQgfSkge1xuICAgIEJhcmRvLnByZXNlcnZpbmdQZXJtYW5lbnRFbGVtZW50cyh0aGlzLCBnZXRQZXJtYW5lbnRFbGVtZW50TWFwRm9yRnJhZ21lbnQoZnJhZ21lbnQpLCAoKSA9PiB7XG4gICAgICB3aXRoQXV0b2ZvY3VzRnJvbUZyYWdtZW50KGZyYWdtZW50LCAoKSA9PiB7XG4gICAgICAgIHdpdGhQcmVzZXJ2ZWRGb2N1cygoKSA9PiB7XG4gICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFwcGVuZENoaWxkKGZyYWdtZW50KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIEJhcmRvIGRlbGVnYXRlXG5cbiAgZW50ZXJpbmdCYXJkbyhjdXJyZW50UGVybWFuZW50RWxlbWVudCwgbmV3UGVybWFuZW50RWxlbWVudCkge1xuICAgIG5ld1Blcm1hbmVudEVsZW1lbnQucmVwbGFjZVdpdGgoY3VycmVudFBlcm1hbmVudEVsZW1lbnQuY2xvbmVOb2RlKHRydWUpKTtcbiAgfVxuXG4gIGxlYXZpbmdCYXJkbygpIHt9XG59XG5cbmZ1bmN0aW9uIGdldFBlcm1hbmVudEVsZW1lbnRNYXBGb3JGcmFnbWVudChmcmFnbWVudCkge1xuICBjb25zdCBwZXJtYW5lbnRFbGVtZW50c0luRG9jdW1lbnQgPSBxdWVyeVBlcm1hbmVudEVsZW1lbnRzQWxsKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCk7XG4gIGNvbnN0IHBlcm1hbmVudEVsZW1lbnRNYXAgPSB7fTtcbiAgZm9yIChjb25zdCBwZXJtYW5lbnRFbGVtZW50SW5Eb2N1bWVudCBvZiBwZXJtYW5lbnRFbGVtZW50c0luRG9jdW1lbnQpIHtcbiAgICBjb25zdCB7IGlkIH0gPSBwZXJtYW5lbnRFbGVtZW50SW5Eb2N1bWVudDtcblxuICAgIGZvciAoY29uc3Qgc3RyZWFtRWxlbWVudCBvZiBmcmFnbWVudC5xdWVyeVNlbGVjdG9yQWxsKFwidHVyYm8tc3RyZWFtXCIpKSB7XG4gICAgICBjb25zdCBlbGVtZW50SW5TdHJlYW0gPSBnZXRQZXJtYW5lbnRFbGVtZW50QnlJZChzdHJlYW1FbGVtZW50LnRlbXBsYXRlRWxlbWVudC5jb250ZW50LCBpZCk7XG5cbiAgICAgIGlmIChlbGVtZW50SW5TdHJlYW0pIHtcbiAgICAgICAgcGVybWFuZW50RWxlbWVudE1hcFtpZF0gPSBbcGVybWFuZW50RWxlbWVudEluRG9jdW1lbnQsIGVsZW1lbnRJblN0cmVhbV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBlcm1hbmVudEVsZW1lbnRNYXBcbn1cblxuYXN5bmMgZnVuY3Rpb24gd2l0aEF1dG9mb2N1c0Zyb21GcmFnbWVudChmcmFnbWVudCwgY2FsbGJhY2spIHtcbiAgY29uc3QgZ2VuZXJhdGVkSUQgPSBgdHVyYm8tc3RyZWFtLWF1dG9mb2N1cy0ke3V1aWQoKX1gO1xuICBjb25zdCB0dXJib1N0cmVhbXMgPSBmcmFnbWVudC5xdWVyeVNlbGVjdG9yQWxsKFwidHVyYm8tc3RyZWFtXCIpO1xuICBjb25zdCBlbGVtZW50V2l0aEF1dG9mb2N1cyA9IGZpcnN0QXV0b2ZvY3VzYWJsZUVsZW1lbnRJblN0cmVhbXModHVyYm9TdHJlYW1zKTtcbiAgbGV0IHdpbGxBdXRvZm9jdXNJZCA9IG51bGw7XG5cbiAgaWYgKGVsZW1lbnRXaXRoQXV0b2ZvY3VzKSB7XG4gICAgaWYgKGVsZW1lbnRXaXRoQXV0b2ZvY3VzLmlkKSB7XG4gICAgICB3aWxsQXV0b2ZvY3VzSWQgPSBlbGVtZW50V2l0aEF1dG9mb2N1cy5pZDtcbiAgICB9IGVsc2Uge1xuICAgICAgd2lsbEF1dG9mb2N1c0lkID0gZ2VuZXJhdGVkSUQ7XG4gICAgfVxuXG4gICAgZWxlbWVudFdpdGhBdXRvZm9jdXMuaWQgPSB3aWxsQXV0b2ZvY3VzSWQ7XG4gIH1cblxuICBjYWxsYmFjaygpO1xuICBhd2FpdCBuZXh0UmVwYWludCgpO1xuXG4gIGNvbnN0IGhhc05vQWN0aXZlRWxlbWVudCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT0gbnVsbCB8fCBkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09IGRvY3VtZW50LmJvZHk7XG5cbiAgaWYgKGhhc05vQWN0aXZlRWxlbWVudCAmJiB3aWxsQXV0b2ZvY3VzSWQpIHtcbiAgICBjb25zdCBlbGVtZW50VG9BdXRvZm9jdXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh3aWxsQXV0b2ZvY3VzSWQpO1xuXG4gICAgaWYgKGVsZW1lbnRJc0ZvY3VzYWJsZShlbGVtZW50VG9BdXRvZm9jdXMpKSB7XG4gICAgICBlbGVtZW50VG9BdXRvZm9jdXMuZm9jdXMoKTtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnRUb0F1dG9mb2N1cyAmJiBlbGVtZW50VG9BdXRvZm9jdXMuaWQgPT0gZ2VuZXJhdGVkSUQpIHtcbiAgICAgIGVsZW1lbnRUb0F1dG9mb2N1cy5yZW1vdmVBdHRyaWJ1dGUoXCJpZFwiKTtcbiAgICB9XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gd2l0aFByZXNlcnZlZEZvY3VzKGNhbGxiYWNrKSB7XG4gIGNvbnN0IFthY3RpdmVFbGVtZW50QmVmb3JlUmVuZGVyLCBhY3RpdmVFbGVtZW50QWZ0ZXJSZW5kZXJdID0gYXdhaXQgYXJvdW5kKGNhbGxiYWNrLCAoKSA9PiBkb2N1bWVudC5hY3RpdmVFbGVtZW50KTtcblxuICBjb25zdCByZXN0b3JlRm9jdXNUbyA9IGFjdGl2ZUVsZW1lbnRCZWZvcmVSZW5kZXIgJiYgYWN0aXZlRWxlbWVudEJlZm9yZVJlbmRlci5pZDtcblxuICBpZiAocmVzdG9yZUZvY3VzVG8pIHtcbiAgICBjb25zdCBlbGVtZW50VG9Gb2N1cyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHJlc3RvcmVGb2N1c1RvKTtcblxuICAgIGlmIChlbGVtZW50SXNGb2N1c2FibGUoZWxlbWVudFRvRm9jdXMpICYmIGVsZW1lbnRUb0ZvY3VzICE9IGFjdGl2ZUVsZW1lbnRBZnRlclJlbmRlcikge1xuICAgICAgZWxlbWVudFRvRm9jdXMuZm9jdXMoKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmlyc3RBdXRvZm9jdXNhYmxlRWxlbWVudEluU3RyZWFtcyhub2RlTGlzdE9mU3RyZWFtRWxlbWVudHMpIHtcbiAgZm9yIChjb25zdCBzdHJlYW1FbGVtZW50IG9mIG5vZGVMaXN0T2ZTdHJlYW1FbGVtZW50cykge1xuICAgIGNvbnN0IGVsZW1lbnRXaXRoQXV0b2ZvY3VzID0gcXVlcnlBdXRvZm9jdXNhYmxlRWxlbWVudChzdHJlYW1FbGVtZW50LnRlbXBsYXRlRWxlbWVudC5jb250ZW50KTtcblxuICAgIGlmIChlbGVtZW50V2l0aEF1dG9mb2N1cykgcmV0dXJuIGVsZW1lbnRXaXRoQXV0b2ZvY3VzXG4gIH1cblxuICByZXR1cm4gbnVsbFxufVxuXG5jbGFzcyBTdHJlYW1PYnNlcnZlciB7XG4gIHNvdXJjZXMgPSBuZXcgU2V0KClcbiAgI3N0YXJ0ZWQgPSBmYWxzZVxuXG4gIGNvbnN0cnVjdG9yKGRlbGVnYXRlKSB7XG4gICAgdGhpcy5kZWxlZ2F0ZSA9IGRlbGVnYXRlO1xuICB9XG5cbiAgc3RhcnQoKSB7XG4gICAgaWYgKCF0aGlzLiNzdGFydGVkKSB7XG4gICAgICB0aGlzLiNzdGFydGVkID0gdHJ1ZTtcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXIoXCJ0dXJibzpiZWZvcmUtZmV0Y2gtcmVzcG9uc2VcIiwgdGhpcy5pbnNwZWN0RmV0Y2hSZXNwb25zZSwgZmFsc2UpO1xuICAgIH1cbiAgfVxuXG4gIHN0b3AoKSB7XG4gICAgaWYgKHRoaXMuI3N0YXJ0ZWQpIHtcbiAgICAgIHRoaXMuI3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0dXJibzpiZWZvcmUtZmV0Y2gtcmVzcG9uc2VcIiwgdGhpcy5pbnNwZWN0RmV0Y2hSZXNwb25zZSwgZmFsc2UpO1xuICAgIH1cbiAgfVxuXG4gIGNvbm5lY3RTdHJlYW1Tb3VyY2Uoc291cmNlKSB7XG4gICAgaWYgKCF0aGlzLnN0cmVhbVNvdXJjZUlzQ29ubmVjdGVkKHNvdXJjZSkpIHtcbiAgICAgIHRoaXMuc291cmNlcy5hZGQoc291cmNlKTtcbiAgICAgIHNvdXJjZS5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCB0aGlzLnJlY2VpdmVNZXNzYWdlRXZlbnQsIGZhbHNlKTtcbiAgICB9XG4gIH1cblxuICBkaXNjb25uZWN0U3RyZWFtU291cmNlKHNvdXJjZSkge1xuICAgIGlmICh0aGlzLnN0cmVhbVNvdXJjZUlzQ29ubmVjdGVkKHNvdXJjZSkpIHtcbiAgICAgIHRoaXMuc291cmNlcy5kZWxldGUoc291cmNlKTtcbiAgICAgIHNvdXJjZS5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCB0aGlzLnJlY2VpdmVNZXNzYWdlRXZlbnQsIGZhbHNlKTtcbiAgICB9XG4gIH1cblxuICBzdHJlYW1Tb3VyY2VJc0Nvbm5lY3RlZChzb3VyY2UpIHtcbiAgICByZXR1cm4gdGhpcy5zb3VyY2VzLmhhcyhzb3VyY2UpXG4gIH1cblxuICBpbnNwZWN0RmV0Y2hSZXNwb25zZSA9IChldmVudCkgPT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gZmV0Y2hSZXNwb25zZUZyb21FdmVudChldmVudCk7XG4gICAgaWYgKHJlc3BvbnNlICYmIGZldGNoUmVzcG9uc2VJc1N0cmVhbShyZXNwb25zZSkpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLnJlY2VpdmVNZXNzYWdlUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIH1cbiAgfVxuXG4gIHJlY2VpdmVNZXNzYWdlRXZlbnQgPSAoZXZlbnQpID0+IHtcbiAgICBpZiAodGhpcy4jc3RhcnRlZCAmJiB0eXBlb2YgZXZlbnQuZGF0YSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aGlzLnJlY2VpdmVNZXNzYWdlSFRNTChldmVudC5kYXRhKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyByZWNlaXZlTWVzc2FnZVJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgY29uc3QgaHRtbCA9IGF3YWl0IHJlc3BvbnNlLnJlc3BvbnNlSFRNTDtcbiAgICBpZiAoaHRtbCkge1xuICAgICAgdGhpcy5yZWNlaXZlTWVzc2FnZUhUTUwoaHRtbCk7XG4gICAgfVxuICB9XG5cbiAgcmVjZWl2ZU1lc3NhZ2VIVE1MKGh0bWwpIHtcbiAgICB0aGlzLmRlbGVnYXRlLnJlY2VpdmVkTWVzc2FnZUZyb21TdHJlYW0oU3RyZWFtTWVzc2FnZS53cmFwKGh0bWwpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmZXRjaFJlc3BvbnNlRnJvbUV2ZW50KGV2ZW50KSB7XG4gIGNvbnN0IGZldGNoUmVzcG9uc2UgPSBldmVudC5kZXRhaWw/LmZldGNoUmVzcG9uc2U7XG4gIGlmIChmZXRjaFJlc3BvbnNlIGluc3RhbmNlb2YgRmV0Y2hSZXNwb25zZSkge1xuICAgIHJldHVybiBmZXRjaFJlc3BvbnNlXG4gIH1cbn1cblxuZnVuY3Rpb24gZmV0Y2hSZXNwb25zZUlzU3RyZWFtKHJlc3BvbnNlKSB7XG4gIGNvbnN0IGNvbnRlbnRUeXBlID0gcmVzcG9uc2UuY29udGVudFR5cGUgPz8gXCJcIjtcbiAgcmV0dXJuIGNvbnRlbnRUeXBlLnN0YXJ0c1dpdGgoU3RyZWFtTWVzc2FnZS5jb250ZW50VHlwZSlcbn1cblxuY2xhc3MgRXJyb3JSZW5kZXJlciBleHRlbmRzIFJlbmRlcmVyIHtcbiAgc3RhdGljIHJlbmRlckVsZW1lbnQoY3VycmVudEVsZW1lbnQsIG5ld0VsZW1lbnQpIHtcbiAgICBjb25zdCB7IGRvY3VtZW50RWxlbWVudCwgYm9keSB9ID0gZG9jdW1lbnQ7XG5cbiAgICBkb2N1bWVudEVsZW1lbnQucmVwbGFjZUNoaWxkKG5ld0VsZW1lbnQsIGJvZHkpO1xuICB9XG5cbiAgYXN5bmMgcmVuZGVyKCkge1xuICAgIHRoaXMucmVwbGFjZUhlYWRBbmRCb2R5KCk7XG4gICAgdGhpcy5hY3RpdmF0ZVNjcmlwdEVsZW1lbnRzKCk7XG4gIH1cblxuICByZXBsYWNlSGVhZEFuZEJvZHkoKSB7XG4gICAgY29uc3QgeyBkb2N1bWVudEVsZW1lbnQsIGhlYWQgfSA9IGRvY3VtZW50O1xuICAgIGRvY3VtZW50RWxlbWVudC5yZXBsYWNlQ2hpbGQodGhpcy5uZXdIZWFkLCBoZWFkKTtcbiAgICB0aGlzLnJlbmRlckVsZW1lbnQodGhpcy5jdXJyZW50RWxlbWVudCwgdGhpcy5uZXdFbGVtZW50KTtcbiAgfVxuXG4gIGFjdGl2YXRlU2NyaXB0RWxlbWVudHMoKSB7XG4gICAgZm9yIChjb25zdCByZXBsYWNlYWJsZUVsZW1lbnQgb2YgdGhpcy5zY3JpcHRFbGVtZW50cykge1xuICAgICAgY29uc3QgcGFyZW50Tm9kZSA9IHJlcGxhY2VhYmxlRWxlbWVudC5wYXJlbnROb2RlO1xuICAgICAgaWYgKHBhcmVudE5vZGUpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IGFjdGl2YXRlU2NyaXB0RWxlbWVudChyZXBsYWNlYWJsZUVsZW1lbnQpO1xuICAgICAgICBwYXJlbnROb2RlLnJlcGxhY2VDaGlsZChlbGVtZW50LCByZXBsYWNlYWJsZUVsZW1lbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGdldCBuZXdIZWFkKCkge1xuICAgIHJldHVybiB0aGlzLm5ld1NuYXBzaG90LmhlYWRTbmFwc2hvdC5lbGVtZW50XG4gIH1cblxuICBnZXQgc2NyaXB0RWxlbWVudHMoKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFwic2NyaXB0XCIpXG4gIH1cbn1cblxuY2xhc3MgUGFnZVJlbmRlcmVyIGV4dGVuZHMgUmVuZGVyZXIge1xuICBzdGF0aWMgcmVuZGVyRWxlbWVudChjdXJyZW50RWxlbWVudCwgbmV3RWxlbWVudCkge1xuICAgIGlmIChkb2N1bWVudC5ib2R5ICYmIG5ld0VsZW1lbnQgaW5zdGFuY2VvZiBIVE1MQm9keUVsZW1lbnQpIHtcbiAgICAgIGRvY3VtZW50LmJvZHkucmVwbGFjZVdpdGgobmV3RWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZChuZXdFbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICBnZXQgc2hvdWxkUmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLm5ld1NuYXBzaG90LmlzVmlzaXRhYmxlICYmIHRoaXMudHJhY2tlZEVsZW1lbnRzQXJlSWRlbnRpY2FsXG4gIH1cblxuICBnZXQgcmVsb2FkUmVhc29uKCkge1xuICAgIGlmICghdGhpcy5uZXdTbmFwc2hvdC5pc1Zpc2l0YWJsZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVhc29uOiBcInR1cmJvX3Zpc2l0X2NvbnRyb2xfaXNfcmVsb2FkXCJcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIXRoaXMudHJhY2tlZEVsZW1lbnRzQXJlSWRlbnRpY2FsKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZWFzb246IFwidHJhY2tlZF9lbGVtZW50X21pc21hdGNoXCJcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhc3luYyBwcmVwYXJlVG9SZW5kZXIoKSB7XG4gICAgdGhpcy4jc2V0TGFuZ3VhZ2UoKTtcbiAgICBhd2FpdCB0aGlzLm1lcmdlSGVhZCgpO1xuICB9XG5cbiAgYXN5bmMgcmVuZGVyKCkge1xuICAgIGlmICh0aGlzLndpbGxSZW5kZXIpIHtcbiAgICAgIGF3YWl0IHRoaXMucmVwbGFjZUJvZHkoKTtcbiAgICB9XG4gIH1cblxuICBmaW5pc2hSZW5kZXJpbmcoKSB7XG4gICAgc3VwZXIuZmluaXNoUmVuZGVyaW5nKCk7XG4gICAgaWYgKCF0aGlzLmlzUHJldmlldykge1xuICAgICAgdGhpcy5mb2N1c0ZpcnN0QXV0b2ZvY3VzYWJsZUVsZW1lbnQoKTtcbiAgICB9XG4gIH1cblxuICBnZXQgY3VycmVudEhlYWRTbmFwc2hvdCgpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50U25hcHNob3QuaGVhZFNuYXBzaG90XG4gIH1cblxuICBnZXQgbmV3SGVhZFNuYXBzaG90KCkge1xuICAgIHJldHVybiB0aGlzLm5ld1NuYXBzaG90LmhlYWRTbmFwc2hvdFxuICB9XG5cbiAgZ2V0IG5ld0VsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMubmV3U25hcHNob3QuZWxlbWVudFxuICB9XG5cbiAgI3NldExhbmd1YWdlKCkge1xuICAgIGNvbnN0IHsgZG9jdW1lbnRFbGVtZW50IH0gPSB0aGlzLmN1cnJlbnRTbmFwc2hvdDtcbiAgICBjb25zdCB7IGxhbmcgfSA9IHRoaXMubmV3U25hcHNob3Q7XG5cbiAgICBpZiAobGFuZykge1xuICAgICAgZG9jdW1lbnRFbGVtZW50LnNldEF0dHJpYnV0ZShcImxhbmdcIiwgbGFuZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRvY3VtZW50RWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoXCJsYW5nXCIpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIG1lcmdlSGVhZCgpIHtcbiAgICBjb25zdCBtZXJnZWRIZWFkRWxlbWVudHMgPSB0aGlzLm1lcmdlUHJvdmlzaW9uYWxFbGVtZW50cygpO1xuICAgIGNvbnN0IG5ld1N0eWxlc2hlZXRFbGVtZW50cyA9IHRoaXMuY29weU5ld0hlYWRTdHlsZXNoZWV0RWxlbWVudHMoKTtcbiAgICB0aGlzLmNvcHlOZXdIZWFkU2NyaXB0RWxlbWVudHMoKTtcblxuICAgIGF3YWl0IG1lcmdlZEhlYWRFbGVtZW50cztcbiAgICBhd2FpdCBuZXdTdHlsZXNoZWV0RWxlbWVudHM7XG5cbiAgICBpZiAodGhpcy53aWxsUmVuZGVyKSB7XG4gICAgICB0aGlzLnJlbW92ZVVudXNlZER5bmFtaWNTdHlsZXNoZWV0RWxlbWVudHMoKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyByZXBsYWNlQm9keSgpIHtcbiAgICBhd2FpdCB0aGlzLnByZXNlcnZpbmdQZXJtYW5lbnRFbGVtZW50cyhhc3luYyAoKSA9PiB7XG4gICAgICB0aGlzLmFjdGl2YXRlTmV3Qm9keSgpO1xuICAgICAgYXdhaXQgdGhpcy5hc3NpZ25OZXdCb2R5KCk7XG4gICAgfSk7XG4gIH1cblxuICBnZXQgdHJhY2tlZEVsZW1lbnRzQXJlSWRlbnRpY2FsKCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRIZWFkU25hcHNob3QudHJhY2tlZEVsZW1lbnRTaWduYXR1cmUgPT0gdGhpcy5uZXdIZWFkU25hcHNob3QudHJhY2tlZEVsZW1lbnRTaWduYXR1cmVcbiAgfVxuXG4gIGFzeW5jIGNvcHlOZXdIZWFkU3R5bGVzaGVldEVsZW1lbnRzKCkge1xuICAgIGNvbnN0IGxvYWRpbmdFbGVtZW50cyA9IFtdO1xuXG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHRoaXMubmV3SGVhZFN0eWxlc2hlZXRFbGVtZW50cykge1xuICAgICAgbG9hZGluZ0VsZW1lbnRzLnB1c2god2FpdEZvckxvYWQoZWxlbWVudCkpO1xuXG4gICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIGF3YWl0IFByb21pc2UuYWxsKGxvYWRpbmdFbGVtZW50cyk7XG4gIH1cblxuICBjb3B5TmV3SGVhZFNjcmlwdEVsZW1lbnRzKCkge1xuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiB0aGlzLm5ld0hlYWRTY3JpcHRFbGVtZW50cykge1xuICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChhY3RpdmF0ZVNjcmlwdEVsZW1lbnQoZWxlbWVudCkpO1xuICAgIH1cbiAgfVxuXG4gIHJlbW92ZVVudXNlZER5bmFtaWNTdHlsZXNoZWV0RWxlbWVudHMoKSB7XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHRoaXMudW51c2VkRHluYW1pY1N0eWxlc2hlZXRFbGVtZW50cykge1xuICAgICAgZG9jdW1lbnQuaGVhZC5yZW1vdmVDaGlsZChlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICBhc3luYyBtZXJnZVByb3Zpc2lvbmFsRWxlbWVudHMoKSB7XG4gICAgY29uc3QgbmV3SGVhZEVsZW1lbnRzID0gWy4uLnRoaXMubmV3SGVhZFByb3Zpc2lvbmFsRWxlbWVudHNdO1xuXG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHRoaXMuY3VycmVudEhlYWRQcm92aXNpb25hbEVsZW1lbnRzKSB7XG4gICAgICBpZiAoIXRoaXMuaXNDdXJyZW50RWxlbWVudEluRWxlbWVudExpc3QoZWxlbWVudCwgbmV3SGVhZEVsZW1lbnRzKSkge1xuICAgICAgICBkb2N1bWVudC5oZWFkLnJlbW92ZUNoaWxkKGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBuZXdIZWFkRWxlbWVudHMpIHtcbiAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgaXNDdXJyZW50RWxlbWVudEluRWxlbWVudExpc3QoZWxlbWVudCwgZWxlbWVudExpc3QpIHtcbiAgICBmb3IgKGNvbnN0IFtpbmRleCwgbmV3RWxlbWVudF0gb2YgZWxlbWVudExpc3QuZW50cmllcygpKSB7XG4gICAgICAvLyBpZiB0aXRsZSBlbGVtZW50Li4uXG4gICAgICBpZiAoZWxlbWVudC50YWdOYW1lID09IFwiVElUTEVcIikge1xuICAgICAgICBpZiAobmV3RWxlbWVudC50YWdOYW1lICE9IFwiVElUTEVcIikge1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsZW1lbnQuaW5uZXJIVE1MID09IG5ld0VsZW1lbnQuaW5uZXJIVE1MKSB7XG4gICAgICAgICAgZWxlbWVudExpc3Quc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIGFueSBvdGhlciBlbGVtZW50Li4uXG4gICAgICBpZiAobmV3RWxlbWVudC5pc0VxdWFsTm9kZShlbGVtZW50KSkge1xuICAgICAgICBlbGVtZW50TGlzdC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmVtb3ZlQ3VycmVudEhlYWRQcm92aXNpb25hbEVsZW1lbnRzKCkge1xuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiB0aGlzLmN1cnJlbnRIZWFkUHJvdmlzaW9uYWxFbGVtZW50cykge1xuICAgICAgZG9jdW1lbnQuaGVhZC5yZW1vdmVDaGlsZChlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICBjb3B5TmV3SGVhZFByb3Zpc2lvbmFsRWxlbWVudHMoKSB7XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHRoaXMubmV3SGVhZFByb3Zpc2lvbmFsRWxlbWVudHMpIHtcbiAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgYWN0aXZhdGVOZXdCb2R5KCkge1xuICAgIGRvY3VtZW50LmFkb3B0Tm9kZSh0aGlzLm5ld0VsZW1lbnQpO1xuICAgIHRoaXMuYWN0aXZhdGVOZXdCb2R5U2NyaXB0RWxlbWVudHMoKTtcbiAgfVxuXG4gIGFjdGl2YXRlTmV3Qm9keVNjcmlwdEVsZW1lbnRzKCkge1xuICAgIGZvciAoY29uc3QgaW5lcnRTY3JpcHRFbGVtZW50IG9mIHRoaXMubmV3Qm9keVNjcmlwdEVsZW1lbnRzKSB7XG4gICAgICBjb25zdCBhY3RpdmF0ZWRTY3JpcHRFbGVtZW50ID0gYWN0aXZhdGVTY3JpcHRFbGVtZW50KGluZXJ0U2NyaXB0RWxlbWVudCk7XG4gICAgICBpbmVydFNjcmlwdEVsZW1lbnQucmVwbGFjZVdpdGgoYWN0aXZhdGVkU2NyaXB0RWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgYXNzaWduTmV3Qm9keSgpIHtcbiAgICBhd2FpdCB0aGlzLnJlbmRlckVsZW1lbnQodGhpcy5jdXJyZW50RWxlbWVudCwgdGhpcy5uZXdFbGVtZW50KTtcbiAgfVxuXG4gIGdldCB1bnVzZWREeW5hbWljU3R5bGVzaGVldEVsZW1lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLm9sZEhlYWRTdHlsZXNoZWV0RWxlbWVudHMuZmlsdGVyKChlbGVtZW50KSA9PiB7XG4gICAgICByZXR1cm4gZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJkYXRhLXR1cmJvLXRyYWNrXCIpID09PSBcImR5bmFtaWNcIlxuICAgIH0pXG4gIH1cblxuICBnZXQgb2xkSGVhZFN0eWxlc2hlZXRFbGVtZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50SGVhZFNuYXBzaG90LmdldFN0eWxlc2hlZXRFbGVtZW50c05vdEluU25hcHNob3QodGhpcy5uZXdIZWFkU25hcHNob3QpXG4gIH1cblxuICBnZXQgbmV3SGVhZFN0eWxlc2hlZXRFbGVtZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5uZXdIZWFkU25hcHNob3QuZ2V0U3R5bGVzaGVldEVsZW1lbnRzTm90SW5TbmFwc2hvdCh0aGlzLmN1cnJlbnRIZWFkU25hcHNob3QpXG4gIH1cblxuICBnZXQgbmV3SGVhZFNjcmlwdEVsZW1lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLm5ld0hlYWRTbmFwc2hvdC5nZXRTY3JpcHRFbGVtZW50c05vdEluU25hcHNob3QodGhpcy5jdXJyZW50SGVhZFNuYXBzaG90KVxuICB9XG5cbiAgZ2V0IGN1cnJlbnRIZWFkUHJvdmlzaW9uYWxFbGVtZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50SGVhZFNuYXBzaG90LnByb3Zpc2lvbmFsRWxlbWVudHNcbiAgfVxuXG4gIGdldCBuZXdIZWFkUHJvdmlzaW9uYWxFbGVtZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5uZXdIZWFkU25hcHNob3QucHJvdmlzaW9uYWxFbGVtZW50c1xuICB9XG5cbiAgZ2V0IG5ld0JvZHlTY3JpcHRFbGVtZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5uZXdFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJzY3JpcHRcIilcbiAgfVxufVxuXG5jbGFzcyBNb3JwaGluZ1BhZ2VSZW5kZXJlciBleHRlbmRzIFBhZ2VSZW5kZXJlciB7XG4gIHN0YXRpYyByZW5kZXJFbGVtZW50KGN1cnJlbnRFbGVtZW50LCBuZXdFbGVtZW50KSB7XG4gICAgbW9ycGhFbGVtZW50cyhjdXJyZW50RWxlbWVudCwgbmV3RWxlbWVudCwge1xuICAgICAgY2FsbGJhY2tzOiB7XG4gICAgICAgIGJlZm9yZU5vZGVNb3JwaGVkOiBlbGVtZW50ID0+ICFjYW5SZWZyZXNoRnJhbWUoZWxlbWVudClcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGZvciAoY29uc3QgZnJhbWUgb2YgY3VycmVudEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChcInR1cmJvLWZyYW1lXCIpKSB7XG4gICAgICBpZiAoY2FuUmVmcmVzaEZyYW1lKGZyYW1lKSkgZnJhbWUucmVsb2FkKCk7XG4gICAgfVxuXG4gICAgZGlzcGF0Y2goXCJ0dXJibzptb3JwaFwiLCB7IGRldGFpbDogeyBjdXJyZW50RWxlbWVudCwgbmV3RWxlbWVudCB9IH0pO1xuICB9XG5cbiAgYXN5bmMgcHJlc2VydmluZ1Blcm1hbmVudEVsZW1lbnRzKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIGF3YWl0IGNhbGxiYWNrKClcbiAgfVxuXG4gIGdldCByZW5kZXJNZXRob2QoKSB7XG4gICAgcmV0dXJuIFwibW9ycGhcIlxuICB9XG5cbiAgZ2V0IHNob3VsZEF1dG9mb2N1cygpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5mdW5jdGlvbiBjYW5SZWZyZXNoRnJhbWUoZnJhbWUpIHtcbiAgcmV0dXJuIGZyYW1lIGluc3RhbmNlb2YgRnJhbWVFbGVtZW50ICYmXG4gICAgZnJhbWUuc3JjICYmXG4gICAgZnJhbWUucmVmcmVzaCA9PT0gXCJtb3JwaFwiICYmXG4gICAgIWZyYW1lLmNsb3Nlc3QoXCJbZGF0YS10dXJiby1wZXJtYW5lbnRdXCIpXG59XG5cbmNsYXNzIFNuYXBzaG90Q2FjaGUge1xuICBrZXlzID0gW11cbiAgc25hcHNob3RzID0ge31cblxuICBjb25zdHJ1Y3RvcihzaXplKSB7XG4gICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgfVxuXG4gIGhhcyhsb2NhdGlvbikge1xuICAgIHJldHVybiB0b0NhY2hlS2V5KGxvY2F0aW9uKSBpbiB0aGlzLnNuYXBzaG90c1xuICB9XG5cbiAgZ2V0KGxvY2F0aW9uKSB7XG4gICAgaWYgKHRoaXMuaGFzKGxvY2F0aW9uKSkge1xuICAgICAgY29uc3Qgc25hcHNob3QgPSB0aGlzLnJlYWQobG9jYXRpb24pO1xuICAgICAgdGhpcy50b3VjaChsb2NhdGlvbik7XG4gICAgICByZXR1cm4gc25hcHNob3RcbiAgICB9XG4gIH1cblxuICBwdXQobG9jYXRpb24sIHNuYXBzaG90KSB7XG4gICAgdGhpcy53cml0ZShsb2NhdGlvbiwgc25hcHNob3QpO1xuICAgIHRoaXMudG91Y2gobG9jYXRpb24pO1xuICAgIHJldHVybiBzbmFwc2hvdFxuICB9XG5cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5zbmFwc2hvdHMgPSB7fTtcbiAgfVxuXG4gIC8vIFByaXZhdGVcblxuICByZWFkKGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuc25hcHNob3RzW3RvQ2FjaGVLZXkobG9jYXRpb24pXVxuICB9XG5cbiAgd3JpdGUobG9jYXRpb24sIHNuYXBzaG90KSB7XG4gICAgdGhpcy5zbmFwc2hvdHNbdG9DYWNoZUtleShsb2NhdGlvbildID0gc25hcHNob3Q7XG4gIH1cblxuICB0b3VjaChsb2NhdGlvbikge1xuICAgIGNvbnN0IGtleSA9IHRvQ2FjaGVLZXkobG9jYXRpb24pO1xuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5rZXlzLmluZGV4T2Yoa2V5KTtcbiAgICBpZiAoaW5kZXggPiAtMSkgdGhpcy5rZXlzLnNwbGljZShpbmRleCwgMSk7XG4gICAgdGhpcy5rZXlzLnVuc2hpZnQoa2V5KTtcbiAgICB0aGlzLnRyaW0oKTtcbiAgfVxuXG4gIHRyaW0oKSB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgdGhpcy5rZXlzLnNwbGljZSh0aGlzLnNpemUpKSB7XG4gICAgICBkZWxldGUgdGhpcy5zbmFwc2hvdHNba2V5XTtcbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgUGFnZVZpZXcgZXh0ZW5kcyBWaWV3IHtcbiAgc25hcHNob3RDYWNoZSA9IG5ldyBTbmFwc2hvdENhY2hlKDEwKVxuICBsYXN0UmVuZGVyZWRMb2NhdGlvbiA9IG5ldyBVUkwobG9jYXRpb24uaHJlZilcbiAgZm9yY2VSZWxvYWRlZCA9IGZhbHNlXG5cbiAgc2hvdWxkVHJhbnNpdGlvblRvKG5ld1NuYXBzaG90KSB7XG4gICAgcmV0dXJuIHRoaXMuc25hcHNob3QucHJlZmVyc1ZpZXdUcmFuc2l0aW9ucyAmJiBuZXdTbmFwc2hvdC5wcmVmZXJzVmlld1RyYW5zaXRpb25zXG4gIH1cblxuICByZW5kZXJQYWdlKHNuYXBzaG90LCBpc1ByZXZpZXcgPSBmYWxzZSwgd2lsbFJlbmRlciA9IHRydWUsIHZpc2l0KSB7XG4gICAgY29uc3Qgc2hvdWxkTW9ycGhQYWdlID0gdGhpcy5pc1BhZ2VSZWZyZXNoKHZpc2l0KSAmJiB0aGlzLnNuYXBzaG90LnNob3VsZE1vcnBoUGFnZTtcbiAgICBjb25zdCByZW5kZXJlckNsYXNzID0gc2hvdWxkTW9ycGhQYWdlID8gTW9ycGhpbmdQYWdlUmVuZGVyZXIgOiBQYWdlUmVuZGVyZXI7XG5cbiAgICBjb25zdCByZW5kZXJlciA9IG5ldyByZW5kZXJlckNsYXNzKHRoaXMuc25hcHNob3QsIHNuYXBzaG90LCBpc1ByZXZpZXcsIHdpbGxSZW5kZXIpO1xuXG4gICAgaWYgKCFyZW5kZXJlci5zaG91bGRSZW5kZXIpIHtcbiAgICAgIHRoaXMuZm9yY2VSZWxvYWRlZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZpc2l0Py5jaGFuZ2VIaXN0b3J5KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucmVuZGVyKHJlbmRlcmVyKVxuICB9XG5cbiAgcmVuZGVyRXJyb3Ioc25hcHNob3QsIHZpc2l0KSB7XG4gICAgdmlzaXQ/LmNoYW5nZUhpc3RvcnkoKTtcbiAgICBjb25zdCByZW5kZXJlciA9IG5ldyBFcnJvclJlbmRlcmVyKHRoaXMuc25hcHNob3QsIHNuYXBzaG90LCBmYWxzZSk7XG4gICAgcmV0dXJuIHRoaXMucmVuZGVyKHJlbmRlcmVyKVxuICB9XG5cbiAgY2xlYXJTbmFwc2hvdENhY2hlKCkge1xuICAgIHRoaXMuc25hcHNob3RDYWNoZS5jbGVhcigpO1xuICB9XG5cbiAgYXN5bmMgY2FjaGVTbmFwc2hvdChzbmFwc2hvdCA9IHRoaXMuc25hcHNob3QpIHtcbiAgICBpZiAoc25hcHNob3QuaXNDYWNoZWFibGUpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUudmlld1dpbGxDYWNoZVNuYXBzaG90KCk7XG4gICAgICBjb25zdCB7IGxhc3RSZW5kZXJlZExvY2F0aW9uOiBsb2NhdGlvbiB9ID0gdGhpcztcbiAgICAgIGF3YWl0IG5leHRFdmVudExvb3BUaWNrKCk7XG4gICAgICBjb25zdCBjYWNoZWRTbmFwc2hvdCA9IHNuYXBzaG90LmNsb25lKCk7XG4gICAgICB0aGlzLnNuYXBzaG90Q2FjaGUucHV0KGxvY2F0aW9uLCBjYWNoZWRTbmFwc2hvdCk7XG4gICAgICByZXR1cm4gY2FjaGVkU25hcHNob3RcbiAgICB9XG4gIH1cblxuICBnZXRDYWNoZWRTbmFwc2hvdEZvckxvY2F0aW9uKGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMuc25hcHNob3RDYWNoZS5nZXQobG9jYXRpb24pXG4gIH1cblxuICBpc1BhZ2VSZWZyZXNoKHZpc2l0KSB7XG4gICAgcmV0dXJuICF2aXNpdCB8fCAodGhpcy5sYXN0UmVuZGVyZWRMb2NhdGlvbi5wYXRobmFtZSA9PT0gdmlzaXQubG9jYXRpb24ucGF0aG5hbWUgJiYgdmlzaXQuYWN0aW9uID09PSBcInJlcGxhY2VcIilcbiAgfVxuXG4gIHNob3VsZFByZXNlcnZlU2Nyb2xsUG9zaXRpb24odmlzaXQpIHtcbiAgICByZXR1cm4gdGhpcy5pc1BhZ2VSZWZyZXNoKHZpc2l0KSAmJiB0aGlzLnNuYXBzaG90LnNob3VsZFByZXNlcnZlU2Nyb2xsUG9zaXRpb25cbiAgfVxuXG4gIGdldCBzbmFwc2hvdCgpIHtcbiAgICByZXR1cm4gUGFnZVNuYXBzaG90LmZyb21FbGVtZW50KHRoaXMuZWxlbWVudClcbiAgfVxufVxuXG5jbGFzcyBQcmVsb2FkZXIge1xuICBzZWxlY3RvciA9IFwiYVtkYXRhLXR1cmJvLXByZWxvYWRdXCJcblxuICBjb25zdHJ1Y3RvcihkZWxlZ2F0ZSwgc25hcHNob3RDYWNoZSkge1xuICAgIHRoaXMuZGVsZWdhdGUgPSBkZWxlZ2F0ZTtcbiAgICB0aGlzLnNuYXBzaG90Q2FjaGUgPSBzbmFwc2hvdENhY2hlO1xuICB9XG5cbiAgc3RhcnQoKSB7XG4gICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwibG9hZGluZ1wiKSB7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiRE9NQ29udGVudExvYWRlZFwiLCB0aGlzLiNwcmVsb2FkQWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wcmVsb2FkT25Mb2FkTGlua3NGb3JWaWV3KGRvY3VtZW50LmJvZHkpO1xuICAgIH1cbiAgfVxuXG4gIHN0b3AoKSB7XG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIkRPTUNvbnRlbnRMb2FkZWRcIiwgdGhpcy4jcHJlbG9hZEFsbCk7XG4gIH1cblxuICBwcmVsb2FkT25Mb2FkTGlua3NGb3JWaWV3KGVsZW1lbnQpIHtcbiAgICBmb3IgKGNvbnN0IGxpbmsgb2YgZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKHRoaXMuc2VsZWN0b3IpKSB7XG4gICAgICBpZiAodGhpcy5kZWxlZ2F0ZS5zaG91bGRQcmVsb2FkTGluayhsaW5rKSkge1xuICAgICAgICB0aGlzLnByZWxvYWRVUkwobGluayk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgcHJlbG9hZFVSTChsaW5rKSB7XG4gICAgY29uc3QgbG9jYXRpb24gPSBuZXcgVVJMKGxpbmsuaHJlZik7XG5cbiAgICBpZiAodGhpcy5zbmFwc2hvdENhY2hlLmhhcyhsb2NhdGlvbikpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGZldGNoUmVxdWVzdCA9IG5ldyBGZXRjaFJlcXVlc3QodGhpcywgRmV0Y2hNZXRob2QuZ2V0LCBsb2NhdGlvbiwgbmV3IFVSTFNlYXJjaFBhcmFtcygpLCBsaW5rKTtcbiAgICBhd2FpdCBmZXRjaFJlcXVlc3QucGVyZm9ybSgpO1xuICB9XG5cbiAgLy8gRmV0Y2ggcmVxdWVzdCBkZWxlZ2F0ZVxuXG4gIHByZXBhcmVSZXF1ZXN0KGZldGNoUmVxdWVzdCkge1xuICAgIGZldGNoUmVxdWVzdC5oZWFkZXJzW1wiWC1TZWMtUHVycG9zZVwiXSA9IFwicHJlZmV0Y2hcIjtcbiAgfVxuXG4gIGFzeW5jIHJlcXVlc3RTdWNjZWVkZWRXaXRoUmVzcG9uc2UoZmV0Y2hSZXF1ZXN0LCBmZXRjaFJlc3BvbnNlKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlSFRNTCA9IGF3YWl0IGZldGNoUmVzcG9uc2UucmVzcG9uc2VIVE1MO1xuICAgICAgY29uc3Qgc25hcHNob3QgPSBQYWdlU25hcHNob3QuZnJvbUhUTUxTdHJpbmcocmVzcG9uc2VIVE1MKTtcblxuICAgICAgdGhpcy5zbmFwc2hvdENhY2hlLnB1dChmZXRjaFJlcXVlc3QudXJsLCBzbmFwc2hvdCk7XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgLy8gSWYgd2UgY2Fubm90IHByZWxvYWQgdGhhdCBpcyBvayFcbiAgICB9XG4gIH1cblxuICByZXF1ZXN0U3RhcnRlZChmZXRjaFJlcXVlc3QpIHt9XG5cbiAgcmVxdWVzdEVycm9yZWQoZmV0Y2hSZXF1ZXN0KSB7fVxuXG4gIHJlcXVlc3RGaW5pc2hlZChmZXRjaFJlcXVlc3QpIHt9XG5cbiAgcmVxdWVzdFByZXZlbnRlZEhhbmRsaW5nUmVzcG9uc2UoZmV0Y2hSZXF1ZXN0LCBmZXRjaFJlc3BvbnNlKSB7fVxuXG4gIHJlcXVlc3RGYWlsZWRXaXRoUmVzcG9uc2UoZmV0Y2hSZXF1ZXN0LCBmZXRjaFJlc3BvbnNlKSB7fVxuXG4gICNwcmVsb2FkQWxsID0gKCkgPT4ge1xuICAgIHRoaXMucHJlbG9hZE9uTG9hZExpbmtzRm9yVmlldyhkb2N1bWVudC5ib2R5KTtcbiAgfVxufVxuXG5jbGFzcyBDYWNoZSB7XG4gIGNvbnN0cnVjdG9yKHNlc3Npb24pIHtcbiAgICB0aGlzLnNlc3Npb24gPSBzZXNzaW9uO1xuICB9XG5cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5zZXNzaW9uLmNsZWFyQ2FjaGUoKTtcbiAgfVxuXG4gIHJlc2V0Q2FjaGVDb250cm9sKCkge1xuICAgIHRoaXMuI3NldENhY2hlQ29udHJvbChcIlwiKTtcbiAgfVxuXG4gIGV4ZW1wdFBhZ2VGcm9tQ2FjaGUoKSB7XG4gICAgdGhpcy4jc2V0Q2FjaGVDb250cm9sKFwibm8tY2FjaGVcIik7XG4gIH1cblxuICBleGVtcHRQYWdlRnJvbVByZXZpZXcoKSB7XG4gICAgdGhpcy4jc2V0Q2FjaGVDb250cm9sKFwibm8tcHJldmlld1wiKTtcbiAgfVxuXG4gICNzZXRDYWNoZUNvbnRyb2wodmFsdWUpIHtcbiAgICBzZXRNZXRhQ29udGVudChcInR1cmJvLWNhY2hlLWNvbnRyb2xcIiwgdmFsdWUpO1xuICB9XG59XG5cbmNsYXNzIFNlc3Npb24ge1xuICBuYXZpZ2F0b3IgPSBuZXcgTmF2aWdhdG9yKHRoaXMpXG4gIGhpc3RvcnkgPSBuZXcgSGlzdG9yeSh0aGlzKVxuICB2aWV3ID0gbmV3IFBhZ2VWaWV3KHRoaXMsIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudClcbiAgYWRhcHRlciA9IG5ldyBCcm93c2VyQWRhcHRlcih0aGlzKVxuXG4gIHBhZ2VPYnNlcnZlciA9IG5ldyBQYWdlT2JzZXJ2ZXIodGhpcylcbiAgY2FjaGVPYnNlcnZlciA9IG5ldyBDYWNoZU9ic2VydmVyKClcbiAgbGlua1ByZWZldGNoT2JzZXJ2ZXIgPSBuZXcgTGlua1ByZWZldGNoT2JzZXJ2ZXIodGhpcywgZG9jdW1lbnQpXG4gIGxpbmtDbGlja09ic2VydmVyID0gbmV3IExpbmtDbGlja09ic2VydmVyKHRoaXMsIHdpbmRvdylcbiAgZm9ybVN1Ym1pdE9ic2VydmVyID0gbmV3IEZvcm1TdWJtaXRPYnNlcnZlcih0aGlzLCBkb2N1bWVudClcbiAgc2Nyb2xsT2JzZXJ2ZXIgPSBuZXcgU2Nyb2xsT2JzZXJ2ZXIodGhpcylcbiAgc3RyZWFtT2JzZXJ2ZXIgPSBuZXcgU3RyZWFtT2JzZXJ2ZXIodGhpcylcbiAgZm9ybUxpbmtDbGlja09ic2VydmVyID0gbmV3IEZvcm1MaW5rQ2xpY2tPYnNlcnZlcih0aGlzLCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpXG4gIGZyYW1lUmVkaXJlY3RvciA9IG5ldyBGcmFtZVJlZGlyZWN0b3IodGhpcywgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KVxuICBzdHJlYW1NZXNzYWdlUmVuZGVyZXIgPSBuZXcgU3RyZWFtTWVzc2FnZVJlbmRlcmVyKClcbiAgY2FjaGUgPSBuZXcgQ2FjaGUodGhpcylcblxuICBlbmFibGVkID0gdHJ1ZVxuICBzdGFydGVkID0gZmFsc2VcbiAgI3BhZ2VSZWZyZXNoRGVib3VuY2VQZXJpb2QgPSAxNTBcblxuICBjb25zdHJ1Y3RvcihyZWNlbnRSZXF1ZXN0cykge1xuICAgIHRoaXMucmVjZW50UmVxdWVzdHMgPSByZWNlbnRSZXF1ZXN0cztcbiAgICB0aGlzLnByZWxvYWRlciA9IG5ldyBQcmVsb2FkZXIodGhpcywgdGhpcy52aWV3LnNuYXBzaG90Q2FjaGUpO1xuICAgIHRoaXMuZGVib3VuY2VkUmVmcmVzaCA9IHRoaXMucmVmcmVzaDtcbiAgICB0aGlzLnBhZ2VSZWZyZXNoRGVib3VuY2VQZXJpb2QgPSB0aGlzLnBhZ2VSZWZyZXNoRGVib3VuY2VQZXJpb2Q7XG4gIH1cblxuICBzdGFydCgpIHtcbiAgICBpZiAoIXRoaXMuc3RhcnRlZCkge1xuICAgICAgdGhpcy5wYWdlT2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICAgIHRoaXMuY2FjaGVPYnNlcnZlci5zdGFydCgpO1xuICAgICAgdGhpcy5saW5rUHJlZmV0Y2hPYnNlcnZlci5zdGFydCgpO1xuICAgICAgdGhpcy5mb3JtTGlua0NsaWNrT2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICAgIHRoaXMubGlua0NsaWNrT2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICAgIHRoaXMuZm9ybVN1Ym1pdE9ic2VydmVyLnN0YXJ0KCk7XG4gICAgICB0aGlzLnNjcm9sbE9ic2VydmVyLnN0YXJ0KCk7XG4gICAgICB0aGlzLnN0cmVhbU9ic2VydmVyLnN0YXJ0KCk7XG4gICAgICB0aGlzLmZyYW1lUmVkaXJlY3Rvci5zdGFydCgpO1xuICAgICAgdGhpcy5oaXN0b3J5LnN0YXJ0KCk7XG4gICAgICB0aGlzLnByZWxvYWRlci5zdGFydCgpO1xuICAgICAgdGhpcy5zdGFydGVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgZGlzYWJsZSgpIHtcbiAgICB0aGlzLmVuYWJsZWQgPSBmYWxzZTtcbiAgfVxuXG4gIHN0b3AoKSB7XG4gICAgaWYgKHRoaXMuc3RhcnRlZCkge1xuICAgICAgdGhpcy5wYWdlT2JzZXJ2ZXIuc3RvcCgpO1xuICAgICAgdGhpcy5jYWNoZU9ic2VydmVyLnN0b3AoKTtcbiAgICAgIHRoaXMubGlua1ByZWZldGNoT2JzZXJ2ZXIuc3RvcCgpO1xuICAgICAgdGhpcy5mb3JtTGlua0NsaWNrT2JzZXJ2ZXIuc3RvcCgpO1xuICAgICAgdGhpcy5saW5rQ2xpY2tPYnNlcnZlci5zdG9wKCk7XG4gICAgICB0aGlzLmZvcm1TdWJtaXRPYnNlcnZlci5zdG9wKCk7XG4gICAgICB0aGlzLnNjcm9sbE9ic2VydmVyLnN0b3AoKTtcbiAgICAgIHRoaXMuc3RyZWFtT2JzZXJ2ZXIuc3RvcCgpO1xuICAgICAgdGhpcy5mcmFtZVJlZGlyZWN0b3Iuc3RvcCgpO1xuICAgICAgdGhpcy5oaXN0b3J5LnN0b3AoKTtcbiAgICAgIHRoaXMucHJlbG9hZGVyLnN0b3AoKTtcbiAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJlZ2lzdGVyQWRhcHRlcihhZGFwdGVyKSB7XG4gICAgdGhpcy5hZGFwdGVyID0gYWRhcHRlcjtcbiAgfVxuXG4gIHZpc2l0KGxvY2F0aW9uLCBvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBmcmFtZUVsZW1lbnQgPSBvcHRpb25zLmZyYW1lID8gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQob3B0aW9ucy5mcmFtZSkgOiBudWxsO1xuXG4gICAgaWYgKGZyYW1lRWxlbWVudCBpbnN0YW5jZW9mIEZyYW1lRWxlbWVudCkge1xuICAgICAgY29uc3QgYWN0aW9uID0gb3B0aW9ucy5hY3Rpb24gfHwgZ2V0VmlzaXRBY3Rpb24oZnJhbWVFbGVtZW50KTtcblxuICAgICAgZnJhbWVFbGVtZW50LmRlbGVnYXRlLnByb3Bvc2VWaXNpdElmTmF2aWdhdGVkV2l0aEFjdGlvbihmcmFtZUVsZW1lbnQsIGFjdGlvbik7XG4gICAgICBmcmFtZUVsZW1lbnQuc3JjID0gbG9jYXRpb24udG9TdHJpbmcoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5uYXZpZ2F0b3IucHJvcG9zZVZpc2l0KGV4cGFuZFVSTChsb2NhdGlvbiksIG9wdGlvbnMpO1xuICAgIH1cbiAgfVxuXG4gIHJlZnJlc2godXJsLCByZXF1ZXN0SWQpIHtcbiAgICBjb25zdCBpc1JlY2VudFJlcXVlc3QgPSByZXF1ZXN0SWQgJiYgdGhpcy5yZWNlbnRSZXF1ZXN0cy5oYXMocmVxdWVzdElkKTtcbiAgICBjb25zdCBpc0N1cnJlbnRVcmwgPSB1cmwgPT09IGRvY3VtZW50LmJhc2VVUkk7XG4gICAgaWYgKCFpc1JlY2VudFJlcXVlc3QgJiYgIXRoaXMubmF2aWdhdG9yLmN1cnJlbnRWaXNpdCAmJiBpc0N1cnJlbnRVcmwpIHtcbiAgICAgIHRoaXMudmlzaXQodXJsLCB7IGFjdGlvbjogXCJyZXBsYWNlXCIsIHNob3VsZENhY2hlU25hcHNob3Q6IGZhbHNlIH0pO1xuICAgIH1cbiAgfVxuXG4gIGNvbm5lY3RTdHJlYW1Tb3VyY2Uoc291cmNlKSB7XG4gICAgdGhpcy5zdHJlYW1PYnNlcnZlci5jb25uZWN0U3RyZWFtU291cmNlKHNvdXJjZSk7XG4gIH1cblxuICBkaXNjb25uZWN0U3RyZWFtU291cmNlKHNvdXJjZSkge1xuICAgIHRoaXMuc3RyZWFtT2JzZXJ2ZXIuZGlzY29ubmVjdFN0cmVhbVNvdXJjZShzb3VyY2UpO1xuICB9XG5cbiAgcmVuZGVyU3RyZWFtTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgdGhpcy5zdHJlYW1NZXNzYWdlUmVuZGVyZXIucmVuZGVyKFN0cmVhbU1lc3NhZ2Uud3JhcChtZXNzYWdlKSk7XG4gIH1cblxuICBjbGVhckNhY2hlKCkge1xuICAgIHRoaXMudmlldy5jbGVhclNuYXBzaG90Q2FjaGUoKTtcbiAgfVxuXG4gIHNldFByb2dyZXNzQmFyRGVsYXkoZGVsYXkpIHtcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICBcIlBsZWFzZSByZXBsYWNlIGBzZXNzaW9uLnNldFByb2dyZXNzQmFyRGVsYXkoZGVsYXkpYCB3aXRoIGBzZXNzaW9uLnByb2dyZXNzQmFyRGVsYXkgPSBkZWxheWAuIFRoZSBmdW5jdGlvbiBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgdmVyc2lvbiBvZiBUdXJiby5gXCJcbiAgICApO1xuXG4gICAgdGhpcy5wcm9ncmVzc0JhckRlbGF5ID0gZGVsYXk7XG4gIH1cblxuICBzZXQgcHJvZ3Jlc3NCYXJEZWxheShkZWxheSkge1xuICAgIGNvbmZpZy5kcml2ZS5wcm9ncmVzc0JhckRlbGF5ID0gZGVsYXk7XG4gIH1cblxuICBnZXQgcHJvZ3Jlc3NCYXJEZWxheSgpIHtcbiAgICByZXR1cm4gY29uZmlnLmRyaXZlLnByb2dyZXNzQmFyRGVsYXlcbiAgfVxuXG4gIHNldCBkcml2ZSh2YWx1ZSkge1xuICAgIGNvbmZpZy5kcml2ZS5lbmFibGVkID0gdmFsdWU7XG4gIH1cblxuICBnZXQgZHJpdmUoKSB7XG4gICAgcmV0dXJuIGNvbmZpZy5kcml2ZS5lbmFibGVkXG4gIH1cblxuICBzZXQgZm9ybU1vZGUodmFsdWUpIHtcbiAgICBjb25maWcuZm9ybXMubW9kZSA9IHZhbHVlO1xuICB9XG5cbiAgZ2V0IGZvcm1Nb2RlKCkge1xuICAgIHJldHVybiBjb25maWcuZm9ybXMubW9kZVxuICB9XG5cbiAgZ2V0IGxvY2F0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmhpc3RvcnkubG9jYXRpb25cbiAgfVxuXG4gIGdldCByZXN0b3JhdGlvbklkZW50aWZpZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGlzdG9yeS5yZXN0b3JhdGlvbklkZW50aWZpZXJcbiAgfVxuXG4gIGdldCBwYWdlUmVmcmVzaERlYm91bmNlUGVyaW9kKCkge1xuICAgIHJldHVybiB0aGlzLiNwYWdlUmVmcmVzaERlYm91bmNlUGVyaW9kXG4gIH1cblxuICBzZXQgcGFnZVJlZnJlc2hEZWJvdW5jZVBlcmlvZCh2YWx1ZSkge1xuICAgIHRoaXMucmVmcmVzaCA9IGRlYm91bmNlKHRoaXMuZGVib3VuY2VkUmVmcmVzaC5iaW5kKHRoaXMpLCB2YWx1ZSk7XG4gICAgdGhpcy4jcGFnZVJlZnJlc2hEZWJvdW5jZVBlcmlvZCA9IHZhbHVlO1xuICB9XG5cbiAgLy8gUHJlbG9hZGVyIGRlbGVnYXRlXG5cbiAgc2hvdWxkUHJlbG9hZExpbmsoZWxlbWVudCkge1xuICAgIGNvbnN0IGlzVW5zYWZlID0gZWxlbWVudC5oYXNBdHRyaWJ1dGUoXCJkYXRhLXR1cmJvLW1ldGhvZFwiKTtcbiAgICBjb25zdCBpc1N0cmVhbSA9IGVsZW1lbnQuaGFzQXR0cmlidXRlKFwiZGF0YS10dXJiby1zdHJlYW1cIik7XG4gICAgY29uc3QgZnJhbWVUYXJnZXQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtdHVyYm8tZnJhbWVcIik7XG4gICAgY29uc3QgZnJhbWUgPSBmcmFtZVRhcmdldCA9PSBcIl90b3BcIiA/XG4gICAgICBudWxsIDpcbiAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGZyYW1lVGFyZ2V0KSB8fCBmaW5kQ2xvc2VzdFJlY3Vyc2l2ZWx5KGVsZW1lbnQsIFwidHVyYm8tZnJhbWU6bm90KFtkaXNhYmxlZF0pXCIpO1xuXG4gICAgaWYgKGlzVW5zYWZlIHx8IGlzU3RyZWFtIHx8IGZyYW1lIGluc3RhbmNlb2YgRnJhbWVFbGVtZW50KSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbG9jYXRpb24gPSBuZXcgVVJMKGVsZW1lbnQuaHJlZik7XG5cbiAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRJc05hdmlnYXRhYmxlKGVsZW1lbnQpICYmIGxvY2F0aW9uSXNWaXNpdGFibGUobG9jYXRpb24sIHRoaXMuc25hcHNob3Qucm9vdExvY2F0aW9uKVxuICAgIH1cbiAgfVxuXG4gIC8vIEhpc3RvcnkgZGVsZWdhdGVcblxuICBoaXN0b3J5UG9wcGVkVG9Mb2NhdGlvbldpdGhSZXN0b3JhdGlvbklkZW50aWZpZXJBbmREaXJlY3Rpb24obG9jYXRpb24sIHJlc3RvcmF0aW9uSWRlbnRpZmllciwgZGlyZWN0aW9uKSB7XG4gICAgaWYgKHRoaXMuZW5hYmxlZCkge1xuICAgICAgdGhpcy5uYXZpZ2F0b3Iuc3RhcnRWaXNpdChsb2NhdGlvbiwgcmVzdG9yYXRpb25JZGVudGlmaWVyLCB7XG4gICAgICAgIGFjdGlvbjogXCJyZXN0b3JlXCIsXG4gICAgICAgIGhpc3RvcnlDaGFuZ2VkOiB0cnVlLFxuICAgICAgICBkaXJlY3Rpb25cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkYXB0ZXIucGFnZUludmFsaWRhdGVkKHtcbiAgICAgICAgcmVhc29uOiBcInR1cmJvX2Rpc2FibGVkXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIFNjcm9sbCBvYnNlcnZlciBkZWxlZ2F0ZVxuXG4gIHNjcm9sbFBvc2l0aW9uQ2hhbmdlZChwb3NpdGlvbikge1xuICAgIHRoaXMuaGlzdG9yeS51cGRhdGVSZXN0b3JhdGlvbkRhdGEoeyBzY3JvbGxQb3NpdGlvbjogcG9zaXRpb24gfSk7XG4gIH1cblxuICAvLyBGb3JtIGNsaWNrIG9ic2VydmVyIGRlbGVnYXRlXG5cbiAgd2lsbFN1Ym1pdEZvcm1MaW5rVG9Mb2NhdGlvbihsaW5rLCBsb2NhdGlvbikge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnRJc05hdmlnYXRhYmxlKGxpbmspICYmIGxvY2F0aW9uSXNWaXNpdGFibGUobG9jYXRpb24sIHRoaXMuc25hcHNob3Qucm9vdExvY2F0aW9uKVxuICB9XG5cbiAgc3VibWl0dGVkRm9ybUxpbmtUb0xvY2F0aW9uKCkge31cblxuICAvLyBMaW5rIGhvdmVyIG9ic2VydmVyIGRlbGVnYXRlXG5cbiAgY2FuUHJlZmV0Y2hSZXF1ZXN0VG9Mb2NhdGlvbihsaW5rLCBsb2NhdGlvbikge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLmVsZW1lbnRJc05hdmlnYXRhYmxlKGxpbmspICYmXG4gICAgICBsb2NhdGlvbklzVmlzaXRhYmxlKGxvY2F0aW9uLCB0aGlzLnNuYXBzaG90LnJvb3RMb2NhdGlvbikgJiZcbiAgICAgIHRoaXMubmF2aWdhdG9yLmxpbmtQcmVmZXRjaGluZ0lzRW5hYmxlZEZvckxvY2F0aW9uKGxvY2F0aW9uKVxuICAgIClcbiAgfVxuXG4gIC8vIExpbmsgY2xpY2sgb2JzZXJ2ZXIgZGVsZWdhdGVcblxuICB3aWxsRm9sbG93TGlua1RvTG9jYXRpb24obGluaywgbG9jYXRpb24sIGV2ZW50KSB7XG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMuZWxlbWVudElzTmF2aWdhdGFibGUobGluaykgJiZcbiAgICAgIGxvY2F0aW9uSXNWaXNpdGFibGUobG9jYXRpb24sIHRoaXMuc25hcHNob3Qucm9vdExvY2F0aW9uKSAmJlxuICAgICAgdGhpcy5hcHBsaWNhdGlvbkFsbG93c0ZvbGxvd2luZ0xpbmtUb0xvY2F0aW9uKGxpbmssIGxvY2F0aW9uLCBldmVudClcbiAgICApXG4gIH1cblxuICBmb2xsb3dlZExpbmtUb0xvY2F0aW9uKGxpbmssIGxvY2F0aW9uKSB7XG4gICAgY29uc3QgYWN0aW9uID0gdGhpcy5nZXRBY3Rpb25Gb3JMaW5rKGxpbmspO1xuICAgIGNvbnN0IGFjY2VwdHNTdHJlYW1SZXNwb25zZSA9IGxpbmsuaGFzQXR0cmlidXRlKFwiZGF0YS10dXJiby1zdHJlYW1cIik7XG5cbiAgICB0aGlzLnZpc2l0KGxvY2F0aW9uLmhyZWYsIHsgYWN0aW9uLCBhY2NlcHRzU3RyZWFtUmVzcG9uc2UgfSk7XG4gIH1cblxuICAvLyBOYXZpZ2F0b3IgZGVsZWdhdGVcblxuICBhbGxvd3NWaXNpdGluZ0xvY2F0aW9uV2l0aEFjdGlvbihsb2NhdGlvbiwgYWN0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMubG9jYXRpb25XaXRoQWN0aW9uSXNTYW1lUGFnZShsb2NhdGlvbiwgYWN0aW9uKSB8fCB0aGlzLmFwcGxpY2F0aW9uQWxsb3dzVmlzaXRpbmdMb2NhdGlvbihsb2NhdGlvbilcbiAgfVxuXG4gIHZpc2l0UHJvcG9zZWRUb0xvY2F0aW9uKGxvY2F0aW9uLCBvcHRpb25zKSB7XG4gICAgZXh0ZW5kVVJMV2l0aERlcHJlY2F0ZWRQcm9wZXJ0aWVzKGxvY2F0aW9uKTtcbiAgICB0aGlzLmFkYXB0ZXIudmlzaXRQcm9wb3NlZFRvTG9jYXRpb24obG9jYXRpb24sIG9wdGlvbnMpO1xuICB9XG5cbiAgLy8gVmlzaXQgZGVsZWdhdGVcblxuICB2aXNpdFN0YXJ0ZWQodmlzaXQpIHtcbiAgICBpZiAoIXZpc2l0LmFjY2VwdHNTdHJlYW1SZXNwb25zZSkge1xuICAgICAgbWFya0FzQnVzeShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpO1xuICAgICAgdGhpcy52aWV3Lm1hcmtWaXNpdERpcmVjdGlvbih2aXNpdC5kaXJlY3Rpb24pO1xuICAgIH1cbiAgICBleHRlbmRVUkxXaXRoRGVwcmVjYXRlZFByb3BlcnRpZXModmlzaXQubG9jYXRpb24pO1xuICAgIGlmICghdmlzaXQuc2lsZW50KSB7XG4gICAgICB0aGlzLm5vdGlmeUFwcGxpY2F0aW9uQWZ0ZXJWaXNpdGluZ0xvY2F0aW9uKHZpc2l0LmxvY2F0aW9uLCB2aXNpdC5hY3Rpb24pO1xuICAgIH1cbiAgfVxuXG4gIHZpc2l0Q29tcGxldGVkKHZpc2l0KSB7XG4gICAgdGhpcy52aWV3LnVubWFya1Zpc2l0RGlyZWN0aW9uKCk7XG4gICAgY2xlYXJCdXN5U3RhdGUoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KTtcbiAgICB0aGlzLm5vdGlmeUFwcGxpY2F0aW9uQWZ0ZXJQYWdlTG9hZCh2aXNpdC5nZXRUaW1pbmdNZXRyaWNzKCkpO1xuICB9XG5cbiAgbG9jYXRpb25XaXRoQWN0aW9uSXNTYW1lUGFnZShsb2NhdGlvbiwgYWN0aW9uKSB7XG4gICAgcmV0dXJuIHRoaXMubmF2aWdhdG9yLmxvY2F0aW9uV2l0aEFjdGlvbklzU2FtZVBhZ2UobG9jYXRpb24sIGFjdGlvbilcbiAgfVxuXG4gIHZpc2l0U2Nyb2xsZWRUb1NhbWVQYWdlTG9jYXRpb24ob2xkVVJMLCBuZXdVUkwpIHtcbiAgICB0aGlzLm5vdGlmeUFwcGxpY2F0aW9uQWZ0ZXJWaXNpdGluZ1NhbWVQYWdlTG9jYXRpb24ob2xkVVJMLCBuZXdVUkwpO1xuICB9XG5cbiAgLy8gRm9ybSBzdWJtaXQgb2JzZXJ2ZXIgZGVsZWdhdGVcblxuICB3aWxsU3VibWl0Rm9ybShmb3JtLCBzdWJtaXR0ZXIpIHtcbiAgICBjb25zdCBhY3Rpb24gPSBnZXRBY3Rpb24kMShmb3JtLCBzdWJtaXR0ZXIpO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIHRoaXMuc3VibWlzc2lvbklzTmF2aWdhdGFibGUoZm9ybSwgc3VibWl0dGVyKSAmJlxuICAgICAgbG9jYXRpb25Jc1Zpc2l0YWJsZShleHBhbmRVUkwoYWN0aW9uKSwgdGhpcy5zbmFwc2hvdC5yb290TG9jYXRpb24pXG4gICAgKVxuICB9XG5cbiAgZm9ybVN1Ym1pdHRlZChmb3JtLCBzdWJtaXR0ZXIpIHtcbiAgICB0aGlzLm5hdmlnYXRvci5zdWJtaXRGb3JtKGZvcm0sIHN1Ym1pdHRlcik7XG4gIH1cblxuICAvLyBQYWdlIG9ic2VydmVyIGRlbGVnYXRlXG5cbiAgcGFnZUJlY2FtZUludGVyYWN0aXZlKCkge1xuICAgIHRoaXMudmlldy5sYXN0UmVuZGVyZWRMb2NhdGlvbiA9IHRoaXMubG9jYXRpb247XG4gICAgdGhpcy5ub3RpZnlBcHBsaWNhdGlvbkFmdGVyUGFnZUxvYWQoKTtcbiAgfVxuXG4gIHBhZ2VMb2FkZWQoKSB7XG4gICAgdGhpcy5oaXN0b3J5LmFzc3VtZUNvbnRyb2xPZlNjcm9sbFJlc3RvcmF0aW9uKCk7XG4gIH1cblxuICBwYWdlV2lsbFVubG9hZCgpIHtcbiAgICB0aGlzLmhpc3RvcnkucmVsaW5xdWlzaENvbnRyb2xPZlNjcm9sbFJlc3RvcmF0aW9uKCk7XG4gIH1cblxuICAvLyBTdHJlYW0gb2JzZXJ2ZXIgZGVsZWdhdGVcblxuICByZWNlaXZlZE1lc3NhZ2VGcm9tU3RyZWFtKG1lc3NhZ2UpIHtcbiAgICB0aGlzLnJlbmRlclN0cmVhbU1lc3NhZ2UobWVzc2FnZSk7XG4gIH1cblxuICAvLyBQYWdlIHZpZXcgZGVsZWdhdGVcblxuICB2aWV3V2lsbENhY2hlU25hcHNob3QoKSB7XG4gICAgaWYgKCF0aGlzLm5hdmlnYXRvci5jdXJyZW50VmlzaXQ/LnNpbGVudCkge1xuICAgICAgdGhpcy5ub3RpZnlBcHBsaWNhdGlvbkJlZm9yZUNhY2hpbmdTbmFwc2hvdCgpO1xuICAgIH1cbiAgfVxuXG4gIGFsbG93c0ltbWVkaWF0ZVJlbmRlcih7IGVsZW1lbnQgfSwgb3B0aW9ucykge1xuICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5ub3RpZnlBcHBsaWNhdGlvbkJlZm9yZVJlbmRlcihlbGVtZW50LCBvcHRpb25zKTtcbiAgICBjb25zdCB7XG4gICAgICBkZWZhdWx0UHJldmVudGVkLFxuICAgICAgZGV0YWlsOiB7IHJlbmRlciB9XG4gICAgfSA9IGV2ZW50O1xuXG4gICAgaWYgKHRoaXMudmlldy5yZW5kZXJlciAmJiByZW5kZXIpIHtcbiAgICAgIHRoaXMudmlldy5yZW5kZXJlci5yZW5kZXJFbGVtZW50ID0gcmVuZGVyO1xuICAgIH1cblxuICAgIHJldHVybiAhZGVmYXVsdFByZXZlbnRlZFxuICB9XG5cbiAgdmlld1JlbmRlcmVkU25hcHNob3QoX3NuYXBzaG90LCBfaXNQcmV2aWV3LCByZW5kZXJNZXRob2QpIHtcbiAgICB0aGlzLnZpZXcubGFzdFJlbmRlcmVkTG9jYXRpb24gPSB0aGlzLmhpc3RvcnkubG9jYXRpb247XG4gICAgdGhpcy5ub3RpZnlBcHBsaWNhdGlvbkFmdGVyUmVuZGVyKHJlbmRlck1ldGhvZCk7XG4gIH1cblxuICBwcmVsb2FkT25Mb2FkTGlua3NGb3JWaWV3KGVsZW1lbnQpIHtcbiAgICB0aGlzLnByZWxvYWRlci5wcmVsb2FkT25Mb2FkTGlua3NGb3JWaWV3KGVsZW1lbnQpO1xuICB9XG5cbiAgdmlld0ludmFsaWRhdGVkKHJlYXNvbikge1xuICAgIHRoaXMuYWRhcHRlci5wYWdlSW52YWxpZGF0ZWQocmVhc29uKTtcbiAgfVxuXG4gIC8vIEZyYW1lIGVsZW1lbnRcblxuICBmcmFtZUxvYWRlZChmcmFtZSkge1xuICAgIHRoaXMubm90aWZ5QXBwbGljYXRpb25BZnRlckZyYW1lTG9hZChmcmFtZSk7XG4gIH1cblxuICBmcmFtZVJlbmRlcmVkKGZldGNoUmVzcG9uc2UsIGZyYW1lKSB7XG4gICAgdGhpcy5ub3RpZnlBcHBsaWNhdGlvbkFmdGVyRnJhbWVSZW5kZXIoZmV0Y2hSZXNwb25zZSwgZnJhbWUpO1xuICB9XG5cbiAgLy8gQXBwbGljYXRpb24gZXZlbnRzXG5cbiAgYXBwbGljYXRpb25BbGxvd3NGb2xsb3dpbmdMaW5rVG9Mb2NhdGlvbihsaW5rLCBsb2NhdGlvbiwgZXYpIHtcbiAgICBjb25zdCBldmVudCA9IHRoaXMubm90aWZ5QXBwbGljYXRpb25BZnRlckNsaWNraW5nTGlua1RvTG9jYXRpb24obGluaywgbG9jYXRpb24sIGV2KTtcbiAgICByZXR1cm4gIWV2ZW50LmRlZmF1bHRQcmV2ZW50ZWRcbiAgfVxuXG4gIGFwcGxpY2F0aW9uQWxsb3dzVmlzaXRpbmdMb2NhdGlvbihsb2NhdGlvbikge1xuICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5ub3RpZnlBcHBsaWNhdGlvbkJlZm9yZVZpc2l0aW5nTG9jYXRpb24obG9jYXRpb24pO1xuICAgIHJldHVybiAhZXZlbnQuZGVmYXVsdFByZXZlbnRlZFxuICB9XG5cbiAgbm90aWZ5QXBwbGljYXRpb25BZnRlckNsaWNraW5nTGlua1RvTG9jYXRpb24obGluaywgbG9jYXRpb24sIGV2ZW50KSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoKFwidHVyYm86Y2xpY2tcIiwge1xuICAgICAgdGFyZ2V0OiBsaW5rLFxuICAgICAgZGV0YWlsOiB7IHVybDogbG9jYXRpb24uaHJlZiwgb3JpZ2luYWxFdmVudDogZXZlbnQgfSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICB9KVxuICB9XG5cbiAgbm90aWZ5QXBwbGljYXRpb25CZWZvcmVWaXNpdGluZ0xvY2F0aW9uKGxvY2F0aW9uKSB7XG4gICAgcmV0dXJuIGRpc3BhdGNoKFwidHVyYm86YmVmb3JlLXZpc2l0XCIsIHtcbiAgICAgIGRldGFpbDogeyB1cmw6IGxvY2F0aW9uLmhyZWYgfSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICB9KVxuICB9XG5cbiAgbm90aWZ5QXBwbGljYXRpb25BZnRlclZpc2l0aW5nTG9jYXRpb24obG9jYXRpb24sIGFjdGlvbikge1xuICAgIHJldHVybiBkaXNwYXRjaChcInR1cmJvOnZpc2l0XCIsIHsgZGV0YWlsOiB7IHVybDogbG9jYXRpb24uaHJlZiwgYWN0aW9uIH0gfSlcbiAgfVxuXG4gIG5vdGlmeUFwcGxpY2F0aW9uQmVmb3JlQ2FjaGluZ1NuYXBzaG90KCkge1xuICAgIHJldHVybiBkaXNwYXRjaChcInR1cmJvOmJlZm9yZS1jYWNoZVwiKVxuICB9XG5cbiAgbm90aWZ5QXBwbGljYXRpb25CZWZvcmVSZW5kZXIobmV3Qm9keSwgb3B0aW9ucykge1xuICAgIHJldHVybiBkaXNwYXRjaChcInR1cmJvOmJlZm9yZS1yZW5kZXJcIiwge1xuICAgICAgZGV0YWlsOiB7IG5ld0JvZHksIC4uLm9wdGlvbnMgfSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICB9KVxuICB9XG5cbiAgbm90aWZ5QXBwbGljYXRpb25BZnRlclJlbmRlcihyZW5kZXJNZXRob2QpIHtcbiAgICByZXR1cm4gZGlzcGF0Y2goXCJ0dXJibzpyZW5kZXJcIiwgeyBkZXRhaWw6IHsgcmVuZGVyTWV0aG9kIH0gfSlcbiAgfVxuXG4gIG5vdGlmeUFwcGxpY2F0aW9uQWZ0ZXJQYWdlTG9hZCh0aW1pbmcgPSB7fSkge1xuICAgIHJldHVybiBkaXNwYXRjaChcInR1cmJvOmxvYWRcIiwge1xuICAgICAgZGV0YWlsOiB7IHVybDogdGhpcy5sb2NhdGlvbi5ocmVmLCB0aW1pbmcgfVxuICAgIH0pXG4gIH1cblxuICBub3RpZnlBcHBsaWNhdGlvbkFmdGVyVmlzaXRpbmdTYW1lUGFnZUxvY2F0aW9uKG9sZFVSTCwgbmV3VVJMKSB7XG4gICAgZGlzcGF0Y2hFdmVudChcbiAgICAgIG5ldyBIYXNoQ2hhbmdlRXZlbnQoXCJoYXNoY2hhbmdlXCIsIHtcbiAgICAgICAgb2xkVVJMOiBvbGRVUkwudG9TdHJpbmcoKSxcbiAgICAgICAgbmV3VVJMOiBuZXdVUkwudG9TdHJpbmcoKVxuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgbm90aWZ5QXBwbGljYXRpb25BZnRlckZyYW1lTG9hZChmcmFtZSkge1xuICAgIHJldHVybiBkaXNwYXRjaChcInR1cmJvOmZyYW1lLWxvYWRcIiwgeyB0YXJnZXQ6IGZyYW1lIH0pXG4gIH1cblxuICBub3RpZnlBcHBsaWNhdGlvbkFmdGVyRnJhbWVSZW5kZXIoZmV0Y2hSZXNwb25zZSwgZnJhbWUpIHtcbiAgICByZXR1cm4gZGlzcGF0Y2goXCJ0dXJibzpmcmFtZS1yZW5kZXJcIiwge1xuICAgICAgZGV0YWlsOiB7IGZldGNoUmVzcG9uc2UgfSxcbiAgICAgIHRhcmdldDogZnJhbWUsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgfSlcbiAgfVxuXG4gIC8vIEhlbHBlcnNcblxuICBzdWJtaXNzaW9uSXNOYXZpZ2F0YWJsZShmb3JtLCBzdWJtaXR0ZXIpIHtcbiAgICBpZiAoY29uZmlnLmZvcm1zLm1vZGUgPT0gXCJvZmZcIikge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHN1Ym1pdHRlcklzTmF2aWdhdGFibGUgPSBzdWJtaXR0ZXIgPyB0aGlzLmVsZW1lbnRJc05hdmlnYXRhYmxlKHN1Ym1pdHRlcikgOiB0cnVlO1xuXG4gICAgICBpZiAoY29uZmlnLmZvcm1zLm1vZGUgPT0gXCJvcHRpblwiKSB7XG4gICAgICAgIHJldHVybiBzdWJtaXR0ZXJJc05hdmlnYXRhYmxlICYmIGZvcm0uY2xvc2VzdCgnW2RhdGEtdHVyYm89XCJ0cnVlXCJdJykgIT0gbnVsbFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHN1Ym1pdHRlcklzTmF2aWdhdGFibGUgJiYgdGhpcy5lbGVtZW50SXNOYXZpZ2F0YWJsZShmb3JtKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGVsZW1lbnRJc05hdmlnYXRhYmxlKGVsZW1lbnQpIHtcbiAgICBjb25zdCBjb250YWluZXIgPSBmaW5kQ2xvc2VzdFJlY3Vyc2l2ZWx5KGVsZW1lbnQsIFwiW2RhdGEtdHVyYm9dXCIpO1xuICAgIGNvbnN0IHdpdGhpbkZyYW1lID0gZmluZENsb3Nlc3RSZWN1cnNpdmVseShlbGVtZW50LCBcInR1cmJvLWZyYW1lXCIpO1xuXG4gICAgLy8gQ2hlY2sgaWYgRHJpdmUgaXMgZW5hYmxlZCBvbiB0aGUgc2Vzc2lvbiBvciB3ZSdyZSB3aXRoaW4gYSBGcmFtZS5cbiAgICBpZiAoY29uZmlnLmRyaXZlLmVuYWJsZWQgfHwgd2l0aGluRnJhbWUpIHtcbiAgICAgIC8vIEVsZW1lbnQgaXMgbmF2aWdhdGFibGUgYnkgZGVmYXVsdCwgdW5sZXNzIGBkYXRhLXR1cmJvPVwiZmFsc2VcImAuXG4gICAgICBpZiAoY29udGFpbmVyKSB7XG4gICAgICAgIHJldHVybiBjb250YWluZXIuZ2V0QXR0cmlidXRlKFwiZGF0YS10dXJib1wiKSAhPSBcImZhbHNlXCJcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEVsZW1lbnQgaXNuJ3QgbmF2aWdhdGFibGUgYnkgZGVmYXVsdCwgdW5sZXNzIGBkYXRhLXR1cmJvPVwidHJ1ZVwiYC5cbiAgICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lci5nZXRBdHRyaWJ1dGUoXCJkYXRhLXR1cmJvXCIpID09IFwidHJ1ZVwiXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBQcml2YXRlXG5cbiAgZ2V0QWN0aW9uRm9yTGluayhsaW5rKSB7XG4gICAgcmV0dXJuIGdldFZpc2l0QWN0aW9uKGxpbmspIHx8IFwiYWR2YW5jZVwiXG4gIH1cblxuICBnZXQgc25hcHNob3QoKSB7XG4gICAgcmV0dXJuIHRoaXMudmlldy5zbmFwc2hvdFxuICB9XG59XG5cbi8vIE9sZGVyIHZlcnNpb25zIG9mIHRoZSBUdXJibyBOYXRpdmUgYWRhcHRlcnMgcmVmZXJlbmNlZCB0aGVcbi8vIGBMb2NhdGlvbiNhYnNvbHV0ZVVSTGAgcHJvcGVydHkgaW4gdGhlaXIgaW1wbGVtZW50YXRpb25zIG9mXG4vLyB0aGUgYEFkYXB0ZXIjdmlzaXRQcm9wb3NlZFRvTG9jYXRpb24oKWAgYW5kIGAjdmlzaXRTdGFydGVkKClgXG4vLyBtZXRob2RzLiBUaGUgTG9jYXRpb24gY2xhc3MgaGFzIHNpbmNlIGJlZW4gcmVtb3ZlZCBpbiBmYXZvclxuLy8gb2YgdGhlIERPTSBVUkwgQVBJLCBhbmQgYWNjb3JkaW5nbHkgYWxsIEFkYXB0ZXIgbWV0aG9kcyBub3dcbi8vIHJlY2VpdmUgVVJMIG9iamVjdHMuXG4vL1xuLy8gV2UgYWxpYXMgI2Fic29sdXRlVVJMIHRvICN0b1N0cmluZygpIGhlcmUgdG8gYXZvaWQgY3Jhc2hpbmdcbi8vIG9sZGVyIGFkYXB0ZXJzIHdoaWNoIGRvIG5vdCBleHBlY3QgVVJMIG9iamVjdHMuIFdlIHNob3VsZFxuLy8gY29uc2lkZXIgcmVtb3ZpbmcgdGhpcyBzdXBwb3J0IGF0IHNvbWUgcG9pbnQgaW4gdGhlIGZ1dHVyZS5cblxuZnVuY3Rpb24gZXh0ZW5kVVJMV2l0aERlcHJlY2F0ZWRQcm9wZXJ0aWVzKHVybCkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh1cmwsIGRlcHJlY2F0ZWRMb2NhdGlvblByb3BlcnR5RGVzY3JpcHRvcnMpO1xufVxuXG5jb25zdCBkZXByZWNhdGVkTG9jYXRpb25Qcm9wZXJ0eURlc2NyaXB0b3JzID0ge1xuICBhYnNvbHV0ZVVSTDoge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvU3RyaW5nKClcbiAgICB9XG4gIH1cbn07XG5cbmNvbnN0IHNlc3Npb24gPSBuZXcgU2Vzc2lvbihyZWNlbnRSZXF1ZXN0cyk7XG5jb25zdCB7IGNhY2hlLCBuYXZpZ2F0b3I6IG5hdmlnYXRvciQxIH0gPSBzZXNzaW9uO1xuXG4vKipcbiAqIFN0YXJ0cyB0aGUgbWFpbiBzZXNzaW9uLlxuICogVGhpcyBpbml0aWFsaXNlcyBhbnkgbmVjZXNzYXJ5IG9ic2VydmVycyBzdWNoIGFzIHRob3NlIHRvIG1vbml0b3JcbiAqIGxpbmsgaW50ZXJhY3Rpb25zLlxuICovXG5mdW5jdGlvbiBzdGFydCgpIHtcbiAgc2Vzc2lvbi5zdGFydCgpO1xufVxuXG4vKipcbiAqIFJlZ2lzdGVycyBhbiBhZGFwdGVyIGZvciB0aGUgbWFpbiBzZXNzaW9uLlxuICpcbiAqIEBwYXJhbSBhZGFwdGVyIEFkYXB0ZXIgdG8gcmVnaXN0ZXJcbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJBZGFwdGVyKGFkYXB0ZXIpIHtcbiAgc2Vzc2lvbi5yZWdpc3RlckFkYXB0ZXIoYWRhcHRlcik7XG59XG5cbi8qKlxuICogUGVyZm9ybXMgYW4gYXBwbGljYXRpb24gdmlzaXQgdG8gdGhlIGdpdmVuIGxvY2F0aW9uLlxuICpcbiAqIEBwYXJhbSBsb2NhdGlvbiBMb2NhdGlvbiB0byB2aXNpdCAoYSBVUkwgb3IgcGF0aClcbiAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbnMgdG8gYXBwbHlcbiAqIEBwYXJhbSBvcHRpb25zLmFjdGlvbiBUeXBlIG9mIGhpc3RvcnkgbmF2aWdhdGlvbiB0byBhcHBseSAoXCJyZXN0b3JlXCIsXG4gKiBcInJlcGxhY2VcIiBvciBcImFkdmFuY2VcIilcbiAqIEBwYXJhbSBvcHRpb25zLmhpc3RvcnlDaGFuZ2VkIFNwZWNpZmllcyB3aGV0aGVyIHRoZSBicm93c2VyIGhpc3RvcnkgaGFzXG4gKiBhbHJlYWR5IGJlZW4gY2hhbmdlZCBmb3IgdGhpcyB2aXNpdCBvciBub3RcbiAqIEBwYXJhbSBvcHRpb25zLnJlZmVycmVyIFNwZWNpZmllcyB0aGUgcmVmZXJyZXIgb2YgdGhpcyB2aXNpdCBzdWNoIHRoYXRcbiAqIG5hdmlnYXRpb25zIHRvIHRoZSBzYW1lIHBhZ2Ugd2lsbCBub3QgcmVzdWx0IGluIGEgbmV3IGhpc3RvcnkgZW50cnkuXG4gKiBAcGFyYW0gb3B0aW9ucy5zbmFwc2hvdEhUTUwgQ2FjaGVkIHNuYXBzaG90IHRvIHJlbmRlclxuICogQHBhcmFtIG9wdGlvbnMucmVzcG9uc2UgUmVzcG9uc2Ugb2YgdGhlIHNwZWNpZmllZCBsb2NhdGlvblxuICovXG5mdW5jdGlvbiB2aXNpdChsb2NhdGlvbiwgb3B0aW9ucykge1xuICBzZXNzaW9uLnZpc2l0KGxvY2F0aW9uLCBvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBDb25uZWN0cyBhIHN0cmVhbSBzb3VyY2UgdG8gdGhlIG1haW4gc2Vzc2lvbi5cbiAqXG4gKiBAcGFyYW0gc291cmNlIFN0cmVhbSBzb3VyY2UgdG8gY29ubmVjdFxuICovXG5mdW5jdGlvbiBjb25uZWN0U3RyZWFtU291cmNlKHNvdXJjZSkge1xuICBzZXNzaW9uLmNvbm5lY3RTdHJlYW1Tb3VyY2Uoc291cmNlKTtcbn1cblxuLyoqXG4gKiBEaXNjb25uZWN0cyBhIHN0cmVhbSBzb3VyY2UgZnJvbSB0aGUgbWFpbiBzZXNzaW9uLlxuICpcbiAqIEBwYXJhbSBzb3VyY2UgU3RyZWFtIHNvdXJjZSB0byBkaXNjb25uZWN0XG4gKi9cbmZ1bmN0aW9uIGRpc2Nvbm5lY3RTdHJlYW1Tb3VyY2Uoc291cmNlKSB7XG4gIHNlc3Npb24uZGlzY29ubmVjdFN0cmVhbVNvdXJjZShzb3VyY2UpO1xufVxuXG4vKipcbiAqIFJlbmRlcnMgYSBzdHJlYW0gbWVzc2FnZSB0byB0aGUgbWFpbiBzZXNzaW9uIGJ5IGFwcGVuZGluZyBpdCB0byB0aGVcbiAqIGN1cnJlbnQgZG9jdW1lbnQuXG4gKlxuICogQHBhcmFtIG1lc3NhZ2UgTWVzc2FnZSB0byByZW5kZXJcbiAqL1xuZnVuY3Rpb24gcmVuZGVyU3RyZWFtTWVzc2FnZShtZXNzYWdlKSB7XG4gIHNlc3Npb24ucmVuZGVyU3RyZWFtTWVzc2FnZShtZXNzYWdlKTtcbn1cblxuLyoqXG4gKiBSZW1vdmVzIGFsbCBlbnRyaWVzIGZyb20gdGhlIFR1cmJvIERyaXZlIHBhZ2UgY2FjaGUuXG4gKiBDYWxsIHRoaXMgd2hlbiBzdGF0ZSBoYXMgY2hhbmdlZCBvbiB0aGUgc2VydmVyIHRoYXQgbWF5IGFmZmVjdCBjYWNoZWQgcGFnZXMuXG4gKlxuICogQGRlcHJlY2F0ZWQgc2luY2UgdmVyc2lvbiA3LjIuMCBpbiBmYXZvciBvZiBgVHVyYm8uY2FjaGUuY2xlYXIoKWBcbiAqL1xuZnVuY3Rpb24gY2xlYXJDYWNoZSgpIHtcbiAgY29uc29sZS53YXJuKFxuICAgIFwiUGxlYXNlIHJlcGxhY2UgYFR1cmJvLmNsZWFyQ2FjaGUoKWAgd2l0aCBgVHVyYm8uY2FjaGUuY2xlYXIoKWAuIFRoZSB0b3AtbGV2ZWwgZnVuY3Rpb24gaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24gb2YgVHVyYm8uYFwiXG4gICk7XG4gIHNlc3Npb24uY2xlYXJDYWNoZSgpO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIGRlbGF5IGFmdGVyIHdoaWNoIHRoZSBwcm9ncmVzcyBiYXIgd2lsbCBhcHBlYXIgZHVyaW5nIG5hdmlnYXRpb24uXG4gKlxuICogVGhlIHByb2dyZXNzIGJhciBhcHBlYXJzIGFmdGVyIDUwMG1zIGJ5IGRlZmF1bHQuXG4gKlxuICogTm90ZSB0aGF0IHRoaXMgbWV0aG9kIGhhcyBubyBlZmZlY3Qgd2hlbiB1c2VkIHdpdGggdGhlIGlPUyBvciBBbmRyb2lkXG4gKiBhZGFwdGVycy5cbiAqXG4gKiBAcGFyYW0gZGVsYXkgVGltZSB0byBkZWxheSBpbiBtaWxsaXNlY29uZHNcbiAqL1xuZnVuY3Rpb24gc2V0UHJvZ3Jlc3NCYXJEZWxheShkZWxheSkge1xuICBjb25zb2xlLndhcm4oXG4gICAgXCJQbGVhc2UgcmVwbGFjZSBgVHVyYm8uc2V0UHJvZ3Jlc3NCYXJEZWxheShkZWxheSlgIHdpdGggYFR1cmJvLmNvbmZpZy5kcml2ZS5wcm9ncmVzc0JhckRlbGF5ID0gZGVsYXlgLiBUaGUgdG9wLWxldmVsIGZ1bmN0aW9uIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uIG9mIFR1cmJvLmBcIlxuICApO1xuICBjb25maWcuZHJpdmUucHJvZ3Jlc3NCYXJEZWxheSA9IGRlbGF5O1xufVxuXG5mdW5jdGlvbiBzZXRDb25maXJtTWV0aG9kKGNvbmZpcm1NZXRob2QpIHtcbiAgY29uc29sZS53YXJuKFxuICAgIFwiUGxlYXNlIHJlcGxhY2UgYFR1cmJvLnNldENvbmZpcm1NZXRob2QoY29uZmlybU1ldGhvZClgIHdpdGggYFR1cmJvLmNvbmZpZy5mb3Jtcy5jb25maXJtID0gY29uZmlybU1ldGhvZGAuIFRoZSB0b3AtbGV2ZWwgZnVuY3Rpb24gaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24gb2YgVHVyYm8uYFwiXG4gICk7XG4gIGNvbmZpZy5mb3Jtcy5jb25maXJtID0gY29uZmlybU1ldGhvZDtcbn1cblxuZnVuY3Rpb24gc2V0Rm9ybU1vZGUobW9kZSkge1xuICBjb25zb2xlLndhcm4oXG4gICAgXCJQbGVhc2UgcmVwbGFjZSBgVHVyYm8uc2V0Rm9ybU1vZGUobW9kZSlgIHdpdGggYFR1cmJvLmNvbmZpZy5mb3Jtcy5tb2RlID0gbW9kZWAuIFRoZSB0b3AtbGV2ZWwgZnVuY3Rpb24gaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24gb2YgVHVyYm8uYFwiXG4gICk7XG4gIGNvbmZpZy5mb3Jtcy5tb2RlID0gbW9kZTtcbn1cblxudmFyIFR1cmJvID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIG5hdmlnYXRvcjogbmF2aWdhdG9yJDEsXG4gIHNlc3Npb246IHNlc3Npb24sXG4gIGNhY2hlOiBjYWNoZSxcbiAgUGFnZVJlbmRlcmVyOiBQYWdlUmVuZGVyZXIsXG4gIFBhZ2VTbmFwc2hvdDogUGFnZVNuYXBzaG90LFxuICBGcmFtZVJlbmRlcmVyOiBGcmFtZVJlbmRlcmVyLFxuICBmZXRjaDogZmV0Y2hXaXRoVHVyYm9IZWFkZXJzLFxuICBjb25maWc6IGNvbmZpZyxcbiAgc3RhcnQ6IHN0YXJ0LFxuICByZWdpc3RlckFkYXB0ZXI6IHJlZ2lzdGVyQWRhcHRlcixcbiAgdmlzaXQ6IHZpc2l0LFxuICBjb25uZWN0U3RyZWFtU291cmNlOiBjb25uZWN0U3RyZWFtU291cmNlLFxuICBkaXNjb25uZWN0U3RyZWFtU291cmNlOiBkaXNjb25uZWN0U3RyZWFtU291cmNlLFxuICByZW5kZXJTdHJlYW1NZXNzYWdlOiByZW5kZXJTdHJlYW1NZXNzYWdlLFxuICBjbGVhckNhY2hlOiBjbGVhckNhY2hlLFxuICBzZXRQcm9ncmVzc0JhckRlbGF5OiBzZXRQcm9ncmVzc0JhckRlbGF5LFxuICBzZXRDb25maXJtTWV0aG9kOiBzZXRDb25maXJtTWV0aG9kLFxuICBzZXRGb3JtTW9kZTogc2V0Rm9ybU1vZGVcbn0pO1xuXG5jbGFzcyBUdXJib0ZyYW1lTWlzc2luZ0Vycm9yIGV4dGVuZHMgRXJyb3Ige31cblxuY2xhc3MgRnJhbWVDb250cm9sbGVyIHtcbiAgZmV0Y2hSZXNwb25zZUxvYWRlZCA9IChfZmV0Y2hSZXNwb25zZSkgPT4gUHJvbWlzZS5yZXNvbHZlKClcbiAgI2N1cnJlbnRGZXRjaFJlcXVlc3QgPSBudWxsXG4gICNyZXNvbHZlVmlzaXRQcm9taXNlID0gKCkgPT4ge31cbiAgI2Nvbm5lY3RlZCA9IGZhbHNlXG4gICNoYXNCZWVuTG9hZGVkID0gZmFsc2VcbiAgI2lnbm9yZWRBdHRyaWJ1dGVzID0gbmV3IFNldCgpXG4gICNzaG91bGRNb3JwaEZyYW1lID0gZmFsc2VcbiAgYWN0aW9uID0gbnVsbFxuXG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQpIHtcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMudmlldyA9IG5ldyBGcmFtZVZpZXcodGhpcywgdGhpcy5lbGVtZW50KTtcbiAgICB0aGlzLmFwcGVhcmFuY2VPYnNlcnZlciA9IG5ldyBBcHBlYXJhbmNlT2JzZXJ2ZXIodGhpcywgdGhpcy5lbGVtZW50KTtcbiAgICB0aGlzLmZvcm1MaW5rQ2xpY2tPYnNlcnZlciA9IG5ldyBGb3JtTGlua0NsaWNrT2JzZXJ2ZXIodGhpcywgdGhpcy5lbGVtZW50KTtcbiAgICB0aGlzLmxpbmtJbnRlcmNlcHRvciA9IG5ldyBMaW5rSW50ZXJjZXB0b3IodGhpcywgdGhpcy5lbGVtZW50KTtcbiAgICB0aGlzLnJlc3RvcmF0aW9uSWRlbnRpZmllciA9IHV1aWQoKTtcbiAgICB0aGlzLmZvcm1TdWJtaXRPYnNlcnZlciA9IG5ldyBGb3JtU3VibWl0T2JzZXJ2ZXIodGhpcywgdGhpcy5lbGVtZW50KTtcbiAgfVxuXG4gIC8vIEZyYW1lIGRlbGVnYXRlXG5cbiAgY29ubmVjdCgpIHtcbiAgICBpZiAoIXRoaXMuI2Nvbm5lY3RlZCkge1xuICAgICAgdGhpcy4jY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgIGlmICh0aGlzLmxvYWRpbmdTdHlsZSA9PSBGcmFtZUxvYWRpbmdTdHlsZS5sYXp5KSB7XG4gICAgICAgIHRoaXMuYXBwZWFyYW5jZU9ic2VydmVyLnN0YXJ0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLiNsb2FkU291cmNlVVJMKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmZvcm1MaW5rQ2xpY2tPYnNlcnZlci5zdGFydCgpO1xuICAgICAgdGhpcy5saW5rSW50ZXJjZXB0b3Iuc3RhcnQoKTtcbiAgICAgIHRoaXMuZm9ybVN1Ym1pdE9ic2VydmVyLnN0YXJ0KCk7XG4gICAgfVxuICB9XG5cbiAgZGlzY29ubmVjdCgpIHtcbiAgICBpZiAodGhpcy4jY29ubmVjdGVkKSB7XG4gICAgICB0aGlzLiNjb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuYXBwZWFyYW5jZU9ic2VydmVyLnN0b3AoKTtcbiAgICAgIHRoaXMuZm9ybUxpbmtDbGlja09ic2VydmVyLnN0b3AoKTtcbiAgICAgIHRoaXMubGlua0ludGVyY2VwdG9yLnN0b3AoKTtcbiAgICAgIHRoaXMuZm9ybVN1Ym1pdE9ic2VydmVyLnN0b3AoKTtcbiAgICB9XG4gIH1cblxuICBkaXNhYmxlZENoYW5nZWQoKSB7XG4gICAgaWYgKHRoaXMubG9hZGluZ1N0eWxlID09IEZyYW1lTG9hZGluZ1N0eWxlLmVhZ2VyKSB7XG4gICAgICB0aGlzLiNsb2FkU291cmNlVVJMKCk7XG4gICAgfVxuICB9XG5cbiAgc291cmNlVVJMQ2hhbmdlZCgpIHtcbiAgICBpZiAodGhpcy4jaXNJZ25vcmluZ0NoYW5nZXNUbyhcInNyY1wiKSkgcmV0dXJuXG5cbiAgICBpZiAodGhpcy5lbGVtZW50LmlzQ29ubmVjdGVkKSB7XG4gICAgICB0aGlzLmNvbXBsZXRlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubG9hZGluZ1N0eWxlID09IEZyYW1lTG9hZGluZ1N0eWxlLmVhZ2VyIHx8IHRoaXMuI2hhc0JlZW5Mb2FkZWQpIHtcbiAgICAgIHRoaXMuI2xvYWRTb3VyY2VVUkwoKTtcbiAgICB9XG4gIH1cblxuICBzb3VyY2VVUkxSZWxvYWRlZCgpIHtcbiAgICBjb25zdCB7IHJlZnJlc2gsIHNyYyB9ID0gdGhpcy5lbGVtZW50O1xuXG4gICAgdGhpcy4jc2hvdWxkTW9ycGhGcmFtZSA9IHNyYyAmJiByZWZyZXNoID09PSBcIm1vcnBoXCI7XG5cbiAgICB0aGlzLmVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwiY29tcGxldGVcIik7XG4gICAgdGhpcy5lbGVtZW50LnNyYyA9IG51bGw7XG4gICAgdGhpcy5lbGVtZW50LnNyYyA9IHNyYztcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50LmxvYWRlZFxuICB9XG5cbiAgbG9hZGluZ1N0eWxlQ2hhbmdlZCgpIHtcbiAgICBpZiAodGhpcy5sb2FkaW5nU3R5bGUgPT0gRnJhbWVMb2FkaW5nU3R5bGUubGF6eSkge1xuICAgICAgdGhpcy5hcHBlYXJhbmNlT2JzZXJ2ZXIuc3RhcnQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hcHBlYXJhbmNlT2JzZXJ2ZXIuc3RvcCgpO1xuICAgICAgdGhpcy4jbG9hZFNvdXJjZVVSTCgpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jICNsb2FkU291cmNlVVJMKCkge1xuICAgIGlmICh0aGlzLmVuYWJsZWQgJiYgdGhpcy5pc0FjdGl2ZSAmJiAhdGhpcy5jb21wbGV0ZSAmJiB0aGlzLnNvdXJjZVVSTCkge1xuICAgICAgdGhpcy5lbGVtZW50LmxvYWRlZCA9IHRoaXMuI3Zpc2l0KGV4cGFuZFVSTCh0aGlzLnNvdXJjZVVSTCkpO1xuICAgICAgdGhpcy5hcHBlYXJhbmNlT2JzZXJ2ZXIuc3RvcCgpO1xuICAgICAgYXdhaXQgdGhpcy5lbGVtZW50LmxvYWRlZDtcbiAgICAgIHRoaXMuI2hhc0JlZW5Mb2FkZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGxvYWRSZXNwb25zZShmZXRjaFJlc3BvbnNlKSB7XG4gICAgaWYgKGZldGNoUmVzcG9uc2UucmVkaXJlY3RlZCB8fCAoZmV0Y2hSZXNwb25zZS5zdWNjZWVkZWQgJiYgZmV0Y2hSZXNwb25zZS5pc0hUTUwpKSB7XG4gICAgICB0aGlzLnNvdXJjZVVSTCA9IGZldGNoUmVzcG9uc2UucmVzcG9uc2UudXJsO1xuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBodG1sID0gYXdhaXQgZmV0Y2hSZXNwb25zZS5yZXNwb25zZUhUTUw7XG4gICAgICBpZiAoaHRtbCkge1xuICAgICAgICBjb25zdCBkb2N1bWVudCA9IHBhcnNlSFRNTERvY3VtZW50KGh0bWwpO1xuICAgICAgICBjb25zdCBwYWdlU25hcHNob3QgPSBQYWdlU25hcHNob3QuZnJvbURvY3VtZW50KGRvY3VtZW50KTtcblxuICAgICAgICBpZiAocGFnZVNuYXBzaG90LmlzVmlzaXRhYmxlKSB7XG4gICAgICAgICAgYXdhaXQgdGhpcy4jbG9hZEZyYW1lUmVzcG9uc2UoZmV0Y2hSZXNwb25zZSwgZG9jdW1lbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGF3YWl0IHRoaXMuI2hhbmRsZVVudmlzaXRhYmxlRnJhbWVSZXNwb25zZShmZXRjaFJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLiNzaG91bGRNb3JwaEZyYW1lID0gZmFsc2U7XG4gICAgICB0aGlzLmZldGNoUmVzcG9uc2VMb2FkZWQgPSAoKSA9PiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gIH1cblxuICAvLyBBcHBlYXJhbmNlIG9ic2VydmVyIGRlbGVnYXRlXG5cbiAgZWxlbWVudEFwcGVhcmVkSW5WaWV3cG9ydChlbGVtZW50KSB7XG4gICAgdGhpcy5wcm9wb3NlVmlzaXRJZk5hdmlnYXRlZFdpdGhBY3Rpb24oZWxlbWVudCwgZ2V0VmlzaXRBY3Rpb24oZWxlbWVudCkpO1xuICAgIHRoaXMuI2xvYWRTb3VyY2VVUkwoKTtcbiAgfVxuXG4gIC8vIEZvcm0gbGluayBjbGljayBvYnNlcnZlciBkZWxlZ2F0ZVxuXG4gIHdpbGxTdWJtaXRGb3JtTGlua1RvTG9jYXRpb24obGluaykge1xuICAgIHJldHVybiB0aGlzLiNzaG91bGRJbnRlcmNlcHROYXZpZ2F0aW9uKGxpbmspXG4gIH1cblxuICBzdWJtaXR0ZWRGb3JtTGlua1RvTG9jYXRpb24obGluaywgX2xvY2F0aW9uLCBmb3JtKSB7XG4gICAgY29uc3QgZnJhbWUgPSB0aGlzLiNmaW5kRnJhbWVFbGVtZW50KGxpbmspO1xuICAgIGlmIChmcmFtZSkgZm9ybS5zZXRBdHRyaWJ1dGUoXCJkYXRhLXR1cmJvLWZyYW1lXCIsIGZyYW1lLmlkKTtcbiAgfVxuXG4gIC8vIExpbmsgaW50ZXJjZXB0b3IgZGVsZWdhdGVcblxuICBzaG91bGRJbnRlcmNlcHRMaW5rQ2xpY2soZWxlbWVudCwgX2xvY2F0aW9uLCBfZXZlbnQpIHtcbiAgICByZXR1cm4gdGhpcy4jc2hvdWxkSW50ZXJjZXB0TmF2aWdhdGlvbihlbGVtZW50KVxuICB9XG5cbiAgbGlua0NsaWNrSW50ZXJjZXB0ZWQoZWxlbWVudCwgbG9jYXRpb24pIHtcbiAgICB0aGlzLiNuYXZpZ2F0ZUZyYW1lKGVsZW1lbnQsIGxvY2F0aW9uKTtcbiAgfVxuXG4gIC8vIEZvcm0gc3VibWl0IG9ic2VydmVyIGRlbGVnYXRlXG5cbiAgd2lsbFN1Ym1pdEZvcm0oZWxlbWVudCwgc3VibWl0dGVyKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuY2xvc2VzdChcInR1cmJvLWZyYW1lXCIpID09IHRoaXMuZWxlbWVudCAmJiB0aGlzLiNzaG91bGRJbnRlcmNlcHROYXZpZ2F0aW9uKGVsZW1lbnQsIHN1Ym1pdHRlcilcbiAgfVxuXG4gIGZvcm1TdWJtaXR0ZWQoZWxlbWVudCwgc3VibWl0dGVyKSB7XG4gICAgaWYgKHRoaXMuZm9ybVN1Ym1pc3Npb24pIHtcbiAgICAgIHRoaXMuZm9ybVN1Ym1pc3Npb24uc3RvcCgpO1xuICAgIH1cblxuICAgIHRoaXMuZm9ybVN1Ym1pc3Npb24gPSBuZXcgRm9ybVN1Ym1pc3Npb24odGhpcywgZWxlbWVudCwgc3VibWl0dGVyKTtcbiAgICBjb25zdCB7IGZldGNoUmVxdWVzdCB9ID0gdGhpcy5mb3JtU3VibWlzc2lvbjtcbiAgICB0aGlzLnByZXBhcmVSZXF1ZXN0KGZldGNoUmVxdWVzdCk7XG4gICAgdGhpcy5mb3JtU3VibWlzc2lvbi5zdGFydCgpO1xuICB9XG5cbiAgLy8gRmV0Y2ggcmVxdWVzdCBkZWxlZ2F0ZVxuXG4gIHByZXBhcmVSZXF1ZXN0KHJlcXVlc3QpIHtcbiAgICByZXF1ZXN0LmhlYWRlcnNbXCJUdXJiby1GcmFtZVwiXSA9IHRoaXMuaWQ7XG5cbiAgICBpZiAodGhpcy5jdXJyZW50TmF2aWdhdGlvbkVsZW1lbnQ/Lmhhc0F0dHJpYnV0ZShcImRhdGEtdHVyYm8tc3RyZWFtXCIpKSB7XG4gICAgICByZXF1ZXN0LmFjY2VwdFJlc3BvbnNlVHlwZShTdHJlYW1NZXNzYWdlLmNvbnRlbnRUeXBlKTtcbiAgICB9XG4gIH1cblxuICByZXF1ZXN0U3RhcnRlZChfcmVxdWVzdCkge1xuICAgIG1hcmtBc0J1c3kodGhpcy5lbGVtZW50KTtcbiAgfVxuXG4gIHJlcXVlc3RQcmV2ZW50ZWRIYW5kbGluZ1Jlc3BvbnNlKF9yZXF1ZXN0LCBfcmVzcG9uc2UpIHtcbiAgICB0aGlzLiNyZXNvbHZlVmlzaXRQcm9taXNlKCk7XG4gIH1cblxuICBhc3luYyByZXF1ZXN0U3VjY2VlZGVkV2l0aFJlc3BvbnNlKHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gICAgYXdhaXQgdGhpcy5sb2FkUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIHRoaXMuI3Jlc29sdmVWaXNpdFByb21pc2UoKTtcbiAgfVxuXG4gIGFzeW5jIHJlcXVlc3RGYWlsZWRXaXRoUmVzcG9uc2UocmVxdWVzdCwgcmVzcG9uc2UpIHtcbiAgICBhd2FpdCB0aGlzLmxvYWRSZXNwb25zZShyZXNwb25zZSk7XG4gICAgdGhpcy4jcmVzb2x2ZVZpc2l0UHJvbWlzZSgpO1xuICB9XG5cbiAgcmVxdWVzdEVycm9yZWQocmVxdWVzdCwgZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICB0aGlzLiNyZXNvbHZlVmlzaXRQcm9taXNlKCk7XG4gIH1cblxuICByZXF1ZXN0RmluaXNoZWQoX3JlcXVlc3QpIHtcbiAgICBjbGVhckJ1c3lTdGF0ZSh0aGlzLmVsZW1lbnQpO1xuICB9XG5cbiAgLy8gRm9ybSBzdWJtaXNzaW9uIGRlbGVnYXRlXG5cbiAgZm9ybVN1Ym1pc3Npb25TdGFydGVkKHsgZm9ybUVsZW1lbnQgfSkge1xuICAgIG1hcmtBc0J1c3koZm9ybUVsZW1lbnQsIHRoaXMuI2ZpbmRGcmFtZUVsZW1lbnQoZm9ybUVsZW1lbnQpKTtcbiAgfVxuXG4gIGZvcm1TdWJtaXNzaW9uU3VjY2VlZGVkV2l0aFJlc3BvbnNlKGZvcm1TdWJtaXNzaW9uLCByZXNwb25zZSkge1xuICAgIGNvbnN0IGZyYW1lID0gdGhpcy4jZmluZEZyYW1lRWxlbWVudChmb3JtU3VibWlzc2lvbi5mb3JtRWxlbWVudCwgZm9ybVN1Ym1pc3Npb24uc3VibWl0dGVyKTtcblxuICAgIGZyYW1lLmRlbGVnYXRlLnByb3Bvc2VWaXNpdElmTmF2aWdhdGVkV2l0aEFjdGlvbihmcmFtZSwgZ2V0VmlzaXRBY3Rpb24oZm9ybVN1Ym1pc3Npb24uc3VibWl0dGVyLCBmb3JtU3VibWlzc2lvbi5mb3JtRWxlbWVudCwgZnJhbWUpKTtcbiAgICBmcmFtZS5kZWxlZ2F0ZS5sb2FkUmVzcG9uc2UocmVzcG9uc2UpO1xuXG4gICAgaWYgKCFmb3JtU3VibWlzc2lvbi5pc1NhZmUpIHtcbiAgICAgIHNlc3Npb24uY2xlYXJDYWNoZSgpO1xuICAgIH1cbiAgfVxuXG4gIGZvcm1TdWJtaXNzaW9uRmFpbGVkV2l0aFJlc3BvbnNlKGZvcm1TdWJtaXNzaW9uLCBmZXRjaFJlc3BvbnNlKSB7XG4gICAgdGhpcy5lbGVtZW50LmRlbGVnYXRlLmxvYWRSZXNwb25zZShmZXRjaFJlc3BvbnNlKTtcbiAgICBzZXNzaW9uLmNsZWFyQ2FjaGUoKTtcbiAgfVxuXG4gIGZvcm1TdWJtaXNzaW9uRXJyb3JlZChmb3JtU3VibWlzc2lvbiwgZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgfVxuXG4gIGZvcm1TdWJtaXNzaW9uRmluaXNoZWQoeyBmb3JtRWxlbWVudCB9KSB7XG4gICAgY2xlYXJCdXN5U3RhdGUoZm9ybUVsZW1lbnQsIHRoaXMuI2ZpbmRGcmFtZUVsZW1lbnQoZm9ybUVsZW1lbnQpKTtcbiAgfVxuXG4gIC8vIFZpZXcgZGVsZWdhdGVcblxuICBhbGxvd3NJbW1lZGlhdGVSZW5kZXIoeyBlbGVtZW50OiBuZXdGcmFtZSB9LCBvcHRpb25zKSB7XG4gICAgY29uc3QgZXZlbnQgPSBkaXNwYXRjaChcInR1cmJvOmJlZm9yZS1mcmFtZS1yZW5kZXJcIiwge1xuICAgICAgdGFyZ2V0OiB0aGlzLmVsZW1lbnQsXG4gICAgICBkZXRhaWw6IHsgbmV3RnJhbWUsIC4uLm9wdGlvbnMgfSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICB9KTtcblxuICAgIGNvbnN0IHtcbiAgICAgIGRlZmF1bHRQcmV2ZW50ZWQsXG4gICAgICBkZXRhaWw6IHsgcmVuZGVyIH1cbiAgICB9ID0gZXZlbnQ7XG5cbiAgICBpZiAodGhpcy52aWV3LnJlbmRlcmVyICYmIHJlbmRlcikge1xuICAgICAgdGhpcy52aWV3LnJlbmRlcmVyLnJlbmRlckVsZW1lbnQgPSByZW5kZXI7XG4gICAgfVxuXG4gICAgcmV0dXJuICFkZWZhdWx0UHJldmVudGVkXG4gIH1cblxuICB2aWV3UmVuZGVyZWRTbmFwc2hvdChfc25hcHNob3QsIF9pc1ByZXZpZXcsIF9yZW5kZXJNZXRob2QpIHt9XG5cbiAgcHJlbG9hZE9uTG9hZExpbmtzRm9yVmlldyhlbGVtZW50KSB7XG4gICAgc2Vzc2lvbi5wcmVsb2FkT25Mb2FkTGlua3NGb3JWaWV3KGVsZW1lbnQpO1xuICB9XG5cbiAgdmlld0ludmFsaWRhdGVkKCkge31cblxuICAvLyBGcmFtZSByZW5kZXJlciBkZWxlZ2F0ZVxuXG4gIHdpbGxSZW5kZXJGcmFtZShjdXJyZW50RWxlbWVudCwgX25ld0VsZW1lbnQpIHtcbiAgICB0aGlzLnByZXZpb3VzRnJhbWVFbGVtZW50ID0gY3VycmVudEVsZW1lbnQuY2xvbmVOb2RlKHRydWUpO1xuICB9XG5cbiAgdmlzaXRDYWNoZWRTbmFwc2hvdCA9ICh7IGVsZW1lbnQgfSkgPT4ge1xuICAgIGNvbnN0IGZyYW1lID0gZWxlbWVudC5xdWVyeVNlbGVjdG9yKFwiI1wiICsgdGhpcy5lbGVtZW50LmlkKTtcblxuICAgIGlmIChmcmFtZSAmJiB0aGlzLnByZXZpb3VzRnJhbWVFbGVtZW50KSB7XG4gICAgICBmcmFtZS5yZXBsYWNlQ2hpbGRyZW4oLi4udGhpcy5wcmV2aW91c0ZyYW1lRWxlbWVudC5jaGlsZHJlbik7XG4gICAgfVxuXG4gICAgZGVsZXRlIHRoaXMucHJldmlvdXNGcmFtZUVsZW1lbnQ7XG4gIH1cblxuICAvLyBQcml2YXRlXG5cbiAgYXN5bmMgI2xvYWRGcmFtZVJlc3BvbnNlKGZldGNoUmVzcG9uc2UsIGRvY3VtZW50KSB7XG4gICAgY29uc3QgbmV3RnJhbWVFbGVtZW50ID0gYXdhaXQgdGhpcy5leHRyYWN0Rm9yZWlnbkZyYW1lRWxlbWVudChkb2N1bWVudC5ib2R5KTtcbiAgICBjb25zdCByZW5kZXJlckNsYXNzID0gdGhpcy4jc2hvdWxkTW9ycGhGcmFtZSA/IE1vcnBoaW5nRnJhbWVSZW5kZXJlciA6IEZyYW1lUmVuZGVyZXI7XG5cbiAgICBpZiAobmV3RnJhbWVFbGVtZW50KSB7XG4gICAgICBjb25zdCBzbmFwc2hvdCA9IG5ldyBTbmFwc2hvdChuZXdGcmFtZUVsZW1lbnQpO1xuICAgICAgY29uc3QgcmVuZGVyZXIgPSBuZXcgcmVuZGVyZXJDbGFzcyh0aGlzLCB0aGlzLnZpZXcuc25hcHNob3QsIHNuYXBzaG90LCBmYWxzZSwgZmFsc2UpO1xuICAgICAgaWYgKHRoaXMudmlldy5yZW5kZXJQcm9taXNlKSBhd2FpdCB0aGlzLnZpZXcucmVuZGVyUHJvbWlzZTtcbiAgICAgIHRoaXMuY2hhbmdlSGlzdG9yeSgpO1xuXG4gICAgICBhd2FpdCB0aGlzLnZpZXcucmVuZGVyKHJlbmRlcmVyKTtcbiAgICAgIHRoaXMuY29tcGxldGUgPSB0cnVlO1xuICAgICAgc2Vzc2lvbi5mcmFtZVJlbmRlcmVkKGZldGNoUmVzcG9uc2UsIHRoaXMuZWxlbWVudCk7XG4gICAgICBzZXNzaW9uLmZyYW1lTG9hZGVkKHRoaXMuZWxlbWVudCk7XG4gICAgICBhd2FpdCB0aGlzLmZldGNoUmVzcG9uc2VMb2FkZWQoZmV0Y2hSZXNwb25zZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLiN3aWxsSGFuZGxlRnJhbWVNaXNzaW5nRnJvbVJlc3BvbnNlKGZldGNoUmVzcG9uc2UpKSB7XG4gICAgICB0aGlzLiNoYW5kbGVGcmFtZU1pc3NpbmdGcm9tUmVzcG9uc2UoZmV0Y2hSZXNwb25zZSk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgI3Zpc2l0KHVybCkge1xuICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgRmV0Y2hSZXF1ZXN0KHRoaXMsIEZldGNoTWV0aG9kLmdldCwgdXJsLCBuZXcgVVJMU2VhcmNoUGFyYW1zKCksIHRoaXMuZWxlbWVudCk7XG5cbiAgICB0aGlzLiNjdXJyZW50RmV0Y2hSZXF1ZXN0Py5jYW5jZWwoKTtcbiAgICB0aGlzLiNjdXJyZW50RmV0Y2hSZXF1ZXN0ID0gcmVxdWVzdDtcblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgdGhpcy4jcmVzb2x2ZVZpc2l0UHJvbWlzZSA9ICgpID0+IHtcbiAgICAgICAgdGhpcy4jcmVzb2x2ZVZpc2l0UHJvbWlzZSA9ICgpID0+IHt9O1xuICAgICAgICB0aGlzLiNjdXJyZW50RmV0Y2hSZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfTtcbiAgICAgIHJlcXVlc3QucGVyZm9ybSgpO1xuICAgIH0pXG4gIH1cblxuICAjbmF2aWdhdGVGcmFtZShlbGVtZW50LCB1cmwsIHN1Ym1pdHRlcikge1xuICAgIGNvbnN0IGZyYW1lID0gdGhpcy4jZmluZEZyYW1lRWxlbWVudChlbGVtZW50LCBzdWJtaXR0ZXIpO1xuXG4gICAgZnJhbWUuZGVsZWdhdGUucHJvcG9zZVZpc2l0SWZOYXZpZ2F0ZWRXaXRoQWN0aW9uKGZyYW1lLCBnZXRWaXNpdEFjdGlvbihzdWJtaXR0ZXIsIGVsZW1lbnQsIGZyYW1lKSk7XG5cbiAgICB0aGlzLiN3aXRoQ3VycmVudE5hdmlnYXRpb25FbGVtZW50KGVsZW1lbnQsICgpID0+IHtcbiAgICAgIGZyYW1lLnNyYyA9IHVybDtcbiAgICB9KTtcbiAgfVxuXG4gIHByb3Bvc2VWaXNpdElmTmF2aWdhdGVkV2l0aEFjdGlvbihmcmFtZSwgYWN0aW9uID0gbnVsbCkge1xuICAgIHRoaXMuYWN0aW9uID0gYWN0aW9uO1xuXG4gICAgaWYgKHRoaXMuYWN0aW9uKSB7XG4gICAgICBjb25zdCBwYWdlU25hcHNob3QgPSBQYWdlU25hcHNob3QuZnJvbUVsZW1lbnQoZnJhbWUpLmNsb25lKCk7XG4gICAgICBjb25zdCB7IHZpc2l0Q2FjaGVkU25hcHNob3QgfSA9IGZyYW1lLmRlbGVnYXRlO1xuXG4gICAgICBmcmFtZS5kZWxlZ2F0ZS5mZXRjaFJlc3BvbnNlTG9hZGVkID0gYXN5bmMgKGZldGNoUmVzcG9uc2UpID0+IHtcbiAgICAgICAgaWYgKGZyYW1lLnNyYykge1xuICAgICAgICAgIGNvbnN0IHsgc3RhdHVzQ29kZSwgcmVkaXJlY3RlZCB9ID0gZmV0Y2hSZXNwb25zZTtcbiAgICAgICAgICBjb25zdCByZXNwb25zZUhUTUwgPSBhd2FpdCBmZXRjaFJlc3BvbnNlLnJlc3BvbnNlSFRNTDtcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHsgc3RhdHVzQ29kZSwgcmVkaXJlY3RlZCwgcmVzcG9uc2VIVE1MIH07XG4gICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHJlc3BvbnNlLFxuICAgICAgICAgICAgdmlzaXRDYWNoZWRTbmFwc2hvdCxcbiAgICAgICAgICAgIHdpbGxSZW5kZXI6IGZhbHNlLFxuICAgICAgICAgICAgdXBkYXRlSGlzdG9yeTogZmFsc2UsXG4gICAgICAgICAgICByZXN0b3JhdGlvbklkZW50aWZpZXI6IHRoaXMucmVzdG9yYXRpb25JZGVudGlmaWVyLFxuICAgICAgICAgICAgc25hcHNob3Q6IHBhZ2VTbmFwc2hvdFxuICAgICAgICAgIH07XG5cbiAgICAgICAgICBpZiAodGhpcy5hY3Rpb24pIG9wdGlvbnMuYWN0aW9uID0gdGhpcy5hY3Rpb247XG5cbiAgICAgICAgICBzZXNzaW9uLnZpc2l0KGZyYW1lLnNyYywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgY2hhbmdlSGlzdG9yeSgpIHtcbiAgICBpZiAodGhpcy5hY3Rpb24pIHtcbiAgICAgIGNvbnN0IG1ldGhvZCA9IGdldEhpc3RvcnlNZXRob2RGb3JBY3Rpb24odGhpcy5hY3Rpb24pO1xuICAgICAgc2Vzc2lvbi5oaXN0b3J5LnVwZGF0ZShtZXRob2QsIGV4cGFuZFVSTCh0aGlzLmVsZW1lbnQuc3JjIHx8IFwiXCIpLCB0aGlzLnJlc3RvcmF0aW9uSWRlbnRpZmllcik7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgI2hhbmRsZVVudmlzaXRhYmxlRnJhbWVSZXNwb25zZShmZXRjaFJlc3BvbnNlKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgYFRoZSByZXNwb25zZSAoJHtmZXRjaFJlc3BvbnNlLnN0YXR1c0NvZGV9KSBmcm9tIDx0dXJiby1mcmFtZSBpZD1cIiR7dGhpcy5lbGVtZW50LmlkfVwiPiBpcyBwZXJmb3JtaW5nIGEgZnVsbCBwYWdlIHZpc2l0IGR1ZSB0byB0dXJiby12aXNpdC1jb250cm9sLmBcbiAgICApO1xuXG4gICAgYXdhaXQgdGhpcy4jdmlzaXRSZXNwb25zZShmZXRjaFJlc3BvbnNlLnJlc3BvbnNlKTtcbiAgfVxuXG4gICN3aWxsSGFuZGxlRnJhbWVNaXNzaW5nRnJvbVJlc3BvbnNlKGZldGNoUmVzcG9uc2UpIHtcbiAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKFwiY29tcGxldGVcIiwgXCJcIik7XG5cbiAgICBjb25zdCByZXNwb25zZSA9IGZldGNoUmVzcG9uc2UucmVzcG9uc2U7XG4gICAgY29uc3QgdmlzaXQgPSBhc3luYyAodXJsLCBvcHRpb25zKSA9PiB7XG4gICAgICBpZiAodXJsIGluc3RhbmNlb2YgUmVzcG9uc2UpIHtcbiAgICAgICAgdGhpcy4jdmlzaXRSZXNwb25zZSh1cmwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2Vzc2lvbi52aXNpdCh1cmwsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBldmVudCA9IGRpc3BhdGNoKFwidHVyYm86ZnJhbWUtbWlzc2luZ1wiLCB7XG4gICAgICB0YXJnZXQ6IHRoaXMuZWxlbWVudCxcbiAgICAgIGRldGFpbDogeyByZXNwb25zZSwgdmlzaXQgfSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICB9KTtcblxuICAgIHJldHVybiAhZXZlbnQuZGVmYXVsdFByZXZlbnRlZFxuICB9XG5cbiAgI2hhbmRsZUZyYW1lTWlzc2luZ0Zyb21SZXNwb25zZShmZXRjaFJlc3BvbnNlKSB7XG4gICAgdGhpcy52aWV3Lm1pc3NpbmcoKTtcbiAgICB0aGlzLiN0aHJvd0ZyYW1lTWlzc2luZ0Vycm9yKGZldGNoUmVzcG9uc2UpO1xuICB9XG5cbiAgI3Rocm93RnJhbWVNaXNzaW5nRXJyb3IoZmV0Y2hSZXNwb25zZSkge1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBgVGhlIHJlc3BvbnNlICgke2ZldGNoUmVzcG9uc2Uuc3RhdHVzQ29kZX0pIGRpZCBub3QgY29udGFpbiB0aGUgZXhwZWN0ZWQgPHR1cmJvLWZyYW1lIGlkPVwiJHt0aGlzLmVsZW1lbnQuaWR9XCI+IGFuZCB3aWxsIGJlIGlnbm9yZWQuIFRvIHBlcmZvcm0gYSBmdWxsIHBhZ2UgdmlzaXQgaW5zdGVhZCwgc2V0IHR1cmJvLXZpc2l0LWNvbnRyb2wgdG8gcmVsb2FkLmA7XG4gICAgdGhyb3cgbmV3IFR1cmJvRnJhbWVNaXNzaW5nRXJyb3IobWVzc2FnZSlcbiAgfVxuXG4gIGFzeW5jICN2aXNpdFJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gICAgY29uc3Qgd3JhcHBlZCA9IG5ldyBGZXRjaFJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICBjb25zdCByZXNwb25zZUhUTUwgPSBhd2FpdCB3cmFwcGVkLnJlc3BvbnNlSFRNTDtcbiAgICBjb25zdCB7IGxvY2F0aW9uLCByZWRpcmVjdGVkLCBzdGF0dXNDb2RlIH0gPSB3cmFwcGVkO1xuXG4gICAgcmV0dXJuIHNlc3Npb24udmlzaXQobG9jYXRpb24sIHsgcmVzcG9uc2U6IHsgcmVkaXJlY3RlZCwgc3RhdHVzQ29kZSwgcmVzcG9uc2VIVE1MIH0gfSlcbiAgfVxuXG4gICNmaW5kRnJhbWVFbGVtZW50KGVsZW1lbnQsIHN1Ym1pdHRlcikge1xuICAgIGNvbnN0IGlkID0gZ2V0QXR0cmlidXRlKFwiZGF0YS10dXJiby1mcmFtZVwiLCBzdWJtaXR0ZXIsIGVsZW1lbnQpIHx8IHRoaXMuZWxlbWVudC5nZXRBdHRyaWJ1dGUoXCJ0YXJnZXRcIik7XG4gICAgcmV0dXJuIGdldEZyYW1lRWxlbWVudEJ5SWQoaWQpID8/IHRoaXMuZWxlbWVudFxuICB9XG5cbiAgYXN5bmMgZXh0cmFjdEZvcmVpZ25GcmFtZUVsZW1lbnQoY29udGFpbmVyKSB7XG4gICAgbGV0IGVsZW1lbnQ7XG4gICAgY29uc3QgaWQgPSBDU1MuZXNjYXBlKHRoaXMuaWQpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGVsZW1lbnQgPSBhY3RpdmF0ZUVsZW1lbnQoY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoYHR1cmJvLWZyYW1lIyR7aWR9YCksIHRoaXMuc291cmNlVVJMKTtcbiAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50XG4gICAgICB9XG5cbiAgICAgIGVsZW1lbnQgPSBhY3RpdmF0ZUVsZW1lbnQoY29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoYHR1cmJvLWZyYW1lW3NyY11bcmVjdXJzZX49JHtpZH1dYCksIHRoaXMuc291cmNlVVJMKTtcbiAgICAgIGlmIChlbGVtZW50KSB7XG4gICAgICAgIGF3YWl0IGVsZW1lbnQubG9hZGVkO1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5leHRyYWN0Rm9yZWlnbkZyYW1lRWxlbWVudChlbGVtZW50KVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgIHJldHVybiBuZXcgRnJhbWVFbGVtZW50KClcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgI2Zvcm1BY3Rpb25Jc1Zpc2l0YWJsZShmb3JtLCBzdWJtaXR0ZXIpIHtcbiAgICBjb25zdCBhY3Rpb24gPSBnZXRBY3Rpb24kMShmb3JtLCBzdWJtaXR0ZXIpO1xuXG4gICAgcmV0dXJuIGxvY2F0aW9uSXNWaXNpdGFibGUoZXhwYW5kVVJMKGFjdGlvbiksIHRoaXMucm9vdExvY2F0aW9uKVxuICB9XG5cbiAgI3Nob3VsZEludGVyY2VwdE5hdmlnYXRpb24oZWxlbWVudCwgc3VibWl0dGVyKSB7XG4gICAgY29uc3QgaWQgPSBnZXRBdHRyaWJ1dGUoXCJkYXRhLXR1cmJvLWZyYW1lXCIsIHN1Ym1pdHRlciwgZWxlbWVudCkgfHwgdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZShcInRhcmdldFwiKTtcblxuICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgSFRNTEZvcm1FbGVtZW50ICYmICF0aGlzLiNmb3JtQWN0aW9uSXNWaXNpdGFibGUoZWxlbWVudCwgc3VibWl0dGVyKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmVuYWJsZWQgfHwgaWQgPT0gXCJfdG9wXCIpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGlmIChpZCkge1xuICAgICAgY29uc3QgZnJhbWVFbGVtZW50ID0gZ2V0RnJhbWVFbGVtZW50QnlJZChpZCk7XG4gICAgICBpZiAoZnJhbWVFbGVtZW50KSB7XG4gICAgICAgIHJldHVybiAhZnJhbWVFbGVtZW50LmRpc2FibGVkXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFzZXNzaW9uLmVsZW1lbnRJc05hdmlnYXRhYmxlKGVsZW1lbnQpKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAoc3VibWl0dGVyICYmICFzZXNzaW9uLmVsZW1lbnRJc05hdmlnYXRhYmxlKHN1Ym1pdHRlcikpIHtcbiAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICAvLyBDb21wdXRlZCBwcm9wZXJ0aWVzXG5cbiAgZ2V0IGlkKCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnQuaWRcbiAgfVxuXG4gIGdldCBlbmFibGVkKCkge1xuICAgIHJldHVybiAhdGhpcy5lbGVtZW50LmRpc2FibGVkXG4gIH1cblxuICBnZXQgc291cmNlVVJMKCkge1xuICAgIGlmICh0aGlzLmVsZW1lbnQuc3JjKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbGVtZW50LnNyY1xuICAgIH1cbiAgfVxuXG4gIHNldCBzb3VyY2VVUkwoc291cmNlVVJMKSB7XG4gICAgdGhpcy4jaWdub3JpbmdDaGFuZ2VzVG9BdHRyaWJ1dGUoXCJzcmNcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5lbGVtZW50LnNyYyA9IHNvdXJjZVVSTCA/PyBudWxsO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0IGxvYWRpbmdTdHlsZSgpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50LmxvYWRpbmdcbiAgfVxuXG4gIGdldCBpc0xvYWRpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9ybVN1Ym1pc3Npb24gIT09IHVuZGVmaW5lZCB8fCB0aGlzLiNyZXNvbHZlVmlzaXRQcm9taXNlKCkgIT09IHVuZGVmaW5lZFxuICB9XG5cbiAgZ2V0IGNvbXBsZXRlKCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnQuaGFzQXR0cmlidXRlKFwiY29tcGxldGVcIilcbiAgfVxuXG4gIHNldCBjb21wbGV0ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy5lbGVtZW50LnNldEF0dHJpYnV0ZShcImNvbXBsZXRlXCIsIFwiXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlQXR0cmlidXRlKFwiY29tcGxldGVcIik7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGlzQWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnQuaXNBY3RpdmUgJiYgdGhpcy4jY29ubmVjdGVkXG4gIH1cblxuICBnZXQgcm9vdExvY2F0aW9uKCkge1xuICAgIGNvbnN0IG1ldGEgPSB0aGlzLmVsZW1lbnQub3duZXJEb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBtZXRhW25hbWU9XCJ0dXJiby1yb290XCJdYCk7XG4gICAgY29uc3Qgcm9vdCA9IG1ldGE/LmNvbnRlbnQgPz8gXCIvXCI7XG4gICAgcmV0dXJuIGV4cGFuZFVSTChyb290KVxuICB9XG5cbiAgI2lzSWdub3JpbmdDaGFuZ2VzVG8oYXR0cmlidXRlTmFtZSkge1xuICAgIHJldHVybiB0aGlzLiNpZ25vcmVkQXR0cmlidXRlcy5oYXMoYXR0cmlidXRlTmFtZSlcbiAgfVxuXG4gICNpZ25vcmluZ0NoYW5nZXNUb0F0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCBjYWxsYmFjaykge1xuICAgIHRoaXMuI2lnbm9yZWRBdHRyaWJ1dGVzLmFkZChhdHRyaWJ1dGVOYW1lKTtcbiAgICBjYWxsYmFjaygpO1xuICAgIHRoaXMuI2lnbm9yZWRBdHRyaWJ1dGVzLmRlbGV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgfVxuXG4gICN3aXRoQ3VycmVudE5hdmlnYXRpb25FbGVtZW50KGVsZW1lbnQsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5jdXJyZW50TmF2aWdhdGlvbkVsZW1lbnQgPSBlbGVtZW50O1xuICAgIGNhbGxiYWNrKCk7XG4gICAgZGVsZXRlIHRoaXMuY3VycmVudE5hdmlnYXRpb25FbGVtZW50O1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEZyYW1lRWxlbWVudEJ5SWQoaWQpIHtcbiAgaWYgKGlkICE9IG51bGwpIHtcbiAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgRnJhbWVFbGVtZW50KSB7XG4gICAgICByZXR1cm4gZWxlbWVudFxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhY3RpdmF0ZUVsZW1lbnQoZWxlbWVudCwgY3VycmVudFVSTCkge1xuICBpZiAoZWxlbWVudCkge1xuICAgIGNvbnN0IHNyYyA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKFwic3JjXCIpO1xuICAgIGlmIChzcmMgIT0gbnVsbCAmJiBjdXJyZW50VVJMICE9IG51bGwgJiYgdXJsc0FyZUVxdWFsKHNyYywgY3VycmVudFVSTCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTWF0Y2hpbmcgPHR1cmJvLWZyYW1lIGlkPVwiJHtlbGVtZW50LmlkfVwiPiBlbGVtZW50IGhhcyBhIHNvdXJjZSBVUkwgd2hpY2ggcmVmZXJlbmNlcyBpdHNlbGZgKVxuICAgIH1cbiAgICBpZiAoZWxlbWVudC5vd25lckRvY3VtZW50ICE9PSBkb2N1bWVudCkge1xuICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmltcG9ydE5vZGUoZWxlbWVudCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBGcmFtZUVsZW1lbnQpIHtcbiAgICAgIGVsZW1lbnQuY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgICAgIGVsZW1lbnQuZGlzY29ubmVjdGVkQ2FsbGJhY2soKTtcbiAgICAgIHJldHVybiBlbGVtZW50XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IFN0cmVhbUFjdGlvbnMgPSB7XG4gIGFmdGVyKCkge1xuICAgIHRoaXMudGFyZ2V0RWxlbWVudHMuZm9yRWFjaCgoZSkgPT4gZS5wYXJlbnRFbGVtZW50Py5pbnNlcnRCZWZvcmUodGhpcy50ZW1wbGF0ZUNvbnRlbnQsIGUubmV4dFNpYmxpbmcpKTtcbiAgfSxcblxuICBhcHBlbmQoKSB7XG4gICAgdGhpcy5yZW1vdmVEdXBsaWNhdGVUYXJnZXRDaGlsZHJlbigpO1xuICAgIHRoaXMudGFyZ2V0RWxlbWVudHMuZm9yRWFjaCgoZSkgPT4gZS5hcHBlbmQodGhpcy50ZW1wbGF0ZUNvbnRlbnQpKTtcbiAgfSxcblxuICBiZWZvcmUoKSB7XG4gICAgdGhpcy50YXJnZXRFbGVtZW50cy5mb3JFYWNoKChlKSA9PiBlLnBhcmVudEVsZW1lbnQ/Lmluc2VydEJlZm9yZSh0aGlzLnRlbXBsYXRlQ29udGVudCwgZSkpO1xuICB9LFxuXG4gIHByZXBlbmQoKSB7XG4gICAgdGhpcy5yZW1vdmVEdXBsaWNhdGVUYXJnZXRDaGlsZHJlbigpO1xuICAgIHRoaXMudGFyZ2V0RWxlbWVudHMuZm9yRWFjaCgoZSkgPT4gZS5wcmVwZW5kKHRoaXMudGVtcGxhdGVDb250ZW50KSk7XG4gIH0sXG5cbiAgcmVtb3ZlKCkge1xuICAgIHRoaXMudGFyZ2V0RWxlbWVudHMuZm9yRWFjaCgoZSkgPT4gZS5yZW1vdmUoKSk7XG4gIH0sXG5cbiAgcmVwbGFjZSgpIHtcbiAgICBjb25zdCBtZXRob2QgPSB0aGlzLmdldEF0dHJpYnV0ZShcIm1ldGhvZFwiKTtcblxuICAgIHRoaXMudGFyZ2V0RWxlbWVudHMuZm9yRWFjaCgodGFyZ2V0RWxlbWVudCkgPT4ge1xuICAgICAgaWYgKG1ldGhvZCA9PT0gXCJtb3JwaFwiKSB7XG4gICAgICAgIG1vcnBoRWxlbWVudHModGFyZ2V0RWxlbWVudCwgdGhpcy50ZW1wbGF0ZUNvbnRlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0RWxlbWVudC5yZXBsYWNlV2l0aCh0aGlzLnRlbXBsYXRlQ29udGVudCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgdXBkYXRlKCkge1xuICAgIGNvbnN0IG1ldGhvZCA9IHRoaXMuZ2V0QXR0cmlidXRlKFwibWV0aG9kXCIpO1xuXG4gICAgdGhpcy50YXJnZXRFbGVtZW50cy5mb3JFYWNoKCh0YXJnZXRFbGVtZW50KSA9PiB7XG4gICAgICBpZiAobWV0aG9kID09PSBcIm1vcnBoXCIpIHtcbiAgICAgICAgbW9ycGhDaGlsZHJlbih0YXJnZXRFbGVtZW50LCB0aGlzLnRlbXBsYXRlQ29udGVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXRFbGVtZW50LmlubmVySFRNTCA9IFwiXCI7XG4gICAgICAgIHRhcmdldEVsZW1lbnQuYXBwZW5kKHRoaXMudGVtcGxhdGVDb250ZW50KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICByZWZyZXNoKCkge1xuICAgIHNlc3Npb24ucmVmcmVzaCh0aGlzLmJhc2VVUkksIHRoaXMucmVxdWVzdElkKTtcbiAgfVxufTtcblxuLy8gPHR1cmJvLXN0cmVhbSBhY3Rpb249cmVwbGFjZSB0YXJnZXQ9aWQ+PHRlbXBsYXRlPi4uLlxuXG4vKipcbiAqIFJlbmRlcnMgdXBkYXRlcyB0byB0aGUgcGFnZSBmcm9tIGEgc3RyZWFtIG9mIG1lc3NhZ2VzLlxuICpcbiAqIFVzaW5nIHRoZSBgYWN0aW9uYCBhdHRyaWJ1dGUsIHRoaXMgY2FuIGJlIGNvbmZpZ3VyZWQgb25lIG9mIGVpZ2h0IHdheXM6XG4gKlxuICogLSBgYWZ0ZXJgIC0gaW5zZXJ0cyB0aGUgcmVzdWx0IGFmdGVyIHRoZSB0YXJnZXRcbiAqIC0gYGFwcGVuZGAgLSBhcHBlbmRzIHRoZSByZXN1bHQgdG8gdGhlIHRhcmdldFxuICogLSBgYmVmb3JlYCAtIGluc2VydHMgdGhlIHJlc3VsdCBiZWZvcmUgdGhlIHRhcmdldFxuICogLSBgcHJlcGVuZGAgLSBwcmVwZW5kcyB0aGUgcmVzdWx0IHRvIHRoZSB0YXJnZXRcbiAqIC0gYHJlZnJlc2hgIC0gaW5pdGlhdGVzIGEgcGFnZSByZWZyZXNoXG4gKiAtIGByZW1vdmVgIC0gcmVtb3ZlcyB0aGUgdGFyZ2V0XG4gKiAtIGByZXBsYWNlYCAtIHJlcGxhY2VzIHRoZSBvdXRlciBIVE1MIG9mIHRoZSB0YXJnZXRcbiAqIC0gYHVwZGF0ZWAgLSByZXBsYWNlcyB0aGUgaW5uZXIgSFRNTCBvZiB0aGUgdGFyZ2V0XG4gKlxuICogQGN1c3RvbUVsZW1lbnQgdHVyYm8tc3RyZWFtXG4gKiBAZXhhbXBsZVxuICogICA8dHVyYm8tc3RyZWFtIGFjdGlvbj1cImFwcGVuZFwiIHRhcmdldD1cImRvbV9pZFwiPlxuICogICAgIDx0ZW1wbGF0ZT5cbiAqICAgICAgIENvbnRlbnQgdG8gYXBwZW5kIHRvIHRhcmdldCBkZXNpZ25hdGVkIHdpdGggdGhlIGRvbV9pZC5cbiAqICAgICA8L3RlbXBsYXRlPlxuICogICA8L3R1cmJvLXN0cmVhbT5cbiAqL1xuY2xhc3MgU3RyZWFtRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgc3RhdGljIGFzeW5jIHJlbmRlckVsZW1lbnQobmV3RWxlbWVudCkge1xuICAgIGF3YWl0IG5ld0VsZW1lbnQucGVyZm9ybUFjdGlvbigpO1xuICB9XG5cbiAgYXN5bmMgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHRoaXMucmVuZGVyKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICB9XG4gIH1cblxuICBhc3luYyByZW5kZXIoKSB7XG4gICAgcmV0dXJuICh0aGlzLnJlbmRlclByb21pc2UgPz89IChhc3luYyAoKSA9PiB7XG4gICAgICBjb25zdCBldmVudCA9IHRoaXMuYmVmb3JlUmVuZGVyRXZlbnQ7XG5cbiAgICAgIGlmICh0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpKSB7XG4gICAgICAgIGF3YWl0IG5leHRSZXBhaW50KCk7XG4gICAgICAgIGF3YWl0IGV2ZW50LmRldGFpbC5yZW5kZXIodGhpcyk7XG4gICAgICB9XG4gICAgfSkoKSlcbiAgfVxuXG4gIGRpc2Nvbm5lY3QoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgICB9IGNhdGNoIHt9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBkdXBsaWNhdGUgY2hpbGRyZW4gKGJ5IElEKVxuICAgKi9cbiAgcmVtb3ZlRHVwbGljYXRlVGFyZ2V0Q2hpbGRyZW4oKSB7XG4gICAgdGhpcy5kdXBsaWNhdGVDaGlsZHJlbi5mb3JFYWNoKChjKSA9PiBjLnJlbW92ZSgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBsaXN0IG9mIGR1cGxpY2F0ZSBjaGlsZHJlbiAoaS5lLiB0aG9zZSB3aXRoIHRoZSBzYW1lIElEKVxuICAgKi9cbiAgZ2V0IGR1cGxpY2F0ZUNoaWxkcmVuKCkge1xuICAgIGNvbnN0IGV4aXN0aW5nQ2hpbGRyZW4gPSB0aGlzLnRhcmdldEVsZW1lbnRzLmZsYXRNYXAoKGUpID0+IFsuLi5lLmNoaWxkcmVuXSkuZmlsdGVyKChjKSA9PiAhIWMuZ2V0QXR0cmlidXRlKFwiaWRcIikpO1xuICAgIGNvbnN0IG5ld0NoaWxkcmVuSWRzID0gWy4uLih0aGlzLnRlbXBsYXRlQ29udGVudD8uY2hpbGRyZW4gfHwgW10pXS5maWx0ZXIoKGMpID0+ICEhYy5nZXRBdHRyaWJ1dGUoXCJpZFwiKSkubWFwKChjKSA9PiBjLmdldEF0dHJpYnV0ZShcImlkXCIpKTtcblxuICAgIHJldHVybiBleGlzdGluZ0NoaWxkcmVuLmZpbHRlcigoYykgPT4gbmV3Q2hpbGRyZW5JZHMuaW5jbHVkZXMoYy5nZXRBdHRyaWJ1dGUoXCJpZFwiKSkpXG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgYWN0aW9uIGZ1bmN0aW9uIHRvIGJlIHBlcmZvcm1lZC5cbiAgICovXG4gIGdldCBwZXJmb3JtQWN0aW9uKCkge1xuICAgIGlmICh0aGlzLmFjdGlvbikge1xuICAgICAgY29uc3QgYWN0aW9uRnVuY3Rpb24gPSBTdHJlYW1BY3Rpb25zW3RoaXMuYWN0aW9uXTtcbiAgICAgIGlmIChhY3Rpb25GdW5jdGlvbikge1xuICAgICAgICByZXR1cm4gYWN0aW9uRnVuY3Rpb25cbiAgICAgIH1cbiAgICAgIHRoaXMuI3JhaXNlKFwidW5rbm93biBhY3Rpb25cIik7XG4gICAgfVxuICAgIHRoaXMuI3JhaXNlKFwiYWN0aW9uIGF0dHJpYnV0ZSBpcyBtaXNzaW5nXCIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHRhcmdldCBlbGVtZW50cyB3aGljaCB0aGUgdGVtcGxhdGUgd2lsbCBiZSByZW5kZXJlZCB0by5cbiAgICovXG4gIGdldCB0YXJnZXRFbGVtZW50cygpIHtcbiAgICBpZiAodGhpcy50YXJnZXQpIHtcbiAgICAgIHJldHVybiB0aGlzLnRhcmdldEVsZW1lbnRzQnlJZFxuICAgIH0gZWxzZSBpZiAodGhpcy50YXJnZXRzKSB7XG4gICAgICByZXR1cm4gdGhpcy50YXJnZXRFbGVtZW50c0J5UXVlcnlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jcmFpc2UoXCJ0YXJnZXQgb3IgdGFyZ2V0cyBhdHRyaWJ1dGUgaXMgbWlzc2luZ1wiKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgY29udGVudHMgb2YgdGhlIG1haW4gYDx0ZW1wbGF0ZT5gLlxuICAgKi9cbiAgZ2V0IHRlbXBsYXRlQ29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy50ZW1wbGF0ZUVsZW1lbnQuY29udGVudC5jbG9uZU5vZGUodHJ1ZSlcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBtYWluIGA8dGVtcGxhdGU+YCB1c2VkIGZvciByZW5kZXJpbmdcbiAgICovXG4gIGdldCB0ZW1wbGF0ZUVsZW1lbnQoKSB7XG4gICAgaWYgKHRoaXMuZmlyc3RFbGVtZW50Q2hpbGQgPT09IG51bGwpIHtcbiAgICAgIGNvbnN0IHRlbXBsYXRlID0gdGhpcy5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0ZW1wbGF0ZVwiKTtcbiAgICAgIHRoaXMuYXBwZW5kQ2hpbGQodGVtcGxhdGUpO1xuICAgICAgcmV0dXJuIHRlbXBsYXRlXG4gICAgfSBlbHNlIGlmICh0aGlzLmZpcnN0RWxlbWVudENoaWxkIGluc3RhbmNlb2YgSFRNTFRlbXBsYXRlRWxlbWVudCkge1xuICAgICAgcmV0dXJuIHRoaXMuZmlyc3RFbGVtZW50Q2hpbGRcbiAgICB9XG4gICAgdGhpcy4jcmFpc2UoXCJmaXJzdCBjaGlsZCBlbGVtZW50IG11c3QgYmUgYSA8dGVtcGxhdGU+IGVsZW1lbnRcIik7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgY3VycmVudCBhY3Rpb24uXG4gICAqL1xuICBnZXQgYWN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZShcImFjdGlvblwiKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgdGFyZ2V0IChhbiBlbGVtZW50IElEKSB0byB3aGljaCB0aGUgcmVzdWx0IHdpbGxcbiAgICogYmUgcmVuZGVyZWQuXG4gICAqL1xuICBnZXQgdGFyZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZShcInRhcmdldFwiKVxuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgXCJ0YXJnZXRzXCIgc2VsZWN0b3IgKGEgQ1NTIHNlbGVjdG9yKVxuICAgKi9cbiAgZ2V0IHRhcmdldHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKFwidGFyZ2V0c1wiKVxuICB9XG5cbiAgLyoqXG4gICAqIFJlYWRzIHRoZSByZXF1ZXN0LWlkIGF0dHJpYnV0ZVxuICAgKi9cbiAgZ2V0IHJlcXVlc3RJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoXCJyZXF1ZXN0LWlkXCIpXG4gIH1cblxuICAjcmFpc2UobWVzc2FnZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHt0aGlzLmRlc2NyaXB0aW9ufTogJHttZXNzYWdlfWApXG4gIH1cblxuICBnZXQgZGVzY3JpcHRpb24oKSB7XG4gICAgcmV0dXJuICh0aGlzLm91dGVySFRNTC5tYXRjaCgvPFtePl0rPi8pID8/IFtdKVswXSA/PyBcIjx0dXJiby1zdHJlYW0+XCJcbiAgfVxuXG4gIGdldCBiZWZvcmVSZW5kZXJFdmVudCgpIHtcbiAgICByZXR1cm4gbmV3IEN1c3RvbUV2ZW50KFwidHVyYm86YmVmb3JlLXN0cmVhbS1yZW5kZXJcIiwge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICBkZXRhaWw6IHsgbmV3U3RyZWFtOiB0aGlzLCByZW5kZXI6IFN0cmVhbUVsZW1lbnQucmVuZGVyRWxlbWVudCB9XG4gICAgfSlcbiAgfVxuXG4gIGdldCB0YXJnZXRFbGVtZW50c0J5SWQoKSB7XG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMub3duZXJEb2N1bWVudD8uZ2V0RWxlbWVudEJ5SWQodGhpcy50YXJnZXQpO1xuXG4gICAgaWYgKGVsZW1lbnQgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBbZWxlbWVudF1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtdXG4gICAgfVxuICB9XG5cbiAgZ2V0IHRhcmdldEVsZW1lbnRzQnlRdWVyeSgpIHtcbiAgICBjb25zdCBlbGVtZW50cyA9IHRoaXMub3duZXJEb2N1bWVudD8ucXVlcnlTZWxlY3RvckFsbCh0aGlzLnRhcmdldHMpO1xuXG4gICAgaWYgKGVsZW1lbnRzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGVsZW1lbnRzKVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW11cbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgU3RyZWFtU291cmNlRWxlbWVudCBleHRlbmRzIEhUTUxFbGVtZW50IHtcbiAgc3RyZWFtU291cmNlID0gbnVsbFxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHRoaXMuc3RyZWFtU291cmNlID0gdGhpcy5zcmMubWF0Y2goL153c3sxLDJ9Oi8pID8gbmV3IFdlYlNvY2tldCh0aGlzLnNyYykgOiBuZXcgRXZlbnRTb3VyY2UodGhpcy5zcmMpO1xuXG4gICAgY29ubmVjdFN0cmVhbVNvdXJjZSh0aGlzLnN0cmVhbVNvdXJjZSk7XG4gIH1cblxuICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBpZiAodGhpcy5zdHJlYW1Tb3VyY2UpIHtcbiAgICAgIHRoaXMuc3RyZWFtU291cmNlLmNsb3NlKCk7XG5cbiAgICAgIGRpc2Nvbm5lY3RTdHJlYW1Tb3VyY2UodGhpcy5zdHJlYW1Tb3VyY2UpO1xuICAgIH1cbiAgfVxuXG4gIGdldCBzcmMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKFwic3JjXCIpIHx8IFwiXCJcbiAgfVxufVxuXG5GcmFtZUVsZW1lbnQuZGVsZWdhdGVDb25zdHJ1Y3RvciA9IEZyYW1lQ29udHJvbGxlcjtcblxuaWYgKGN1c3RvbUVsZW1lbnRzLmdldChcInR1cmJvLWZyYW1lXCIpID09PSB1bmRlZmluZWQpIHtcbiAgY3VzdG9tRWxlbWVudHMuZGVmaW5lKFwidHVyYm8tZnJhbWVcIiwgRnJhbWVFbGVtZW50KTtcbn1cblxuaWYgKGN1c3RvbUVsZW1lbnRzLmdldChcInR1cmJvLXN0cmVhbVwiKSA9PT0gdW5kZWZpbmVkKSB7XG4gIGN1c3RvbUVsZW1lbnRzLmRlZmluZShcInR1cmJvLXN0cmVhbVwiLCBTdHJlYW1FbGVtZW50KTtcbn1cblxuaWYgKGN1c3RvbUVsZW1lbnRzLmdldChcInR1cmJvLXN0cmVhbS1zb3VyY2VcIikgPT09IHVuZGVmaW5lZCkge1xuICBjdXN0b21FbGVtZW50cy5kZWZpbmUoXCJ0dXJiby1zdHJlYW0tc291cmNlXCIsIFN0cmVhbVNvdXJjZUVsZW1lbnQpO1xufVxuXG4oKCkgPT4ge1xuICBsZXQgZWxlbWVudCA9IGRvY3VtZW50LmN1cnJlbnRTY3JpcHQ7XG4gIGlmICghZWxlbWVudCkgcmV0dXJuXG4gIGlmIChlbGVtZW50Lmhhc0F0dHJpYnV0ZShcImRhdGEtdHVyYm8tc3VwcHJlc3Mtd2FybmluZ1wiKSkgcmV0dXJuXG5cbiAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgd2hpbGUgKGVsZW1lbnQpIHtcbiAgICBpZiAoZWxlbWVudCA9PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICByZXR1cm4gY29uc29sZS53YXJuKFxuICAgICAgICB1bmluZGVudGBcbiAgICAgICAgWW91IGFyZSBsb2FkaW5nIFR1cmJvIGZyb20gYSA8c2NyaXB0PiBlbGVtZW50IGluc2lkZSB0aGUgPGJvZHk+IGVsZW1lbnQuIFRoaXMgaXMgcHJvYmFibHkgbm90IHdoYXQgeW91IG1lYW50IHRvIGRvIVxuXG4gICAgICAgIExvYWQgeW91ciBhcHBsaWNhdGlvbuKAmXMgSmF2YVNjcmlwdCBidW5kbGUgaW5zaWRlIHRoZSA8aGVhZD4gZWxlbWVudCBpbnN0ZWFkLiA8c2NyaXB0PiBlbGVtZW50cyBpbiA8Ym9keT4gYXJlIGV2YWx1YXRlZCB3aXRoIGVhY2ggcGFnZSBjaGFuZ2UuXG5cbiAgICAgICAgRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZTogaHR0cHM6Ly90dXJiby5ob3R3aXJlZC5kZXYvaGFuZGJvb2svYnVpbGRpbmcjd29ya2luZy13aXRoLXNjcmlwdC1lbGVtZW50c1xuXG4gICAgICAgIOKAlOKAlFxuICAgICAgICBTdXBwcmVzcyB0aGlzIHdhcm5pbmcgYnkgYWRkaW5nIGEgXCJkYXRhLXR1cmJvLXN1cHByZXNzLXdhcm5pbmdcIiBhdHRyaWJ1dGUgdG86ICVzXG4gICAgICBgLFxuICAgICAgICBlbGVtZW50Lm91dGVySFRNTFxuICAgICAgKVxuICAgIH1cblxuICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gIH1cbn0pKCk7XG5cbndpbmRvdy5UdXJibyA9IHsgLi4uVHVyYm8sIFN0cmVhbUFjdGlvbnMgfTtcbnN0YXJ0KCk7XG5cbmV4cG9ydCB7IEZldGNoRW5jdHlwZSwgRmV0Y2hNZXRob2QsIEZldGNoUmVxdWVzdCwgRmV0Y2hSZXNwb25zZSwgRnJhbWVFbGVtZW50LCBGcmFtZUxvYWRpbmdTdHlsZSwgRnJhbWVSZW5kZXJlciwgUGFnZVJlbmRlcmVyLCBQYWdlU25hcHNob3QsIFN0cmVhbUFjdGlvbnMsIFN0cmVhbUVsZW1lbnQsIFN0cmVhbVNvdXJjZUVsZW1lbnQsIGNhY2hlLCBjbGVhckNhY2hlLCBjb25maWcsIGNvbm5lY3RTdHJlYW1Tb3VyY2UsIGRpc2Nvbm5lY3RTdHJlYW1Tb3VyY2UsIGZldGNoV2l0aFR1cmJvSGVhZGVycyBhcyBmZXRjaCwgZmV0Y2hFbmN0eXBlRnJvbVN0cmluZywgZmV0Y2hNZXRob2RGcm9tU3RyaW5nLCBpc1NhZmUsIG5hdmlnYXRvciQxIGFzIG5hdmlnYXRvciwgcmVnaXN0ZXJBZGFwdGVyLCByZW5kZXJTdHJlYW1NZXNzYWdlLCBzZXNzaW9uLCBzZXRDb25maXJtTWV0aG9kLCBzZXRGb3JtTW9kZSwgc2V0UHJvZ3Jlc3NCYXJEZWxheSwgc3RhcnQsIHZpc2l0IH07XG4iLCIvKiEgUGlja3IgMS45LjAgTUlUIHwgaHR0cHM6Ly9naXRodWIuY29tL1NpbW9ud2VwL3BpY2tyICovXG4hZnVuY3Rpb24odCxlKXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZT9tb2R1bGUuZXhwb3J0cz1lKCk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXSxlKTpcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cz9leHBvcnRzLlBpY2tyPWUoKTp0LlBpY2tyPWUoKX0oc2VsZiwoKCk9PigoKT0+e1widXNlIHN0cmljdFwiO3ZhciB0PXtkOihlLG8pPT57Zm9yKHZhciBuIGluIG8pdC5vKG8sbikmJiF0Lm8oZSxuKSYmT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsbix7ZW51bWVyYWJsZTohMCxnZXQ6b1tuXX0pfSxvOih0LGUpPT5PYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxlKSxyOnQ9PntcInVuZGVmaW5lZFwiIT10eXBlb2YgU3ltYm9sJiZTeW1ib2wudG9TdHJpbmdUYWcmJk9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFN5bWJvbC50b1N0cmluZ1RhZyx7dmFsdWU6XCJNb2R1bGVcIn0pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pfX0sZT17fTt0LmQoZSx7ZGVmYXVsdDooKT0+RX0pO3ZhciBvPXt9O2Z1bmN0aW9uIG4odCxlLG8sbixpPXt9KXtlIGluc3RhbmNlb2YgSFRNTENvbGxlY3Rpb258fGUgaW5zdGFuY2VvZiBOb2RlTGlzdD9lPUFycmF5LmZyb20oZSk6QXJyYXkuaXNBcnJheShlKXx8KGU9W2VdKSxBcnJheS5pc0FycmF5KG8pfHwobz1bb10pO2Zvcihjb25zdCBzIG9mIGUpZm9yKGNvbnN0IGUgb2YgbylzW3RdKGUsbix7Y2FwdHVyZTohMSwuLi5pfSk7cmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKX10LnIobyksdC5kKG8se2FkanVzdGFibGVJbnB1dE51bWJlcnM6KCk9PnAsY3JlYXRlRWxlbWVudEZyb21TdHJpbmc6KCk9PnIsY3JlYXRlRnJvbVRlbXBsYXRlOigpPT5hLGV2ZW50UGF0aDooKT0+bCxvZmY6KCk9PnMsb246KCk9PmkscmVzb2x2ZUVsZW1lbnQ6KCk9PmN9KTtjb25zdCBpPW4uYmluZChudWxsLFwiYWRkRXZlbnRMaXN0ZW5lclwiKSxzPW4uYmluZChudWxsLFwicmVtb3ZlRXZlbnRMaXN0ZW5lclwiKTtmdW5jdGlvbiByKHQpe2NvbnN0IGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtyZXR1cm4gZS5pbm5lckhUTUw9dC50cmltKCksZS5maXJzdEVsZW1lbnRDaGlsZH1mdW5jdGlvbiBhKHQpe2NvbnN0IGU9KHQsZSk9Pntjb25zdCBvPXQuZ2V0QXR0cmlidXRlKGUpO3JldHVybiB0LnJlbW92ZUF0dHJpYnV0ZShlKSxvfSxvPSh0LG49e30pPT57Y29uc3QgaT1lKHQsXCI6b2JqXCIpLHM9ZSh0LFwiOnJlZlwiKSxyPWk/bltpXT17fTpuO3MmJihuW3NdPXQpO2Zvcihjb25zdCBuIG9mIEFycmF5LmZyb20odC5jaGlsZHJlbikpe2NvbnN0IHQ9ZShuLFwiOmFyclwiKSxpPW8obix0P3t9OnIpO3QmJihyW3RdfHwoclt0XT1bXSkpLnB1c2goT2JqZWN0LmtleXMoaSkubGVuZ3RoP2k6bil9cmV0dXJuIG59O3JldHVybiBvKHIodCkpfWZ1bmN0aW9uIGwodCl7bGV0IGU9dC5wYXRofHx0LmNvbXBvc2VkUGF0aCYmdC5jb21wb3NlZFBhdGgoKTtpZihlKXJldHVybiBlO2xldCBvPXQudGFyZ2V0LnBhcmVudEVsZW1lbnQ7Zm9yKGU9W3QudGFyZ2V0LG9dO289by5wYXJlbnRFbGVtZW50OyllLnB1c2gobyk7cmV0dXJuIGUucHVzaChkb2N1bWVudCx3aW5kb3cpLGV9ZnVuY3Rpb24gYyh0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIEVsZW1lbnQ/dDpcInN0cmluZ1wiPT10eXBlb2YgdD90LnNwbGl0KC8+Pi9nKS5yZWR1Y2UoKCh0LGUsbyxuKT0+KHQ9dC5xdWVyeVNlbGVjdG9yKGUpLG88bi5sZW5ndGgtMT90LnNoYWRvd1Jvb3Q6dCkpLGRvY3VtZW50KTpudWxsfWZ1bmN0aW9uIHAodCxlPSh0PT50KSl7ZnVuY3Rpb24gbyhvKXtjb25zdCBuPVsuMDAxLC4wMSwuMV1bTnVtYmVyKG8uc2hpZnRLZXl8fDIqby5jdHJsS2V5KV0qKG8uZGVsdGFZPDA/MTotMSk7bGV0IGk9MCxzPXQuc2VsZWN0aW9uU3RhcnQ7dC52YWx1ZT10LnZhbHVlLnJlcGxhY2UoL1tcXGQuXSsvZywoKHQsbyk9Pm88PXMmJm8rdC5sZW5ndGg+PXM/KHM9byxlKE51bWJlcih0KSxuLGkpKTooaSsrLHQpKSksdC5mb2N1cygpLHQuc2V0U2VsZWN0aW9uUmFuZ2UocyxzKSxvLnByZXZlbnREZWZhdWx0KCksdC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChcImlucHV0XCIpKX1pKHQsXCJmb2N1c1wiLCgoKT0+aSh3aW5kb3csXCJ3aGVlbFwiLG8se3Bhc3NpdmU6ITF9KSkpLGkodCxcImJsdXJcIiwoKCk9PnMod2luZG93LFwid2hlZWxcIixvKSkpfWNvbnN0e21pbjp1LG1heDpoLGZsb29yOmQscm91bmQ6bX09TWF0aDtmdW5jdGlvbiBmKHQsZSxvKXtlLz0xMDAsby89MTAwO2NvbnN0IG49ZCh0PXQvMzYwKjYpLGk9dC1uLHM9byooMS1lKSxyPW8qKDEtaSplKSxhPW8qKDEtKDEtaSkqZSksbD1uJTY7cmV0dXJuWzI1NSpbbyxyLHMscyxhLG9dW2xdLDI1NSpbYSxvLG8scixzLHNdW2xdLDI1NSpbcyxzLGEsbyxvLHJdW2xdXX1mdW5jdGlvbiB2KHQsZSxvKXtjb25zdCBuPSgyLShlLz0xMDApKSooby89MTAwKS8yO3JldHVybiAwIT09biYmKGU9MT09PW4/MDpuPC41P2Uqby8oMipuKTplKm8vKDItMipuKSksW3QsMTAwKmUsMTAwKm5dfWZ1bmN0aW9uIGIodCxlLG8pe2NvbnN0IG49dSh0Lz0yNTUsZS89MjU1LG8vPTI1NSksaT1oKHQsZSxvKSxzPWktbjtsZXQgcixhO2lmKDA9PT1zKXI9YT0wO2Vsc2V7YT1zL2k7Y29uc3Qgbj0oKGktdCkvNitzLzIpL3MsbD0oKGktZSkvNitzLzIpL3MsYz0oKGktbykvNitzLzIpL3M7dD09PWk/cj1jLWw6ZT09PWk/cj0xLzMrbi1jOm89PT1pJiYocj0yLzMrbC1uKSxyPDA/cis9MTpyPjEmJihyLT0xKX1yZXR1cm5bMzYwKnIsMTAwKmEsMTAwKmldfWZ1bmN0aW9uIHkodCxlLG8sbil7ZS89MTAwLG8vPTEwMDtyZXR1cm5bLi4uYigyNTUqKDEtdSgxLCh0Lz0xMDApKigxLShuLz0xMDApKStuKSksMjU1KigxLXUoMSxlKigxLW4pK24pKSwyNTUqKDEtdSgxLG8qKDEtbikrbikpKV19ZnVuY3Rpb24gZyh0LGUsbyl7ZS89MTAwO2NvbnN0IG49MiooZSo9KG8vPTEwMCk8LjU/bzoxLW8pLyhvK2UpKjEwMCxpPTEwMCoobytlKTtyZXR1cm5bdCxpc05hTihuKT8wOm4saV19ZnVuY3Rpb24gXyh0KXtyZXR1cm4gYiguLi50Lm1hdGNoKC8uezJ9L2cpLm1hcCgodD0+cGFyc2VJbnQodCwxNikpKSl9ZnVuY3Rpb24gdyh0KXt0PXQubWF0Y2goL15bYS16QS1aXSskLyk/ZnVuY3Rpb24odCl7aWYoXCJibGFja1wiPT09dC50b0xvd2VyQ2FzZSgpKXJldHVyblwiIzAwMFwiO2NvbnN0IGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKS5nZXRDb250ZXh0KFwiMmRcIik7cmV0dXJuIGUuZmlsbFN0eWxlPXQsXCIjMDAwXCI9PT1lLmZpbGxTdHlsZT9udWxsOmUuZmlsbFN0eWxlfSh0KTp0O2NvbnN0IGU9e2NteWs6L15jbXlrXFxEKyhbXFxkLl0rKVxcRCsoW1xcZC5dKylcXEQrKFtcXGQuXSspXFxEKyhbXFxkLl0rKS9pLHJnYmE6L15yZ2JhP1xcRCsoW1xcZC5dKykoJT8pXFxEKyhbXFxkLl0rKSglPylcXEQrKFtcXGQuXSspKCU/KVxcRCo/KChbXFxkLl0rKSglPyl8JCkvaSxoc2xhOi9eaHNsYT9cXEQrKFtcXGQuXSspXFxEKyhbXFxkLl0rKVxcRCsoW1xcZC5dKylcXEQqPygoW1xcZC5dKykoJT8pfCQpL2ksaHN2YTovXmhzdmE/XFxEKyhbXFxkLl0rKVxcRCsoW1xcZC5dKylcXEQrKFtcXGQuXSspXFxEKj8oKFtcXGQuXSspKCU/KXwkKS9pLGhleGE6L14jPygoW1xcZEEtRmEtZl17Myw0fSl8KFtcXGRBLUZhLWZdezZ9KXwoW1xcZEEtRmEtZl17OH0pKSQvaX0sbz10PT50Lm1hcCgodD0+L14ofFxcZCspXFwuXFxkK3xcXGQrJC8udGVzdCh0KT9OdW1iZXIodCk6dm9pZCAwKSk7bGV0IG47dDpmb3IoY29uc3QgaSBpbiBlKWlmKG49ZVtpXS5leGVjKHQpKXN3aXRjaChpKXtjYXNlXCJjbXlrXCI6e2NvbnN0Wyx0LGUscyxyXT1vKG4pO2lmKHQ+MTAwfHxlPjEwMHx8cz4xMDB8fHI+MTAwKWJyZWFrIHQ7cmV0dXJue3ZhbHVlczp5KHQsZSxzLHIpLHR5cGU6aX19Y2FzZVwicmdiYVwiOntsZXRbLHQsLGUsLHMsLCxyXT1vKG4pO2lmKHQ9XCIlXCI9PT1uWzJdP3QvMTAwKjI1NTp0LGU9XCIlXCI9PT1uWzRdP2UvMTAwKjI1NTplLHM9XCIlXCI9PT1uWzZdP3MvMTAwKjI1NTpzLHI9XCIlXCI9PT1uWzldP3IvMTAwOnIsdD4yNTV8fGU+MjU1fHxzPjI1NXx8cjwwfHxyPjEpYnJlYWsgdDtyZXR1cm57dmFsdWVzOlsuLi5iKHQsZSxzKSxyXSxhOnIsdHlwZTppfX1jYXNlXCJoZXhhXCI6e2xldFssdF09bjs0IT09dC5sZW5ndGgmJjMhPT10Lmxlbmd0aHx8KHQ9dC5zcGxpdChcIlwiKS5tYXAoKHQ9PnQrdCkpLmpvaW4oXCJcIikpO2NvbnN0IGU9dC5zdWJzdHJpbmcoMCw2KTtsZXQgbz10LnN1YnN0cmluZyg2KTtyZXR1cm4gbz1vP3BhcnNlSW50KG8sMTYpLzI1NTp2b2lkIDAse3ZhbHVlczpbLi4uXyhlKSxvXSxhOm8sdHlwZTppfX1jYXNlXCJoc2xhXCI6e2xldFssdCxlLHMsLHJdPW8obik7aWYocj1cIiVcIj09PW5bNl0/ci8xMDA6cix0PjM2MHx8ZT4xMDB8fHM+MTAwfHxyPDB8fHI+MSlicmVhayB0O3JldHVybnt2YWx1ZXM6Wy4uLmcodCxlLHMpLHJdLGE6cix0eXBlOml9fWNhc2VcImhzdmFcIjp7bGV0Wyx0LGUscywscl09byhuKTtpZihyPVwiJVwiPT09bls2XT9yLzEwMDpyLHQ+MzYwfHxlPjEwMHx8cz4xMDB8fHI8MHx8cj4xKWJyZWFrIHQ7cmV0dXJue3ZhbHVlczpbdCxlLHMscl0sYTpyLHR5cGU6aX19fXJldHVybnt2YWx1ZXM6bnVsbCx0eXBlOm51bGx9fWZ1bmN0aW9uIEEodD0wLGU9MCxvPTAsbj0xKXtjb25zdCBpPSh0LGUpPT4obz0tMSk9PmUofm8/dC5tYXAoKHQ9Pk51bWJlcih0LnRvRml4ZWQobykpKSk6dCkscz17aDp0LHM6ZSx2Om8sYTpuLHRvSFNWQSgpe2NvbnN0IHQ9W3MuaCxzLnMscy52LHMuYV07cmV0dXJuIHQudG9TdHJpbmc9aSh0LCh0PT5gaHN2YSgke3RbMF19LCAke3RbMV19JSwgJHt0WzJdfSUsICR7cy5hfSlgKSksdH0sdG9IU0xBKCl7Y29uc3QgdD1bLi4udihzLmgscy5zLHMudikscy5hXTtyZXR1cm4gdC50b1N0cmluZz1pKHQsKHQ9PmBoc2xhKCR7dFswXX0sICR7dFsxXX0lLCAke3RbMl19JSwgJHtzLmF9KWApKSx0fSx0b1JHQkEoKXtjb25zdCB0PVsuLi5mKHMuaCxzLnMscy52KSxzLmFdO3JldHVybiB0LnRvU3RyaW5nPWkodCwodD0+YHJnYmEoJHt0WzBdfSwgJHt0WzFdfSwgJHt0WzJdfSwgJHtzLmF9KWApKSx0fSx0b0NNWUsoKXtjb25zdCB0PWZ1bmN0aW9uKHQsZSxvKXtjb25zdCBuPWYodCxlLG8pLGk9blswXS8yNTUscz1uWzFdLzI1NSxyPW5bMl0vMjU1LGE9dSgxLWksMS1zLDEtcik7cmV0dXJuWzEwMCooMT09PWE/MDooMS1pLWEpLygxLWEpKSwxMDAqKDE9PT1hPzA6KDEtcy1hKS8oMS1hKSksMTAwKigxPT09YT8wOigxLXItYSkvKDEtYSkpLDEwMCphXX0ocy5oLHMucyxzLnYpO3JldHVybiB0LnRvU3RyaW5nPWkodCwodD0+YGNteWsoJHt0WzBdfSUsICR7dFsxXX0lLCAke3RbMl19JSwgJHt0WzNdfSUpYCkpLHR9LHRvSEVYQSgpe2NvbnN0IHQ9ZnVuY3Rpb24odCxlLG8pe3JldHVybiBmKHQsZSxvKS5tYXAoKHQ9Pm0odCkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsXCIwXCIpKSl9KHMuaCxzLnMscy52KSxlPXMuYT49MT9cIlwiOk51bWJlcigoMjU1KnMuYSkudG9GaXhlZCgwKSkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkucGFkU3RhcnQoMixcIjBcIik7cmV0dXJuIGUmJnQucHVzaChlKSx0LnRvU3RyaW5nPSgpPT5gIyR7dC5qb2luKFwiXCIpLnRvVXBwZXJDYXNlKCl9YCx0fSxjbG9uZTooKT0+QShzLmgscy5zLHMudixzLmEpfTtyZXR1cm4gc31jb25zdCAkPXQ9Pk1hdGgubWF4KE1hdGgubWluKHQsMSksMCk7ZnVuY3Rpb24gQyh0KXtjb25zdCBlPXtvcHRpb25zOk9iamVjdC5hc3NpZ24oe2xvY2s6bnVsbCxvbmNoYW5nZTooKT0+MCxvbnN0b3A6KCk9PjB9LHQpLF9rZXlib2FyZCh0KXtjb25zdHtvcHRpb25zOm99PWUse3R5cGU6bixrZXk6aX09dDtpZihkb2N1bWVudC5hY3RpdmVFbGVtZW50PT09by53cmFwcGVyKXtjb25zdHtsb2NrOm99PWUub3B0aW9ucyxzPVwiQXJyb3dVcFwiPT09aSxyPVwiQXJyb3dSaWdodFwiPT09aSxhPVwiQXJyb3dEb3duXCI9PT1pLGw9XCJBcnJvd0xlZnRcIj09PWk7aWYoXCJrZXlkb3duXCI9PT1uJiYoc3x8cnx8YXx8bCkpe2xldCBuPTAsaT0wO1widlwiPT09bz9uPXN8fHI/MTotMTpcImhcIj09PW8/bj1zfHxyPy0xOjE6KGk9cz8tMTphPzE6MCxuPWw/LTE6cj8xOjApLGUudXBkYXRlKCQoZS5jYWNoZS54Ky4wMSpuKSwkKGUuY2FjaGUueSsuMDEqaSkpLHQucHJldmVudERlZmF1bHQoKX1lbHNlIGkuc3RhcnRzV2l0aChcIkFycm93XCIpJiYoZS5vcHRpb25zLm9uc3RvcCgpLHQucHJldmVudERlZmF1bHQoKSl9fSxfdGFwc3RhcnQodCl7aShkb2N1bWVudCxbXCJtb3VzZXVwXCIsXCJ0b3VjaGVuZFwiLFwidG91Y2hjYW5jZWxcIl0sZS5fdGFwc3RvcCksaShkb2N1bWVudCxbXCJtb3VzZW1vdmVcIixcInRvdWNobW92ZVwiXSxlLl90YXBtb3ZlKSx0LmNhbmNlbGFibGUmJnQucHJldmVudERlZmF1bHQoKSxlLl90YXBtb3ZlKHQpfSxfdGFwbW92ZSh0KXtjb25zdHtvcHRpb25zOm8sY2FjaGU6bn09ZSx7bG9jazppLGVsZW1lbnQ6cyx3cmFwcGVyOnJ9PW8sYT1yLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO2xldCBsPTAsYz0wO2lmKHQpe2NvbnN0IGU9dCYmdC50b3VjaGVzJiZ0LnRvdWNoZXNbMF07bD10PyhlfHx0KS5jbGllbnRYOjAsYz10PyhlfHx0KS5jbGllbnRZOjAsbDxhLmxlZnQ/bD1hLmxlZnQ6bD5hLmxlZnQrYS53aWR0aCYmKGw9YS5sZWZ0K2Eud2lkdGgpLGM8YS50b3A/Yz1hLnRvcDpjPmEudG9wK2EuaGVpZ2h0JiYoYz1hLnRvcCthLmhlaWdodCksbC09YS5sZWZ0LGMtPWEudG9wfWVsc2UgbiYmKGw9bi54KmEud2lkdGgsYz1uLnkqYS5oZWlnaHQpO1wiaFwiIT09aSYmKHMuc3R5bGUubGVmdD1gY2FsYygke2wvYS53aWR0aCoxMDB9JSAtICR7cy5vZmZzZXRXaWR0aC8yfXB4KWApLFwidlwiIT09aSYmKHMuc3R5bGUudG9wPWBjYWxjKCR7Yy9hLmhlaWdodCoxMDB9JSAtICR7cy5vZmZzZXRIZWlnaHQvMn1weClgKSxlLmNhY2hlPXt4OmwvYS53aWR0aCx5OmMvYS5oZWlnaHR9O2NvbnN0IHA9JChsL2Eud2lkdGgpLHU9JChjL2EuaGVpZ2h0KTtzd2l0Y2goaSl7Y2FzZVwidlwiOnJldHVybiBvLm9uY2hhbmdlKHApO2Nhc2VcImhcIjpyZXR1cm4gby5vbmNoYW5nZSh1KTtkZWZhdWx0OnJldHVybiBvLm9uY2hhbmdlKHAsdSl9fSxfdGFwc3RvcCgpe2Uub3B0aW9ucy5vbnN0b3AoKSxzKGRvY3VtZW50LFtcIm1vdXNldXBcIixcInRvdWNoZW5kXCIsXCJ0b3VjaGNhbmNlbFwiXSxlLl90YXBzdG9wKSxzKGRvY3VtZW50LFtcIm1vdXNlbW92ZVwiLFwidG91Y2htb3ZlXCJdLGUuX3RhcG1vdmUpfSx0cmlnZ2VyKCl7ZS5fdGFwbW92ZSgpfSx1cGRhdGUodD0wLG89MCl7Y29uc3R7bGVmdDpuLHRvcDppLHdpZHRoOnMsaGVpZ2h0OnJ9PWUub3B0aW9ucy53cmFwcGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1wiaFwiPT09ZS5vcHRpb25zLmxvY2smJihvPXQpLGUuX3RhcG1vdmUoe2NsaWVudFg6bitzKnQsY2xpZW50WTppK3Iqb30pfSxkZXN0cm95KCl7Y29uc3R7b3B0aW9uczp0LF90YXBzdGFydDpvLF9rZXlib2FyZDpufT1lO3MoZG9jdW1lbnQsW1wia2V5ZG93blwiLFwia2V5dXBcIl0sbikscyhbdC53cmFwcGVyLHQuZWxlbWVudF0sXCJtb3VzZWRvd25cIixvKSxzKFt0LndyYXBwZXIsdC5lbGVtZW50XSxcInRvdWNoc3RhcnRcIixvLHtwYXNzaXZlOiExfSl9fSx7b3B0aW9uczpvLF90YXBzdGFydDpuLF9rZXlib2FyZDpyfT1lO3JldHVybiBpKFtvLndyYXBwZXIsby5lbGVtZW50XSxcIm1vdXNlZG93blwiLG4pLGkoW28ud3JhcHBlcixvLmVsZW1lbnRdLFwidG91Y2hzdGFydFwiLG4se3Bhc3NpdmU6ITF9KSxpKGRvY3VtZW50LFtcImtleWRvd25cIixcImtleXVwXCJdLHIpLGV9ZnVuY3Rpb24gayh0PXt9KXt0PU9iamVjdC5hc3NpZ24oe29uY2hhbmdlOigpPT4wLGNsYXNzTmFtZTpcIlwiLGVsZW1lbnRzOltdfSx0KTtjb25zdCBlPWkodC5lbGVtZW50cyxcImNsaWNrXCIsKGU9Pnt0LmVsZW1lbnRzLmZvckVhY2goKG89Pm8uY2xhc3NMaXN0W2UudGFyZ2V0PT09bz9cImFkZFwiOlwicmVtb3ZlXCJdKHQuY2xhc3NOYW1lKSkpLHQub25jaGFuZ2UoZSksZS5zdG9wUHJvcGFnYXRpb24oKX0pKTtyZXR1cm57ZGVzdHJveTooKT0+cyguLi5lKX19Y29uc3QgUz17dmFyaWFudEZsaXBPcmRlcjp7c3RhcnQ6XCJzbWVcIixtaWRkbGU6XCJtc2VcIixlbmQ6XCJlbXNcIn0scG9zaXRpb25GbGlwT3JkZXI6e3RvcDpcInRicmxcIixyaWdodDpcInJsdGJcIixib3R0b206XCJidHJsXCIsbGVmdDpcImxyYnRcIn0scG9zaXRpb246XCJib3R0b21cIixtYXJnaW46OCxwYWRkaW5nOjB9LE89KHQsZSxvKT0+e2NvbnN0IG49XCJvYmplY3RcIiE9dHlwZW9mIHR8fHQgaW5zdGFuY2VvZiBIVE1MRWxlbWVudD97cmVmZXJlbmNlOnQscG9wcGVyOmUsLi4ub306dDtyZXR1cm57dXBkYXRlKHQ9bil7Y29uc3R7cmVmZXJlbmNlOmUscG9wcGVyOm99PU9iamVjdC5hc3NpZ24obix0KTtpZighb3x8IWUpdGhyb3cgbmV3IEVycm9yKFwiUG9wcGVyLSBvciByZWZlcmVuY2UtZWxlbWVudCBtaXNzaW5nLlwiKTtyZXR1cm4oKHQsZSxvKT0+e2NvbnN0e2NvbnRhaW5lcjpuLGFycm93OmksbWFyZ2luOnMscGFkZGluZzpyLHBvc2l0aW9uOmEsdmFyaWFudEZsaXBPcmRlcjpsLHBvc2l0aW9uRmxpcE9yZGVyOmN9PXtjb250YWluZXI6ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLC4uLlMsLi4ub30se2xlZnQ6cCx0b3A6dX09ZS5zdHlsZTtlLnN0eWxlLmxlZnQ9XCIwXCIsZS5zdHlsZS50b3A9XCIwXCI7Y29uc3QgaD10LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLGQ9ZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxtPXt0OmgudG9wLWQuaGVpZ2h0LXMsYjpoLmJvdHRvbStzLHI6aC5yaWdodCtzLGw6aC5sZWZ0LWQud2lkdGgtc30sZj17dnM6aC5sZWZ0LHZtOmgubGVmdCtoLndpZHRoLzItZC53aWR0aC8yLHZlOmgubGVmdCtoLndpZHRoLWQud2lkdGgsaHM6aC50b3AsaG06aC5ib3R0b20taC5oZWlnaHQvMi1kLmhlaWdodC8yLGhlOmguYm90dG9tLWQuaGVpZ2h0fSxbdixiPVwibWlkZGxlXCJdPWEuc3BsaXQoXCItXCIpLHk9Y1t2XSxnPWxbYl0se3RvcDpfLGxlZnQ6dyxib3R0b206QSxyaWdodDokfT1uO2Zvcihjb25zdCB0IG9mIHkpe2NvbnN0IG89XCJ0XCI9PT10fHxcImJcIj09PXQ7bGV0IG49bVt0XTtjb25zdFtzLGFdPW8/W1widG9wXCIsXCJsZWZ0XCJdOltcImxlZnRcIixcInRvcFwiXSxbbCxjXT1vP1tkLmhlaWdodCxkLndpZHRoXTpbZC53aWR0aCxkLmhlaWdodF0sW3AsdV09bz9bQSwkXTpbJCxBXSxbdixiXT1vP1tfLHddOlt3LF9dO2lmKCEobjx2fHxuK2wrcj5wKSlmb3IoY29uc3QgcCBvZiBnKXtsZXQgbT1mWyhvP1widlwiOlwiaFwiKStwXTtpZighKG08Ynx8bStjK3I+dSkpe2lmKG0tPWRbYV0sbi09ZFtzXSxlLnN0eWxlW2FdPWAke219cHhgLGUuc3R5bGVbc109YCR7bn1weGAsaSl7Y29uc3QgdD1vP2gud2lkdGgvMjpoLmhlaWdodC8yLGU9Mip0PGM/aFthXSt0Om0rYy8yO248aFtzXSYmKG4rPWwpLGkuc3R5bGVbYV09YCR7ZX1weGAsaS5zdHlsZVtzXT1gJHtufXB4YH1yZXR1cm4gdCtwfX19cmV0dXJuIGUuc3R5bGUubGVmdD1wLGUuc3R5bGUudG9wPXUsbnVsbH0pKGUsbyxuKX19fTtjbGFzcyBFe3N0YXRpYyB1dGlscz1vO3N0YXRpYyB2ZXJzaW9uPVwiMS45LjBcIjtzdGF0aWMgSTE4Tl9ERUZBVUxUUz17XCJ1aTpkaWFsb2dcIjpcImNvbG9yIHBpY2tlciBkaWFsb2dcIixcImJ0bjp0b2dnbGVcIjpcInRvZ2dsZSBjb2xvciBwaWNrZXIgZGlhbG9nXCIsXCJidG46c3dhdGNoXCI6XCJjb2xvciBzd2F0Y2hcIixcImJ0bjpsYXN0LWNvbG9yXCI6XCJ1c2UgcHJldmlvdXMgY29sb3JcIixcImJ0bjpzYXZlXCI6XCJTYXZlXCIsXCJidG46Y2FuY2VsXCI6XCJDYW5jZWxcIixcImJ0bjpjbGVhclwiOlwiQ2xlYXJcIixcImFyaWE6YnRuOnNhdmVcIjpcInNhdmUgYW5kIGNsb3NlXCIsXCJhcmlhOmJ0bjpjYW5jZWxcIjpcImNhbmNlbCBhbmQgY2xvc2VcIixcImFyaWE6YnRuOmNsZWFyXCI6XCJjbGVhciBhbmQgY2xvc2VcIixcImFyaWE6aW5wdXRcIjpcImNvbG9yIGlucHV0IGZpZWxkXCIsXCJhcmlhOnBhbGV0dGVcIjpcImNvbG9yIHNlbGVjdGlvbiBhcmVhXCIsXCJhcmlhOmh1ZVwiOlwiaHVlIHNlbGVjdGlvbiBzbGlkZXJcIixcImFyaWE6b3BhY2l0eVwiOlwic2VsZWN0aW9uIHNsaWRlclwifTtzdGF0aWMgREVGQVVMVF9PUFRJT05TPXthcHBDbGFzczpudWxsLHRoZW1lOlwiY2xhc3NpY1wiLHVzZUFzQnV0dG9uOiExLHBhZGRpbmc6OCxkaXNhYmxlZDohMSxjb21wYXJpc29uOiEwLGNsb3NlT25TY3JvbGw6ITEsb3V0cHV0UHJlY2lzaW9uOjAsbG9ja09wYWNpdHk6ITEsYXV0b1JlcG9zaXRpb246ITAsY29udGFpbmVyOlwiYm9keVwiLGNvbXBvbmVudHM6e2ludGVyYWN0aW9uOnt9fSxpMThuOnt9LHN3YXRjaGVzOm51bGwsaW5saW5lOiExLHNsaWRlcnM6bnVsbCxkZWZhdWx0OlwiIzQyNDQ1YVwiLGRlZmF1bHRSZXByZXNlbnRhdGlvbjpudWxsLHBvc2l0aW9uOlwiYm90dG9tLW1pZGRsZVwiLGFkanVzdGFibGVOdW1iZXJzOiEwLHNob3dBbHdheXM6ITEsY2xvc2VXaXRoS2V5OlwiRXNjYXBlXCJ9O19pbml0aWFsaXppbmdBY3RpdmU9ITA7X3JlY2FsYz0hMDtfbmFub3BvcD1udWxsO19yb290PW51bGw7X2NvbG9yPUEoKTtfbGFzdENvbG9yPUEoKTtfc3dhdGNoQ29sb3JzPVtdO19zZXR1cEFuaW1hdGlvbkZyYW1lPW51bGw7X2V2ZW50TGlzdGVuZXI9e2luaXQ6W10sc2F2ZTpbXSxoaWRlOltdLHNob3c6W10sY2xlYXI6W10sY2hhbmdlOltdLGNoYW5nZXN0b3A6W10sY2FuY2VsOltdLHN3YXRjaHNlbGVjdDpbXX07Y29uc3RydWN0b3IodCl7dGhpcy5vcHRpb25zPXQ9T2JqZWN0LmFzc2lnbih7Li4uRS5ERUZBVUxUX09QVElPTlN9LHQpO2NvbnN0e3N3YXRjaGVzOmUsY29tcG9uZW50czpvLHRoZW1lOm4sc2xpZGVyczppLGxvY2tPcGFjaXR5OnMscGFkZGluZzpyfT10O1tcIm5hbm9cIixcIm1vbm9saXRoXCJdLmluY2x1ZGVzKG4pJiYhaSYmKHQuc2xpZGVycz1cImhcIiksby5pbnRlcmFjdGlvbnx8KG8uaW50ZXJhY3Rpb249e30pO2NvbnN0e3ByZXZpZXc6YSxvcGFjaXR5OmwsaHVlOmMscGFsZXR0ZTpwfT1vO28ub3BhY2l0eT0hcyYmbCxvLnBhbGV0dGU9cHx8YXx8bHx8Yyx0aGlzLl9wcmVCdWlsZCgpLHRoaXMuX2J1aWxkQ29tcG9uZW50cygpLHRoaXMuX2JpbmRFdmVudHMoKSx0aGlzLl9maW5hbEJ1aWxkKCksZSYmZS5sZW5ndGgmJmUuZm9yRWFjaCgodD0+dGhpcy5hZGRTd2F0Y2godCkpKTtjb25zdHtidXR0b246dSxhcHA6aH09dGhpcy5fcm9vdDt0aGlzLl9uYW5vcG9wPU8odSxoLHttYXJnaW46cn0pLHUuc2V0QXR0cmlidXRlKFwicm9sZVwiLFwiYnV0dG9uXCIpLHUuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLHRoaXMuX3QoXCJidG46dG9nZ2xlXCIpKTtjb25zdCBkPXRoaXM7dGhpcy5fc2V0dXBBbmltYXRpb25GcmFtZT1yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKGZ1bmN0aW9uIGUoKXtpZighaC5vZmZzZXRXaWR0aClyZXR1cm4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGUpO2Quc2V0Q29sb3IodC5kZWZhdWx0KSxkLl9yZVBvc2l0aW9uaW5nUGlja2VyKCksdC5kZWZhdWx0UmVwcmVzZW50YXRpb24mJihkLl9yZXByZXNlbnRhdGlvbj10LmRlZmF1bHRSZXByZXNlbnRhdGlvbixkLnNldENvbG9yUmVwcmVzZW50YXRpb24oZC5fcmVwcmVzZW50YXRpb24pKSx0LnNob3dBbHdheXMmJmQuc2hvdygpLGQuX2luaXRpYWxpemluZ0FjdGl2ZT0hMSxkLl9lbWl0KFwiaW5pdFwiKX0pKX1zdGF0aWMgY3JlYXRlPXQ9Pm5ldyBFKHQpO19wcmVCdWlsZCgpe2NvbnN0e29wdGlvbnM6dH09dGhpcztmb3IoY29uc3QgZSBvZltcImVsXCIsXCJjb250YWluZXJcIl0pdFtlXT1jKHRbZV0pO3RoaXMuX3Jvb3Q9KHQ9Pntjb25zdHtjb21wb25lbnRzOmUsdXNlQXNCdXR0b246byxpbmxpbmU6bixhcHBDbGFzczppLHRoZW1lOnMsbG9ja09wYWNpdHk6cn09dC5vcHRpb25zLGw9dD0+dD9cIlwiOidzdHlsZT1cImRpc3BsYXk6bm9uZVwiIGhpZGRlbicsYz1lPT50Ll90KGUpLHA9YShgXFxuICAgICAgPGRpdiA6cmVmPVwicm9vdFwiIGNsYXNzPVwicGlja3JcIj5cXG5cXG4gICAgICAgICR7bz9cIlwiOic8YnV0dG9uIHR5cGU9XCJidXR0b25cIiA6cmVmPVwiYnV0dG9uXCIgY2xhc3M9XCJwY3ItYnV0dG9uXCI+PC9idXR0b24+J31cXG5cXG4gICAgICAgIDxkaXYgOnJlZj1cImFwcFwiIGNsYXNzPVwicGNyLWFwcCAke2l8fFwiXCJ9XCIgZGF0YS10aGVtZT1cIiR7c31cIiAke24/J3N0eWxlPVwicG9zaXRpb246IHVuc2V0XCInOlwiXCJ9IGFyaWEtbGFiZWw9XCIke2MoXCJ1aTpkaWFsb2dcIil9XCIgcm9sZT1cIndpbmRvd1wiPlxcbiAgICAgICAgICA8ZGl2IGNsYXNzPVwicGNyLXNlbGVjdGlvblwiICR7bChlLnBhbGV0dGUpfT5cXG4gICAgICAgICAgICA8ZGl2IDpvYmo9XCJwcmV2aWV3XCIgY2xhc3M9XCJwY3ItY29sb3ItcHJldmlld1wiICR7bChlLnByZXZpZXcpfT5cXG4gICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIDpyZWY9XCJsYXN0Q29sb3JcIiBjbGFzcz1cInBjci1sYXN0LWNvbG9yXCIgYXJpYS1sYWJlbD1cIiR7YyhcImJ0bjpsYXN0LWNvbG9yXCIpfVwiPjwvYnV0dG9uPlxcbiAgICAgICAgICAgICAgPGRpdiA6cmVmPVwiY3VycmVudENvbG9yXCIgY2xhc3M9XCJwY3ItY3VycmVudC1jb2xvclwiPjwvZGl2PlxcbiAgICAgICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgICAgIDxkaXYgOm9iaj1cInBhbGV0dGVcIiBjbGFzcz1cInBjci1jb2xvci1wYWxldHRlXCI+XFxuICAgICAgICAgICAgICA8ZGl2IDpyZWY9XCJwaWNrZXJcIiBjbGFzcz1cInBjci1waWNrZXJcIj48L2Rpdj5cXG4gICAgICAgICAgICAgIDxkaXYgOnJlZj1cInBhbGV0dGVcIiBjbGFzcz1cInBjci1wYWxldHRlXCIgdGFiaW5kZXg9XCIwXCIgYXJpYS1sYWJlbD1cIiR7YyhcImFyaWE6cGFsZXR0ZVwiKX1cIiByb2xlPVwibGlzdGJveFwiPjwvZGl2PlxcbiAgICAgICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgICAgIDxkaXYgOm9iaj1cImh1ZVwiIGNsYXNzPVwicGNyLWNvbG9yLWNob29zZXJcIiAke2woZS5odWUpfT5cXG4gICAgICAgICAgICAgIDxkaXYgOnJlZj1cInBpY2tlclwiIGNsYXNzPVwicGNyLXBpY2tlclwiPjwvZGl2PlxcbiAgICAgICAgICAgICAgPGRpdiA6cmVmPVwic2xpZGVyXCIgY2xhc3M9XCJwY3ItaHVlIHBjci1zbGlkZXJcIiB0YWJpbmRleD1cIjBcIiBhcmlhLWxhYmVsPVwiJHtjKFwiYXJpYTpodWVcIil9XCIgcm9sZT1cInNsaWRlclwiPjwvZGl2PlxcbiAgICAgICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgICAgIDxkaXYgOm9iaj1cIm9wYWNpdHlcIiBjbGFzcz1cInBjci1jb2xvci1vcGFjaXR5XCIgJHtsKGUub3BhY2l0eSl9PlxcbiAgICAgICAgICAgICAgPGRpdiA6cmVmPVwicGlja2VyXCIgY2xhc3M9XCJwY3ItcGlja2VyXCI+PC9kaXY+XFxuICAgICAgICAgICAgICA8ZGl2IDpyZWY9XCJzbGlkZXJcIiBjbGFzcz1cInBjci1vcGFjaXR5IHBjci1zbGlkZXJcIiB0YWJpbmRleD1cIjBcIiBhcmlhLWxhYmVsPVwiJHtjKFwiYXJpYTpvcGFjaXR5XCIpfVwiIHJvbGU9XCJzbGlkZXJcIj48L2Rpdj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgPC9kaXY+XFxuXFxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJwY3Itc3dhdGNoZXMgJHtlLnBhbGV0dGU/XCJcIjpcInBjci1sYXN0XCJ9XCIgOnJlZj1cInN3YXRjaGVzXCI+PC9kaXY+XFxuXFxuICAgICAgICAgIDxkaXYgOm9iaj1cImludGVyYWN0aW9uXCIgY2xhc3M9XCJwY3ItaW50ZXJhY3Rpb25cIiAke2woT2JqZWN0LmtleXMoZS5pbnRlcmFjdGlvbikubGVuZ3RoKX0+XFxuICAgICAgICAgICAgPGlucHV0IDpyZWY9XCJyZXN1bHRcIiBjbGFzcz1cInBjci1yZXN1bHRcIiB0eXBlPVwidGV4dFwiIHNwZWxsY2hlY2s9XCJmYWxzZVwiICR7bChlLmludGVyYWN0aW9uLmlucHV0KX0gYXJpYS1sYWJlbD1cIiR7YyhcImFyaWE6aW5wdXRcIil9XCI+XFxuXFxuICAgICAgICAgICAgPGlucHV0IDphcnI9XCJvcHRpb25zXCIgY2xhc3M9XCJwY3ItdHlwZVwiIGRhdGEtdHlwZT1cIkhFWEFcIiB2YWx1ZT1cIiR7cj9cIkhFWFwiOlwiSEVYQVwifVwiIHR5cGU9XCJidXR0b25cIiAke2woZS5pbnRlcmFjdGlvbi5oZXgpfT5cXG4gICAgICAgICAgICA8aW5wdXQgOmFycj1cIm9wdGlvbnNcIiBjbGFzcz1cInBjci10eXBlXCIgZGF0YS10eXBlPVwiUkdCQVwiIHZhbHVlPVwiJHtyP1wiUkdCXCI6XCJSR0JBXCJ9XCIgdHlwZT1cImJ1dHRvblwiICR7bChlLmludGVyYWN0aW9uLnJnYmEpfT5cXG4gICAgICAgICAgICA8aW5wdXQgOmFycj1cIm9wdGlvbnNcIiBjbGFzcz1cInBjci10eXBlXCIgZGF0YS10eXBlPVwiSFNMQVwiIHZhbHVlPVwiJHtyP1wiSFNMXCI6XCJIU0xBXCJ9XCIgdHlwZT1cImJ1dHRvblwiICR7bChlLmludGVyYWN0aW9uLmhzbGEpfT5cXG4gICAgICAgICAgICA8aW5wdXQgOmFycj1cIm9wdGlvbnNcIiBjbGFzcz1cInBjci10eXBlXCIgZGF0YS10eXBlPVwiSFNWQVwiIHZhbHVlPVwiJHtyP1wiSFNWXCI6XCJIU1ZBXCJ9XCIgdHlwZT1cImJ1dHRvblwiICR7bChlLmludGVyYWN0aW9uLmhzdmEpfT5cXG4gICAgICAgICAgICA8aW5wdXQgOmFycj1cIm9wdGlvbnNcIiBjbGFzcz1cInBjci10eXBlXCIgZGF0YS10eXBlPVwiQ01ZS1wiIHZhbHVlPVwiQ01ZS1wiIHR5cGU9XCJidXR0b25cIiAke2woZS5pbnRlcmFjdGlvbi5jbXlrKX0+XFxuXFxuICAgICAgICAgICAgPGlucHV0IDpyZWY9XCJzYXZlXCIgY2xhc3M9XCJwY3Itc2F2ZVwiIHZhbHVlPVwiJHtjKFwiYnRuOnNhdmVcIil9XCIgdHlwZT1cImJ1dHRvblwiICR7bChlLmludGVyYWN0aW9uLnNhdmUpfSBhcmlhLWxhYmVsPVwiJHtjKFwiYXJpYTpidG46c2F2ZVwiKX1cIj5cXG4gICAgICAgICAgICA8aW5wdXQgOnJlZj1cImNhbmNlbFwiIGNsYXNzPVwicGNyLWNhbmNlbFwiIHZhbHVlPVwiJHtjKFwiYnRuOmNhbmNlbFwiKX1cIiB0eXBlPVwiYnV0dG9uXCIgJHtsKGUuaW50ZXJhY3Rpb24uY2FuY2VsKX0gYXJpYS1sYWJlbD1cIiR7YyhcImFyaWE6YnRuOmNhbmNlbFwiKX1cIj5cXG4gICAgICAgICAgICA8aW5wdXQgOnJlZj1cImNsZWFyXCIgY2xhc3M9XCJwY3ItY2xlYXJcIiB2YWx1ZT1cIiR7YyhcImJ0bjpjbGVhclwiKX1cIiB0eXBlPVwiYnV0dG9uXCIgJHtsKGUuaW50ZXJhY3Rpb24uY2xlYXIpfSBhcmlhLWxhYmVsPVwiJHtjKFwiYXJpYTpidG46Y2xlYXJcIil9XCI+XFxuICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC9kaXY+XFxuICAgICAgPC9kaXY+XFxuICAgIGApLHU9cC5pbnRlcmFjdGlvbjtyZXR1cm4gdS5vcHRpb25zLmZpbmQoKHQ9PiF0LmhpZGRlbiYmIXQuY2xhc3NMaXN0LmFkZChcImFjdGl2ZVwiKSkpLHUudHlwZT0oKT0+dS5vcHRpb25zLmZpbmQoKHQ9PnQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiYWN0aXZlXCIpKSkscH0pKHRoaXMpLHQudXNlQXNCdXR0b24mJih0aGlzLl9yb290LmJ1dHRvbj10LmVsKSx0LmNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9yb290LnJvb3QpfV9maW5hbEJ1aWxkKCl7Y29uc3QgdD10aGlzLm9wdGlvbnMsZT10aGlzLl9yb290O2lmKHQuY29udGFpbmVyLnJlbW92ZUNoaWxkKGUucm9vdCksdC5pbmxpbmUpe2NvbnN0IG89dC5lbC5wYXJlbnRFbGVtZW50O3QuZWwubmV4dFNpYmxpbmc/by5pbnNlcnRCZWZvcmUoZS5hcHAsdC5lbC5uZXh0U2libGluZyk6by5hcHBlbmRDaGlsZChlLmFwcCl9ZWxzZSB0LmNvbnRhaW5lci5hcHBlbmRDaGlsZChlLmFwcCk7dC51c2VBc0J1dHRvbj90LmlubGluZSYmdC5lbC5yZW1vdmUoKTp0LmVsLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKGUucm9vdCx0LmVsKSx0LmRpc2FibGVkJiZ0aGlzLmRpc2FibGUoKSx0LmNvbXBhcmlzb258fChlLmJ1dHRvbi5zdHlsZS50cmFuc2l0aW9uPVwibm9uZVwiLHQudXNlQXNCdXR0b258fChlLnByZXZpZXcubGFzdENvbG9yLnN0eWxlLnRyYW5zaXRpb249XCJub25lXCIpKSx0aGlzLmhpZGUoKX1fYnVpbGRDb21wb25lbnRzKCl7Y29uc3QgdD10aGlzLGU9dGhpcy5vcHRpb25zLmNvbXBvbmVudHMsbz0odC5vcHRpb25zLnNsaWRlcnN8fFwidlwiKS5yZXBlYXQoMiksW24saV09by5tYXRjaCgvXlt2aF0rJC9nKT9vOltdLHM9KCk9PnRoaXMuX2NvbG9yfHwodGhpcy5fY29sb3I9dGhpcy5fbGFzdENvbG9yLmNsb25lKCkpLHI9e3BhbGV0dGU6Qyh7ZWxlbWVudDp0Ll9yb290LnBhbGV0dGUucGlja2VyLHdyYXBwZXI6dC5fcm9vdC5wYWxldHRlLnBhbGV0dGUsb25zdG9wOigpPT50Ll9lbWl0KFwiY2hhbmdlc3RvcFwiLFwic2xpZGVyXCIsdCksb25jaGFuZ2UobyxuKXtpZighZS5wYWxldHRlKXJldHVybjtjb25zdCBpPXMoKSx7X3Jvb3Q6cixvcHRpb25zOmF9PXQse2xhc3RDb2xvcjpsLGN1cnJlbnRDb2xvcjpjfT1yLnByZXZpZXc7dC5fcmVjYWxjJiYoaS5zPTEwMCpvLGkudj0xMDAtMTAwKm4saS52PDAmJihpLnY9MCksdC5fdXBkYXRlT3V0cHV0KFwic2xpZGVyXCIpKTtjb25zdCBwPWkudG9SR0JBKCkudG9TdHJpbmcoMCk7dGhpcy5lbGVtZW50LnN0eWxlLmJhY2tncm91bmQ9cCx0aGlzLndyYXBwZXIuc3R5bGUuYmFja2dyb3VuZD1gXFxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZWFyLWdyYWRpZW50KHRvIHRvcCwgcmdiYSgwLCAwLCAwLCAke2kuYX0pLCB0cmFuc3BhcmVudCksXFxuICAgICAgICAgICAgICAgICAgICAgICAgbGluZWFyLWdyYWRpZW50KHRvIGxlZnQsIGhzbGEoJHtpLmh9LCAxMDAlLCA1MCUsICR7aS5hfSksIHJnYmEoMjU1LCAyNTUsIDI1NSwgJHtpLmF9KSlcXG4gICAgICAgICAgICAgICAgICAgIGAsYS5jb21wYXJpc29uP2EudXNlQXNCdXR0b258fHQuX2xhc3RDb2xvcnx8bC5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tcGNyLWNvbG9yXCIscCk6KHIuYnV0dG9uLnN0eWxlLnNldFByb3BlcnR5KFwiLS1wY3ItY29sb3JcIixwKSxyLmJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKFwiY2xlYXJcIikpO2NvbnN0IHU9aS50b0hFWEEoKS50b1N0cmluZygpO2Zvcihjb25zdHtlbDplLGNvbG9yOm99b2YgdC5fc3dhdGNoQ29sb3JzKWUuY2xhc3NMaXN0W3U9PT1vLnRvSEVYQSgpLnRvU3RyaW5nKCk/XCJhZGRcIjpcInJlbW92ZVwiXShcInBjci1hY3RpdmVcIik7Yy5zdHlsZS5zZXRQcm9wZXJ0eShcIi0tcGNyLWNvbG9yXCIscCl9fSksaHVlOkMoe2xvY2s6XCJ2XCI9PT1pP1wiaFwiOlwidlwiLGVsZW1lbnQ6dC5fcm9vdC5odWUucGlja2VyLHdyYXBwZXI6dC5fcm9vdC5odWUuc2xpZGVyLG9uc3RvcDooKT0+dC5fZW1pdChcImNoYW5nZXN0b3BcIixcInNsaWRlclwiLHQpLG9uY2hhbmdlKG8pe2lmKCFlLmh1ZXx8IWUucGFsZXR0ZSlyZXR1cm47Y29uc3Qgbj1zKCk7dC5fcmVjYWxjJiYobi5oPTM2MCpvKSx0aGlzLmVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZENvbG9yPWBoc2woJHtuLmh9LCAxMDAlLCA1MCUpYCxyLnBhbGV0dGUudHJpZ2dlcigpfX0pLG9wYWNpdHk6Qyh7bG9jazpcInZcIj09PW4/XCJoXCI6XCJ2XCIsZWxlbWVudDp0Ll9yb290Lm9wYWNpdHkucGlja2VyLHdyYXBwZXI6dC5fcm9vdC5vcGFjaXR5LnNsaWRlcixvbnN0b3A6KCk9PnQuX2VtaXQoXCJjaGFuZ2VzdG9wXCIsXCJzbGlkZXJcIix0KSxvbmNoYW5nZShvKXtpZighZS5vcGFjaXR5fHwhZS5wYWxldHRlKXJldHVybjtjb25zdCBuPXMoKTt0Ll9yZWNhbGMmJihuLmE9TWF0aC5yb3VuZCgxMDAqbykvMTAwKSx0aGlzLmVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZD1gcmdiYSgwLCAwLCAwLCAke24uYX0pYCxyLnBhbGV0dGUudHJpZ2dlcigpfX0pLHNlbGVjdGFibGU6ayh7ZWxlbWVudHM6dC5fcm9vdC5pbnRlcmFjdGlvbi5vcHRpb25zLGNsYXNzTmFtZTpcImFjdGl2ZVwiLG9uY2hhbmdlKGUpe3QuX3JlcHJlc2VudGF0aW9uPWUudGFyZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtdHlwZVwiKS50b1VwcGVyQ2FzZSgpLHQuX3JlY2FsYyYmdC5fdXBkYXRlT3V0cHV0KFwic3dhdGNoXCIpfX0pfTt0aGlzLl9jb21wb25lbnRzPXJ9X2JpbmRFdmVudHMoKXtjb25zdHtfcm9vdDp0LG9wdGlvbnM6ZX09dGhpcyxvPVtpKHQuaW50ZXJhY3Rpb24uY2xlYXIsXCJjbGlja1wiLCgoKT0+dGhpcy5fY2xlYXJDb2xvcigpKSksaShbdC5pbnRlcmFjdGlvbi5jYW5jZWwsdC5wcmV2aWV3Lmxhc3RDb2xvcl0sXCJjbGlja1wiLCgoKT0+e3RoaXMuc2V0SFNWQSguLi4odGhpcy5fbGFzdENvbG9yfHx0aGlzLl9jb2xvcikudG9IU1ZBKCksITApLHRoaXMuX2VtaXQoXCJjYW5jZWxcIil9KSksaSh0LmludGVyYWN0aW9uLnNhdmUsXCJjbGlja1wiLCgoKT0+eyF0aGlzLmFwcGx5Q29sb3IoKSYmIWUuc2hvd0Fsd2F5cyYmdGhpcy5oaWRlKCl9KSksaSh0LmludGVyYWN0aW9uLnJlc3VsdCxbXCJrZXl1cFwiLFwiaW5wdXRcIl0sKHQ9Pnt0aGlzLnNldENvbG9yKHQudGFyZ2V0LnZhbHVlLCEwKSYmIXRoaXMuX2luaXRpYWxpemluZ0FjdGl2ZSYmKHRoaXMuX2VtaXQoXCJjaGFuZ2VcIix0aGlzLl9jb2xvcixcImlucHV0XCIsdGhpcyksdGhpcy5fZW1pdChcImNoYW5nZXN0b3BcIixcImlucHV0XCIsdGhpcykpLHQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCl9KSksaSh0LmludGVyYWN0aW9uLnJlc3VsdCxbXCJmb2N1c1wiLFwiYmx1clwiXSwodD0+e3RoaXMuX3JlY2FsYz1cImJsdXJcIj09PXQudHlwZSx0aGlzLl9yZWNhbGMmJnRoaXMuX3VwZGF0ZU91dHB1dChudWxsKX0pKSxpKFt0LnBhbGV0dGUucGFsZXR0ZSx0LnBhbGV0dGUucGlja2VyLHQuaHVlLnNsaWRlcix0Lmh1ZS5waWNrZXIsdC5vcGFjaXR5LnNsaWRlcix0Lm9wYWNpdHkucGlja2VyXSxbXCJtb3VzZWRvd25cIixcInRvdWNoc3RhcnRcIl0sKCgpPT50aGlzLl9yZWNhbGM9ITApLHtwYXNzaXZlOiEwfSldO2lmKCFlLnNob3dBbHdheXMpe2NvbnN0IG49ZS5jbG9zZVdpdGhLZXk7by5wdXNoKGkodC5idXR0b24sXCJjbGlja1wiLCgoKT0+dGhpcy5pc09wZW4oKT90aGlzLmhpZGUoKTp0aGlzLnNob3coKSkpLGkoZG9jdW1lbnQsXCJrZXl1cFwiLCh0PT50aGlzLmlzT3BlbigpJiYodC5rZXk9PT1ufHx0LmNvZGU9PT1uKSYmdGhpcy5oaWRlKCkpKSxpKGRvY3VtZW50LFtcInRvdWNoc3RhcnRcIixcIm1vdXNlZG93blwiXSwoZT0+e3RoaXMuaXNPcGVuKCkmJiFsKGUpLnNvbWUoKGU9PmU9PT10LmFwcHx8ZT09PXQuYnV0dG9uKSkmJnRoaXMuaGlkZSgpfSkse2NhcHR1cmU6ITB9KSl9aWYoZS5hZGp1c3RhYmxlTnVtYmVycyl7Y29uc3QgZT17cmdiYTpbMjU1LDI1NSwyNTUsMV0saHN2YTpbMzYwLDEwMCwxMDAsMV0saHNsYTpbMzYwLDEwMCwxMDAsMV0sY215azpbMTAwLDEwMCwxMDAsMTAwXX07cCh0LmludGVyYWN0aW9uLnJlc3VsdCwoKHQsbyxuKT0+e2NvbnN0IGk9ZVt0aGlzLmdldENvbG9yUmVwcmVzZW50YXRpb24oKS50b0xvd2VyQ2FzZSgpXTtpZihpKXtjb25zdCBlPWlbbl0scz10KyhlPj0xMDA/MWUzKm86byk7cmV0dXJuIHM8PTA/MDpOdW1iZXIoKHM8ZT9zOmUpLnRvUHJlY2lzaW9uKDMpKX1yZXR1cm4gdH0pKX1pZihlLmF1dG9SZXBvc2l0aW9uJiYhZS5pbmxpbmUpe2xldCB0PW51bGw7Y29uc3Qgbj10aGlzO28ucHVzaChpKHdpbmRvdyxbXCJzY3JvbGxcIixcInJlc2l6ZVwiXSwoKCk9PntuLmlzT3BlbigpJiYoZS5jbG9zZU9uU2Nyb2xsJiZuLmhpZGUoKSxudWxsPT09dD8odD1zZXRUaW1lb3V0KCgoKT0+dD1udWxsKSwxMDApLHJlcXVlc3RBbmltYXRpb25GcmFtZSgoZnVuY3Rpb24gZSgpe24uX3JlUG9zaXRpb25pbmdQaWNrZXIoKSxudWxsIT09dCYmcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGUpfSkpKTooY2xlYXJUaW1lb3V0KHQpLHQ9c2V0VGltZW91dCgoKCk9PnQ9bnVsbCksMTAwKSkpfSkse2NhcHR1cmU6ITB9KSl9dGhpcy5fZXZlbnRCaW5kaW5ncz1vfV9yZVBvc2l0aW9uaW5nUGlja2VyKCl7Y29uc3R7b3B0aW9uczp0fT10aGlzO2lmKCF0LmlubGluZSl7aWYoIXRoaXMuX25hbm9wb3AudXBkYXRlKHtjb250YWluZXI6ZG9jdW1lbnQuYm9keS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxwb3NpdGlvbjp0LnBvc2l0aW9ufSkpe2NvbnN0IHQ9dGhpcy5fcm9vdC5hcHAsZT10LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO3Quc3R5bGUudG9wPSh3aW5kb3cuaW5uZXJIZWlnaHQtZS5oZWlnaHQpLzIrXCJweFwiLHQuc3R5bGUubGVmdD0od2luZG93LmlubmVyV2lkdGgtZS53aWR0aCkvMitcInB4XCJ9fX1fdXBkYXRlT3V0cHV0KHQpe2NvbnN0e19yb290OmUsX2NvbG9yOm8sb3B0aW9uczpufT10aGlzO2lmKGUuaW50ZXJhY3Rpb24udHlwZSgpKXtjb25zdCB0PWB0byR7ZS5pbnRlcmFjdGlvbi50eXBlKCkuZ2V0QXR0cmlidXRlKFwiZGF0YS10eXBlXCIpfWA7ZS5pbnRlcmFjdGlvbi5yZXN1bHQudmFsdWU9XCJmdW5jdGlvblwiPT10eXBlb2Ygb1t0XT9vW3RdKCkudG9TdHJpbmcobi5vdXRwdXRQcmVjaXNpb24pOlwiXCJ9IXRoaXMuX2luaXRpYWxpemluZ0FjdGl2ZSYmdGhpcy5fcmVjYWxjJiZ0aGlzLl9lbWl0KFwiY2hhbmdlXCIsbyx0LHRoaXMpfV9jbGVhckNvbG9yKHQ9ITEpe2NvbnN0e19yb290OmUsb3B0aW9uczpvfT10aGlzO28udXNlQXNCdXR0b258fGUuYnV0dG9uLnN0eWxlLnNldFByb3BlcnR5KFwiLS1wY3ItY29sb3JcIixcInJnYmEoMCwgMCwgMCwgMC4xNSlcIiksZS5idXR0b24uY2xhc3NMaXN0LmFkZChcImNsZWFyXCIpLG8uc2hvd0Fsd2F5c3x8dGhpcy5oaWRlKCksdGhpcy5fbGFzdENvbG9yPW51bGwsdGhpcy5faW5pdGlhbGl6aW5nQWN0aXZlfHx0fHwodGhpcy5fZW1pdChcInNhdmVcIixudWxsKSx0aGlzLl9lbWl0KFwiY2xlYXJcIikpfV9wYXJzZUxvY2FsQ29sb3IodCl7Y29uc3R7dmFsdWVzOmUsdHlwZTpvLGE6bn09dyh0KSx7bG9ja09wYWNpdHk6aX09dGhpcy5vcHRpb25zLHM9dm9pZCAwIT09biYmMSE9PW47cmV0dXJuIGUmJjM9PT1lLmxlbmd0aCYmKGVbM109dm9pZCAwKSx7dmFsdWVzOiFlfHxpJiZzP251bGw6ZSx0eXBlOm99fV90KHQpe3JldHVybiB0aGlzLm9wdGlvbnMuaTE4blt0XXx8RS5JMThOX0RFRkFVTFRTW3RdfV9lbWl0KHQsLi4uZSl7dGhpcy5fZXZlbnRMaXN0ZW5lclt0XS5mb3JFYWNoKCh0PT50KC4uLmUsdGhpcykpKX1vbih0LGUpe3JldHVybiB0aGlzLl9ldmVudExpc3RlbmVyW3RdLnB1c2goZSksdGhpc31vZmYodCxlKXtjb25zdCBvPXRoaXMuX2V2ZW50TGlzdGVuZXJbdF18fFtdLG49by5pbmRleE9mKGUpO3JldHVybn5uJiZvLnNwbGljZShuLDEpLHRoaXN9YWRkU3dhdGNoKHQpe2NvbnN0e3ZhbHVlczplfT10aGlzLl9wYXJzZUxvY2FsQ29sb3IodCk7aWYoZSl7Y29uc3R7X3N3YXRjaENvbG9yczp0LF9yb290Om99PXRoaXMsbj1BKC4uLmUpLHM9cihgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgc3R5bGU9XCItLXBjci1jb2xvcjogJHtuLnRvUkdCQSgpLnRvU3RyaW5nKDApfVwiIGFyaWEtbGFiZWw9XCIke3RoaXMuX3QoXCJidG46c3dhdGNoXCIpfVwiLz5gKTtyZXR1cm4gby5zd2F0Y2hlcy5hcHBlbmRDaGlsZChzKSx0LnB1c2goe2VsOnMsY29sb3I6bn0pLHRoaXMuX2V2ZW50QmluZGluZ3MucHVzaChpKHMsXCJjbGlja1wiLCgoKT0+e3RoaXMuc2V0SFNWQSguLi5uLnRvSFNWQSgpLCEwKSx0aGlzLl9lbWl0KFwic3dhdGNoc2VsZWN0XCIsbiksdGhpcy5fZW1pdChcImNoYW5nZVwiLG4sXCJzd2F0Y2hcIix0aGlzKX0pKSksITB9cmV0dXJuITF9cmVtb3ZlU3dhdGNoKHQpe2NvbnN0IGU9dGhpcy5fc3dhdGNoQ29sb3JzW3RdO2lmKGUpe2NvbnN0e2VsOm99PWU7cmV0dXJuIHRoaXMuX3Jvb3Quc3dhdGNoZXMucmVtb3ZlQ2hpbGQobyksdGhpcy5fc3dhdGNoQ29sb3JzLnNwbGljZSh0LDEpLCEwfXJldHVybiExfWFwcGx5Q29sb3IodD0hMSl7Y29uc3R7cHJldmlldzplLGJ1dHRvbjpvfT10aGlzLl9yb290LG49dGhpcy5fY29sb3IudG9SR0JBKCkudG9TdHJpbmcoMCk7cmV0dXJuIGUubGFzdENvbG9yLnN0eWxlLnNldFByb3BlcnR5KFwiLS1wY3ItY29sb3JcIixuKSx0aGlzLm9wdGlvbnMudXNlQXNCdXR0b258fG8uc3R5bGUuc2V0UHJvcGVydHkoXCItLXBjci1jb2xvclwiLG4pLG8uY2xhc3NMaXN0LnJlbW92ZShcImNsZWFyXCIpLHRoaXMuX2xhc3RDb2xvcj10aGlzLl9jb2xvci5jbG9uZSgpLHRoaXMuX2luaXRpYWxpemluZ0FjdGl2ZXx8dHx8dGhpcy5fZW1pdChcInNhdmVcIix0aGlzLl9jb2xvciksdGhpc31kZXN0cm95KCl7Y2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5fc2V0dXBBbmltYXRpb25GcmFtZSksdGhpcy5fZXZlbnRCaW5kaW5ncy5mb3JFYWNoKCh0PT5zKC4uLnQpKSksT2JqZWN0LmtleXModGhpcy5fY29tcG9uZW50cykuZm9yRWFjaCgodD0+dGhpcy5fY29tcG9uZW50c1t0XS5kZXN0cm95KCkpKX1kZXN0cm95QW5kUmVtb3ZlKCl7dGhpcy5kZXN0cm95KCk7Y29uc3R7cm9vdDp0LGFwcDplfT10aGlzLl9yb290O3QucGFyZW50RWxlbWVudCYmdC5wYXJlbnRFbGVtZW50LnJlbW92ZUNoaWxkKHQpLGUucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZChlKSxPYmplY3Qua2V5cyh0aGlzKS5mb3JFYWNoKCh0PT50aGlzW3RdPW51bGwpKX1oaWRlKCl7cmV0dXJuISF0aGlzLmlzT3BlbigpJiYodGhpcy5fcm9vdC5hcHAuY2xhc3NMaXN0LnJlbW92ZShcInZpc2libGVcIiksdGhpcy5fZW1pdChcImhpZGVcIiksITApfXNob3coKXtyZXR1cm4hdGhpcy5vcHRpb25zLmRpc2FibGVkJiYhdGhpcy5pc09wZW4oKSYmKHRoaXMuX3Jvb3QuYXBwLmNsYXNzTGlzdC5hZGQoXCJ2aXNpYmxlXCIpLHRoaXMuX3JlUG9zaXRpb25pbmdQaWNrZXIoKSx0aGlzLl9lbWl0KFwic2hvd1wiLHRoaXMuX2NvbG9yKSx0aGlzKX1pc09wZW4oKXtyZXR1cm4gdGhpcy5fcm9vdC5hcHAuY2xhc3NMaXN0LmNvbnRhaW5zKFwidmlzaWJsZVwiKX1zZXRIU1ZBKHQ9MzYwLGU9MCxvPTAsbj0xLGk9ITEpe2NvbnN0IHM9dGhpcy5fcmVjYWxjO2lmKHRoaXMuX3JlY2FsYz0hMSx0PDB8fHQ+MzYwfHxlPDB8fGU+MTAwfHxvPDB8fG8+MTAwfHxuPDB8fG4+MSlyZXR1cm4hMTt0aGlzLl9jb2xvcj1BKHQsZSxvLG4pO2NvbnN0e2h1ZTpyLG9wYWNpdHk6YSxwYWxldHRlOmx9PXRoaXMuX2NvbXBvbmVudHM7cmV0dXJuIHIudXBkYXRlKHQvMzYwKSxhLnVwZGF0ZShuKSxsLnVwZGF0ZShlLzEwMCwxLW8vMTAwKSxpfHx0aGlzLmFwcGx5Q29sb3IoKSxzJiZ0aGlzLl91cGRhdGVPdXRwdXQoKSx0aGlzLl9yZWNhbGM9cywhMH1zZXRDb2xvcih0LGU9ITEpe2lmKG51bGw9PT10KXJldHVybiB0aGlzLl9jbGVhckNvbG9yKGUpLCEwO2NvbnN0e3ZhbHVlczpvLHR5cGU6bn09dGhpcy5fcGFyc2VMb2NhbENvbG9yKHQpO2lmKG8pe2NvbnN0IHQ9bi50b1VwcGVyQ2FzZSgpLHtvcHRpb25zOml9PXRoaXMuX3Jvb3QuaW50ZXJhY3Rpb24scz1pLmZpbmQoKGU9PmUuZ2V0QXR0cmlidXRlKFwiZGF0YS10eXBlXCIpPT09dCkpO2lmKHMmJiFzLmhpZGRlbilmb3IoY29uc3QgdCBvZiBpKXQuY2xhc3NMaXN0W3Q9PT1zP1wiYWRkXCI6XCJyZW1vdmVcIl0oXCJhY3RpdmVcIik7cmV0dXJuISF0aGlzLnNldEhTVkEoLi4ubyxlKSYmdGhpcy5zZXRDb2xvclJlcHJlc2VudGF0aW9uKHQpfXJldHVybiExfXNldENvbG9yUmVwcmVzZW50YXRpb24odCl7cmV0dXJuIHQ9dC50b1VwcGVyQ2FzZSgpLCEhdGhpcy5fcm9vdC5pbnRlcmFjdGlvbi5vcHRpb25zLmZpbmQoKGU9PmUuZ2V0QXR0cmlidXRlKFwiZGF0YS10eXBlXCIpLnN0YXJ0c1dpdGgodCkmJiFlLmNsaWNrKCkpKX1nZXRDb2xvclJlcHJlc2VudGF0aW9uKCl7cmV0dXJuIHRoaXMuX3JlcHJlc2VudGF0aW9ufWdldENvbG9yKCl7cmV0dXJuIHRoaXMuX2NvbG9yfWdldFNlbGVjdGVkQ29sb3IoKXtyZXR1cm4gdGhpcy5fbGFzdENvbG9yfWdldFJvb3QoKXtyZXR1cm4gdGhpcy5fcm9vdH1kaXNhYmxlKCl7cmV0dXJuIHRoaXMuaGlkZSgpLHRoaXMub3B0aW9ucy5kaXNhYmxlZD0hMCx0aGlzLl9yb290LmJ1dHRvbi5jbGFzc0xpc3QuYWRkKFwiZGlzYWJsZWRcIiksdGhpc31lbmFibGUoKXtyZXR1cm4gdGhpcy5vcHRpb25zLmRpc2FibGVkPSExLHRoaXMuX3Jvb3QuYnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoXCJkaXNhYmxlZFwiKSx0aGlzfX1yZXR1cm4gZT1lLmRlZmF1bHR9KSgpKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1waWNrci5taW4uanMubWFwIiwiLyoqXG4gKiBDb252ZXJ0IGZyb20gYSBCYXNlNjRVUkwtZW5jb2RlZCBzdHJpbmcgdG8gYW4gQXJyYXkgQnVmZmVyLiBCZXN0IHVzZWQgd2hlbiBjb252ZXJ0aW5nIGFcbiAqIGNyZWRlbnRpYWwgSUQgZnJvbSBhIEpTT04gc3RyaW5nIHRvIGFuIEFycmF5QnVmZmVyLCBsaWtlIGluIGFsbG93Q3JlZGVudGlhbHMgb3JcbiAqIGV4Y2x1ZGVDcmVkZW50aWFsc1xuICpcbiAqIEhlbHBlciBtZXRob2QgdG8gY29tcGxpbWVudCBgYnVmZmVyVG9CYXNlNjRVUkxTdHJpbmdgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiYXNlNjRVUkxTdHJpbmdUb0J1ZmZlcihiYXNlNjRVUkxTdHJpbmcpIHtcbiAgICAvLyBDb252ZXJ0IGZyb20gQmFzZTY0VVJMIHRvIEJhc2U2NFxuICAgIGNvbnN0IGJhc2U2NCA9IGJhc2U2NFVSTFN0cmluZy5yZXBsYWNlKC8tL2csICcrJykucmVwbGFjZSgvXy9nLCAnLycpO1xuICAgIC8qKlxuICAgICAqIFBhZCB3aXRoICc9JyB1bnRpbCBpdCdzIGEgbXVsdGlwbGUgb2YgZm91clxuICAgICAqICg0IC0gKDg1ICUgNCA9IDEpID0gMykgJSA0ID0gMyBwYWRkaW5nXG4gICAgICogKDQgLSAoODYgJSA0ID0gMikgPSAyKSAlIDQgPSAyIHBhZGRpbmdcbiAgICAgKiAoNCAtICg4NyAlIDQgPSAzKSA9IDEpICUgNCA9IDEgcGFkZGluZ1xuICAgICAqICg0IC0gKDg4ICUgNCA9IDApID0gNCkgJSA0ID0gMCBwYWRkaW5nXG4gICAgICovXG4gICAgY29uc3QgcGFkTGVuZ3RoID0gKDQgLSAoYmFzZTY0Lmxlbmd0aCAlIDQpKSAlIDQ7XG4gICAgY29uc3QgcGFkZGVkID0gYmFzZTY0LnBhZEVuZChiYXNlNjQubGVuZ3RoICsgcGFkTGVuZ3RoLCAnPScpO1xuICAgIC8vIENvbnZlcnQgdG8gYSBiaW5hcnkgc3RyaW5nXG4gICAgY29uc3QgYmluYXJ5ID0gYXRvYihwYWRkZWQpO1xuICAgIC8vIENvbnZlcnQgYmluYXJ5IHN0cmluZyB0byBidWZmZXJcbiAgICBjb25zdCBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYmluYXJ5Lmxlbmd0aCk7XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmluYXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGJ5dGVzW2ldID0gYmluYXJ5LmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuICAgIHJldHVybiBidWZmZXI7XG59XG4iLCIvKipcbiAqIERldGVybWluZSBpZiB0aGUgYnJvd3NlciBpcyBjYXBhYmxlIG9mIFdlYmF1dGhuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBicm93c2VyU3VwcG9ydHNXZWJBdXRobigpIHtcbiAgICByZXR1cm4gX2Jyb3dzZXJTdXBwb3J0c1dlYkF1dGhuSW50ZXJuYWxzLnN0dWJUaGlzKGdsb2JhbFRoaXM/LlB1YmxpY0tleUNyZWRlbnRpYWwgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICB0eXBlb2YgZ2xvYmFsVGhpcy5QdWJsaWNLZXlDcmVkZW50aWFsID09PSAnZnVuY3Rpb24nKTtcbn1cbi8qKlxuICogTWFrZSBpdCBwb3NzaWJsZSB0byBzdHViIHRoZSByZXR1cm4gdmFsdWUgZHVyaW5nIHRlc3RpbmdcbiAqIEBpZ25vcmUgRG9uJ3QgaW5jbHVkZSB0aGlzIGluIGRvY3Mgb3V0cHV0XG4gKi9cbmV4cG9ydCBjb25zdCBfYnJvd3NlclN1cHBvcnRzV2ViQXV0aG5JbnRlcm5hbHMgPSB7XG4gICAgc3R1YlRoaXM6ICh2YWx1ZSkgPT4gdmFsdWUsXG59O1xuIiwiaW1wb3J0IHsgYnJvd3NlclN1cHBvcnRzV2ViQXV0aG4gfSBmcm9tICcuL2Jyb3dzZXJTdXBwb3J0c1dlYkF1dGhuLmpzJztcbi8qKlxuICogRGV0ZXJtaW5lIGlmIHRoZSBicm93c2VyIHN1cHBvcnRzIGNvbmRpdGlvbmFsIFVJLCBzbyB0aGF0IFdlYkF1dGhuIGNyZWRlbnRpYWxzIGNhblxuICogYmUgc2hvd24gdG8gdGhlIHVzZXIgaW4gdGhlIGJyb3dzZXIncyB0eXBpY2FsIHBhc3N3b3JkIGF1dG9maWxsIHBvcHVwLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYnJvd3NlclN1cHBvcnRzV2ViQXV0aG5BdXRvZmlsbCgpIHtcbiAgICBpZiAoIWJyb3dzZXJTdXBwb3J0c1dlYkF1dGhuKCkpIHtcbiAgICAgICAgcmV0dXJuIF9icm93c2VyU3VwcG9ydHNXZWJBdXRobkF1dG9maWxsSW50ZXJuYWxzLnN0dWJUaGlzKG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiByZXNvbHZlKGZhbHNlKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJIGRvbid0IGxpa2UgdGhlIGBhcyB1bmtub3duYCBoZXJlIGJ1dCB0aGVyZSdzIGEgYGRlY2xhcmUgdmFyIFB1YmxpY0tleUNyZWRlbnRpYWxgIGluXG4gICAgICogVFMnIERPTSBsaWIgdGhhdCdzIG1ha2luZyBpdCBkaWZmaWN1bHQgZm9yIG1lIHRvIGp1c3QgZ28gYGFzIFB1YmxpY0tleUNyZWRlbnRpYWxGdXR1cmVgIGFzIElcbiAgICAgKiB3YW50LiBJIHRoaW5rIEknbSBmaW5lIHdpdGggdGhpcyBmb3Igbm93IHNpbmNlIGl0J3MgX3N1cHBvc2VkXyB0byBiZSB0ZW1wb3JhcnksIHVudGlsIFRTIHR5cGVzXG4gICAgICogaGF2ZSBhIGNoYW5jZSB0byBjYXRjaCB1cC5cbiAgICAgKi9cbiAgICBjb25zdCBnbG9iYWxQdWJsaWNLZXlDcmVkZW50aWFsID0gZ2xvYmFsVGhpc1xuICAgICAgICAuUHVibGljS2V5Q3JlZGVudGlhbDtcbiAgICBpZiAoZ2xvYmFsUHVibGljS2V5Q3JlZGVudGlhbD8uaXNDb25kaXRpb25hbE1lZGlhdGlvbkF2YWlsYWJsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBfYnJvd3NlclN1cHBvcnRzV2ViQXV0aG5BdXRvZmlsbEludGVybmFscy5zdHViVGhpcyhuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gcmVzb2x2ZShmYWxzZSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIF9icm93c2VyU3VwcG9ydHNXZWJBdXRobkF1dG9maWxsSW50ZXJuYWxzLnN0dWJUaGlzKGdsb2JhbFB1YmxpY0tleUNyZWRlbnRpYWwuaXNDb25kaXRpb25hbE1lZGlhdGlvbkF2YWlsYWJsZSgpKTtcbn1cbi8vIE1ha2UgaXQgcG9zc2libGUgdG8gc3R1YiB0aGUgcmV0dXJuIHZhbHVlIGR1cmluZyB0ZXN0aW5nXG5leHBvcnQgY29uc3QgX2Jyb3dzZXJTdXBwb3J0c1dlYkF1dGhuQXV0b2ZpbGxJbnRlcm5hbHMgPSB7XG4gICAgc3R1YlRoaXM6ICh2YWx1ZSkgPT4gdmFsdWUsXG59O1xuIiwiLyoqXG4gKiBDb252ZXJ0IHRoZSBnaXZlbiBhcnJheSBidWZmZXIgaW50byBhIEJhc2U2NFVSTC1lbmNvZGVkIHN0cmluZy4gSWRlYWwgZm9yIGNvbnZlcnRpbmcgdmFyaW91c1xuICogY3JlZGVudGlhbCByZXNwb25zZSBBcnJheUJ1ZmZlcnMgdG8gc3RyaW5nIGZvciBzZW5kaW5nIGJhY2sgdG8gdGhlIHNlcnZlciBhcyBKU09OLlxuICpcbiAqIEhlbHBlciBtZXRob2QgdG8gY29tcGxpbWVudCBgYmFzZTY0VVJMU3RyaW5nVG9CdWZmZXJgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBidWZmZXJUb0Jhc2U2NFVSTFN0cmluZyhidWZmZXIpIHtcbiAgICBjb25zdCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgbGV0IHN0ciA9ICcnO1xuICAgIGZvciAoY29uc3QgY2hhckNvZGUgb2YgYnl0ZXMpIHtcbiAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xuICAgIH1cbiAgICBjb25zdCBiYXNlNjRTdHJpbmcgPSBidG9hKHN0cik7XG4gICAgcmV0dXJuIGJhc2U2NFN0cmluZy5yZXBsYWNlKC9cXCsvZywgJy0nKS5yZXBsYWNlKC9cXC8vZywgJ18nKS5yZXBsYWNlKC89L2csICcnKTtcbn1cbiIsImltcG9ydCB7IGlzVmFsaWREb21haW4gfSBmcm9tICcuL2lzVmFsaWREb21haW4uanMnO1xuaW1wb3J0IHsgV2ViQXV0aG5FcnJvciB9IGZyb20gJy4vd2ViQXV0aG5FcnJvci5qcyc7XG4vKipcbiAqIEF0dGVtcHQgdG8gaW50dWl0IF93aHlfIGFuIGVycm9yIHdhcyByYWlzZWQgYWZ0ZXIgY2FsbGluZyBgbmF2aWdhdG9yLmNyZWRlbnRpYWxzLmdldCgpYFxuICovXG5leHBvcnQgZnVuY3Rpb24gaWRlbnRpZnlBdXRoZW50aWNhdGlvbkVycm9yKHsgZXJyb3IsIG9wdGlvbnMsIH0pIHtcbiAgICBjb25zdCB7IHB1YmxpY0tleSB9ID0gb3B0aW9ucztcbiAgICBpZiAoIXB1YmxpY0tleSkge1xuICAgICAgICB0aHJvdyBFcnJvcignb3B0aW9ucyB3YXMgbWlzc2luZyByZXF1aXJlZCBwdWJsaWNLZXkgcHJvcGVydHknKTtcbiAgICB9XG4gICAgaWYgKGVycm9yLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xuICAgICAgICBpZiAob3B0aW9ucy5zaWduYWwgaW5zdGFuY2VvZiBBYm9ydFNpZ25hbCkge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYmF1dGhuLTIvI3NjdG4tY3JlYXRlQ3JlZGVudGlhbCAoU3RlcCAxNilcbiAgICAgICAgICAgIHJldHVybiBuZXcgV2ViQXV0aG5FcnJvcih7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ0F1dGhlbnRpY2F0aW9uIGNlcmVtb255IHdhcyBzZW50IGFuIGFib3J0IHNpZ25hbCcsXG4gICAgICAgICAgICAgICAgY29kZTogJ0VSUk9SX0NFUkVNT05ZX0FCT1JURUQnLFxuICAgICAgICAgICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGVycm9yLm5hbWUgPT09ICdOb3RBbGxvd2VkRXJyb3InKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQYXNzIHRoZSBlcnJvciBkaXJlY3RseSB0aHJvdWdoLiBQbGF0Zm9ybXMgYXJlIG92ZXJsb2FkaW5nIHRoaXMgZXJyb3IgYmV5b25kIHdoYXQgdGhlIHNwZWNcbiAgICAgICAgICogZGVmaW5lcyBhbmQgd2UgZG9uJ3Qgd2FudCB0byBvdmVyd3JpdGUgcG90ZW50aWFsbHkgdXNlZnVsIGVycm9yIG1lc3NhZ2VzLlxuICAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuIG5ldyBXZWJBdXRobkVycm9yKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2UsXG4gICAgICAgICAgICBjb2RlOiAnRVJST1JfUEFTU1RIUk9VR0hfU0VFX0NBVVNFX1BST1BFUlRZJyxcbiAgICAgICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVycm9yLm5hbWUgPT09ICdTZWN1cml0eUVycm9yJykge1xuICAgICAgICBjb25zdCBlZmZlY3RpdmVEb21haW4gPSBnbG9iYWxUaGlzLmxvY2F0aW9uLmhvc3RuYW1lO1xuICAgICAgICBpZiAoIWlzVmFsaWREb21haW4oZWZmZWN0aXZlRG9tYWluKSkge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYmF1dGhuLTIvI3NjdG4tZGlzY292ZXItZnJvbS1leHRlcm5hbC1zb3VyY2UgKFN0ZXAgNSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgV2ViQXV0aG5FcnJvcih7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogYCR7Z2xvYmFsVGhpcy5sb2NhdGlvbi5ob3N0bmFtZX0gaXMgYW4gaW52YWxpZCBkb21haW5gLFxuICAgICAgICAgICAgICAgIGNvZGU6ICdFUlJPUl9JTlZBTElEX0RPTUFJTicsXG4gICAgICAgICAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHVibGljS2V5LnJwSWQgIT09IGVmZmVjdGl2ZURvbWFpbikge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYmF1dGhuLTIvI3NjdG4tZGlzY292ZXItZnJvbS1leHRlcm5hbC1zb3VyY2UgKFN0ZXAgNilcbiAgICAgICAgICAgIHJldHVybiBuZXcgV2ViQXV0aG5FcnJvcih7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogYFRoZSBSUCBJRCBcIiR7cHVibGljS2V5LnJwSWR9XCIgaXMgaW52YWxpZCBmb3IgdGhpcyBkb21haW5gLFxuICAgICAgICAgICAgICAgIGNvZGU6ICdFUlJPUl9JTlZBTElEX1JQX0lEJyxcbiAgICAgICAgICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChlcnJvci5uYW1lID09PSAnVW5rbm93bkVycm9yJykge1xuICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvd2ViYXV0aG4tMi8jc2N0bi1vcC1nZXQtYXNzZXJ0aW9uIChTdGVwIDEpXG4gICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJhdXRobi0yLyNzY3RuLW9wLWdldC1hc3NlcnRpb24gKFN0ZXAgMTIpXG4gICAgICAgIHJldHVybiBuZXcgV2ViQXV0aG5FcnJvcih7XG4gICAgICAgICAgICBtZXNzYWdlOiAnVGhlIGF1dGhlbnRpY2F0b3Igd2FzIHVuYWJsZSB0byBwcm9jZXNzIHRoZSBzcGVjaWZpZWQgb3B0aW9ucywgb3IgY291bGQgbm90IGNyZWF0ZSBhIG5ldyBhc3NlcnRpb24gc2lnbmF0dXJlJyxcbiAgICAgICAgICAgIGNvZGU6ICdFUlJPUl9BVVRIRU5USUNBVE9SX0dFTkVSQUxfRVJST1InLFxuICAgICAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9yO1xufVxuIiwiaW1wb3J0IHsgaXNWYWxpZERvbWFpbiB9IGZyb20gJy4vaXNWYWxpZERvbWFpbi5qcyc7XG5pbXBvcnQgeyBXZWJBdXRobkVycm9yIH0gZnJvbSAnLi93ZWJBdXRobkVycm9yLmpzJztcbi8qKlxuICogQXR0ZW1wdCB0byBpbnR1aXQgX3doeV8gYW4gZXJyb3Igd2FzIHJhaXNlZCBhZnRlciBjYWxsaW5nIGBuYXZpZ2F0b3IuY3JlZGVudGlhbHMuY3JlYXRlKClgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpZGVudGlmeVJlZ2lzdHJhdGlvbkVycm9yKHsgZXJyb3IsIG9wdGlvbnMsIH0pIHtcbiAgICBjb25zdCB7IHB1YmxpY0tleSB9ID0gb3B0aW9ucztcbiAgICBpZiAoIXB1YmxpY0tleSkge1xuICAgICAgICB0aHJvdyBFcnJvcignb3B0aW9ucyB3YXMgbWlzc2luZyByZXF1aXJlZCBwdWJsaWNLZXkgcHJvcGVydHknKTtcbiAgICB9XG4gICAgaWYgKGVycm9yLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xuICAgICAgICBpZiAob3B0aW9ucy5zaWduYWwgaW5zdGFuY2VvZiBBYm9ydFNpZ25hbCkge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYmF1dGhuLTIvI3NjdG4tY3JlYXRlQ3JlZGVudGlhbCAoU3RlcCAxNilcbiAgICAgICAgICAgIHJldHVybiBuZXcgV2ViQXV0aG5FcnJvcih7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ1JlZ2lzdHJhdGlvbiBjZXJlbW9ueSB3YXMgc2VudCBhbiBhYm9ydCBzaWduYWwnLFxuICAgICAgICAgICAgICAgIGNvZGU6ICdFUlJPUl9DRVJFTU9OWV9BQk9SVEVEJyxcbiAgICAgICAgICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChlcnJvci5uYW1lID09PSAnQ29uc3RyYWludEVycm9yJykge1xuICAgICAgICBpZiAocHVibGljS2V5LmF1dGhlbnRpY2F0b3JTZWxlY3Rpb24/LnJlcXVpcmVSZXNpZGVudEtleSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYmF1dGhuLTIvI3NjdG4tb3AtbWFrZS1jcmVkIChTdGVwIDQpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFdlYkF1dGhuRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdEaXNjb3ZlcmFibGUgY3JlZGVudGlhbHMgd2VyZSByZXF1aXJlZCBidXQgbm8gYXZhaWxhYmxlIGF1dGhlbnRpY2F0b3Igc3VwcG9ydGVkIGl0JyxcbiAgICAgICAgICAgICAgICBjb2RlOiAnRVJST1JfQVVUSEVOVElDQVRPUl9NSVNTSU5HX0RJU0NPVkVSQUJMRV9DUkVERU5USUFMX1NVUFBPUlQnLFxuICAgICAgICAgICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAvLyBAdHMtaWdub3JlOiBgbWVkaWF0aW9uYCBkb2Vzbid0IHlldCBleGlzdCBvbiBDcmVkZW50aWFsQ3JlYXRpb25PcHRpb25zIGJ1dCBpdCdzIHBvc3NpYmxlIGFzIG9mIFNlcHQgMjAyNFxuICAgICAgICBvcHRpb25zLm1lZGlhdGlvbiA9PT0gJ2NvbmRpdGlvbmFsJyAmJlxuICAgICAgICAgICAgcHVibGljS2V5LmF1dGhlbnRpY2F0b3JTZWxlY3Rpb24/LnVzZXJWZXJpZmljYXRpb24gPT09ICdyZXF1aXJlZCcpIHtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vdzNjLmdpdGh1Yi5pby93ZWJhdXRobi8jc2N0bi1jcmVhdGVDcmVkZW50aWFsIChTdGVwIDIyLjQpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFdlYkF1dGhuRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6ICdVc2VyIHZlcmlmaWNhdGlvbiB3YXMgcmVxdWlyZWQgZHVyaW5nIGF1dG9tYXRpYyByZWdpc3RyYXRpb24gYnV0IGl0IGNvdWxkIG5vdCBiZSBwZXJmb3JtZWQnLFxuICAgICAgICAgICAgICAgIGNvZGU6ICdFUlJPUl9BVVRPX1JFR0lTVEVSX1VTRVJfVkVSSUZJQ0FUSU9OX0ZBSUxVUkUnLFxuICAgICAgICAgICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHB1YmxpY0tleS5hdXRoZW50aWNhdG9yU2VsZWN0aW9uPy51c2VyVmVyaWZpY2F0aW9uID09PSAncmVxdWlyZWQnKSB7XG4gICAgICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvd2ViYXV0aG4tMi8jc2N0bi1vcC1tYWtlLWNyZWQgKFN0ZXAgNSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgV2ViQXV0aG5FcnJvcih7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ1VzZXIgdmVyaWZpY2F0aW9uIHdhcyByZXF1aXJlZCBidXQgbm8gYXZhaWxhYmxlIGF1dGhlbnRpY2F0b3Igc3VwcG9ydGVkIGl0JyxcbiAgICAgICAgICAgICAgICBjb2RlOiAnRVJST1JfQVVUSEVOVElDQVRPUl9NSVNTSU5HX1VTRVJfVkVSSUZJQ0FUSU9OX1NVUFBPUlQnLFxuICAgICAgICAgICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGVycm9yLm5hbWUgPT09ICdJbnZhbGlkU3RhdGVFcnJvcicpIHtcbiAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYmF1dGhuLTIvI3NjdG4tY3JlYXRlQ3JlZGVudGlhbCAoU3RlcCAyMClcbiAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYmF1dGhuLTIvI3NjdG4tb3AtbWFrZS1jcmVkIChTdGVwIDMpXG4gICAgICAgIHJldHVybiBuZXcgV2ViQXV0aG5FcnJvcih7XG4gICAgICAgICAgICBtZXNzYWdlOiAnVGhlIGF1dGhlbnRpY2F0b3Igd2FzIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCcsXG4gICAgICAgICAgICBjb2RlOiAnRVJST1JfQVVUSEVOVElDQVRPUl9QUkVWSU9VU0xZX1JFR0lTVEVSRUQnLFxuICAgICAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXJyb3IubmFtZSA9PT0gJ05vdEFsbG93ZWRFcnJvcicpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhc3MgdGhlIGVycm9yIGRpcmVjdGx5IHRocm91Z2guIFBsYXRmb3JtcyBhcmUgb3ZlcmxvYWRpbmcgdGhpcyBlcnJvciBiZXlvbmQgd2hhdCB0aGUgc3BlY1xuICAgICAgICAgKiBkZWZpbmVzIGFuZCB3ZSBkb24ndCB3YW50IHRvIG92ZXJ3cml0ZSBwb3RlbnRpYWxseSB1c2VmdWwgZXJyb3IgbWVzc2FnZXMuXG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gbmV3IFdlYkF1dGhuRXJyb3Ioe1xuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICAgIGNvZGU6ICdFUlJPUl9QQVNTVEhST1VHSF9TRUVfQ0FVU0VfUFJPUEVSVFknLFxuICAgICAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXJyb3IubmFtZSA9PT0gJ05vdFN1cHBvcnRlZEVycm9yJykge1xuICAgICAgICBjb25zdCB2YWxpZFB1YktleUNyZWRQYXJhbXMgPSBwdWJsaWNLZXkucHViS2V5Q3JlZFBhcmFtcy5maWx0ZXIoKHBhcmFtKSA9PiBwYXJhbS50eXBlID09PSAncHVibGljLWtleScpO1xuICAgICAgICBpZiAodmFsaWRQdWJLZXlDcmVkUGFyYW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYmF1dGhuLTIvI3NjdG4tY3JlYXRlQ3JlZGVudGlhbCAoU3RlcCAxMClcbiAgICAgICAgICAgIHJldHVybiBuZXcgV2ViQXV0aG5FcnJvcih7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ05vIGVudHJ5IGluIHB1YktleUNyZWRQYXJhbXMgd2FzIG9mIHR5cGUgXCJwdWJsaWMta2V5XCInLFxuICAgICAgICAgICAgICAgIGNvZGU6ICdFUlJPUl9NQUxGT1JNRURfUFVCS0VZQ1JFRFBBUkFNUycsXG4gICAgICAgICAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYmF1dGhuLTIvI3NjdG4tb3AtbWFrZS1jcmVkIChTdGVwIDIpXG4gICAgICAgIHJldHVybiBuZXcgV2ViQXV0aG5FcnJvcih7XG4gICAgICAgICAgICBtZXNzYWdlOiAnTm8gYXZhaWxhYmxlIGF1dGhlbnRpY2F0b3Igc3VwcG9ydGVkIGFueSBvZiB0aGUgc3BlY2lmaWVkIHB1YktleUNyZWRQYXJhbXMgYWxnb3JpdGhtcycsXG4gICAgICAgICAgICBjb2RlOiAnRVJST1JfQVVUSEVOVElDQVRPUl9OT19TVVBQT1JURURfUFVCS0VZQ1JFRFBBUkFNU19BTEcnLFxuICAgICAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZXJyb3IubmFtZSA9PT0gJ1NlY3VyaXR5RXJyb3InKSB7XG4gICAgICAgIGNvbnN0IGVmZmVjdGl2ZURvbWFpbiA9IGdsb2JhbFRoaXMubG9jYXRpb24uaG9zdG5hbWU7XG4gICAgICAgIGlmICghaXNWYWxpZERvbWFpbihlZmZlY3RpdmVEb21haW4pKSB7XG4gICAgICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvd2ViYXV0aG4tMi8jc2N0bi1jcmVhdGVDcmVkZW50aWFsIChTdGVwIDcpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFdlYkF1dGhuRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGAke2dsb2JhbFRoaXMubG9jYXRpb24uaG9zdG5hbWV9IGlzIGFuIGludmFsaWQgZG9tYWluYCxcbiAgICAgICAgICAgICAgICBjb2RlOiAnRVJST1JfSU5WQUxJRF9ET01BSU4nLFxuICAgICAgICAgICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHB1YmxpY0tleS5ycC5pZCAhPT0gZWZmZWN0aXZlRG9tYWluKSB7XG4gICAgICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvd2ViYXV0aG4tMi8jc2N0bi1jcmVhdGVDcmVkZW50aWFsIChTdGVwIDgpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFdlYkF1dGhuRXJyb3Ioe1xuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBUaGUgUlAgSUQgXCIke3B1YmxpY0tleS5ycC5pZH1cIiBpcyBpbnZhbGlkIGZvciB0aGlzIGRvbWFpbmAsXG4gICAgICAgICAgICAgICAgY29kZTogJ0VSUk9SX0lOVkFMSURfUlBfSUQnLFxuICAgICAgICAgICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGVycm9yLm5hbWUgPT09ICdUeXBlRXJyb3InKSB7XG4gICAgICAgIGlmIChwdWJsaWNLZXkudXNlci5pZC5ieXRlTGVuZ3RoIDwgMSB8fCBwdWJsaWNLZXkudXNlci5pZC5ieXRlTGVuZ3RoID4gNjQpIHtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi93ZWJhdXRobi0yLyNzY3RuLWNyZWF0ZUNyZWRlbnRpYWwgKFN0ZXAgNSlcbiAgICAgICAgICAgIHJldHVybiBuZXcgV2ViQXV0aG5FcnJvcih7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogJ1VzZXIgSUQgd2FzIG5vdCBiZXR3ZWVuIDEgYW5kIDY0IGNoYXJhY3RlcnMnLFxuICAgICAgICAgICAgICAgIGNvZGU6ICdFUlJPUl9JTlZBTElEX1VTRVJfSURfTEVOR1RIJyxcbiAgICAgICAgICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChlcnJvci5uYW1lID09PSAnVW5rbm93bkVycm9yJykge1xuICAgICAgICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvd2ViYXV0aG4tMi8jc2N0bi1vcC1tYWtlLWNyZWQgKFN0ZXAgMSlcbiAgICAgICAgLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSL3dlYmF1dGhuLTIvI3NjdG4tb3AtbWFrZS1jcmVkIChTdGVwIDgpXG4gICAgICAgIHJldHVybiBuZXcgV2ViQXV0aG5FcnJvcih7XG4gICAgICAgICAgICBtZXNzYWdlOiAnVGhlIGF1dGhlbnRpY2F0b3Igd2FzIHVuYWJsZSB0byBwcm9jZXNzIHRoZSBzcGVjaWZpZWQgb3B0aW9ucywgb3IgY291bGQgbm90IGNyZWF0ZSBhIG5ldyBjcmVkZW50aWFsJyxcbiAgICAgICAgICAgIGNvZGU6ICdFUlJPUl9BVVRIRU5USUNBVE9SX0dFTkVSQUxfRVJST1InLFxuICAgICAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9yO1xufVxuIiwiLyoqXG4gKiBBIHNpbXBsZSB0ZXN0IHRvIGRldGVybWluZSBpZiBhIGhvc3RuYW1lIGlzIGEgcHJvcGVybHktZm9ybWF0dGVkIGRvbWFpbiBuYW1lXG4gKlxuICogQSBcInZhbGlkIGRvbWFpblwiIGlzIGRlZmluZWQgaGVyZTogaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN2YWxpZC1kb21haW5cbiAqXG4gKiBSZWdleCBzb3VyY2VkIGZyb20gaGVyZTpcbiAqIGh0dHBzOi8vd3d3Lm9yZWlsbHkuY29tL2xpYnJhcnkvdmlldy9yZWd1bGFyLWV4cHJlc3Npb25zLWNvb2tib29rLzk3ODE0NDkzMjc0NTMvY2gwOHMxNS5odG1sXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkRG9tYWluKGhvc3RuYW1lKSB7XG4gICAgcmV0dXJuIChcbiAgICAvLyBDb25zaWRlciBsb2NhbGhvc3QgdmFsaWQgYXMgd2VsbCBzaW5jZSBpdCdzIG9rYXkgd3J0IFNlY3VyZSBDb250ZXh0c1xuICAgIGhvc3RuYW1lID09PSAnbG9jYWxob3N0JyB8fFxuICAgICAgICAvXihbYS16MC05XSsoLVthLXowLTldKykqXFwuKStbYS16XXsyLH0kL2kudGVzdChob3N0bmFtZSkpO1xufVxuIiwiaW1wb3J0IHsgYnJvd3NlclN1cHBvcnRzV2ViQXV0aG4gfSBmcm9tICcuL2Jyb3dzZXJTdXBwb3J0c1dlYkF1dGhuLmpzJztcbi8qKlxuICogRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGJyb3dzZXIgY2FuIGNvbW11bmljYXRlIHdpdGggYSBidWlsdC1pbiBhdXRoZW50aWNhdG9yLCBsaWtlXG4gKiBUb3VjaCBJRCwgQW5kcm9pZCBmaW5nZXJwcmludCBzY2FubmVyLCBvciBXaW5kb3dzIEhlbGxvLlxuICpcbiAqIFRoaXMgbWV0aG9kIHdpbGwgX25vdF8gYmUgYWJsZSB0byB0ZWxsIHlvdSB0aGUgbmFtZSBvZiB0aGUgcGxhdGZvcm0gYXV0aGVudGljYXRvci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBsYXRmb3JtQXV0aGVudGljYXRvcklzQXZhaWxhYmxlKCkge1xuICAgIGlmICghYnJvd3NlclN1cHBvcnRzV2ViQXV0aG4oKSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHJlc29sdmUoZmFsc2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIFB1YmxpY0tleUNyZWRlbnRpYWwuaXNVc2VyVmVyaWZ5aW5nUGxhdGZvcm1BdXRoZW50aWNhdG9yQXZhaWxhYmxlKCk7XG59XG4iLCJjb25zdCBhdHRhY2htZW50cyA9IFsnY3Jvc3MtcGxhdGZvcm0nLCAncGxhdGZvcm0nXTtcbi8qKlxuICogSWYgcG9zc2libGUgY29lcmNlIGEgYHN0cmluZ2AgdmFsdWUgaW50byBhIGtub3duIGBBdXRoZW50aWNhdG9yQXR0YWNobWVudGBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQXV0aGVudGljYXRvckF0dGFjaG1lbnQoYXR0YWNobWVudCkge1xuICAgIGlmICghYXR0YWNobWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChhdHRhY2htZW50cy5pbmRleE9mKGF0dGFjaG1lbnQpIDwgMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiBhdHRhY2htZW50O1xufVxuIiwiaW1wb3J0IHsgYmFzZTY0VVJMU3RyaW5nVG9CdWZmZXIgfSBmcm9tICcuL2Jhc2U2NFVSTFN0cmluZ1RvQnVmZmVyLmpzJztcbmV4cG9ydCBmdW5jdGlvbiB0b1B1YmxpY0tleUNyZWRlbnRpYWxEZXNjcmlwdG9yKGRlc2NyaXB0b3IpIHtcbiAgICBjb25zdCB7IGlkIH0gPSBkZXNjcmlwdG9yO1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLmRlc2NyaXB0b3IsXG4gICAgICAgIGlkOiBiYXNlNjRVUkxTdHJpbmdUb0J1ZmZlcihpZCksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBgZGVzY3JpcHRvci50cmFuc3BvcnRzYCBpcyBhbiBhcnJheSBvZiBvdXIgYEF1dGhlbnRpY2F0b3JUcmFuc3BvcnRGdXR1cmVgIHRoYXQgaW5jbHVkZXMgbmV3ZXJcbiAgICAgICAgICogdHJhbnNwb3J0cyB0aGF0IFR5cGVTY3JpcHQncyBET00gbGliIGlzIGlnbm9yYW50IG9mLiBDb252aW5jZSBUUyB0aGF0IG91ciBsaXN0IG9mIHRyYW5zcG9ydHNcbiAgICAgICAgICogYXJlIGZpbmUgdG8gcGFzcyB0byBXZWJBdXRobiBzaW5jZSBicm93c2VycyB3aWxsIHJlY29nbml6ZSB0aGUgbmV3IHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgdHJhbnNwb3J0czogZGVzY3JpcHRvci50cmFuc3BvcnRzLFxuICAgIH07XG59XG4iLCJjbGFzcyBCYXNlV2ViQXV0aG5BYm9ydFNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJjb250cm9sbGVyXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiB2b2lkIDBcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNyZWF0ZU5ld0Fib3J0U2lnbmFsKCkge1xuICAgICAgICAvLyBBYm9ydCBhbnkgZXhpc3RpbmcgY2FsbHMgdG8gbmF2aWdhdG9yLmNyZWRlbnRpYWxzLmNyZWF0ZSgpIG9yIG5hdmlnYXRvci5jcmVkZW50aWFscy5nZXQoKVxuICAgICAgICBpZiAodGhpcy5jb250cm9sbGVyKSB7XG4gICAgICAgICAgICBjb25zdCBhYm9ydEVycm9yID0gbmV3IEVycm9yKCdDYW5jZWxsaW5nIGV4aXN0aW5nIFdlYkF1dGhuIEFQSSBjYWxsIGZvciBuZXcgb25lJyk7XG4gICAgICAgICAgICBhYm9ydEVycm9yLm5hbWUgPSAnQWJvcnRFcnJvcic7XG4gICAgICAgICAgICB0aGlzLmNvbnRyb2xsZXIuYWJvcnQoYWJvcnRFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgdGhpcy5jb250cm9sbGVyID0gbmV3Q29udHJvbGxlcjtcbiAgICAgICAgcmV0dXJuIG5ld0NvbnRyb2xsZXIuc2lnbmFsO1xuICAgIH1cbiAgICBjYW5jZWxDZXJlbW9ueSgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29udHJvbGxlcikge1xuICAgICAgICAgICAgY29uc3QgYWJvcnRFcnJvciA9IG5ldyBFcnJvcignTWFudWFsbHkgY2FuY2VsbGluZyBleGlzdGluZyBXZWJBdXRobiBBUEkgY2FsbCcpO1xuICAgICAgICAgICAgYWJvcnRFcnJvci5uYW1lID0gJ0Fib3J0RXJyb3InO1xuICAgICAgICAgICAgdGhpcy5jb250cm9sbGVyLmFib3J0KGFib3J0RXJyb3IpO1xuICAgICAgICAgICAgdGhpcy5jb250cm9sbGVyID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBBIHNlcnZpY2Ugc2luZ2xldG9uIHRvIGhlbHAgZW5zdXJlIHRoYXQgb25seSBhIHNpbmdsZSBXZWJBdXRobiBjZXJlbW9ueSBpcyBhY3RpdmUgYXQgYSB0aW1lLlxuICpcbiAqIFVzZXJzIG9mICoqQHNpbXBsZXdlYmF1dGhuL2Jyb3dzZXIqKiBzaG91bGRuJ3QgdHlwaWNhbGx5IG5lZWQgdG8gdXNlIHRoaXMsIGJ1dCBpdCBjYW4gaGVscCBlLmcuXG4gKiBkZXZlbG9wZXJzIGJ1aWxkaW5nIHByb2plY3RzIHRoYXQgdXNlIGNsaWVudC1zaWRlIHJvdXRpbmcgdG8gYmV0dGVyIGNvbnRyb2wgdGhlIGJlaGF2aW9yIG9mXG4gKiB0aGVpciBVWCBpbiByZXNwb25zZSB0byByb3V0ZXIgbmF2aWdhdGlvbiBldmVudHMuXG4gKi9cbmV4cG9ydCBjb25zdCBXZWJBdXRobkFib3J0U2VydmljZSA9IG5ldyBCYXNlV2ViQXV0aG5BYm9ydFNlcnZpY2UoKTtcbiIsIi8qKlxuICogQSBjdXN0b20gRXJyb3IgdXNlZCB0byByZXR1cm4gYSBtb3JlIG51YW5jZWQgZXJyb3IgZGV0YWlsaW5nIF93aHlfIG9uZSBvZiB0aGUgZWlnaHQgZG9jdW1lbnRlZFxuICogZXJyb3JzIGluIHRoZSBzcGVjIHdhcyByYWlzZWQgYWZ0ZXIgY2FsbGluZyBgbmF2aWdhdG9yLmNyZWRlbnRpYWxzLmNyZWF0ZSgpYCBvclxuICogYG5hdmlnYXRvci5jcmVkZW50aWFscy5nZXQoKWA6XG4gKlxuICogLSBgQWJvcnRFcnJvcmBcbiAqIC0gYENvbnN0cmFpbnRFcnJvcmBcbiAqIC0gYEludmFsaWRTdGF0ZUVycm9yYFxuICogLSBgTm90QWxsb3dlZEVycm9yYFxuICogLSBgTm90U3VwcG9ydGVkRXJyb3JgXG4gKiAtIGBTZWN1cml0eUVycm9yYFxuICogLSBgVHlwZUVycm9yYFxuICogLSBgVW5rbm93bkVycm9yYFxuICpcbiAqIEVycm9yIG1lc3NhZ2VzIHdlcmUgZGV0ZXJtaW5lZCB0aHJvdWdoIGludmVzdGlnYXRpb24gb2YgdGhlIHNwZWMgdG8gZGV0ZXJtaW5lIHVuZGVyIHdoaWNoXG4gKiBzY2VuYXJpb3MgYSBnaXZlbiBlcnJvciB3b3VsZCBiZSByYWlzZWQuXG4gKi9cbmV4cG9ydCBjbGFzcyBXZWJBdXRobkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHsgbWVzc2FnZSwgY29kZSwgY2F1c2UsIG5hbWUsIH0pIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZTogaGVscCBSb2xsdXAgdW5kZXJzdGFuZCB0aGF0IGBjYXVzZWAgaXMgb2theSB0byBzZXRcbiAgICAgICAgc3VwZXIobWVzc2FnZSwgeyBjYXVzZSB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIFwiY29kZVwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lID8/IGNhdXNlLm5hbWU7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgfVxufVxuIiwiZXhwb3J0ICogZnJvbSAnLi9tZXRob2RzL3N0YXJ0UmVnaXN0cmF0aW9uLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vbWV0aG9kcy9zdGFydEF1dGhlbnRpY2F0aW9uLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vaGVscGVycy9icm93c2VyU3VwcG9ydHNXZWJBdXRobi5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2hlbHBlcnMvcGxhdGZvcm1BdXRoZW50aWNhdG9ySXNBdmFpbGFibGUuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9oZWxwZXJzL2Jyb3dzZXJTdXBwb3J0c1dlYkF1dGhuQXV0b2ZpbGwuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9oZWxwZXJzL2Jhc2U2NFVSTFN0cmluZ1RvQnVmZmVyLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vaGVscGVycy9idWZmZXJUb0Jhc2U2NFVSTFN0cmluZy5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2hlbHBlcnMvd2ViQXV0aG5BYm9ydFNlcnZpY2UuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9oZWxwZXJzL3dlYkF1dGhuRXJyb3IuanMnO1xuZXhwb3J0ICogZnJvbSAnLi90eXBlcy9pbmRleC5qcyc7XG4iLCJpbXBvcnQgeyBidWZmZXJUb0Jhc2U2NFVSTFN0cmluZyB9IGZyb20gJy4uL2hlbHBlcnMvYnVmZmVyVG9CYXNlNjRVUkxTdHJpbmcuanMnO1xuaW1wb3J0IHsgYmFzZTY0VVJMU3RyaW5nVG9CdWZmZXIgfSBmcm9tICcuLi9oZWxwZXJzL2Jhc2U2NFVSTFN0cmluZ1RvQnVmZmVyLmpzJztcbmltcG9ydCB7IGJyb3dzZXJTdXBwb3J0c1dlYkF1dGhuIH0gZnJvbSAnLi4vaGVscGVycy9icm93c2VyU3VwcG9ydHNXZWJBdXRobi5qcyc7XG5pbXBvcnQgeyBicm93c2VyU3VwcG9ydHNXZWJBdXRobkF1dG9maWxsIH0gZnJvbSAnLi4vaGVscGVycy9icm93c2VyU3VwcG9ydHNXZWJBdXRobkF1dG9maWxsLmpzJztcbmltcG9ydCB7IHRvUHVibGljS2V5Q3JlZGVudGlhbERlc2NyaXB0b3IgfSBmcm9tICcuLi9oZWxwZXJzL3RvUHVibGljS2V5Q3JlZGVudGlhbERlc2NyaXB0b3IuanMnO1xuaW1wb3J0IHsgaWRlbnRpZnlBdXRoZW50aWNhdGlvbkVycm9yIH0gZnJvbSAnLi4vaGVscGVycy9pZGVudGlmeUF1dGhlbnRpY2F0aW9uRXJyb3IuanMnO1xuaW1wb3J0IHsgV2ViQXV0aG5BYm9ydFNlcnZpY2UgfSBmcm9tICcuLi9oZWxwZXJzL3dlYkF1dGhuQWJvcnRTZXJ2aWNlLmpzJztcbmltcG9ydCB7IHRvQXV0aGVudGljYXRvckF0dGFjaG1lbnQgfSBmcm9tICcuLi9oZWxwZXJzL3RvQXV0aGVudGljYXRvckF0dGFjaG1lbnQuanMnO1xuLyoqXG4gKiBCZWdpbiBhdXRoZW50aWNhdG9yIFwibG9naW5cIiB2aWEgV2ViQXV0aG4gYXNzZXJ0aW9uXG4gKlxuICogQHBhcmFtIG9wdGlvbnNKU09OIE91dHB1dCBmcm9tICoqQHNpbXBsZXdlYmF1dGhuL3NlcnZlcioqJ3MgYGdlbmVyYXRlQXV0aGVudGljYXRpb25PcHRpb25zKClgXG4gKiBAcGFyYW0gdXNlQnJvd3NlckF1dG9maWxsIChPcHRpb25hbCkgSW5pdGlhbGl6ZSBjb25kaXRpb25hbCBVSSB0byBlbmFibGUgbG9nZ2luZyBpbiB2aWEgYnJvd3NlciBhdXRvZmlsbCBwcm9tcHRzLiBEZWZhdWx0cyB0byBgZmFsc2VgLlxuICogQHBhcmFtIHZlcmlmeUJyb3dzZXJBdXRvZmlsbElucHV0IChPcHRpb25hbCkgRW5zdXJlIGEgc3VpdGFibGUgYDxpbnB1dD5gIGVsZW1lbnQgaXMgcHJlc2VudCB3aGVuIGB1c2VCcm93c2VyQXV0b2ZpbGxgIGlzIGB0cnVlYC4gRGVmYXVsdHMgdG8gYHRydWVgLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gc3RhcnRBdXRoZW50aWNhdGlvbihvcHRpb25zKSB7XG4gICAgLy8gQHRzLWlnbm9yZTogSW50ZW50aW9uYWxseSBjaGVjayBmb3Igb2xkIGNhbGwgc3RydWN0dXJlIHRvIHdhcm4gYWJvdXQgaW1wcm9wZXIgQVBJIGNhbGxcbiAgICBpZiAoIW9wdGlvbnMub3B0aW9uc0pTT04gJiYgb3B0aW9ucy5jaGFsbGVuZ2UpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdzdGFydEF1dGhlbnRpY2F0aW9uKCkgd2FzIG5vdCBjYWxsZWQgY29ycmVjdGx5LiBJdCB3aWxsIHRyeSB0byBjb250aW51ZSB3aXRoIHRoZSBwcm92aWRlZCBvcHRpb25zLCBidXQgdGhpcyBjYWxsIHNob3VsZCBiZSByZWZhY3RvcmVkIHRvIHVzZSB0aGUgZXhwZWN0ZWQgY2FsbCBzdHJ1Y3R1cmUgaW5zdGVhZC4gU2VlIGh0dHBzOi8vc2ltcGxld2ViYXV0aG4uZGV2L2RvY3MvcGFja2FnZXMvYnJvd3NlciN0eXBlZXJyb3ItY2Fubm90LXJlYWQtcHJvcGVydGllcy1vZi11bmRlZmluZWQtcmVhZGluZy1jaGFsbGVuZ2UgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyk7XG4gICAgICAgIC8vIEB0cy1pZ25vcmU6IFJlYXNzaWduIHRoZSBvcHRpb25zLCBwYXNzZWQgaW4gYXMgYSBwb3NpdGlvbmFsIGFyZ3VtZW50LCB0byB0aGUgZXhwZWN0ZWQgdmFyaWFibGVcbiAgICAgICAgb3B0aW9ucyA9IHsgb3B0aW9uc0pTT046IG9wdGlvbnMgfTtcbiAgICB9XG4gICAgY29uc3QgeyBvcHRpb25zSlNPTiwgdXNlQnJvd3NlckF1dG9maWxsID0gZmFsc2UsIHZlcmlmeUJyb3dzZXJBdXRvZmlsbElucHV0ID0gdHJ1ZSwgfSA9IG9wdGlvbnM7XG4gICAgaWYgKCFicm93c2VyU3VwcG9ydHNXZWJBdXRobigpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignV2ViQXV0aG4gaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKTtcbiAgICB9XG4gICAgLy8gV2UgbmVlZCB0byBhdm9pZCBwYXNzaW5nIGVtcHR5IGFycmF5IHRvIGF2b2lkIGJsb2NraW5nIHJldHJpZXZhbFxuICAgIC8vIG9mIHB1YmxpYyBrZXlcbiAgICBsZXQgYWxsb3dDcmVkZW50aWFscztcbiAgICBpZiAob3B0aW9uc0pTT04uYWxsb3dDcmVkZW50aWFscz8ubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIGFsbG93Q3JlZGVudGlhbHMgPSBvcHRpb25zSlNPTi5hbGxvd0NyZWRlbnRpYWxzPy5tYXAodG9QdWJsaWNLZXlDcmVkZW50aWFsRGVzY3JpcHRvcik7XG4gICAgfVxuICAgIC8vIFdlIG5lZWQgdG8gY29udmVydCBzb21lIHZhbHVlcyB0byBVaW50OEFycmF5cyBiZWZvcmUgcGFzc2luZyB0aGUgY3JlZGVudGlhbHMgdG8gdGhlIG5hdmlnYXRvclxuICAgIGNvbnN0IHB1YmxpY0tleSA9IHtcbiAgICAgICAgLi4ub3B0aW9uc0pTT04sXG4gICAgICAgIGNoYWxsZW5nZTogYmFzZTY0VVJMU3RyaW5nVG9CdWZmZXIob3B0aW9uc0pTT04uY2hhbGxlbmdlKSxcbiAgICAgICAgYWxsb3dDcmVkZW50aWFscyxcbiAgICB9O1xuICAgIC8vIFByZXBhcmUgb3B0aW9ucyBmb3IgYC5nZXQoKWBcbiAgICBjb25zdCBnZXRPcHRpb25zID0ge307XG4gICAgLyoqXG4gICAgICogU2V0IHVwIHRoZSBwYWdlIHRvIHByb21wdCB0aGUgdXNlciB0byBzZWxlY3QgYSBjcmVkZW50aWFsIGZvciBhdXRoZW50aWNhdGlvbiB2aWEgdGhlIGJyb3dzZXInc1xuICAgICAqIGlucHV0IGF1dG9maWxsIG1lY2hhbmlzbS5cbiAgICAgKi9cbiAgICBpZiAodXNlQnJvd3NlckF1dG9maWxsKSB7XG4gICAgICAgIGlmICghKGF3YWl0IGJyb3dzZXJTdXBwb3J0c1dlYkF1dGhuQXV0b2ZpbGwoKSkpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdCcm93c2VyIGRvZXMgbm90IHN1cHBvcnQgV2ViQXV0aG4gYXV0b2ZpbGwnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBmb3IgYW4gPGlucHV0PiB3aXRoIFwid2ViYXV0aG5cIiBpbiBpdHMgYGF1dG9jb21wbGV0ZWAgYXR0cmlidXRlXG4gICAgICAgIGNvbnN0IGVsaWdpYmxlSW5wdXRzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImlucHV0W2F1dG9jb21wbGV0ZSQ9J3dlYmF1dGhuJ11cIik7XG4gICAgICAgIC8vIFdlYkF1dGhuIGF1dG9maWxsIHJlcXVpcmVzIGF0IGxlYXN0IG9uZSB2YWxpZCBpbnB1dFxuICAgICAgICBpZiAoZWxpZ2libGVJbnB1dHMubGVuZ3RoIDwgMSAmJiB2ZXJpZnlCcm93c2VyQXV0b2ZpbGxJbnB1dCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ05vIDxpbnB1dD4gd2l0aCBcIndlYmF1dGhuXCIgYXMgdGhlIG9ubHkgb3IgbGFzdCB2YWx1ZSBpbiBpdHMgYGF1dG9jb21wbGV0ZWAgYXR0cmlidXRlIHdhcyBkZXRlY3RlZCcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGBDcmVkZW50aWFsTWVkaWF0aW9uUmVxdWlyZW1lbnRgIGRvZXNuJ3Qga25vdyBhYm91dCBcImNvbmRpdGlvbmFsXCIgeWV0IGFzIG9mXG4gICAgICAgIC8vIHR5cGVzY3JpcHRANC42LjNcbiAgICAgICAgZ2V0T3B0aW9ucy5tZWRpYXRpb24gPSAnY29uZGl0aW9uYWwnO1xuICAgICAgICAvLyBDb25kaXRpb25hbCBVSSByZXF1aXJlcyBhbiBlbXB0eSBhbGxvdyBsaXN0XG4gICAgICAgIHB1YmxpY0tleS5hbGxvd0NyZWRlbnRpYWxzID0gW107XG4gICAgfVxuICAgIC8vIEZpbmFsaXplIG9wdGlvbnNcbiAgICBnZXRPcHRpb25zLnB1YmxpY0tleSA9IHB1YmxpY0tleTtcbiAgICAvLyBTZXQgdXAgdGhlIGFiaWxpdHkgdG8gY2FuY2VsIHRoaXMgcmVxdWVzdCBpZiB0aGUgdXNlciBhdHRlbXB0cyBhbm90aGVyXG4gICAgZ2V0T3B0aW9ucy5zaWduYWwgPSBXZWJBdXRobkFib3J0U2VydmljZS5jcmVhdGVOZXdBYm9ydFNpZ25hbCgpO1xuICAgIC8vIFdhaXQgZm9yIHRoZSB1c2VyIHRvIGNvbXBsZXRlIGFzc2VydGlvblxuICAgIGxldCBjcmVkZW50aWFsO1xuICAgIHRyeSB7XG4gICAgICAgIGNyZWRlbnRpYWwgPSAoYXdhaXQgbmF2aWdhdG9yLmNyZWRlbnRpYWxzLmdldChnZXRPcHRpb25zKSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgaWRlbnRpZnlBdXRoZW50aWNhdGlvbkVycm9yKHsgZXJyb3I6IGVyciwgb3B0aW9uczogZ2V0T3B0aW9ucyB9KTtcbiAgICB9XG4gICAgaWYgKCFjcmVkZW50aWFsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQXV0aGVudGljYXRpb24gd2FzIG5vdCBjb21wbGV0ZWQnKTtcbiAgICB9XG4gICAgY29uc3QgeyBpZCwgcmF3SWQsIHJlc3BvbnNlLCB0eXBlIH0gPSBjcmVkZW50aWFsO1xuICAgIGxldCB1c2VySGFuZGxlID0gdW5kZWZpbmVkO1xuICAgIGlmIChyZXNwb25zZS51c2VySGFuZGxlKSB7XG4gICAgICAgIHVzZXJIYW5kbGUgPSBidWZmZXJUb0Jhc2U2NFVSTFN0cmluZyhyZXNwb25zZS51c2VySGFuZGxlKTtcbiAgICB9XG4gICAgLy8gQ29udmVydCB2YWx1ZXMgdG8gYmFzZTY0IHRvIG1ha2UgaXQgZWFzaWVyIHRvIHNlbmQgYmFjayB0byB0aGUgc2VydmVyXG4gICAgcmV0dXJuIHtcbiAgICAgICAgaWQsXG4gICAgICAgIHJhd0lkOiBidWZmZXJUb0Jhc2U2NFVSTFN0cmluZyhyYXdJZCksXG4gICAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgICAgICBhdXRoZW50aWNhdG9yRGF0YTogYnVmZmVyVG9CYXNlNjRVUkxTdHJpbmcocmVzcG9uc2UuYXV0aGVudGljYXRvckRhdGEpLFxuICAgICAgICAgICAgY2xpZW50RGF0YUpTT046IGJ1ZmZlclRvQmFzZTY0VVJMU3RyaW5nKHJlc3BvbnNlLmNsaWVudERhdGFKU09OKSxcbiAgICAgICAgICAgIHNpZ25hdHVyZTogYnVmZmVyVG9CYXNlNjRVUkxTdHJpbmcocmVzcG9uc2Uuc2lnbmF0dXJlKSxcbiAgICAgICAgICAgIHVzZXJIYW5kbGUsXG4gICAgICAgIH0sXG4gICAgICAgIHR5cGUsXG4gICAgICAgIGNsaWVudEV4dGVuc2lvblJlc3VsdHM6IGNyZWRlbnRpYWwuZ2V0Q2xpZW50RXh0ZW5zaW9uUmVzdWx0cygpLFxuICAgICAgICBhdXRoZW50aWNhdG9yQXR0YWNobWVudDogdG9BdXRoZW50aWNhdG9yQXR0YWNobWVudChjcmVkZW50aWFsLmF1dGhlbnRpY2F0b3JBdHRhY2htZW50KSxcbiAgICB9O1xufVxuIiwiaW1wb3J0IHsgYnVmZmVyVG9CYXNlNjRVUkxTdHJpbmcgfSBmcm9tICcuLi9oZWxwZXJzL2J1ZmZlclRvQmFzZTY0VVJMU3RyaW5nLmpzJztcbmltcG9ydCB7IGJhc2U2NFVSTFN0cmluZ1RvQnVmZmVyIH0gZnJvbSAnLi4vaGVscGVycy9iYXNlNjRVUkxTdHJpbmdUb0J1ZmZlci5qcyc7XG5pbXBvcnQgeyBicm93c2VyU3VwcG9ydHNXZWJBdXRobiB9IGZyb20gJy4uL2hlbHBlcnMvYnJvd3NlclN1cHBvcnRzV2ViQXV0aG4uanMnO1xuaW1wb3J0IHsgdG9QdWJsaWNLZXlDcmVkZW50aWFsRGVzY3JpcHRvciB9IGZyb20gJy4uL2hlbHBlcnMvdG9QdWJsaWNLZXlDcmVkZW50aWFsRGVzY3JpcHRvci5qcyc7XG5pbXBvcnQgeyBpZGVudGlmeVJlZ2lzdHJhdGlvbkVycm9yIH0gZnJvbSAnLi4vaGVscGVycy9pZGVudGlmeVJlZ2lzdHJhdGlvbkVycm9yLmpzJztcbmltcG9ydCB7IFdlYkF1dGhuQWJvcnRTZXJ2aWNlIH0gZnJvbSAnLi4vaGVscGVycy93ZWJBdXRobkFib3J0U2VydmljZS5qcyc7XG5pbXBvcnQgeyB0b0F1dGhlbnRpY2F0b3JBdHRhY2htZW50IH0gZnJvbSAnLi4vaGVscGVycy90b0F1dGhlbnRpY2F0b3JBdHRhY2htZW50LmpzJztcbi8qKlxuICogQmVnaW4gYXV0aGVudGljYXRvciBcInJlZ2lzdHJhdGlvblwiIHZpYSBXZWJBdXRobiBhdHRlc3RhdGlvblxuICpcbiAqIEBwYXJhbSBvcHRpb25zSlNPTiBPdXRwdXQgZnJvbSAqKkBzaW1wbGV3ZWJhdXRobi9zZXJ2ZXIqKidzIGBnZW5lcmF0ZVJlZ2lzdHJhdGlvbk9wdGlvbnMoKWBcbiAqIEBwYXJhbSB1c2VBdXRvUmVnaXN0ZXIgKE9wdGlvbmFsKSBUcnkgdG8gc2lsZW50bHkgY3JlYXRlIGEgcGFzc2tleSB3aXRoIHRoZSBwYXNzd29yZCBtYW5hZ2VyIHRoYXQgdGhlIHVzZXIganVzdCBzaWduZWQgaW4gd2l0aC4gRGVmYXVsdHMgdG8gYGZhbHNlYC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHN0YXJ0UmVnaXN0cmF0aW9uKG9wdGlvbnMpIHtcbiAgICAvLyBAdHMtaWdub3JlOiBJbnRlbnRpb25hbGx5IGNoZWNrIGZvciBvbGQgY2FsbCBzdHJ1Y3R1cmUgdG8gd2FybiBhYm91dCBpbXByb3BlciBBUEkgY2FsbFxuICAgIGlmICghb3B0aW9ucy5vcHRpb25zSlNPTiAmJiBvcHRpb25zLmNoYWxsZW5nZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ3N0YXJ0UmVnaXN0cmF0aW9uKCkgd2FzIG5vdCBjYWxsZWQgY29ycmVjdGx5LiBJdCB3aWxsIHRyeSB0byBjb250aW51ZSB3aXRoIHRoZSBwcm92aWRlZCBvcHRpb25zLCBidXQgdGhpcyBjYWxsIHNob3VsZCBiZSByZWZhY3RvcmVkIHRvIHVzZSB0aGUgZXhwZWN0ZWQgY2FsbCBzdHJ1Y3R1cmUgaW5zdGVhZC4gU2VlIGh0dHBzOi8vc2ltcGxld2ViYXV0aG4uZGV2L2RvY3MvcGFja2FnZXMvYnJvd3NlciN0eXBlZXJyb3ItY2Fubm90LXJlYWQtcHJvcGVydGllcy1vZi11bmRlZmluZWQtcmVhZGluZy1jaGFsbGVuZ2UgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyk7XG4gICAgICAgIC8vIEB0cy1pZ25vcmU6IFJlYXNzaWduIHRoZSBvcHRpb25zLCBwYXNzZWQgaW4gYXMgYSBwb3NpdGlvbmFsIGFyZ3VtZW50LCB0byB0aGUgZXhwZWN0ZWQgdmFyaWFibGVcbiAgICAgICAgb3B0aW9ucyA9IHsgb3B0aW9uc0pTT046IG9wdGlvbnMgfTtcbiAgICB9XG4gICAgY29uc3QgeyBvcHRpb25zSlNPTiwgdXNlQXV0b1JlZ2lzdGVyID0gZmFsc2UgfSA9IG9wdGlvbnM7XG4gICAgaWYgKCFicm93c2VyU3VwcG9ydHNXZWJBdXRobigpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignV2ViQXV0aG4gaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKTtcbiAgICB9XG4gICAgLy8gV2UgbmVlZCB0byBjb252ZXJ0IHNvbWUgdmFsdWVzIHRvIFVpbnQ4QXJyYXlzIGJlZm9yZSBwYXNzaW5nIHRoZSBjcmVkZW50aWFscyB0byB0aGUgbmF2aWdhdG9yXG4gICAgY29uc3QgcHVibGljS2V5ID0ge1xuICAgICAgICAuLi5vcHRpb25zSlNPTixcbiAgICAgICAgY2hhbGxlbmdlOiBiYXNlNjRVUkxTdHJpbmdUb0J1ZmZlcihvcHRpb25zSlNPTi5jaGFsbGVuZ2UpLFxuICAgICAgICB1c2VyOiB7XG4gICAgICAgICAgICAuLi5vcHRpb25zSlNPTi51c2VyLFxuICAgICAgICAgICAgaWQ6IGJhc2U2NFVSTFN0cmluZ1RvQnVmZmVyKG9wdGlvbnNKU09OLnVzZXIuaWQpLFxuICAgICAgICB9LFxuICAgICAgICBleGNsdWRlQ3JlZGVudGlhbHM6IG9wdGlvbnNKU09OLmV4Y2x1ZGVDcmVkZW50aWFscz8ubWFwKHRvUHVibGljS2V5Q3JlZGVudGlhbERlc2NyaXB0b3IpLFxuICAgIH07XG4gICAgLy8gUHJlcGFyZSBvcHRpb25zIGZvciBgLmNyZWF0ZSgpYFxuICAgIGNvbnN0IGNyZWF0ZU9wdGlvbnMgPSB7fTtcbiAgICAvKipcbiAgICAgKiBUcnkgdG8gdXNlIGNvbmRpdGlvbmFsIGNyZWF0ZSB0byByZWdpc3RlciBhIHBhc3NrZXkgZm9yIHRoZSB1c2VyIHdpdGggdGhlIHBhc3N3b3JkIG1hbmFnZXJcbiAgICAgKiB0aGUgdXNlciBqdXN0IHVzZWQgdG8gYXV0aGVudGljYXRlIHdpdGguIFRoZSB1c2VyIHdvbid0IGJlIHNob3duIGFueSBwcm9taW5lbnQgVUkgYnkgdGhlXG4gICAgICogYnJvd3Nlci5cbiAgICAgKi9cbiAgICBpZiAodXNlQXV0b1JlZ2lzdGVyKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmU6IGBtZWRpYXRpb25gIGRvZXNuJ3QgeWV0IGV4aXN0IG9uIENyZWRlbnRpYWxDcmVhdGlvbk9wdGlvbnMgYnV0IGl0J3MgcG9zc2libGUgYXMgb2YgU2VwdCAyMDI0XG4gICAgICAgIGNyZWF0ZU9wdGlvbnMubWVkaWF0aW9uID0gJ2NvbmRpdGlvbmFsJztcbiAgICB9XG4gICAgLy8gRmluYWxpemUgb3B0aW9uc1xuICAgIGNyZWF0ZU9wdGlvbnMucHVibGljS2V5ID0gcHVibGljS2V5O1xuICAgIC8vIFNldCB1cCB0aGUgYWJpbGl0eSB0byBjYW5jZWwgdGhpcyByZXF1ZXN0IGlmIHRoZSB1c2VyIGF0dGVtcHRzIGFub3RoZXJcbiAgICBjcmVhdGVPcHRpb25zLnNpZ25hbCA9IFdlYkF1dGhuQWJvcnRTZXJ2aWNlLmNyZWF0ZU5ld0Fib3J0U2lnbmFsKCk7XG4gICAgLy8gV2FpdCBmb3IgdGhlIHVzZXIgdG8gY29tcGxldGUgYXR0ZXN0YXRpb25cbiAgICBsZXQgY3JlZGVudGlhbDtcbiAgICB0cnkge1xuICAgICAgICBjcmVkZW50aWFsID0gKGF3YWl0IG5hdmlnYXRvci5jcmVkZW50aWFscy5jcmVhdGUoY3JlYXRlT3B0aW9ucykpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRocm93IGlkZW50aWZ5UmVnaXN0cmF0aW9uRXJyb3IoeyBlcnJvcjogZXJyLCBvcHRpb25zOiBjcmVhdGVPcHRpb25zIH0pO1xuICAgIH1cbiAgICBpZiAoIWNyZWRlbnRpYWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWdpc3RyYXRpb24gd2FzIG5vdCBjb21wbGV0ZWQnKTtcbiAgICB9XG4gICAgY29uc3QgeyBpZCwgcmF3SWQsIHJlc3BvbnNlLCB0eXBlIH0gPSBjcmVkZW50aWFsO1xuICAgIC8vIENvbnRpbnVlIHRvIHBsYXkgaXQgc2FmZSB3aXRoIGBnZXRUcmFuc3BvcnRzKClgIGZvciBub3csIGV2ZW4gd2hlbiBMMyB0eXBlcyBzYXkgaXQncyByZXF1aXJlZFxuICAgIGxldCB0cmFuc3BvcnRzID0gdW5kZWZpbmVkO1xuICAgIGlmICh0eXBlb2YgcmVzcG9uc2UuZ2V0VHJhbnNwb3J0cyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0cmFuc3BvcnRzID0gcmVzcG9uc2UuZ2V0VHJhbnNwb3J0cygpO1xuICAgIH1cbiAgICAvLyBMMyBzYXlzIHRoaXMgaXMgcmVxdWlyZWQsIGJ1dCBicm93c2VyIGFuZCB3ZWJ2aWV3IHN1cHBvcnQgYXJlIHN0aWxsIG5vdCBndWFyYW50ZWVkLlxuICAgIGxldCByZXNwb25zZVB1YmxpY0tleUFsZ29yaXRobSA9IHVuZGVmaW5lZDtcbiAgICBpZiAodHlwZW9mIHJlc3BvbnNlLmdldFB1YmxpY0tleUFsZ29yaXRobSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzcG9uc2VQdWJsaWNLZXlBbGdvcml0aG0gPSByZXNwb25zZS5nZXRQdWJsaWNLZXlBbGdvcml0aG0oKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHdhcm5PbkJyb2tlbkltcGxlbWVudGF0aW9uKCdnZXRQdWJsaWNLZXlBbGdvcml0aG0oKScsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgcmVzcG9uc2VQdWJsaWNLZXkgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHR5cGVvZiByZXNwb25zZS5nZXRQdWJsaWNLZXkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IF9wdWJsaWNLZXkgPSByZXNwb25zZS5nZXRQdWJsaWNLZXkoKTtcbiAgICAgICAgICAgIGlmIChfcHVibGljS2V5ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VQdWJsaWNLZXkgPSBidWZmZXJUb0Jhc2U2NFVSTFN0cmluZyhfcHVibGljS2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHdhcm5PbkJyb2tlbkltcGxlbWVudGF0aW9uKCdnZXRQdWJsaWNLZXkoKScsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBMMyBzYXlzIHRoaXMgaXMgcmVxdWlyZWQsIGJ1dCBicm93c2VyIGFuZCB3ZWJ2aWV3IHN1cHBvcnQgYXJlIHN0aWxsIG5vdCBndWFyYW50ZWVkLlxuICAgIGxldCByZXNwb25zZUF1dGhlbnRpY2F0b3JEYXRhO1xuICAgIGlmICh0eXBlb2YgcmVzcG9uc2UuZ2V0QXV0aGVudGljYXRvckRhdGEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3BvbnNlQXV0aGVudGljYXRvckRhdGEgPSBidWZmZXJUb0Jhc2U2NFVSTFN0cmluZyhyZXNwb25zZS5nZXRBdXRoZW50aWNhdG9yRGF0YSgpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHdhcm5PbkJyb2tlbkltcGxlbWVudGF0aW9uKCdnZXRBdXRoZW50aWNhdG9yRGF0YSgpJywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGlkLFxuICAgICAgICByYXdJZDogYnVmZmVyVG9CYXNlNjRVUkxTdHJpbmcocmF3SWQpLFxuICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgICAgYXR0ZXN0YXRpb25PYmplY3Q6IGJ1ZmZlclRvQmFzZTY0VVJMU3RyaW5nKHJlc3BvbnNlLmF0dGVzdGF0aW9uT2JqZWN0KSxcbiAgICAgICAgICAgIGNsaWVudERhdGFKU09OOiBidWZmZXJUb0Jhc2U2NFVSTFN0cmluZyhyZXNwb25zZS5jbGllbnREYXRhSlNPTiksXG4gICAgICAgICAgICB0cmFuc3BvcnRzLFxuICAgICAgICAgICAgcHVibGljS2V5QWxnb3JpdGhtOiByZXNwb25zZVB1YmxpY0tleUFsZ29yaXRobSxcbiAgICAgICAgICAgIHB1YmxpY0tleTogcmVzcG9uc2VQdWJsaWNLZXksXG4gICAgICAgICAgICBhdXRoZW50aWNhdG9yRGF0YTogcmVzcG9uc2VBdXRoZW50aWNhdG9yRGF0YSxcbiAgICAgICAgfSxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgY2xpZW50RXh0ZW5zaW9uUmVzdWx0czogY3JlZGVudGlhbC5nZXRDbGllbnRFeHRlbnNpb25SZXN1bHRzKCksXG4gICAgICAgIGF1dGhlbnRpY2F0b3JBdHRhY2htZW50OiB0b0F1dGhlbnRpY2F0b3JBdHRhY2htZW50KGNyZWRlbnRpYWwuYXV0aGVudGljYXRvckF0dGFjaG1lbnQpLFxuICAgIH07XG59XG4vKipcbiAqIFZpc2libHkgd2FybiB3aGVuIHdlIGRldGVjdCBhbiBpc3N1ZSByZWxhdGVkIHRvIGEgcGFzc2tleSBwcm92aWRlciBpbnRlcmNlcHRpbmcgV2ViQXV0aG4gQVBJXG4gKiBjYWxsc1xuICovXG5mdW5jdGlvbiB3YXJuT25Ccm9rZW5JbXBsZW1lbnRhdGlvbihtZXRob2ROYW1lLCBjYXVzZSkge1xuICAgIGNvbnNvbGUud2FybihgVGhlIGJyb3dzZXIgZXh0ZW5zaW9uIHRoYXQgaW50ZXJjZXB0ZWQgdGhpcyBXZWJBdXRobiBBUEkgY2FsbCBpbmNvcnJlY3RseSBpbXBsZW1lbnRlZCAke21ldGhvZE5hbWV9LiBZb3Ugc2hvdWxkIHJlcG9ydCB0aGlzIGVycm9yIHRvIHRoZW0uXFxuYCwgY2F1c2UpO1xufVxuIiwiZXhwb3J0IHt9O1xuIiwiaW1wb3J0IHsgQ29udHJvbGxlciB9IGZyb20gXCJAaG90d2lyZWQvc3RpbXVsdXNcIjtcbmltcG9ydCBQaWNrciBmcm9tIFwiQHNpbW9ud2VwL3BpY2tyXCI7XG5jb25zdCBfQ29sb3JQaWNrZXIgPSBjbGFzcyBfQ29sb3JQaWNrZXIgZXh0ZW5kcyBDb250cm9sbGVyIHtcbiAgaW5pdGlhbGl6ZSgpIHtcbiAgICB0aGlzLm9uU2F2ZSA9IHRoaXMub25TYXZlLmJpbmQodGhpcyk7XG4gIH1cbiAgY29ubmVjdCgpIHtcbiAgICB0aGlzLnBpY2tlciA9IFBpY2tyLmNyZWF0ZSh7XG4gICAgICBlbDogdGhpcy5idXR0b25UYXJnZXQsXG4gICAgICB0aGVtZTogdGhpcy50aGVtZVZhbHVlLFxuICAgICAgZGVmYXVsdDogdGhpcy5pbnB1dFRhcmdldC52YWx1ZSxcbiAgICAgIHN3YXRjaGVzOiB0aGlzLnN3YXRjaGVzLFxuICAgICAgY29tcG9uZW50czogdGhpcy5jb21wb25lbnRPcHRpb25zXG4gICAgfSksIHRoaXMucGlja2VyLm9uKFwic2F2ZVwiLCB0aGlzLm9uU2F2ZSk7XG4gIH1cbiAgZGlzY29ubmVjdCgpIHtcbiAgICB0aGlzLnBpY2tlci5kZXN0cm95KCk7XG4gIH1cbiAgb25TYXZlKGNvbG9yKSB7XG4gICAgdGhpcy5pbnB1dFRhcmdldC52YWx1ZSA9IG51bGwsIGNvbG9yICYmICh0aGlzLmlucHV0VGFyZ2V0LnZhbHVlID0gY29sb3IudG9IRVhBKCkudG9TdHJpbmcoKSksIHRoaXMucGlja2VyLmhpZGUoKTtcbiAgfVxuICBnZXQgY29tcG9uZW50T3B0aW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcHJldmlldzogITAsXG4gICAgICBodWU6ICEwLFxuICAgICAgaW50ZXJhY3Rpb246IHtcbiAgICAgICAgaW5wdXQ6ICEwLFxuICAgICAgICBjbGVhcjogITAsXG4gICAgICAgIHNhdmU6ICEwXG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBnZXQgc3dhdGNoZXMoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgIFwiI0EwQUVDMFwiLFxuICAgICAgXCIjRjU2NTY1XCIsXG4gICAgICBcIiNFRDg5MzZcIixcbiAgICAgIFwiI0VDQzk0QlwiLFxuICAgICAgXCIjNDhCQjc4XCIsXG4gICAgICBcIiMzOEIyQUNcIixcbiAgICAgIFwiIzQyOTlFMVwiLFxuICAgICAgXCIjNjY3RUVBXCIsXG4gICAgICBcIiM5RjdBRUFcIixcbiAgICAgIFwiI0VENjRBNlwiXG4gICAgXTtcbiAgfVxufTtcbl9Db2xvclBpY2tlci50YXJnZXRzID0gW1wiYnV0dG9uXCIsIFwiaW5wdXRcIl0sIF9Db2xvclBpY2tlci52YWx1ZXMgPSB7XG4gIHRoZW1lOiB7XG4gICAgdHlwZTogU3RyaW5nLFxuICAgIGRlZmF1bHQ6IFwiY2xhc3NpY1wiXG4gIH1cbn07XG5sZXQgQ29sb3JQaWNrZXIgPSBfQ29sb3JQaWNrZXI7XG5leHBvcnQge1xuICBDb2xvclBpY2tlciBhcyBkZWZhdWx0XG59O1xuIiwidmFyIFAgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgUiA9IChyLCBlLCB0KSA9PiBlIGluIHIgPyBQKHIsIGUsIHsgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCwgdmFsdWU6IHQgfSkgOiByW2VdID0gdDtcbnZhciB1ID0gKHIsIGUsIHQpID0+IFIociwgdHlwZW9mIGUgIT0gXCJzeW1ib2xcIiA/IGUgKyBcIlwiIDogZSwgdCk7XG5mdW5jdGlvbiBTKHIsIGUpIHtcbiAgciA9PT0gXCJcIiB8fCByLmxlbmd0aCA9PT0gMCB8fCAodHlwZW9mIHIgPT0gXCJzdHJpbmdcIiA/IGUuY2xhc3NMaXN0LmFkZChyKSA6IGUuY2xhc3NMaXN0LmFkZCguLi5yKSk7XG59XG5mdW5jdGlvbiBEKHIsIGUpIHtcbiAgciA9PT0gXCJcIiB8fCByLmxlbmd0aCA9PT0gMCB8fCAodHlwZW9mIHIgPT0gXCJzdHJpbmdcIiA/IGUuY2xhc3NMaXN0LnJlbW92ZShyKSA6IGUuY2xhc3NMaXN0LnJlbW92ZSguLi5yKSk7XG59XG5mdW5jdGlvbiBBKHIsIGUpIHtcbiAgdHJ5IHtcbiAgICBpZiAodHlwZW9mIGUgIT0gXCJvYmplY3RcIikge1xuICAgICAgY29uc3QgdCA9IHR5cGVvZiBlO1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgYEVsZW1lbnRzIGdpdmVuIHRvIGlzVmFsaWRJbnN0YW5jZSgpIG11c3QgYmUgaW5zaWRlIG9mIGFuIG9iamVjdC4gXCIke3R9XCIgZ2l2ZW4uYFxuICAgICAgKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCB0IGluIGUpXG4gICAgICBpZiAoIShlW3RdIGluc3RhbmNlb2YgcikpIHtcbiAgICAgICAgY29uc3QgcyA9IHR5cGVvZiBlW3RdO1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIGAke3R9IG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgJHtyLm5hbWV9LiBcIiR7c31cIiBnaXZlbi5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXR1czogITAsXG4gICAgICBlcnJvcjogbnVsbFxuICAgIH07XG4gIH0gY2F0Y2ggKHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhdHVzOiAhMSxcbiAgICAgIGVycm9yOiB0XG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gYyhyLCBlKSB7XG4gIHRyeSB7XG4gICAgaWYgKHR5cGVvZiBlICE9IFwib2JqZWN0XCIpIHtcbiAgICAgIGNvbnN0IHQgPSB0eXBlb2YgZTtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIGBWYWx1ZXMgZ2l2ZW4gdG8gaXNWYWxpZFR5cGUoKSBtdXN0IGJlIGluc2lkZSBvZiBhbiBvYmplY3QuIFwiJHt0fVwiIGdpdmVuLmBcbiAgICAgICk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgdCBpbiBlKSB7XG4gICAgICBjb25zdCBzID0gdHlwZW9mIGVbdF07XG4gICAgICBpZiAocyAhPT0gcilcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHt0fSBtdXN0IGJlIGEgJHtyfS4gXCIke3N9XCIgZ2l2ZW4uYCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBzdGF0dXM6ICEwLFxuICAgICAgZXJyb3I6IG51bGxcbiAgICB9O1xuICB9IGNhdGNoICh0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXR1czogITEsXG4gICAgICBlcnJvcjogdFxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIHgocikge1xuICB0cnkge1xuICAgIGlmICh0eXBlb2YgciAhPSBcIm9iamVjdFwiKSB7XG4gICAgICBjb25zdCBlID0gdHlwZW9mIHI7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICBgVmFsdWVzIGdpdmVuIHRvIGlzUXVlcnlTZWxlY3RvcigpIG11c3QgYmUgaW5zaWRlIG9mIGFuIG9iamVjdC4gXCIke2V9XCIgZ2l2ZW4uYFxuICAgICAgKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBlIGluIHIpXG4gICAgICB0cnkge1xuICAgICAgICBpZiAocltlXSA9PT0gbnVsbClcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihyW2VdKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIGAke2V9IG11c3QgYmUgYSB2YWxpZCBxdWVyeSBzZWxlY3Rvci4gXCIke3JbZV19XCIgZ2l2ZW4uYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIHJldHVybiB7XG4gICAgICBzdGF0dXM6ICEwLFxuICAgICAgZXJyb3I6IG51bGxcbiAgICB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXR1czogITEsXG4gICAgICBlcnJvcjogZVxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGsocikge1xuICB0cnkge1xuICAgIGlmICh0eXBlb2YgciAhPSBcIm9iamVjdFwiIHx8IEFycmF5LmlzQXJyYXkocikpIHtcbiAgICAgIGNvbnN0IGUgPSB0eXBlb2YgcjtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIGBWYWx1ZXMgZ2l2ZW4gdG8gaXNWYWxpZENsYXNzTGlzdCgpIG11c3QgYmUgaW5zaWRlIG9mIGFuIG9iamVjdC4gXCIke2V9XCIgZ2l2ZW4uYFxuICAgICAgKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBlIGluIHIpIHtcbiAgICAgIGNvbnN0IHQgPSB0eXBlb2YgcltlXTtcbiAgICAgIGlmICh0ICE9PSBcInN0cmluZ1wiKVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShyW2VdKSlcbiAgICAgICAgICByW2VdLmZvckVhY2goKHMpID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcyAhPSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgIGAke2V9IG11c3QgYmUgYSBzdHJpbmcgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncy4gQW4gYXJyYXkgY29udGFpbmluZyBub24tc3RyaW5ncyBnaXZlbi5gXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgYCR7ZX0gbXVzdCBiZSBhIHN0cmluZyBvciBhbiBhcnJheSBvZiBzdHJpbmdzLiBcIiR7dH1cIiBnaXZlbi5gXG4gICAgICAgICAgKTtcbiAgICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBzID0ge307XG4gICAgICAgIHNbZV0gPSByW2VdLCB4KHMpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgc3RhdHVzOiAhMCxcbiAgICAgIGVycm9yOiBudWxsXG4gICAgfTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGF0dXM6ICExLFxuICAgICAgZXJyb3I6IGVcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBVKHIpIHtcbiAgdHJ5IHtcbiAgICBpZiAodHlwZW9mIHIgIT0gXCJvYmplY3RcIikge1xuICAgICAgY29uc3QgdCA9IHR5cGVvZiByO1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgYFZhbHVlcyBnaXZlbiB0byBpc1ZhbGlkU3RhdGUoKSBtdXN0IGJlIGluc2lkZSBvZiBhbiBvYmplY3QuIFwiJHt0fVwiIGdpdmVuLmBcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IGUgPSBbXCJub25lXCIsIFwic2VsZlwiLCBcImNoaWxkXCJdO1xuICAgIGZvciAoY29uc3QgdCBpbiByKVxuICAgICAgaWYgKCFlLmluY2x1ZGVzKHJbdF0pKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIGAke3R9IG11c3QgYmUgb25lIG9mIHRoZSBmb2xsb3dpbmcgdmFsdWVzOiAke2Uuam9pbihcbiAgICAgICAgICAgIFwiLCBcIlxuICAgICAgICAgICl9LiBcIiR7clt0XX1cIiBnaXZlbi5gXG4gICAgICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXR1czogITAsXG4gICAgICBlcnJvcjogbnVsbFxuICAgIH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhdHVzOiAhMSxcbiAgICAgIGVycm9yOiBlXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gVyhyKSB7XG4gIHRyeSB7XG4gICAgaWYgKHR5cGVvZiByICE9IFwib2JqZWN0XCIpIHtcbiAgICAgIGNvbnN0IHQgPSB0eXBlb2YgcjtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgIGBWYWx1ZXMgZ2l2ZW4gdG8gaXNWYWxpZEV2ZW50KCkgbXVzdCBiZSBpbnNpZGUgb2YgYW4gb2JqZWN0LiBcIiR7dH1cIiBnaXZlbi5gXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBlID0gW1wibm9uZVwiLCBcIm1vdXNlXCIsIFwia2V5Ym9hcmRcIiwgXCJjaGFyYWN0ZXJcIl07XG4gICAgZm9yIChjb25zdCB0IGluIHIpXG4gICAgICBpZiAoIWUuaW5jbHVkZXMoclt0XSkpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgYCR7dH0gbXVzdCBiZSBvbmUgb2YgdGhlIGZvbGxvd2luZyB2YWx1ZXM6ICR7ZS5qb2luKFxuICAgICAgICAgICAgXCIsIFwiXG4gICAgICAgICAgKX0uIFwiJHtyW3RdfVwiIGdpdmVuLmBcbiAgICAgICAgKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhdHVzOiAhMCxcbiAgICAgIGVycm9yOiBudWxsXG4gICAgfTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGF0dXM6ICExLFxuICAgICAgZXJyb3I6IGVcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBOKHIpIHtcbiAgdHJ5IHtcbiAgICBpZiAodHlwZW9mIHIgIT0gXCJvYmplY3RcIikge1xuICAgICAgY29uc3QgdCA9IHR5cGVvZiByO1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgYFZhbHVlcyBnaXZlbiB0byBpc1ZhbGlkSG92ZXJUeXBlKCkgbXVzdCBiZSBpbnNpZGUgb2YgYW4gb2JqZWN0LiBcIiR7dH1cIiBnaXZlbi5gXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBlID0gW1wib2ZmXCIsIFwib25cIiwgXCJkeW5hbWljXCJdO1xuICAgIGZvciAoY29uc3QgdCBpbiByKVxuICAgICAgaWYgKCFlLmluY2x1ZGVzKHJbdF0pKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIGAke3R9IG11c3QgYmUgb25lIG9mIHRoZSBmb2xsb3dpbmcgdmFsdWVzOiAke2Uuam9pbihcbiAgICAgICAgICAgIFwiLCBcIlxuICAgICAgICAgICl9LiBcIiR7clt0XX1cIiBnaXZlbi5gXG4gICAgICAgICk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXR1czogITAsXG4gICAgICBlcnJvcjogbnVsbFxuICAgIH07XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhdHVzOiAhMSxcbiAgICAgIGVycm9yOiBlXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gRihyLCBlKSB7XG4gIGlmIChjKFwic3RyaW5nXCIsIHsgdGFnTmFtZTogciB9KS5zdGF0dXMgJiYgQShIVE1MRWxlbWVudCwgZSkuc3RhdHVzKSB7XG4gICAgY29uc3QgdCA9IHIudG9Mb3dlckNhc2UoKTtcbiAgICBsZXQgcyA9ICEwO1xuICAgIGZvciAoY29uc3QgbiBpbiBlKVxuICAgICAgZVtuXS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgIT09IHQgJiYgKHMgPSAhMSk7XG4gICAgcmV0dXJuIHM7XG4gIH0gZWxzZVxuICAgIHJldHVybiAhMTtcbn1cbmNsYXNzIEwge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBgQmFzZU1lbnVUb2dnbGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gICAgICBvcHRpb25zICAgICAgICAgICAgICAgICAgICAgLSBUaGUgb3B0aW9ucyBmb3IgZ2VuZXJhdGluZyB0aGUgbWVudSB0b2dnbGUuXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG9wdGlvbnMubWVudVRvZ2dsZUVsZW1lbnQgICAtIFRoZSB0b2dnbGUgZWxlbWVudCBpbiB0aGUgRE9NLlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBvcHRpb25zLnBhcmVudEVsZW1lbnQgICAgICAgLSBUaGUgZWxlbWVudCBjb250YWluaW5nIHRoZSBjb250cm9sbGVkIG1lbnUuXG4gICAqIEBwYXJhbSB7QmFzZU1lbnV9ICAgIG9wdGlvbnMuY29udHJvbGxlZE1lbnUgICAgICAtIFRoZSBtZW51IGNvbnRyb2xsZWQgYnkgdGhpcyB0b2dnbGUuXG4gICAqIEBwYXJhbSB7P0Jhc2VNZW51fSAgIFtvcHRpb25zLnBhcmVudE1lbnUgPSBudWxsXSAtIFRoZSBtZW51IGNvbnRhaW5pbmcgdGhpcyB0b2dnbGUuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbWVudVRvZ2dsZUVsZW1lbnQ6IGUsXG4gICAgcGFyZW50RWxlbWVudDogdCxcbiAgICBjb250cm9sbGVkTWVudTogcyxcbiAgICBwYXJlbnRNZW51OiBuID0gbnVsbFxuICB9KSB7XG4gICAgLyoqXG4gICAgICogVGhlIERPTSBlbGVtZW50cyB3aXRoaW4gdGhlIG1lbnUgdG9nZ2xlLlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqXG4gICAgICogQHR5cGUge09iamVjdDxIVE1MRWxlbWVudD59XG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSB0b2dnbGUgLSBUaGUgbWVudSB0b2dnbGUuXG4gICAgICogQHByb3BlcnR5IHtIVE1MRWxlbWVudH0gcGFyZW50IC0gVGhlIG1lbnUgY29udGFpbmluZyB0aGlzIHRvZ2dsZS5cbiAgICAgKi9cbiAgICB1KHRoaXMsIFwiX2RvbVwiLCB7XG4gICAgICB0b2dnbGU6IG51bGwsXG4gICAgICBwYXJlbnQ6IG51bGxcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBUaGUgZGVjbGFyZWQgYWNjZXNzaWJsZS1tZW51IGVsZW1lbnRzIHdpdGhpbiB0aGUgbWVudSB0b2dnbGUuXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICpcbiAgICAgKiBAdHlwZSB7T2JqZWN0PEJhc2VNZW51Pn1cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB7QmFzZU1lbnV9IGNvbnRyb2xsZWRNZW51IC0gVGhlIG1lbnUgY29udHJvbGxlZCBieSB0aGlzIHRvZ2dsZS5cbiAgICAgKiBAcHJvcGVydHkge0Jhc2VNZW51fSBwYXJlbnRNZW51ICAgICAtIFRoZSBtZW51IGNvbnRhaW5pbmcgdGhpcyB0b2dnbGUuXG4gICAgICovXG4gICAgdSh0aGlzLCBcIl9lbGVtZW50c1wiLCB7XG4gICAgICBjb250cm9sbGVkTWVudTogbnVsbCxcbiAgICAgIHBhcmVudE1lbnU6IG51bGxcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBUaGUgb3BlbiBzdGF0ZSBvZiB0aGUgbWVudSB0b2dnbGUuXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB1KHRoaXMsIFwiX29wZW5cIiwgITEpO1xuICAgIC8qKlxuICAgICAqIFRoZSBldmVudCB0aGF0IGlzIHRyaWdnZXJlZCB3aGVuIHRoZSBtZW51IHRvZ2dsZSBleHBhbmRzLlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqXG4gICAgICogQGV2ZW50IGFjY2Vzc2libGVNZW51RXhwYW5kXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Q3VzdG9tRXZlbnR9XG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59ICAgICAgICAgICAgICAgIGJ1YmJsZXMgLSBBIGZsYWcgdG8gYnViYmxlIHRoZSBldmVudC5cbiAgICAgKiBAcHJvcGVydHkge09iamVjdDxCYXNlTWVudVRvZ2dsZT59IGRldGFpbHMgLSBUaGUgZGV0YWlscyBvYmplY3QgY29udGFpbmluZyB0aGUgQmFzZU1lbnVUb2dnbGUgaXRzZWxmLlxuICAgICAqL1xuICAgIHUodGhpcywgXCJfZXhwYW5kRXZlbnRcIiwgbmV3IEN1c3RvbUV2ZW50KFwiYWNjZXNzaWJsZU1lbnVFeHBhbmRcIiwge1xuICAgICAgYnViYmxlczogITAsXG4gICAgICBkZXRhaWw6IHsgdG9nZ2xlOiB0aGlzIH1cbiAgICB9KSk7XG4gICAgLyoqXG4gICAgICogVGhlIGV2ZW50IHRoYXQgaXMgdHJpZ2dlcmVkIHdoZW4gdGhlIG1lbnUgdG9nZ2xlIGNvbGxhcHNlcy5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKlxuICAgICAqIEBldmVudCBhY2Nlc3NpYmxlTWVudUNvbGxhcHNlXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Q3VzdG9tRXZlbnR9XG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59ICAgICAgICAgICAgICAgIGJ1YmJsZXMgLSBBIGZsYWcgdG8gYnViYmxlIHRoZSBldmVudC5cbiAgICAgKiBAcHJvcGVydHkge09iamVjdDxCYXNlTWVudVRvZ2dsZT59IGRldGFpbHMgLSBUaGUgZGV0YWlscyBvYmplY3QgY29udGFpbmluZyB0aGUgQmFzZU1lbnVUb2dnbGUgaXRzZWxmLlxuICAgICAqL1xuICAgIHUodGhpcywgXCJfY29sbGFwc2VFdmVudFwiLCBuZXcgQ3VzdG9tRXZlbnQoXCJhY2Nlc3NpYmxlTWVudUNvbGxhcHNlXCIsIHtcbiAgICAgIGJ1YmJsZXM6ICEwLFxuICAgICAgZGV0YWlsOiB7IHRvZ2dsZTogdGhpcyB9XG4gICAgfSkpO1xuICAgIHRoaXMuX2RvbS50b2dnbGUgPSBlLCB0aGlzLl9kb20ucGFyZW50ID0gdCwgdGhpcy5fZWxlbWVudHMuY29udHJvbGxlZE1lbnUgPSBzLCB0aGlzLl9lbGVtZW50cy5wYXJlbnRNZW51ID0gbjtcbiAgfVxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIG1lbnUgdG9nZ2xlLlxuICAgKlxuICAgKiBUaGUgZmlyc3Qgc3RlcHMgYXJlIHRvIGVuc3VyZSB0aGF0IHRoZSB0b2dnbGUgYW5kIGNvbnRyb2xsZWQgbWVudSBoYXZlIElEc1xuICAgKiB1c2luZyB0aGUgc2V0SWRzIG1ldGhvZCwgYW5kIHRvIHNldCB0aGUgQVJJQSBhdHRyaWJ1dGVzIG9uIHRoZSB0b2dnbGVcbiAgICogYW5kIGNvbnRyb2xsZWQgbWVudSB1c2luZyB0aGUgc2V0QXJpYUF0dHJpYnV0ZXMgbWV0aG9kLlxuICAgKlxuICAgKiBUaGVuIHRoZSBjb2xsYXBzZSBtZXRob2QgaXMgY2FsbGVkIHRvIG1ha2Ugc3VyZSB0aGUgc3VibWVudSBpcyBjbG9zZWQuXG4gICAqL1xuICBpbml0aWFsaXplKCkge1xuICAgIHRoaXMuX3NldElkcygpLCB0aGlzLl9zZXRBcmlhQXR0cmlidXRlcygpLCB0aGlzLl9jb2xsYXBzZSghMSk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBET00gZWxlbWVudHMgd2l0aGluIHRoZSB0b2dnbGUuXG4gICAqXG4gICAqIEByZWFkb25seVxuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0PEhUTUxFbGVtZW50Pn1cbiAgICpcbiAgICogQHNlZSBfZG9tXG4gICAqL1xuICBnZXQgZG9tKCkge1xuICAgIHJldHVybiB0aGlzLl9kb207XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBkZWNsYXJlZCBhY2Nlc3NpYmxlLW1lbnUgZWxlbWVudHMgd2l0aGluIHRoZSB0b2dnbGUuXG4gICAqXG4gICAqIEByZWFkb25seVxuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0PEJhc2VNZW51Pn1cbiAgICpcbiAgICogQHNlZSBfZWxlbWVudHNcbiAgICovXG4gIGdldCBlbGVtZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fZWxlbWVudHM7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBvcGVuIHN0YXRlIG9uIHRoZSB0b2dnbGUuXG4gICAqXG4gICAqIEB0eXBlIHtib29sZWFufVxuICAgKlxuICAgKiBAc2VlIF9vcGVuXG4gICAqL1xuICBnZXQgaXNPcGVuKCkge1xuICAgIHJldHVybiB0aGlzLl9vcGVuO1xuICB9XG4gIHNldCBpc09wZW4oZSkge1xuICAgIGMoXCJib29sZWFuXCIsIHsgdmFsdWU6IGUgfSksIHRoaXMuX29wZW4gPSBlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHVuaXF1ZSBJRHMgZm9yIHRoZSB0b2dnbGUgYW5kIGNvbnRyb2xsZWQgbWVudS5cbiAgICpcbiAgICogSWYgdGhlIHRvZ2dsZSBhbmQgY29udHJvbGxlZCBtZW51IGRvIG5vdCBoYXZlIElEcywgdGhlIGZvbGxvd2luZyBzdGVwcyB0YWtlIHBsYWNlOlxuICAgKiAtIEdlbmVyYXRlIGEgcmFuZG9tIHN0cmluZyAxLTEwIGNoYXJhY3RlcnMgbG9uZyxcbiAgICogLSBHZXQgdGhlIGlubmVyVGV4dCBvZiB0aGUgdG9nZ2xlLFxuICAgKiAtIFNldCB0aGUgdG9nZ2xlJ3MgSUQgdG86IGBtZW51LWJ1dHRvbi0ke3RvZ2dsZS1pbm5lci10ZXh0fS0ke3RoZS1yYW5kb20tc3RyaW5nfWBcbiAgICogLSBTZXQgdGhlIG1lbnUncyBJRCB0bzogYG1lbnUtJHt0b2dnbGUtaW5uZXItdGV4dH0tJHt0aGUtcmFuZG9tLXN0cmluZ31gXG4gICAqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9zZXRJZHMoKSB7XG4gICAgdmFyIGU7XG4gICAgaWYgKHRoaXMuZG9tLnRvZ2dsZS5pZCA9PT0gXCJcIiB8fCB0aGlzLmVsZW1lbnRzLmNvbnRyb2xsZWRNZW51LmRvbS5tZW51LmlkID09PSBcIlwiKSB7XG4gICAgICBjb25zdCB0ID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikucmVwbGFjZSgvW15hLXpdKy9nLCBcIlwiKS5zdWJzdHJpbmcoMCwgMTApO1xuICAgICAgbGV0IHMgPSAoKGUgPSB0aGlzLmRvbS50b2dnbGUuaW5uZXJUZXh0KSA9PSBudWxsID8gdm9pZCAwIDogZS5yZXBsYWNlKC9bXmEtekEtWjAtOVxcc10vZywgXCJcIikpIHx8IFwiXCIsIG4gPSB0O1xuICAgICAgIXMucmVwbGFjZSgvXFxzL2csIFwiXCIpLmxlbmd0aCAmJiB0aGlzLmRvbS50b2dnbGUuZ2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiKSAmJiAocyA9IHRoaXMuZG9tLnRvZ2dsZS5nZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIpLnJlcGxhY2UoL1teYS16QS1aMC05XFxzXS9nLCBcIlwiKSksIHMucmVwbGFjZSgvXFxzL2csIFwiXCIpLmxlbmd0aCA+IDAgJiYgKHMgPSBzLnRvTG93ZXJDYXNlKCkucmVwbGFjZSgvXFxzKy9nLCBcIi1cIiksIHMuc3RhcnRzV2l0aChcIi1cIikgJiYgKHMgPSBzLnN1YnN0cmluZygxKSksIHMuZW5kc1dpdGgoXCItXCIpICYmIChzID0gcy5zbGljZSgwLCAtMSkpLCBuID0gYCR7c30tJHtufWApLCB0aGlzLmRvbS50b2dnbGUuaWQgPSB0aGlzLmRvbS50b2dnbGUuaWQgfHwgYG1lbnUtYnV0dG9uLSR7bn1gLCB0aGlzLmVsZW1lbnRzLmNvbnRyb2xsZWRNZW51LmRvbS5tZW51LmlkID0gdGhpcy5lbGVtZW50cy5jb250cm9sbGVkTWVudS5kb20ubWVudS5pZCB8fCBgbWVudS0ke259YDtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIEFSSUEgYXR0cmlidXRlcyBvbiB0aGUgdG9nZ2xlIGFuZCBjb250cm9sbGVkIG1lbnUuXG4gICAqXG4gICAqIFRoZSBmaXJzdCBzdGVwcyBhcmUgdG8gZW5zdXJlIHRoYXQgdGhlIHRvZ2dsZSBoYXMgYGFyaWEtZXhwYW5kZWRgXG4gICAqIGlzIGluaXRpYWxseSBzZXQgdG8gXCJmYWxzZVwiLlxuICAgKlxuICAgKiBUaGVuIHVzaW5nIHRoZSB0b2dnbGUgYW5kIG1lbnUncyBJRHMsIHRoZSBtZW51J3MgYGFyaWEtbGFiZWxsZWRieWAgaXMgc2V0IHRvXG4gICAqIHRoZSB0b2dnbGUncyBJRC5cbiAgICpcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX3NldEFyaWFBdHRyaWJ1dGVzKCkge1xuICAgIHRoaXMuZG9tLnRvZ2dsZS5zZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIsIFwiZmFsc2VcIiksIHRoaXMuZWxlbWVudHMuY29udHJvbGxlZE1lbnUuZG9tLm1lbnUuc2V0QXR0cmlidXRlKFxuICAgICAgXCJhcmlhLWxhYmVsbGVkYnlcIixcbiAgICAgIHRoaXMuZG9tLnRvZ2dsZS5pZFxuICAgICk7XG4gIH1cbiAgLyoqXG4gICAqIEV4cGFuZHMgdGhlIGNvbnRyb2xsZWQgbWVudS5cbiAgICpcbiAgICogU2V0cyB0aGUgdG9nZ2xlJ3MgYGFyaWEtZXhwYW5kZWRgIHRvIFwidHJ1ZVwiLCBhZGRzIHRoZVxuICAgKiBvcGVuIGNsYXNzIHRvIHRoZSB0b2dnbGUncyBwYXJlbnQgbWVudSBpdGVtXG4gICAqIGFuZCBjb250cm9sbGVkIG1lbnUsIGFuZCByZW1vdmVzIHRoZSBjbG9zZWQgY2xhc3NcbiAgICogZnJvbSB0aGUgdG9nZ2xlJ3MgcGFyZW50IG1lbnUgaXRlbSBhbmQgY29udHJvbGxlZCBtZW51LlxuICAgKlxuICAgKiBJZiBgZW1pdGAgaXMgc2V0IHRvIGB0cnVlYCwgdGhpcyB3aWxsIGFsc28gZW1pdCBhIGN1c3RvbSBldmVudFxuICAgKiBjYWxsZWQgYWNjZXNzaWJsZU1lbnVFeHBhbmRcbiAgICpcbiAgICogQHByb3RlY3RlZFxuICAgKlxuICAgKiBAZmlyZXMgYWNjZXNzaWJsZU1lbnVFeHBhbmRcbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBbZW1pdCA9IHRydWVdIC0gQSB0b2dnbGUgdG8gZW1pdCB0aGUgZXhwYW5kIGV2ZW50IG9uY2UgZXhwYW5kZWQuXG4gICAqL1xuICBfZXhwYW5kKGUgPSAhMCkge1xuICAgIGNvbnN0IHsgY2xvc2VDbGFzczogdCwgb3BlbkNsYXNzOiBzLCB0cmFuc2l0aW9uQ2xhc3M6IG4sIG9wZW5EdXJhdGlvbjogaSB9ID0gdGhpcy5lbGVtZW50cy5jb250cm9sbGVkTWVudTtcbiAgICB0aGlzLmRvbS50b2dnbGUuc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLCBcInRydWVcIiksIHRoaXMuZWxlbWVudHMuY29udHJvbGxlZE1lbnUuZWxlbWVudHMucm9vdE1lbnUuaGFzT3BlbmVkID0gITAsIG4gIT09IFwiXCIgPyAoUyhuLCB0aGlzLmVsZW1lbnRzLmNvbnRyb2xsZWRNZW51LmRvbS5tZW51KSwgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIEQodCwgdGhpcy5lbGVtZW50cy5jb250cm9sbGVkTWVudS5kb20ubWVudSksIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgIFMocywgdGhpcy5lbGVtZW50cy5jb250cm9sbGVkTWVudS5kb20ubWVudSksIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBEKFxuICAgICAgICAgICAgICBuLFxuICAgICAgICAgICAgICB0aGlzLmVsZW1lbnRzLmNvbnRyb2xsZWRNZW51LmRvbS5tZW51XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH0sIGkpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pKSA6IChTKHMsIHRoaXMuZWxlbWVudHMuY29udHJvbGxlZE1lbnUuZG9tLm1lbnUpLCBEKHQsIHRoaXMuZWxlbWVudHMuY29udHJvbGxlZE1lbnUuZG9tLm1lbnUpKSwgZSAmJiB0aGlzLmRvbS50b2dnbGUuZGlzcGF0Y2hFdmVudCh0aGlzLl9leHBhbmRFdmVudCk7XG4gIH1cbiAgLyoqXG4gICAqIENvbGxhcHNlcyB0aGUgY29udHJvbGxlZCBtZW51LlxuICAgKlxuICAgKiBTZXRzIHRoZSB0b2dnbGUncyBgYXJpYS1leHBhbmRlZGAgdG8gXCJmYWxzZVwiLCBhZGRzIHRoZVxuICAgKiBjbG9zZWQgY2xhc3MgdG8gdGhlIHRvZ2dsZSdzIHBhcmVudCBtZW51IGl0ZW1cbiAgICogYW5kIGNvbnRyb2xsZWQgbWVudSwgYW5kIHJlbW92ZXMgdGhlIG9wZW4gY2xhc3NcbiAgICogZnJvbSB0aGUgdG9nZ2xlJ3MgcGFyZW50IG1lbnUgaXRlbSBhbmQgY29udHJvbGxlZCBtZW51LlxuICAgKlxuICAgKiBJZiBgZW1pdGAgaXMgc2V0IHRvIGB0cnVlYCwgdGhpcyB3aWxsIGFsc28gZW1pdCBhIGN1c3RvbSBldmVudFxuICAgKiBjYWxsZWQgYWNjZXNzaWJsZU1lbnVDb2xsYXBzZVxuICAgKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqXG4gICAqIEBmaXJlcyBhY2Nlc3NpYmxlTWVudUNvbGxhcHNlXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2VtaXQgPSB0cnVlXSAtIEEgdG9nZ2xlIHRvIGVtaXQgdGhlIGNvbGxhcHNlIGV2ZW50IG9uY2UgY29sbGFwc2VkLlxuICAgKi9cbiAgX2NvbGxhcHNlKGUgPSAhMCkge1xuICAgIGNvbnN0IHsgY2xvc2VDbGFzczogdCwgb3BlbkNsYXNzOiBzLCB0cmFuc2l0aW9uQ2xhc3M6IG4sIGNsb3NlRHVyYXRpb246IGkgfSA9IHRoaXMuZWxlbWVudHMuY29udHJvbGxlZE1lbnU7XG4gICAgdGhpcy5kb20udG9nZ2xlLnNldEF0dHJpYnV0ZShcImFyaWEtZXhwYW5kZWRcIiwgXCJmYWxzZVwiKSwgbiAhPT0gXCJcIiA/IChTKG4sIHRoaXMuZWxlbWVudHMuY29udHJvbGxlZE1lbnUuZG9tLm1lbnUpLCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgRChzLCB0aGlzLmVsZW1lbnRzLmNvbnRyb2xsZWRNZW51LmRvbS5tZW51KSwgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgUyh0LCB0aGlzLmVsZW1lbnRzLmNvbnRyb2xsZWRNZW51LmRvbS5tZW51KSwgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIEQoXG4gICAgICAgICAgICAgIG4sXG4gICAgICAgICAgICAgIHRoaXMuZWxlbWVudHMuY29udHJvbGxlZE1lbnUuZG9tLm1lbnVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSwgaSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSkpIDogKFModCwgdGhpcy5lbGVtZW50cy5jb250cm9sbGVkTWVudS5kb20ubWVudSksIEQocywgdGhpcy5lbGVtZW50cy5jb250cm9sbGVkTWVudS5kb20ubWVudSkpLCBlICYmIHRoaXMuZG9tLnRvZ2dsZS5kaXNwYXRjaEV2ZW50KHRoaXMuX2NvbGxhcHNlRXZlbnQpO1xuICB9XG4gIC8qKlxuICAgKiBPcGVucyB0aGUgY29udHJvbGxlZCBtZW51LlxuICAgKlxuICAgKiBTZXRzIHRoZSBjb250cm9sbGVkIG1lbnUncyBmb2N1cyBzdGF0ZSB0byBcInNlbGZcIlxuICAgKiBhbmQgdGhlIHBhcmVudCBtZW51J3MgZm9jdXMgc3RhdGUgdG8gXCJjaGlsZFwiLCBjYWxscyBleHBhbmQsXG4gICAqIGFuZCBzZXRzIHRoZSBpc09wZW4gdmFsdWUgdG8gYHRydWVgLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBvcGVuKCkge1xuICAgIHRoaXMuZWxlbWVudHMuY29udHJvbGxlZE1lbnUuZm9jdXNTdGF0ZSA9IFwic2VsZlwiLCB0aGlzLmlzT3BlbiB8fCAodGhpcy5fZXhwYW5kKCksIHRoaXMuaXNPcGVuID0gITApO1xuICB9XG4gIC8qKlxuICAgKiBPcGVucyB0aGUgY29udHJvbGxlZCBtZW51IHdpdGhvdXQgdGhlIGN1cnJlbnQgZm9jdXMgZW50ZXJpbmcgaXQuXG4gICAqXG4gICAqIFNldHMgdGhlIGNvbnRyb2xsZWQgbWVudSdzIGZvY3VzIHN0YXRlIHRvIFwic2VsZlwiXG4gICAqIGFuZCB0aGUgcGFyZW50IG1lbnUncyBmb2N1cyBzdGF0ZSB0byBcImNoaWxkXCIsXG4gICAqIGFuZCBjYWxscyBleHBhbmQuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHByZXZpZXcoKSB7XG4gICAgdGhpcy5lbGVtZW50cy5wYXJlbnRNZW51ICYmICh0aGlzLmVsZW1lbnRzLnBhcmVudE1lbnUuZm9jdXNTdGF0ZSA9IFwic2VsZlwiKSwgdGhpcy5pc09wZW4gfHwgKHRoaXMuX2V4cGFuZCgpLCB0aGlzLmlzT3BlbiA9ICEwKTtcbiAgfVxuICAvKipcbiAgICogQ2xvc2VzIHRoZSBjb250cm9sbGVkIG1lbnUuXG4gICAqXG4gICAqIFNldHMgdGhlIGNvbnRyb2xsZWQgbWVudSdzIGZvY3VzIHN0YXRlIHRvIFwibm9uZVwiXG4gICAqIGFuZCB0aGUgcGFyZW50IG1lbnUncyBmb2N1cyBzdGF0ZSB0byBcInNlbGZcIiwgYmx1cnMgdGhlIGNvbnRyb2xsZWQgbWVudVxuICAgKiBhbmQgc2V0cyBpdCdzIGN1cnJlbnQgY2hpbGQgaW5kZXggdG8gMCxcbiAgICogY2FsbHMgY29sbGFwc2UsIGFuZCBzZXRzXG4gICAqIHRoZSBpc09wZW4gdmFsdWUgdG8gYGZhbHNlYC5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY2xvc2UoKSB7XG4gICAgdGhpcy5pc09wZW4gJiYgKHRoaXMuZWxlbWVudHMuY29udHJvbGxlZE1lbnUuYmx1cigpLCB0aGlzLmVsZW1lbnRzLnBhcmVudE1lbnUgJiYgKHRoaXMuZWxlbWVudHMucGFyZW50TWVudS5mb2N1c1N0YXRlID0gXCJzZWxmXCIpLCB0aGlzLl9jb2xsYXBzZSgpLCB0aGlzLmlzT3BlbiA9ICExKTtcbiAgfVxuICAvKipcbiAgICogVG9nZ2xlcyB0aGUgb3BlbiBzdGF0ZSBvZiB0aGUgY29udHJvbGxlZCBtZW51IGJldHdlZW4gYHRydWVgIGFuZCBgZmFsc2VgLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICB0b2dnbGUoKSB7XG4gICAgdGhpcy5pc09wZW4gPyB0aGlzLmNsb3NlKCkgOiB0aGlzLm9wZW4oKTtcbiAgfVxuICAvKipcbiAgICogQ2xvc2VzIGFsbCBzaWJsaW5nIG1lbnVzLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBjbG9zZVNpYmxpbmdzKCkge1xuICAgIHRoaXMuZWxlbWVudHMucGFyZW50TWVudSAmJiB0aGlzLmVsZW1lbnRzLnBhcmVudE1lbnUuZWxlbWVudHMuc3VibWVudVRvZ2dsZXMuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgZSAhPT0gdGhpcyAmJiBlLmNsb3NlKCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENsb3NlcyBhbGwgY2hpbGQgbWVudXMuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNsb3NlQ2hpbGRyZW4oKSB7XG4gICAgdGhpcy5lbGVtZW50cy5jb250cm9sbGVkTWVudS5lbGVtZW50cy5zdWJtZW51VG9nZ2xlcy5mb3JFYWNoKFxuICAgICAgKGUpID0+IGUuY2xvc2UoKVxuICAgICk7XG4gIH1cbn1cbmNsYXNzIE8ge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBgQmFzZU1lbnVJdGVtYC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9ICAgICAgICAgIG9wdGlvbnMgICAgICAgICAgICAgICAgICAgICAgICAgLSBUaGUgb3B0aW9ucyBmb3IgZ2VuZXJhdGluZyB0aGUgbWVudSBpdGVtLlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSAgICAgb3B0aW9ucy5tZW51SXRlbUVsZW1lbnQgICAgICAgICAtIFRoZSBtZW51IGl0ZW0gaW4gdGhlIERPTS5cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gICAgIG9wdGlvbnMubWVudUxpbmtFbGVtZW50ICAgICAgICAgLSBUaGUgbWVudSBpdGVtJ3MgbGluayBpbiB0aGUgRE9NLlxuICAgKiBAcGFyYW0ge0Jhc2VNZW51fSAgICAgICAgb3B0aW9ucy5wYXJlbnRNZW51ICAgICAgICAgICAgICAtIFRoZSBwYXJlbnQgbWVudS5cbiAgICogQHBhcmFtIHtib29sZWFufSAgICAgICAgIFtvcHRpb25zLmlzU3VibWVudUl0ZW0gPSBmYWxzZV0gLSBBIGZsYWcgdG8gbWFyayBpZiB0aGUgbWVudSBpdGVtIGlzIGNvbnRyb2xsaW5nIGEgc3VibWVudS5cbiAgICogQHBhcmFtIHs/QmFzZU1lbnV9ICAgICAgIFtvcHRpb25zLmNoaWxkTWVudSA9IG51bGxdICAgICAgLSBUaGUgY2hpbGQgbWVudS5cbiAgICogQHBhcmFtIHs/QmFzZU1lbnVUb2dnbGV9IFtvcHRpb25zLnRvZ2dsZSA9IG51bGxdICAgICAgICAgLSBUaGUgY29udHJvbGxlciBmb3IgdGhlIGNoaWxkIG1lbnUuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbWVudUl0ZW1FbGVtZW50OiBlLFxuICAgIG1lbnVMaW5rRWxlbWVudDogdCxcbiAgICBwYXJlbnRNZW51OiBzLFxuICAgIGlzU3VibWVudUl0ZW06IG4gPSAhMSxcbiAgICBjaGlsZE1lbnU6IGkgPSBudWxsLFxuICAgIHRvZ2dsZTogbCA9IG51bGxcbiAgfSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBET00gZWxlbWVudHMgd2l0aGluIHRoZSBtZW51IGl0ZW0uXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICpcbiAgICAgKiBAdHlwZSB7T2JqZWN0PEhUTUxFbGVtZW50Pn1cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR9IGl0ZW0gLSBUaGUgbWVudSBpdGVtLlxuICAgICAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR9IGxpbmsgLSBUaGUgbWVudSBpdGVtJ3MgbGluay5cbiAgICAgKi9cbiAgICB1KHRoaXMsIFwiX2RvbVwiLCB7XG4gICAgICBpdGVtOiBudWxsLFxuICAgICAgbGluazogbnVsbFxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFRoZSBkZWNsYXJlZCBhY2Nlc3NpYmxlLW1lbnUgZWxlbWVudHMgd2l0aGluIHRoZSBtZW51IGl0ZW0uXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICpcbiAgICAgKiBAdHlwZSB7T2JqZWN0PEJhc2VNZW51LCBCYXNlTWVudVRvZ2dsZT59XG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkge0Jhc2VNZW51fSAgICAgICAgcGFyZW50TWVudSAtIFRoZSBtZW51IGNvbnRhaW5pbmcgdGhpcyBtZW51IGl0ZW0uXG4gICAgICogQHByb3BlcnR5IHs/QmFzZU1lbnV9ICAgICAgIGNoaWxkTWVudSAgLSBUaGUgbWVudSBjb250YWluZWQgd2l0aGluIHRoaXMgbWVudSBpdGVtLlxuICAgICAqIEBwcm9wZXJ0eSB7P0Jhc2VNZW51VG9nZ2xlfSB0b2dnbGUgICAgIC0gVGhlIG1lbnUgdG9nZ2xlIHdpdGhpbiB0aGlzIG1lbnUgaXRlbSB0aGF0IGNvbnRyb2xzIHRoZSBgY2hpbGRNZW51YC5cbiAgICAgKi9cbiAgICB1KHRoaXMsIFwiX2VsZW1lbnRzXCIsIHtcbiAgICAgIHBhcmVudE1lbnU6IG51bGwsXG4gICAgICBjaGlsZE1lbnU6IG51bGwsXG4gICAgICB0b2dnbGU6IG51bGxcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBBIGZsYWcgbWFya2luZyBhIHN1Ym1lbnUgaXRlbS5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHUodGhpcywgXCJfc3VibWVudVwiLCAhMSk7XG4gICAgdGhpcy5fZG9tLml0ZW0gPSBlLCB0aGlzLl9kb20ubGluayA9IHQsIHRoaXMuX2VsZW1lbnRzLnBhcmVudE1lbnUgPSBzLCB0aGlzLl9lbGVtZW50cy5jaGlsZE1lbnUgPSBpLCB0aGlzLl9lbGVtZW50cy50b2dnbGUgPSBsLCB0aGlzLl9zdWJtZW51ID0gbjtcbiAgfVxuICAvKipcbiAgICogSW5pdGlhbGl6ZSB0aGUgbWVudSBpdGVtLlxuICAgKi9cbiAgaW5pdGlhbGl6ZSgpIHtcbiAgfVxuICAvKipcbiAgICogVGhlIERPTSBlbGVtZW50cyB3aXRoaW4gdGhlIG1lbnUgaXRlbS5cbiAgICpcbiAgICogQHJlYWRvbmx5XG4gICAqXG4gICAqIEB0eXBlIHtPYmplY3Q8SFRNTEVsZW1lbnQ+fVxuICAgKlxuICAgKiBAc2VlIF9kb21cbiAgICovXG4gIGdldCBkb20oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RvbTtcbiAgfVxuICAvKipcbiAgICogVGhlIGRlY2xhcmVkIGFjY2Vzc2libGUtbWVudSBlbGVtZW50cyB3aXRoaW4gdGhlIG1lbnUgaXRlbS5cbiAgICpcbiAgICogQHJlYWRvbmx5XG4gICAqXG4gICAqIEB0eXBlIHtPYmplY3Q8QmFzZU1lbnUsIEJhc2VNZW51VG9nZ2xlPn1cbiAgICpcbiAgICogQHNlZSBfZWxlbWVudHNcbiAgICovXG4gIGdldCBlbGVtZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fZWxlbWVudHM7XG4gIH1cbiAgLyoqXG4gICAqIEEgZmxhZyBtYXJraW5nIGEgc3VibWVudSBpdGVtLlxuICAgKlxuICAgKiBAcmVhZG9ubHlcbiAgICpcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqXG4gICAqIEBzZWUgX3N1Ym1lbnVcbiAgICovXG4gIGdldCBpc1N1Ym1lbnVJdGVtKCkge1xuICAgIHJldHVybiB0aGlzLl9zdWJtZW51O1xuICB9XG4gIC8qKlxuICAgKiBGb2N1c2VzIHRoZSBtZW51IGl0ZW0ncyBsaW5rIGlmIHRoZSBwYXJlbnQgbWVudSdzXG4gICAqIHNob3VsZEZvY3VzIHZhbHVlIGlzIGB0cnVlYC5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZm9jdXMoKSB7XG4gICAgdGhpcy5lbGVtZW50cy5wYXJlbnRNZW51LnNob3VsZEZvY3VzICYmIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICB0aGlzLmRvbS5saW5rLmZvY3VzKCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEJsdXJzIHRoZSBtZW51IGl0ZW0ncyBsaW5rIGlmIHRoZSBwYXJlbnQgbWVudSdzXG4gICAqIHNob3VsZEZvY3VzIHZhbHVlIGlzIGB0cnVlYC5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgYmx1cigpIHtcbiAgICB0aGlzLmVsZW1lbnRzLnBhcmVudE1lbnUuc2hvdWxkRm9jdXMgJiYgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIHRoaXMuZG9tLmxpbmsuYmx1cigpO1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBfKHIpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBlID0gci5rZXkgfHwgci5rZXlDb2RlLCB0ID0ge1xuICAgICAgRW50ZXI6IGUgPT09IFwiRW50ZXJcIiB8fCBlID09PSAxMyxcbiAgICAgIFNwYWNlOiBlID09PSBcIiBcIiB8fCBlID09PSBcIlNwYWNlYmFyXCIgfHwgZSA9PT0gMzIsXG4gICAgICBFc2NhcGU6IGUgPT09IFwiRXNjYXBlXCIgfHwgZSA9PT0gXCJFc2NcIiB8fCBlID09PSAyNyxcbiAgICAgIEFycm93VXA6IGUgPT09IFwiQXJyb3dVcFwiIHx8IGUgPT09IFwiVXBcIiB8fCBlID09PSAzOCxcbiAgICAgIEFycm93UmlnaHQ6IGUgPT09IFwiQXJyb3dSaWdodFwiIHx8IGUgPT09IFwiUmlnaHRcIiB8fCBlID09PSAzOSxcbiAgICAgIEFycm93RG93bjogZSA9PT0gXCJBcnJvd0Rvd25cIiB8fCBlID09PSBcIkRvd25cIiB8fCBlID09PSA0MCxcbiAgICAgIEFycm93TGVmdDogZSA9PT0gXCJBcnJvd0xlZnRcIiB8fCBlID09PSBcIkxlZnRcIiB8fCBlID09PSAzNyxcbiAgICAgIEhvbWU6IGUgPT09IFwiSG9tZVwiIHx8IGUgPT09IDM2LFxuICAgICAgRW5kOiBlID09PSBcIkVuZFwiIHx8IGUgPT09IDM1LFxuICAgICAgQ2hhcmFjdGVyOiBpc05hTihlKSAmJiAhIWUubWF0Y2goL15bYS16QS1aXXsxfSQvKSxcbiAgICAgIFRhYjogZSA9PT0gXCJUYWJcIiB8fCBlID09PSA5LFxuICAgICAgQXN0ZXJpc2s6IGUgPT09IFwiKlwiIHx8IGUgPT09IDU2XG4gICAgfTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModCkuZmluZCgocykgPT4gdFtzXSA9PT0gITApIHx8IFwiXCI7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG59XG5mdW5jdGlvbiBvKHIpIHtcbiAgci5wcmV2ZW50RGVmYXVsdCgpLCByLnN0b3BQcm9wYWdhdGlvbigpO1xufVxuY2xhc3MgdyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGBCYXNlTWVudWAuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgICAgICAgICAgICBvcHRpb25zICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBUaGUgb3B0aW9ucyBmb3IgZ2VuZXJhdGluZyB0aGUgbWVudS5cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gICAgICAgIG9wdGlvbnMubWVudUVsZW1lbnQgICAgICAgICAgICAgICAgICAgICAgICAtIFRoZSBtZW51IGVsZW1lbnQgaW4gdGhlIERPTS5cbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgIFtvcHRpb25zLm1lbnVJdGVtU2VsZWN0b3IgPSBsaV0gICAgICAgICAgICAtIFRoZSBxdWVyeSBzZWxlY3RvciBzdHJpbmcgZm9yIG1lbnUgaXRlbXMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICBbb3B0aW9ucy5tZW51TGlua1NlbGVjdG9yID0gYV0gICAgICAgICAgICAgLSBUaGUgcXVlcnkgc2VsZWN0b3Igc3RyaW5nIGZvciBtZW51IGxpbmtzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgW29wdGlvbnMuc3VibWVudUl0ZW1TZWxlY3RvciA9IGxpOmhhcyh1bCldIC0gVGhlIHF1ZXJ5IHNlbGVjdG9yIHN0cmluZyBmb3IgbWVudSBpdGVtcyBjb250YWluaW5nIHN1Ym1lbnVzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgW29wdGlvbnMuc3VibWVudVRvZ2dsZVNlbGVjdG9yID0gYV0gICAgICAgIC0gVGhlIHF1ZXJ5IHNlbGVjdG9yIHN0cmluZyBmb3Igc3VibWVudSB0b2dnbGUgYnV0dG9ucy9saW5rcy5cbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgIFtvcHRpb25zLnN1Ym1lbnVTZWxlY3RvciA9IHVsXSAgICAgICAgICAgICAtIFRoZSBxdWVyeSBzZWxlY3RvciBzdHJpbmcgZm9yIHN1Ym1lbnVzLlxuICAgKiBAcGFyYW0gez9IVE1MRWxlbWVudH0gICAgICAgW29wdGlvbnMuY29udHJvbGxlckVsZW1lbnQgPSBudWxsXSAgICAgICAgIC0gVGhlIGVsZW1lbnQgY29udHJvbGxpbmcgdGhlIG1lbnUgaW4gdGhlIERPTS5cbiAgICogQHBhcmFtIHs/SFRNTEVsZW1lbnR9ICAgICAgIFtvcHRpb25zLmNvbnRhaW5lckVsZW1lbnQgPSBudWxsXSAgICAgICAgICAtIFRoZSBlbGVtZW50IGNvbnRhaW5pbmcgdGhlIG1lbnUgaW4gdGhlIERPTS5cbiAgICogQHBhcmFtIHs/KHN0cmluZ3xzdHJpbmdbXSl9IFtvcHRpb25zLm9wZW5DbGFzcyA9IHNob3ddICAgICAgICAgICAgICAgICAtIFRoZSBjbGFzcyB0byBhcHBseSB3aGVuIGEgbWVudSBpcyBcIm9wZW5cIi5cbiAgICogQHBhcmFtIHs/KHN0cmluZ3xzdHJpbmdbXSl9IFtvcHRpb25zLmNsb3NlQ2xhc3MgPSBoaWRlXSAgICAgICAgICAgICAgICAtIFRoZSBjbGFzcyB0byBhcHBseSB3aGVuIGEgbWVudSBpcyBcImNsb3NlZFwiLlxuICAgKiBAcGFyYW0gez8oc3RyaW5nfHN0cmluZ1tdKX0gW29wdGlvbnMudHJhbnNpdGlvbkNsYXNzID0gdHJhbnNpdGlvbmluZ10gIC0gVGhlIGNsYXNzIHRvIGFwcGx5IHdoZW4gYSBtZW51IGlzIHRyYW5zaXRpb25pbmcgYmV0d2VlbiBcIm9wZW5cIiBhbmQgXCJjbG9zZWRcIiBzdGF0ZXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSAgICAgICAgICAgICBbb3B0aW9ucy50cmFuc2l0aW9uRHVyYXRpb24gPSAyNTBdICAgICAgICAgLSBUaGUgZHVyYXRpb24gb2YgdGhlIHRyYW5zaXRpb24gYmV0d2VlbiBcIm9wZW5cIiBhbmQgXCJjbG9zZWRcIiBzdGF0ZXMgKGluIG1pbGxpc2Vjb25kcykuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgICAgICAgICBbb3B0aW9ucy5vcGVuRHVyYXRpb24gPSAtMV0gICAgICAgICAgICAgICAgLSBUaGUgZHVyYXRpb24gb2YgdGhlIHRyYW5zaXRpb24gZnJvbSBcImNsb3NlZFwiIHRvIFwib3BlblwiIHN0YXRlcyAoaW4gbWlsbGlzZWNvbmRzKS5cbiAgICogQHBhcmFtIHtib29sZWFufSAgICAgICAgICAgIFtvcHRpb25zLmNsb3NlRHVyYXRpb24gPSAtMV0gICAgICAgICAgICAgICAtIFRoZSBkdXJhdGlvbiBvZiB0aGUgdHJhbnNpdGlvbiBmcm9tIFwib3BlblwiIHRvIFwiY2xvc2VkXCIgc3RhdGVzIChpbiBtaWxsaXNlY29uZHMpLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICAgICAgICAgW29wdGlvbnMuaXNUb3BMZXZlbCA9IGZhbHNlXSAgICAgICAgICAgICAgIC0gQSBmbGFnIHRvIG1hcmsgdGhlIHJvb3QgbWVudS5cbiAgICogQHBhcmFtIHs/QmFzZU1lbnV9ICAgICAgICAgIFtvcHRpb25zLnBhcmVudE1lbnUgPSBudWxsXSAgICAgICAgICAgICAgICAtIFRoZSBwYXJlbnQgbWVudSB0byB0aGlzIG1lbnUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICBbb3B0aW9ucy5ob3ZlclR5cGUgPSBvZmZdICAgICAgICAgICAgICAgICAgLSBUaGUgdHlwZSBvZiBob3ZlcmFiaWxpdHkgYSBtZW51IGhhcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9ICAgICAgICAgICAgIFtvcHRpb25zLmhvdmVyRGVsYXkgPSAyNTBdICAgICAgICAgICAgICAgICAtIFRoZSBkZWxheSBmb3Igb3BlbmluZyBhbmQgY2xvc2luZyBtZW51cyBpZiB0aGUgbWVudSBpcyBob3ZlcmFibGUgKGluIG1pbGxpc2Vjb25kcykuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSAgICAgICAgICAgICBbb3B0aW9ucy5lbnRlckRlbGF5ID0gLTFdICAgICAgICAgICAgICAgICAgLSBUaGUgZGVsYXkgZm9yIG9wZW5pbmcgbWVudXMgaWYgdGhlIG1lbnUgaXMgaG92ZXJhYmxlIChpbiBtaWxsaXNlY29uZHMpLlxuICAgKiBAcGFyYW0ge251bWJlcn0gICAgICAgICAgICAgW29wdGlvbnMubGVhdmVEZWxheSA9IC0xXSAgICAgICAgICAgICAgICAgIC0gVGhlIGRlbGF5IGZvciBjbG9zaW5nIG1lbnVzIGlmIHRoZSBtZW51IGlzIGhvdmVyYWJsZSAoaW4gbWlsbGlzZWNvbmRzKS5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSAgICAgICAgICAgIFtvcHRpb25zLnByZWZpeCA9IGFtLV0gICAgICAgICAgICAgICAgICAgICAtIFRoZSBwcmVmaXggdG8gdXNlIGZvciBDU1MgY3VzdG9tIHByb3BlcnRpZXMuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbWVudUVsZW1lbnQ6IGUsXG4gICAgbWVudUl0ZW1TZWxlY3RvcjogdCA9IFwibGlcIixcbiAgICBtZW51TGlua1NlbGVjdG9yOiBzID0gXCJhXCIsXG4gICAgc3VibWVudUl0ZW1TZWxlY3RvcjogbiA9IFwibGk6aGFzKHVsKVwiLFxuICAgIHN1Ym1lbnVUb2dnbGVTZWxlY3RvcjogaSA9IFwiYVwiLFxuICAgIHN1Ym1lbnVTZWxlY3RvcjogbCA9IFwidWxcIixcbiAgICBjb250cm9sbGVyRWxlbWVudDogaCA9IG51bGwsXG4gICAgY29udGFpbmVyRWxlbWVudDogbSA9IG51bGwsXG4gICAgb3BlbkNsYXNzOiBhID0gXCJzaG93XCIsXG4gICAgY2xvc2VDbGFzczogcCA9IFwiaGlkZVwiLFxuICAgIHRyYW5zaXRpb25DbGFzczogZiA9IFwidHJhbnNpdGlvbmluZ1wiLFxuICAgIHRyYW5zaXRpb25EdXJhdGlvbjogZyA9IDI1MCxcbiAgICBvcGVuRHVyYXRpb246IGQgPSAtMSxcbiAgICBjbG9zZUR1cmF0aW9uOiBNID0gLTEsXG4gICAgaXNUb3BMZXZlbDogeSA9ICEwLFxuICAgIHBhcmVudE1lbnU6IGIgPSBudWxsLFxuICAgIGhvdmVyVHlwZTogQyA9IFwib2ZmXCIsXG4gICAgaG92ZXJEZWxheTogVCA9IDI1MCxcbiAgICBlbnRlckRlbGF5OiBFID0gLTEsXG4gICAgbGVhdmVEZWxheTogdiA9IC0xLFxuICAgIHByZWZpeDogSSA9IFwiYW0tXCJcbiAgfSkge1xuICAgIC8qKlxuICAgICAqIFRoZSBjbGFzcyB0byB1c2Ugd2hlbiBnZW5lcmF0aW5nIHN1Ym1lbnVzLlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqXG4gICAgICogQHR5cGUge3R5cGVvZiBCYXNlTWVudX1cbiAgICAgKi9cbiAgICB1KHRoaXMsIFwiX01lbnVUeXBlXCIsIHcpO1xuICAgIC8qKlxuICAgICAqIFRoZSBjbGFzcyB0byB1c2Ugd2hlbiBnZW5lcmF0aW5nIG1lbnUgaXRlbXMuXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICpcbiAgICAgKiBAdHlwZSB7dHlwZW9mIEJhc2VNZW51SXRlbX1cbiAgICAgKi9cbiAgICB1KHRoaXMsIFwiX01lbnVJdGVtVHlwZVwiLCBPKTtcbiAgICAvKipcbiAgICAgKiBUaGUgY2xhc3MgdG8gdXNlIHdoZW4gZ2VuZXJhdGluZyBzdWJtZW51IHRvZ2dsZXMuXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICpcbiAgICAgKiBAdHlwZSB7dHlwZW9mIEJhc2VNZW51VG9nZ2xlfVxuICAgICAqL1xuICAgIHUodGhpcywgXCJfTWVudVRvZ2dsZVR5cGVcIiwgTCk7XG4gICAgLyoqXG4gICAgICogVGhlIERPTSBlbGVtZW50cyB3aXRoaW4gdGhlIG1lbnUuXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICpcbiAgICAgKiBAdHlwZSB7T2JqZWN0PEhUTUxFbGVtZW50LCBIVE1MRWxlbWVudFtdPn1cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR9ICAgbWVudSAgICAgICAgICAgLSBUaGUgbWVudSBlbGVtZW50LlxuICAgICAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnRbXX0gbWVudUl0ZW1zICAgICAgLSBBbiBhcnJheSBvZiBtZW51IGl0ZW1zLlxuICAgICAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnRbXX0gc3VibWVudUl0ZW1zICAgLSBBbiBhcnJheSBvZiBtZW51IGl0ZW1zIHRoYXQgYWxzbyBjb250YWluIHN1Ym1lbnUgZWxlbWVudHMuXG4gICAgICogQHByb3BlcnR5IHtIVE1MRWxlbWVudFtdfSBzdWJtZW51VG9nZ2xlcyAtIEFuIGFycmF5IG9mIG1lbnUgbGlua3MgdGhhdCBmdW5jdGlvbiBhcyBzdWJtZW51IHRvZ2dsZXMuXG4gICAgICogQHByb3BlcnR5IHtIVE1MRWxlbWVudFtdfSBzdWJtZW51cyAgICAgICAtIEFuIGFycmF5IG9mIHN1Ym1lbnUgZWxlbWVudHMuXG4gICAgICogQHByb3BlcnR5IHtIVE1MRWxlbWVudH0gICBjb250cm9sbGVyICAgICAtIFRoZSB0b2dnbGUgZm9yIHRoaXMgbWVudS5cbiAgICAgKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSAgIGNvbnRhaW5lciAgICAgIC0gVGhlIGNvbnRhaW5lciBmb3IgdGhpcyBtZW51LlxuICAgICAqL1xuICAgIHUodGhpcywgXCJfZG9tXCIsIHtcbiAgICAgIG1lbnU6IG51bGwsXG4gICAgICBtZW51SXRlbXM6IFtdLFxuICAgICAgc3VibWVudUl0ZW1zOiBbXSxcbiAgICAgIHN1Ym1lbnVUb2dnbGVzOiBbXSxcbiAgICAgIHN1Ym1lbnVzOiBbXSxcbiAgICAgIGNvbnRyb2xsZXI6IG51bGwsXG4gICAgICBjb250YWluZXI6IG51bGxcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBUaGUgcXVlcnkgc2VsZWN0b3JzIHVzZWQgYnkgdGhlIG1lbnUgdG8gcG9wdWxhdGUgdGhlIGRvbS5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKlxuICAgICAqIEB0eXBlIHtPYmplY3Q8c3RyaW5nPn1cbiAgICAgKlxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZW51SXRlbXMgICAgICAtIFRoZSBxdWVyeSBzZWxlY3RvciBmb3IgbWVudSBpdGVtcy5cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gbWVudUxpbmtzICAgICAgLSBUaGUgcXVlcnkgc2VsZWN0b3IgZm9yIG1lbnUgbGlua3MuXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHN1Ym1lbnVJdGVtcyAgIC0gVGhlIHF1ZXJ5IHNlbGVjdG9yIGZvciBtZW51IGl0ZW1zIGNvbnRhaW5pbmcgc3VibWVudXMuXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHN1Ym1lbnVUb2dnbGVzIC0gVGhlIHF1ZXJ5IHNlbGVjdG9yIGZvciBtZW51IGxpbmtzIHRoYXQgZnVuY3Rpb24gYXMgc3VibWVudSB0b2dnbGVzLlxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzdWJtZW51cyAgICAgICAtIFRoZSBxdWVyeSBzZWxlY3RvciBmb3IgZm9yIHN1Ym1lbnVzLlxuICAgICAqL1xuICAgIHUodGhpcywgXCJfc2VsZWN0b3JzXCIsIHtcbiAgICAgIG1lbnVJdGVtczogXCJcIixcbiAgICAgIG1lbnVMaW5rczogXCJcIixcbiAgICAgIHN1Ym1lbnVJdGVtczogXCJcIixcbiAgICAgIHN1Ym1lbnVUb2dnbGVzOiBcIlwiLFxuICAgICAgc3VibWVudXM6IFwiXCJcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBUaGUgZGVjbGFyZWQgYWNjZXNzaWJsZS1tZW51IGVsZW1lbnRzIHdpdGhpbiB0aGUgbWVudS5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKlxuICAgICAqIEB0eXBlIHtPYmplY3Q8QmFzZU1lbnUsIEJhc2VNZW51VG9nZ2xlLCBCYXNlTWVudUl0ZW1bXSwgQmFzZU1lbnVUb2dnbGVbXT59XG4gICAgICpcbiAgICAgKiBAcHJvcGVydHkge0Jhc2VNZW51SXRlbVtdfSAgIG1lbnVJdGVtcyAgICAgIC0gQW4gYXJyYXkgb2YgbWVudSBpdGVtcy5cbiAgICAgKiBAcHJvcGVydHkge0Jhc2VNZW51VG9nZ2xlW119IHN1Ym1lbnVUb2dnbGVzIC0gQW4gYXJyYXkgb2YgbWVudSB0b2dnbGVzLlxuICAgICAqIEBwcm9wZXJ0eSB7P0Jhc2VNZW51VG9nZ2xlfSAgY29udHJvbGxlciAgICAgLSBBIG1lbnUgdG9nZ2xlIHRoYXQgY29udHJvbHMgdGhpcyBtZW51LlxuICAgICAqIEBwcm9wZXJ0eSB7P0Jhc2VNZW51fSAgICAgICAgcGFyZW50TWVudSAgICAgLSBUaGUgcGFyZW50IG1lbnUuXG4gICAgICogQHByb3BlcnR5IHs/QmFzZU1lbnV9ICAgICAgICByb290TWVudSAgICAgICAtIFRoZSByb290IG1lbnUgb2YgdGhlIG1lbnUgdHJlZS5cbiAgICAgKi9cbiAgICB1KHRoaXMsIFwiX2VsZW1lbnRzXCIsIHtcbiAgICAgIG1lbnVJdGVtczogW10sXG4gICAgICBzdWJtZW51VG9nZ2xlczogW10sXG4gICAgICBjb250cm9sbGVyOiBudWxsLFxuICAgICAgcGFyZW50TWVudTogbnVsbCxcbiAgICAgIHJvb3RNZW51OiBudWxsXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogVGhlIGNsYXNzKGVzKSB0byBhcHBseSB3aGVuIHRoZSBtZW51IGlzIG9wZW4uXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICpcbiAgICAgKiBAdHlwZSB7c3RyaW5nfHN0cmluZ1tdfVxuICAgICAqL1xuICAgIHUodGhpcywgXCJfb3BlbkNsYXNzXCIsIFwic2hvd1wiKTtcbiAgICAvKipcbiAgICAgKiBUaGUgY2xhc3MoZXMpIHRvIGFwcGx5IHdoZW4gdGhlIG1lbnUgaXMgY2xvc2VkLlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqXG4gICAgICogQHR5cGUge3N0cmluZ3xzdHJpbmdbXX1cbiAgICAgKi9cbiAgICB1KHRoaXMsIFwiX2Nsb3NlQ2xhc3NcIiwgXCJoaWRlXCIpO1xuICAgIC8qKlxuICAgICAqIFRoZSBjbGFzcyhlcykgdG8gYXBwbHkgd2hlbiB0aGUgbWVudSBpcyB0cmFuc2l0aW9uaW5nIGJldHdlZW4gc3RhdGVzLlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqXG4gICAgICogQHR5cGUge3N0cmluZ3xzdHJpbmdbXX1cbiAgICAgKi9cbiAgICB1KHRoaXMsIFwiX3RyYW5zaXRpb25DbGFzc1wiLCBcInRyYW5zaXRpb25pbmdcIik7XG4gICAgLyoqXG4gICAgICogVGhlIGR1cmF0aW9uIHRpbWUgKGluIG1pbGxpc2Vjb25kcykgZm9yIHRoZSB0cmFuc2l0aW9uIGJldHdlZW4gb3BlbiBhbmQgY2xvc2VkIHN0YXRlcy5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdSh0aGlzLCBcIl90cmFuc2l0aW9uRHVyYXRpb25cIiwgMjUwKTtcbiAgICAvKipcbiAgICAgKiBUaGUgZHVyYXRpb24gdGltZSAoaW4gbWlsbGlzZWNvbmRzKSBmb3IgdGhlIHRyYW5zaXRpb24gZnJvbSBjbG9zZWQgdG8gb3BlbiBzdGF0ZXMuXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHUodGhpcywgXCJfb3BlbkR1cmF0aW9uXCIsIC0xKTtcbiAgICAvKipcbiAgICAgKiBUaGUgZHVyYXRpb24gdGltZSAoaW4gbWlsbGlzZWNvbmRzKSBmb3IgdGhlIHRyYW5zaXRpb24gZnJvbSBvcGVuIHRvIGNsb3NlZCBzdGF0ZXMuXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHUodGhpcywgXCJfY2xvc2VEdXJhdGlvblwiLCAtMSk7XG4gICAgLyoqXG4gICAgICogQSBmbGFnIG1hcmtpbmcgdGhlIHJvb3QgbWVudS5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqL1xuICAgIHUodGhpcywgXCJfcm9vdFwiLCAhMCk7XG4gICAgLyoqXG4gICAgICogVGhlIGluZGV4IG9mIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgbWVudSBpdGVtIGluIHRoZSBtZW51LlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB1KHRoaXMsIFwiX2N1cnJlbnRDaGlsZFwiLCAwKTtcbiAgICAvKipcbiAgICAgKiBUaGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgbWVudSdzIGZvY3VzLlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB1KHRoaXMsIFwiX2ZvY3VzU3RhdGVcIiwgXCJub25lXCIpO1xuICAgIC8qKlxuICAgICAqIFRoaXMgbGFzdCBldmVudCB0cmlnZ2VyZWQgb24gdGhlIG1lbnUuXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICpcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHUodGhpcywgXCJfY3VycmVudEV2ZW50XCIsIFwibm9uZVwiKTtcbiAgICAvKipcbiAgICAgKiBUaGUgdHlwZSBvZiBob3ZlcmFiaWxpdHkgZm9yIHRoZSBtZW51LlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICB1KHRoaXMsIFwiX2hvdmVyVHlwZVwiLCBcIm9mZlwiKTtcbiAgICAvKipcbiAgICAgKiBUaGUgZGVsYXkgdGltZSAoaW4gbWlsbGlzZWNvbmRzKSB1c2VkIGZvciBwb2ludGVyZW50ZXIvcG9pbnRlcmxlYXZlIGV2ZW50cyB0byB0YWtlIHBsYWNlLlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB1KHRoaXMsIFwiX2hvdmVyRGVsYXlcIiwgMjUwKTtcbiAgICAvKipcbiAgICAgKiBUaGUgZGVsYXkgdGltZSAoaW4gbWlsbGlzZWNvbmRzKSB1c2VkIGZvciBwb2ludGVyZW50ZXIgZXZlbnRzIHRvIHRha2UgcGxhY2UuXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHUodGhpcywgXCJfZW50ZXJEZWxheVwiLCAtMSk7XG4gICAgLyoqXG4gICAgICogVGhlIGRlbGF5IHRpbWUgKGluIG1pbGxpc2Vjb25kcykgdXNlZCBmb3IgcG9pbnRlcmxlYXZlIGV2ZW50cyB0byB0YWtlIHBsYWNlLlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKi9cbiAgICB1KHRoaXMsIFwiX2xlYXZlRGVsYXlcIiwgLTEpO1xuICAgIC8qKlxuICAgICAqIFRoZSBwcmVmaXggdG8gdXNlIGZvciBDU1MgY3VzdG9tIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICpcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqL1xuICAgIHUodGhpcywgXCJfcHJlZml4XCIsIFwiYW0tXCIpO1xuICAgIC8qKlxuICAgICAqIEEgdmFyaWFibGUgdG8gaG9sZCB0aGUgaG92ZXIgdGltZW91dCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKlxuICAgICAqIEB0eXBlIHs/RnVuY3Rpb259XG4gICAgICovXG4gICAgdSh0aGlzLCBcIl9ob3ZlclRpbWVvdXRcIiwgbnVsbCk7XG4gICAgLyoqXG4gICAgICogQSBmbGFnIHRvIGNoZWNrIGlmIHRoZSBtZW51IGNhbiBkeW5hbWljYWxseSBob3ZlciBiYXNlZCBvbiBpZiBhIG1lbnUgaGFzIGJlZW4gb3BlbmVkIGFscmVhZHkuXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB1KHRoaXMsIFwiX2hhc09wZW5lZFwiLCAhMSk7XG4gICAgLyoqXG4gICAgICogQW4gYXJyYXkgb2YgZXJyb3IgbWVzc2FnZXMgZ2VuZXJhdGVkIGJ5IHRoZSBtZW51LlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqXG4gICAgICogQHR5cGUge3N0cmluZ1tdfVxuICAgICAqL1xuICAgIHUodGhpcywgXCJfZXJyb3JzXCIsIFtdKTtcbiAgICB0aGlzLl9kb20ubWVudSA9IGUsIHRoaXMuX2RvbS5jb250cm9sbGVyID0gaCwgdGhpcy5fZG9tLmNvbnRhaW5lciA9IG0sIHRoaXMuX3NlbGVjdG9ycy5tZW51SXRlbXMgPSB0LCB0aGlzLl9zZWxlY3RvcnMubWVudUxpbmtzID0gcywgdGhpcy5fc2VsZWN0b3JzLnN1Ym1lbnVJdGVtcyA9IG4sIHRoaXMuX3NlbGVjdG9ycy5zdWJtZW51VG9nZ2xlcyA9IGksIHRoaXMuX3NlbGVjdG9ycy5zdWJtZW51cyA9IGwsIHRoaXMuX2VsZW1lbnRzLm1lbnVJdGVtcyA9IFtdLCB0aGlzLl9lbGVtZW50cy5zdWJtZW51VG9nZ2xlcyA9IFtdLCB0aGlzLl9lbGVtZW50cy5jb250cm9sbGVyID0gbnVsbCwgdGhpcy5fZWxlbWVudHMucGFyZW50TWVudSA9IGIsIHRoaXMuX2VsZW1lbnRzLnJvb3RNZW51ID0geSA/IHRoaXMgOiBudWxsLCB0aGlzLl9vcGVuQ2xhc3MgPSBhIHx8IFwiXCIsIHRoaXMuX2Nsb3NlQ2xhc3MgPSBwIHx8IFwiXCIsIHRoaXMuX3RyYW5zaXRpb25DbGFzcyA9IGYgfHwgXCJcIiwgdGhpcy5fdHJhbnNpdGlvbkR1cmF0aW9uID0gZywgdGhpcy5fb3BlbkR1cmF0aW9uID0gZCwgdGhpcy5fY2xvc2VEdXJhdGlvbiA9IE0sIHRoaXMuX3ByZWZpeCA9IEkgfHwgXCJcIiwgdGhpcy5fcm9vdCA9IHksIHRoaXMuX2hvdmVyVHlwZSA9IEMsIHRoaXMuX2hvdmVyRGVsYXkgPSBULCB0aGlzLl9lbnRlckRlbGF5ID0gRSwgdGhpcy5fbGVhdmVEZWxheSA9IHY7XG4gIH1cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBtZW51LlxuICAgKlxuICAgKiBUaGUgZm9sbG93aW5nIHN0ZXBzIHdpbGwgYmUgdGFrZW4gdG8gaW5pdGlhbGl6ZSB0aGUgbWVudTpcbiAgICogLSBWYWxpZGF0ZSB0aGF0IHRoZSBtZW51IGNhbiBpbml0aWFsaXplLlxuICAgKiAtIEZpbmQgdGhlIHJvb3QgbWVudSBvZiB0aGUgbWVudSB0cmVlIGlmIGl0IGlzbid0IGFscmVhZHkgc2V0LlxuICAgKiAtIFBvcHVsYXRlIGFsbCBET00gZWxlbWVudHMgd2l0aGluIHRoZSBkb20uXG4gICAqIC0gSWYgdGhlIGN1cnJlbnQgbWVudSBpcyB0aGUgcm9vdCBtZW51IF9hbmRfIGhhcyBhIGNvbnRyb2xsZXIsIGluaXRpYWxpemVcbiAgICogICB0aGUgY29udHJvbGxlci5cbiAgICogLSBQb3B1bGF0ZSB0aGUgbWVudSBlbGVtZW50cyB3aXRoaW4gdGhlIGVsZW1lbnRzLlxuICAgKiAtIFNldCB0aGUgdHJhbnNpdGlvbiBkdXJhdGlvbiBjdXN0b20gcHJvcCBmb3IgdGhlIG1lbnUuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICpcbiAgICogQHRocm93cyB7RXJyb3J9IFdpbGwgdGhyb3cgYW4gRXJyb3IgaWYgdmFsaWRhdGUgcmV0dXJucyBgZmFsc2VgLlxuICAgKi9cbiAgaW5pdGlhbGl6ZSgpIHtcbiAgICBpZiAoIXRoaXMuX3ZhbGlkYXRlKCkpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBBY2Nlc3NpYmxlTWVudTogY2Fubm90IGluaXRpYWxpemUgbWVudS4gVGhlIGZvbGxvd2luZyBlcnJvcnMgaGF2ZSBiZWVuIGZvdW5kOlxuIC0gJHt0aGlzLmVycm9ycy5qb2luKFxuICAgICAgICAgIGBcbiAtIGBcbiAgICAgICAgKX1gXG4gICAgICApO1xuICAgIGlmICh0aGlzLmVsZW1lbnRzLnJvb3RNZW51ID09PSBudWxsICYmIHRoaXMuX2ZpbmRSb290TWVudSh0aGlzKSwgdGhpcy5fc2V0RE9NRWxlbWVudHMoKSwgdGhpcy5pc1RvcExldmVsICYmIHRoaXMuZG9tLmNvbnRyb2xsZXIgJiYgdGhpcy5kb20uY29udGFpbmVyKSB7XG4gICAgICBjb25zdCBlID0gbmV3IHRoaXMuX01lbnVUb2dnbGVUeXBlKHtcbiAgICAgICAgbWVudVRvZ2dsZUVsZW1lbnQ6IHRoaXMuZG9tLmNvbnRyb2xsZXIsXG4gICAgICAgIHBhcmVudEVsZW1lbnQ6IHRoaXMuZG9tLmNvbnRhaW5lcixcbiAgICAgICAgY29udHJvbGxlZE1lbnU6IHRoaXNcbiAgICAgIH0pO1xuICAgICAgRihcImJ1dHRvblwiLCB7IHRvZ2dsZTogZS5kb20udG9nZ2xlIH0pIHx8IGUuZG9tLnRvZ2dsZS5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwiYnV0dG9uXCIpLCBlLmRvbS50b2dnbGUuc2V0QXR0cmlidXRlKFwiYXJpYS1jb250cm9sc1wiLCB0aGlzLmRvbS5tZW51LmlkKSwgdGhpcy5fZWxlbWVudHMuY29udHJvbGxlciA9IGU7XG4gICAgfVxuICAgIHRoaXMuX2NyZWF0ZUNoaWxkRWxlbWVudHMoKSwgdGhpcy5fc2V0VHJhbnNpdGlvbkR1cmF0aW9ucygpLCB0aGlzLmlzVG9wTGV2ZWwgJiYgKHdpbmRvdy5BY2Nlc3NpYmxlTWVudSA9IHdpbmRvdy5BY2Nlc3NpYmxlTWVudSB8fCB7XG4gICAgICBtZW51czoge31cbiAgICB9LCB3aW5kb3cuQWNjZXNzaWJsZU1lbnUubWVudXNbdGhpcy5kb20ubWVudS5pZF0gPSB0aGlzKTtcbiAgfVxuICAvKipcbiAgICogVGhlIERPTSBlbGVtZW50cyB3aXRoaW4gdGhlIG1lbnUuXG4gICAqXG4gICAqIEByZWFkb25seVxuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0PEhUTUxFbGVtZW50LCBIVE1MRWxlbWVudFtdPn1cbiAgICpcbiAgICogQHNlZSBfZG9tXG4gICAqL1xuICBnZXQgZG9tKCkge1xuICAgIHJldHVybiB0aGlzLl9kb207XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBxdWVyeSBzZWxlY3RvcnMgdXNlZCBieSB0aGUgbWVudSB0byBwb3B1bGF0ZSB0aGUgZG9tLlxuICAgKlxuICAgKiBAcmVhZG9ubHlcbiAgICpcbiAgICogQHR5cGUge09iamVjdDxzdHJpbmc+fVxuICAgKlxuICAgKiBAc2VlIF9zZWxlY3RvcnNcbiAgICovXG4gIGdldCBzZWxlY3RvcnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3NlbGVjdG9ycztcbiAgfVxuICAvKipcbiAgICogVGhlIGRlY2xhcmVkIGFjY2Vzc2libGUtbWVudSBlbGVtZW50cyB3aXRoaW4gdGhlIG1lbnUuXG4gICAqXG4gICAqIEByZWFkb25seVxuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0PEJhc2VNZW51LCBCYXNlTWVudVRvZ2dsZSwgQmFzZU1lbnVJdGVtW10sIEJhc2VNZW51VG9nZ2xlW10+fVxuICAgKlxuICAgKiBAc2VlIF9lbGVtZW50c1xuICAgKi9cbiAgZ2V0IGVsZW1lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLl9lbGVtZW50cztcbiAgfVxuICAvKipcbiAgICogVGhlIGZsYWcgbWFya2luZyB0aGUgcm9vdCBtZW51LlxuICAgKlxuICAgKiBAcmVhZG9ubHlcbiAgICpcbiAgICogQHR5cGUge2Jvb2xlYW59XG4gICAqXG4gICAqIEBzZWUgX3Jvb3RcbiAgICovXG4gIGdldCBpc1RvcExldmVsKCkge1xuICAgIHJldHVybiB0aGlzLl9yb290O1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY2xhc3MoZXMpIHRvIGFwcGx5IHdoZW4gdGhlIG1lbnUgaXMgb3Blbi5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbnMgZGlmZmVyZW50bHkgZm9yIHJvb3QgdnMuIHN1Ym1lbnVzLlxuICAgKiBTdWJtZW51cyB3aWxsIGFsd2F5cyBpbmhlcml0IHRoZWlyIHJvb3QgbWVudSdzIG9wZW4gY2xhc3MoZXMpLlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfHN0cmluZ1tdfVxuICAgKlxuICAgKiBAc2VlIF9vcGVuQ2xhc3NcbiAgICovXG4gIGdldCBvcGVuQ2xhc3MoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNUb3BMZXZlbCA/IHRoaXMuX29wZW5DbGFzcyA6IHRoaXMuZWxlbWVudHMucm9vdE1lbnUub3BlbkNsYXNzO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY2xhc3MoZXMpIHRvIGFwcGx5IHdoZW4gdGhlIG1lbnUgaXMgY2xvc2VkLlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9ucyBkaWZmZXJlbnRseSBmb3Igcm9vdCB2cy4gc3VibWVudXMuXG4gICAqIFN1Ym1lbnVzIHdpbGwgYWx3YXlzIGluaGVyaXQgdGhlaXIgcm9vdCBtZW51J3MgY2xvc2UgY2xhc3MoZXMpLlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfHN0cmluZ1tdfVxuICAgKlxuICAgKiBAc2VlIF9jbG9zZUNsYXNzXG4gICAqL1xuICBnZXQgY2xvc2VDbGFzcygpIHtcbiAgICByZXR1cm4gdGhpcy5pc1RvcExldmVsID8gdGhpcy5fY2xvc2VDbGFzcyA6IHRoaXMuZWxlbWVudHMucm9vdE1lbnUuY2xvc2VDbGFzcztcbiAgfVxuICAvKipcbiAgICogVGhlIGNsYXNzKGVzKSB0byBhcHBseSB3aGVuIHRoZSBtZW51IGlzIHRyYW5zaXRpb25pbmcgYmV0d2VlbiBvcGVuIGFuZCBjbG9zZWQuXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb25zIGRpZmZlcmVudGx5IGZvciByb290IHZzLiBzdWJtZW51cy5cbiAgICogU3VibWVudXMgd2lsbCBhbHdheXMgaW5oZXJpdCB0aGVpciByb290IG1lbnUncyB0cmFuc2l0aW9uIGNsYXNzKGVzKS5cbiAgICpcbiAgICogQHR5cGUge3N0cmluZ3xzdHJpbmdbXX1cbiAgICpcbiAgICogQHNlZSBfdHJhbnNpdGlvbkNsYXNzXG4gICAqL1xuICBnZXQgdHJhbnNpdGlvbkNsYXNzKCkge1xuICAgIHJldHVybiB0aGlzLmlzVG9wTGV2ZWwgPyB0aGlzLl90cmFuc2l0aW9uQ2xhc3MgOiB0aGlzLmVsZW1lbnRzLnJvb3RNZW51LnRyYW5zaXRpb25DbGFzcztcbiAgfVxuICAvKipcbiAgICogVGhlIGR1cmF0aW9uIHRpbWUgKGluIG1pbGxpc2Vjb25kcykgZm9yIHRoZSB0cmFuc2l0aW9uIGJldHdlZW4gb3BlbiBhbmQgY2xvc2VkIHN0YXRlcy5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbnMgZGlmZmVyZW50bHkgZm9yIHJvb3QgdnMuIHN1Ym1lbnVzLlxuICAgKiBTdWJtZW51cyB3aWxsIGFsd2F5cyBpbmhlcml0IHRoZWlyIHJvb3QgbWVudSdzIHRyYW5zaXRpb24gZHVyYXRpb24uXG4gICAqXG4gICAqIFNldHRpbmcgdGhpcyB2YWx1ZSB3aWxsIGFsc28gc2V0IHRoZSAtLWFtLXRyYW5zaXRpb24tZHVyYXRpb24gQ1NTIGN1c3RvbSBwcm9wZXJ0eSBvbiB0aGUgbWVudS5cbiAgICpcbiAgICogQHR5cGUge251bWJlcn1cbiAgICpcbiAgICogQHNlZSBfdHJhbnNpdGlvbkR1cmF0aW9uXG4gICAqL1xuICBnZXQgdHJhbnNpdGlvbkR1cmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmlzVG9wTGV2ZWwgPyB0aGlzLl90cmFuc2l0aW9uRHVyYXRpb24gOiB0aGlzLmVsZW1lbnRzLnJvb3RNZW51LnRyYW5zaXRpb25EdXJhdGlvbjtcbiAgfVxuICAvKipcbiAgICogVGhlIGR1cmF0aW9uIHRpbWUgKGluIG1pbGxpc2Vjb25kcykgZm9yIHRoZSB0cmFuc2l0aW9uIGZyb20gY2xvc2VkIHRvIG9wZW4gc3RhdGVzLlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9ucyBkaWZmZXJlbnRseSBmb3Igcm9vdCB2cy4gc3VibWVudXMuXG4gICAqIFN1Ym1lbnVzIHdpbGwgYWx3YXlzIGluaGVyaXQgdGhlaXIgcm9vdCBtZW51J3Mgb3BlbkR1cmF0aW9uLlxuICAgKlxuICAgKiBJZiBvcGVuRHVyYXRpb24gaXMgc2V0IHRvIC0xLCB0aGUgdHJhbnNpdGlvbkR1cmF0aW9uIHZhbHVlIHdpbGwgYmUgdXNlZCBpbnN0ZWFkLlxuICAgKlxuICAgKiBTZXR0aW5nIHRoaXMgdmFsdWUgd2lsbCBhbHNvIHNldCB0aGUgLS1hbS1vcGVuLXRyYW5zaXRpb24tZHVyYXRpb24gQ1NTIGN1c3RvbSBwcm9wZXJ0eSBvbiB0aGUgbWVudS5cbiAgICpcbiAgICogQHR5cGUge251bWJlcn1cbiAgICpcbiAgICogQHNlZSBfb3BlbkR1cmF0aW9uXG4gICAqL1xuICBnZXQgb3BlbkR1cmF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9vcGVuRHVyYXRpb24gPT09IC0xID8gdGhpcy50cmFuc2l0aW9uRHVyYXRpb24gOiB0aGlzLmlzVG9wTGV2ZWwgPyB0aGlzLl9vcGVuRHVyYXRpb24gOiB0aGlzLmVsZW1lbnRzLnJvb3RNZW51Lm9wZW5EdXJhdGlvbjtcbiAgfVxuICAvKipcbiAgICogVGhlIGR1cmF0aW9uIHRpbWUgKGluIG1pbGxpc2Vjb25kcykgZm9yIHRoZSB0cmFuc2l0aW9uIGZyb20gb3BlbiB0byBjbG9zZWQgc3RhdGVzLlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9ucyBkaWZmZXJlbnRseSBmb3Igcm9vdCB2cy4gc3VibWVudXMuXG4gICAqIFN1Ym1lbnVzIHdpbGwgYWx3YXlzIGluaGVyaXQgdGhlaXIgcm9vdCBtZW51J3MgY2xvc2VEdXJhdGlvbi5cbiAgICpcbiAgICogSWYgY2xvc2VEdXJhdGlvbiBpcyBzZXQgdG8gLTEsIHRoZSB0cmFuc2l0aW9uRHVyYXRpb24gdmFsdWUgd2lsbCBiZSB1c2VkIGluc3RlYWQuXG4gICAqXG4gICAqIFNldHRpbmcgdGhpcyB2YWx1ZSB3aWxsIGFsc28gc2V0IHRoZSAtLWFtLWNsb3NlLXRyYW5zaXRpb24tZHVyYXRpb24gQ1NTIGN1c3RvbSBwcm9wZXJ0eSBvbiB0aGUgbWVudS5cbiAgICpcbiAgICogQHR5cGUge251bWJlcn1cbiAgICpcbiAgICogQHNlZSBfY2xvc2VEdXJhdGlvblxuICAgKi9cbiAgZ2V0IGNsb3NlRHVyYXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nsb3NlRHVyYXRpb24gPT09IC0xID8gdGhpcy50cmFuc2l0aW9uRHVyYXRpb24gOiB0aGlzLmlzVG9wTGV2ZWwgPyB0aGlzLl9jbG9zZUR1cmF0aW9uIDogdGhpcy5lbGVtZW50cy5yb290TWVudS5jbG9zZUR1cmF0aW9uO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgaW5kZXggb2YgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBtZW51IGl0ZW0gaW4gdGhlIG1lbnUuXG4gICAqXG4gICAqIC0gQXR0ZW1wdGluZyB0byBzZXQgYSB2YWx1ZSBsZXNzIHRoYW4gLTEgd2lsbCBzZXQgdGhlIGN1cnJlbnQgY2hpbGQgdG8gLTEuXG4gICAqIC0gQXR0ZW1wdGluZyB0byBzZXQgYSB2YWx1ZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhlIG51bWJlciBvZiBtZW51IGl0ZW1zXG4gICAqICAgd2lsbCBzZXQgdGhlIGN1cnJlbnQgY2hpbGQgdG8gdGhlIGluZGV4IG9mIHRoZSBsYXN0IG1lbnUgaXRlbSBpbiB0aGUgbWVudS5cbiAgICpcbiAgICogSWYgdGhlIGN1cnJlbnQgbWVudSBoYXMgYSBwYXJlbnQgbWVudSBfYW5kXyB0aGUgbWVudSdzXG4gICAqIGN1cnJlbnQgZXZlbnQgaXMgXCJtb3VzZVwiLCBUaGUgcGFyZW50IG1lbnVcbiAgICogd2lsbCBoYXZlIGl0J3MgY3VycmVudCBjaGlsZCB1cGRhdGVkIGFzIHdlbGwgdG8gaGVscCB3aXRoIHRyYW5zaXRpb25pbmdcbiAgICogYmV0d2VlbiBtb3VzZSBhbmQga2V5Ym9hcmQgbmF2aWdhdGlvbi5cbiAgICpcbiAgICogQHR5cGUge251bWJlcn1cbiAgICpcbiAgICogQHNlZSBfY3VycmVudENoaWxkXG4gICAqL1xuICBnZXQgY3VycmVudENoaWxkKCkge1xuICAgIHJldHVybiB0aGlzLl9jdXJyZW50Q2hpbGQ7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBtZW51J3MgZm9jdXMuXG4gICAqXG4gICAqIC0gSWYgdGhlIG1lbnUgaGFzIHN1Ym1lbnVzLCBzZXR0aW5nIHRoZSBmb2N1cyBzdGF0ZSB0byBcIm5vbmVcIiBvciBcInNlbGZcIiB3aWxsXG4gICAqICAgdXBkYXRlIGFsbCBjaGlsZCBtZW51cyB0byBoYXZlIHRoZSBmb2N1cyBzdGF0ZSBvZiBcIm5vbmVcIi5cbiAgICogLSBJZiB0aGUgbWVudSBoYXMgYSBwYXJlbnQgbWVudSwgc2V0dGluZyB0aGUgZm9jdXMgc3RhdGUgdG8gXCJzZWxmXCIgb3IgXCJjaGlsZFwiXG4gICAqICAgd2lsbCB1cGRhdGUgYWxsIHBhcmVudCBtZW51cyB0byBoYXZlIHRoZSBmb2N1cyBzdGF0ZSBvZiBcImNoaWxkXCIuXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqXG4gICAqIEBzZWUgX2ZvY3VzU3RhdGVcbiAgICovXG4gIGdldCBmb2N1c1N0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9mb2N1c1N0YXRlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgbGFzdCBldmVudCB0cmlnZ2VyZWQgb24gdGhlIG1lbnUuXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqXG4gICAqIEBzZWUgX2N1cnJlbnRFdmVudFxuICAgKi9cbiAgZ2V0IGN1cnJlbnRFdmVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY3VycmVudEV2ZW50O1xuICB9XG4gIC8qKlxuICAgKiBUaGUgY3VycmVudGx5IHNlbGVjdGVkIG1lbnUgaXRlbS5cbiAgICpcbiAgICogQHJlYWRvbmx5XG4gICAqXG4gICAqIEB0eXBlIHtCYXNlTWVudUl0ZW19XG4gICAqL1xuICBnZXQgY3VycmVudE1lbnVJdGVtKCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnRzLm1lbnVJdGVtc1t0aGlzLmN1cnJlbnRDaGlsZF07XG4gIH1cbiAgLyoqXG4gICAqIFRoZSB0eXBlIG9mIGhvdmVyYWJpbGl0eSBmb3IgdGhlIG1lbnUuXG4gICAqXG4gICAqIFRoaXMgZnVuY3Rpb25zIGRpZmZlcmVudGx5IGZvciByb290IHZzLiBzdWJtZW51cy5cbiAgICogU3VibWVudXMgd2lsbCBhbHdheXMgaW5oZXJpdCB0aGVpciByb290IG1lbnUncyBob3ZlcmFiaWxpdHkuXG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmd9XG4gICAqXG4gICAqIEBzZWUgX2hvdmVyVHlwZVxuICAgKi9cbiAgZ2V0IGhvdmVyVHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcm9vdCA/IHRoaXMuX2hvdmVyVHlwZSA6IHRoaXMuZWxlbWVudHMucm9vdE1lbnUuaG92ZXJUeXBlO1xuICB9XG4gIC8qKlxuICAgKiBUaGUgZGVsYXkgdGltZSAoaW4gbWlsbGlzZWNvbmRzKSB1c2VkIGZvciBwb2ludGVyZW50ZXIvcG9pbnRlcmxlYXZlIGV2ZW50cyB0byB0YWtlIHBsYWNlLlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9ucyBkaWZmZXJlbnRseSBmb3Igcm9vdCB2cy4gc3VibWVudXMuXG4gICAqIFN1Ym1lbnVzIHdpbGwgYWx3YXlzIGluaGVyaXQgdGhlaXIgcm9vdCBtZW51J3MgaG92ZXIgZGVsYXkuXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqXG4gICAqIEBzZWUgX2hvdmVyRGVsYXlcbiAgICovXG4gIGdldCBob3ZlckRlbGF5KCkge1xuICAgIHJldHVybiB0aGlzLl9yb290ID8gdGhpcy5faG92ZXJEZWxheSA6IHRoaXMuZWxlbWVudHMucm9vdE1lbnUuaG92ZXJEZWxheTtcbiAgfVxuICAvKipcbiAgICogVGhlIGRlbGF5IHRpbWUgKGluIG1pbGxpc2Vjb25kcykgdXNlZCBmb3IgcG9pbnRlcmVudGVyIGV2ZW50cyB0byB0YWtlIHBsYWNlLlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9ucyBkaWZmZXJlbnRseSBmb3Igcm9vdCB2cy4gc3VibWVudXMuXG4gICAqIFN1Ym1lbnVzIHdpbGwgYWx3YXlzIGluaGVyaXQgdGhlaXIgcm9vdCBtZW51J3MgZW50ZXIgZGVsYXkuXG4gICAqXG4gICAqIElmIGVudGVyRGVsYXkgaXMgc2V0IHRvIC0xLCB0aGUgaG92ZXJEZWxheSB2YWx1ZSB3aWxsIGJlIHVzZWQgaW5zdGVhZC5cbiAgICpcbiAgICogQHR5cGUge251bWJlcn1cbiAgICpcbiAgICogQHNlZSBfZW50ZXJEZWxheVxuICAgKi9cbiAgZ2V0IGVudGVyRGVsYXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VudGVyRGVsYXkgPT09IC0xID8gdGhpcy5ob3ZlckRlbGF5IDogdGhpcy5fcm9vdCA/IHRoaXMuX2VudGVyRGVsYXkgOiB0aGlzLmVsZW1lbnRzLnJvb3RNZW51LmVudGVyRGVsYXk7XG4gIH1cbiAgLyoqXG4gICAqIFRoZSBkZWxheSB0aW1lIChpbiBtaWxsaXNlY29uZHMpIHVzZWQgZm9yIHBvaW50ZXJsZWF2ZSBldmVudHMgdG8gdGFrZSBwbGFjZS5cbiAgICpcbiAgICogVGhpcyBmdW5jdGlvbnMgZGlmZmVyZW50bHkgZm9yIHJvb3QgdnMuIHN1Ym1lbnVzLlxuICAgKiBTdWJtZW51cyB3aWxsIGFsd2F5cyBpbmhlcml0IHRoZWlyIHJvb3QgbWVudSdzIGxlYXZlIGRlbGF5LlxuICAgKlxuICAgKiBJZiBsZWF2ZURlbGF5IGlzIHNldCB0byAtMSwgdGhlIGhvdmVyRGVsYXkgdmFsdWUgd2lsbCBiZSB1c2VkIGluc3RlYWQuXG4gICAqXG4gICAqIEB0eXBlIHtudW1iZXJ9XG4gICAqXG4gICAqIEBzZWUgX2xlYXZlRGVsYXlcbiAgICovXG4gIGdldCBsZWF2ZURlbGF5KCkge1xuICAgIHJldHVybiB0aGlzLl9sZWF2ZURlbGF5ID09PSAtMSA/IHRoaXMuaG92ZXJEZWxheSA6IHRoaXMuX3Jvb3QgPyB0aGlzLl9sZWF2ZURlbGF5IDogdGhpcy5lbGVtZW50cy5yb290TWVudS5sZWF2ZURlbGF5O1xuICB9XG4gIC8qKlxuICAgKiBUaGUgcHJlZml4IHRvIHVzZSBmb3IgQ1NTIGN1c3RvbSBwcm9wZXJ0aWVzLlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9ucyBkaWZmZXJlbnRseSBmb3Igcm9vdCB2cy4gc3VibWVudXMuXG4gICAqIFN1Ym1lbnVzIHdpbGwgYWx3YXlzIGluaGVyaXQgdGhlaXIgcm9vdCBtZW51J3MgcHJlZml4LlxuICAgKlxuICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgKlxuICAgKiBAc2VlIF9wcmVmaXhcbiAgICovXG4gIGdldCBwcmVmaXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jvb3QgPyB0aGlzLl9wcmVmaXggOiB0aGlzLmVsZW1lbnRzLnJvb3RNZW51LnByZWZpeDtcbiAgfVxuICAvKipcbiAgICogQSBmbGFnIHRvIGNoZWNrIGlmIHRoZSBtZW51J3MgZm9jdXMgbWV0aG9kcyBzaG91bGQgX2FjdHVhbGx5XyBtb3ZlIHRoZSBmb2N1cyBpbiB0aGUgRE9NLlxuICAgKlxuICAgKiBUaGlzIHdpbGwgYmUgYGZhbHNlYCB1bmxlc3MgYW55IG9mIHRoZSBmb2xsb3dpbmcgY3JpdGVyaWEgYXJlIG1ldDpcbiAgICogLSBUaGUgbWVudSdzIGN1cnJlbnQgZXZlbnQgaXMgXCJrZXlib2FyZFwiLlxuICAgKiAtIFRoZSBtZW51J3MgY3VycmVudCBldmVudCBpcyBcImNoYXJhY3RlclwiLlxuICAgKiAtIFRoZSBtZW51J3MgY3VycmVudCBldmVudCBpcyBcIm1vdXNlXCIgX2FuZF8gdGhlIG1lbnUnc1xuICAgKiAgIGhvdmVyIHR5cGUgaXMgXCJkeW5hbWljXCIuXG4gICAqXG4gICAqIEByZWFkb25seVxuICAgKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICovXG4gIGdldCBzaG91bGRGb2N1cygpIHtcbiAgICBsZXQgZSA9ICExO1xuICAgIHJldHVybiAodGhpcy5jdXJyZW50RXZlbnQgPT09IFwia2V5Ym9hcmRcIiB8fCB0aGlzLmN1cnJlbnRFdmVudCA9PT0gXCJjaGFyYWN0ZXJcIikgJiYgKGUgPSAhMCksIHRoaXMuY3VycmVudEV2ZW50ID09PSBcIm1vdXNlXCIgJiYgdGhpcy5ob3ZlclR5cGUgPT09IFwiZHluYW1pY1wiICYmIChlID0gITApLCBlO1xuICB9XG4gIC8qKlxuICAgKiBBIGZsYWcgdG8gY2hlY2sgaWYgdGhlIG1lbnUgY2FuIGR5bmFtaWNhbGx5IGhvdmVyLlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9ucyBkaWZmZXJlbnRseSBmb3Igcm9vdCB2cy4gc3VibWVudXMuXG4gICAqIFN1Ym1lbnVzIHdpbGwgYWx3YXlzIGluaGVyaXQgdGhlaXIgcm9vdCBtZW51J3MgaGFzT3BlbmVkLlxuICAgKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICpcbiAgICogQHNlZSBfaGFzT3BlbmVkXG4gICAqL1xuICBnZXQgaGFzT3BlbmVkKCkge1xuICAgIHJldHVybiB0aGlzLl9yb290ID8gdGhpcy5faGFzT3BlbmVkIDogdGhpcy5lbGVtZW50cy5yb290TWVudS5oYXNPcGVuZWQ7XG4gIH1cbiAgLyoqXG4gICAqIEFuIGFycmF5IG9mIGVycm9yIG1lc3NhZ2VzIGdlbmVyYXRlZCBieSB0aGUgbWVudS5cbiAgICpcbiAgICogQHJlYWRvbmx5XG4gICAqXG4gICAqIEB0eXBlIHtzdHJpbmdbXX1cbiAgICpcbiAgICogQHNlZSBfZXJyb3JzXG4gICAqL1xuICBnZXQgZXJyb3JzKCkge1xuICAgIHJldHVybiB0aGlzLl9lcnJvcnM7XG4gIH1cbiAgc2V0IG9wZW5DbGFzcyhlKSB7XG4gICAgayh7IG9wZW5DbGFzczogZSB9KSwgdGhpcy5fb3BlbkNsYXNzICE9PSBlICYmICh0aGlzLl9vcGVuQ2xhc3MgPSBlKTtcbiAgfVxuICBzZXQgY2xvc2VDbGFzcyhlKSB7XG4gICAgayh7IGNsb3NlQ2xhc3M6IGUgfSksIHRoaXMuX2Nsb3NlQ2xhc3MgIT09IGUgJiYgKHRoaXMuX2Nsb3NlQ2xhc3MgPSBlKTtcbiAgfVxuICBzZXQgdHJhbnNpdGlvbkNsYXNzKGUpIHtcbiAgICBrKHsgdHJhbnNpdGlvbkNsYXNzOiBlIH0pLCB0aGlzLl90cmFuc2l0aW9uQ2xhc3MgIT09IGUgJiYgKHRoaXMuX3RyYW5zaXRpb25DbGFzcyA9IGUpO1xuICB9XG4gIHNldCB0cmFuc2l0aW9uRHVyYXRpb24oZSkge1xuICAgIGMoXCJudW1iZXJcIiwgeyB2YWx1ZTogZSB9KSwgdGhpcy5fdHJhbnNpdGlvbkR1cmF0aW9uICE9PSBlICYmICh0aGlzLl90cmFuc2l0aW9uRHVyYXRpb24gPSBlLCB0aGlzLl9zZXRUcmFuc2l0aW9uRHVyYXRpb25zKCkpO1xuICB9XG4gIHNldCBvcGVuRHVyYXRpb24oZSkge1xuICAgIGMoXCJudW1iZXJcIiwgeyB2YWx1ZTogZSB9KSwgdGhpcy5fb3BlbkR1cmF0aW9uICE9PSBlICYmICh0aGlzLl9vcGVuRHVyYXRpb24gPSBlLCB0aGlzLl9zZXRUcmFuc2l0aW9uRHVyYXRpb25zKCkpO1xuICB9XG4gIHNldCBjbG9zZUR1cmF0aW9uKGUpIHtcbiAgICBjKFwibnVtYmVyXCIsIHsgdmFsdWU6IGUgfSksIHRoaXMuX2Nsb3NlRHVyYXRpb24gIT09IGUgJiYgKHRoaXMuX2Nsb3NlRHVyYXRpb24gPSBlLCB0aGlzLl9zZXRUcmFuc2l0aW9uRHVyYXRpb25zKCkpO1xuICB9XG4gIHNldCBjdXJyZW50Q2hpbGQoZSkge1xuICAgIGMoXCJudW1iZXJcIiwgeyB2YWx1ZTogZSB9KTtcbiAgICBmdW5jdGlvbiB0KHMpIHtcbiAgICAgIGlmIChbXCJtb3VzZVwiLCBcImNoYXJhY3RlclwiXS5pbmNsdWRlcyhzLmN1cnJlbnRFdmVudCkgJiYgcy5lbGVtZW50cy5wYXJlbnRNZW51KSB7XG4gICAgICAgIGxldCBpID0gMCwgbCA9ICExO1xuICAgICAgICBmb3IgKDsgIWwgJiYgaSA8IHMuZWxlbWVudHMucGFyZW50TWVudS5lbGVtZW50cy5tZW51SXRlbXMubGVuZ3RoOyApIHtcbiAgICAgICAgICBjb25zdCBoID0gcy5lbGVtZW50cy5wYXJlbnRNZW51LmVsZW1lbnRzLm1lbnVJdGVtc1tpXTtcbiAgICAgICAgICBoLmlzU3VibWVudUl0ZW0gJiYgaC5lbGVtZW50cy50b2dnbGUuZWxlbWVudHMuY29udHJvbGxlZE1lbnUgPT09IHMgJiYgKGwgPSAhMCwgcy5lbGVtZW50cy5wYXJlbnRNZW51LmN1cnJlbnRFdmVudCA9IHMuY3VycmVudEV2ZW50LCBzLmVsZW1lbnRzLnBhcmVudE1lbnUuY3VycmVudENoaWxkID0gaSksIGkrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBlIDwgLTEgPyAodGhpcy5fY3VycmVudENoaWxkID0gLTEsIHQodGhpcykpIDogZSA+PSB0aGlzLmVsZW1lbnRzLm1lbnVJdGVtcy5sZW5ndGggPyAodGhpcy5fY3VycmVudENoaWxkID0gdGhpcy5lbGVtZW50cy5tZW51SXRlbXMubGVuZ3RoIC0gMSwgdCh0aGlzKSkgOiB0aGlzLmZvY3VzQ2hpbGQgIT09IGUgJiYgKHRoaXMuX2N1cnJlbnRDaGlsZCA9IGUsIHQodGhpcykpO1xuICB9XG4gIHNldCBmb2N1c1N0YXRlKGUpIHtcbiAgICBVKHsgdmFsdWU6IGUgfSksIHRoaXMuX2ZvY3VzU3RhdGUgIT09IGUgJiYgKHRoaXMuX2ZvY3VzU3RhdGUgPSBlKSwgdGhpcy5lbGVtZW50cy5zdWJtZW51VG9nZ2xlcy5sZW5ndGggPiAwICYmIChlID09PSBcInNlbGZcIiB8fCBlID09PSBcIm5vbmVcIikgJiYgdGhpcy5lbGVtZW50cy5zdWJtZW51VG9nZ2xlcy5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICB0LmVsZW1lbnRzLmNvbnRyb2xsZWRNZW51LmZvY3VzU3RhdGUgPSBcIm5vbmVcIjtcbiAgICB9KSwgdGhpcy5lbGVtZW50cy5wYXJlbnRNZW51ICYmIChlID09PSBcInNlbGZcIiB8fCBlID09PSBcImNoaWxkXCIpICYmICh0aGlzLmVsZW1lbnRzLnBhcmVudE1lbnUuZm9jdXNTdGF0ZSA9IFwiY2hpbGRcIik7XG4gIH1cbiAgc2V0IGN1cnJlbnRFdmVudChlKSB7XG4gICAgVyh7IHZhbHVlOiBlIH0pLCB0aGlzLl9jdXJyZW50RXZlbnQgIT09IGUgJiYgKHRoaXMuX2N1cnJlbnRFdmVudCA9IGUsIHRoaXMuZWxlbWVudHMuc3VibWVudVRvZ2dsZXMubGVuZ3RoID4gMCAmJiB0aGlzLmVsZW1lbnRzLnN1Ym1lbnVUb2dnbGVzLmZvckVhY2goKHQpID0+IHtcbiAgICAgIHQuZWxlbWVudHMuY29udHJvbGxlZE1lbnUuY3VycmVudEV2ZW50ID0gZTtcbiAgICB9KSk7XG4gIH1cbiAgc2V0IGhvdmVyVHlwZShlKSB7XG4gICAgTih7IHZhbHVlOiBlIH0pLCB0aGlzLl9ob3ZlclR5cGUgIT09IGUgJiYgKHRoaXMuX2hvdmVyVHlwZSA9IGUpO1xuICB9XG4gIHNldCBob3ZlckRlbGF5KGUpIHtcbiAgICBjKFwibnVtYmVyXCIsIHsgdmFsdWU6IGUgfSksIHRoaXMuX2hvdmVyRGVsYXkgIT09IGUgJiYgKHRoaXMuX2hvdmVyRGVsYXkgPSBlKTtcbiAgfVxuICBzZXQgZW50ZXJEZWxheShlKSB7XG4gICAgYyhcIm51bWJlclwiLCB7IHZhbHVlOiBlIH0pLCB0aGlzLl9lbnRlckRlbGF5ICE9PSBlICYmICh0aGlzLl9lbnRlckRlbGF5ID0gZSk7XG4gIH1cbiAgc2V0IGxlYXZlRGVsYXkoZSkge1xuICAgIGMoXCJudW1iZXJcIiwgeyB2YWx1ZTogZSB9KSwgdGhpcy5fbGVhdmVEZWxheSAhPT0gZSAmJiAodGhpcy5fbGVhdmVEZWxheSA9IGUpO1xuICB9XG4gIHNldCBwcmVmaXgoZSkge1xuICAgIGMoXCJzdHJpbmdcIiwgeyB2YWx1ZTogZSB9KSwgdGhpcy5fcHJlZml4ICE9PSBlICYmICh0aGlzLl9wcmVmaXggPSBlKTtcbiAgfVxuICBzZXQgaGFzT3BlbmVkKGUpIHtcbiAgICBjKFwiYm9vbGVhblwiLCB7IHZhbHVlOiBlIH0pLCB0aGlzLl9oYXNPcGVuZWQgIT09IGUgJiYgKHRoaXMuX2hhc09wZW5lZCA9IGUpO1xuICB9XG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgYWxsIGFzcGVjdHMgb2YgdGhlIG1lbnUgdG8gZW5zdXJlIHByb3BlciBmdW5jdGlvbmFsaXR5LlxuICAgKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IC0gVGhlIHJlc3VsdCBvZiB0aGUgdmFsaWRhdGlvbi5cbiAgICovXG4gIF92YWxpZGF0ZSgpIHtcbiAgICBsZXQgZSA9ICEwLCB0O1xuICAgIHRoaXMuX2RvbS5jb250YWluZXIgIT09IG51bGwgfHwgdGhpcy5fZG9tLmNvbnRyb2xsZXIgIT09IG51bGwgPyB0ID0gQShIVE1MRWxlbWVudCwge1xuICAgICAgbWVudUVsZW1lbnQ6IHRoaXMuX2RvbS5tZW51LFxuICAgICAgY29udHJvbGxlckVsZW1lbnQ6IHRoaXMuX2RvbS5jb250cm9sbGVyLFxuICAgICAgY29udGFpbmVyRWxlbWVudDogdGhpcy5fZG9tLmNvbnRhaW5lclxuICAgIH0pIDogdCA9IEEoSFRNTEVsZW1lbnQsIHtcbiAgICAgIG1lbnVFbGVtZW50OiB0aGlzLl9kb20ubWVudVxuICAgIH0pLCB0LnN0YXR1cyB8fCAodGhpcy5fZXJyb3JzLnB1c2godC5lcnJvci5tZXNzYWdlKSwgZSA9ICExKTtcbiAgICBsZXQgcztcbiAgICBpZiAodGhpcy5fc2VsZWN0b3JzLnN1Ym1lbnVJdGVtcyAhPT0gXCJcIiA/IHMgPSB4KHtcbiAgICAgIG1lbnVJdGVtU2VsZWN0b3I6IHRoaXMuX3NlbGVjdG9ycy5tZW51SXRlbXMsXG4gICAgICBtZW51TGlua1NlbGVjdG9yOiB0aGlzLl9zZWxlY3RvcnMubWVudUxpbmtzLFxuICAgICAgc3VibWVudUl0ZW1TZWxlY3RvcjogdGhpcy5fc2VsZWN0b3JzLnN1Ym1lbnVJdGVtcyxcbiAgICAgIHN1Ym1lbnVUb2dnbGVTZWxlY3RvcjogdGhpcy5fc2VsZWN0b3JzLnN1Ym1lbnVUb2dnbGVzLFxuICAgICAgc3VibWVudVNlbGVjdG9yOiB0aGlzLl9zZWxlY3RvcnMuc3VibWVudXNcbiAgICB9KSA6IHMgPSB4KHtcbiAgICAgIG1lbnVJdGVtU2VsZWN0b3I6IHRoaXMuX3NlbGVjdG9ycy5tZW51SXRlbXMsXG4gICAgICBtZW51TGlua1NlbGVjdG9yOiB0aGlzLl9zZWxlY3RvcnMubWVudUxpbmtzXG4gICAgfSksIHMuc3RhdHVzIHx8ICh0aGlzLl9lcnJvcnMucHVzaChzLmVycm9yLm1lc3NhZ2UpLCBlID0gITEpLCB0aGlzLl9vcGVuQ2xhc3MgIT09IFwiXCIpIHtcbiAgICAgIGNvbnN0IGQgPSBrKHsgb3BlbkNsYXNzOiB0aGlzLl9vcGVuQ2xhc3MgfSk7XG4gICAgICBkLnN0YXR1cyB8fCAodGhpcy5fZXJyb3JzLnB1c2goZC5lcnJvci5tZXNzYWdlKSwgZSA9ICExKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2Nsb3NlQ2xhc3MgIT09IFwiXCIpIHtcbiAgICAgIGNvbnN0IGQgPSBrKHtcbiAgICAgICAgY2xvc2VDbGFzczogdGhpcy5fY2xvc2VDbGFzc1xuICAgICAgfSk7XG4gICAgICBkLnN0YXR1cyB8fCAodGhpcy5fZXJyb3JzLnB1c2goZC5lcnJvci5tZXNzYWdlKSwgZSA9ICExKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3RyYW5zaXRpb25DbGFzcyAhPT0gXCJcIikge1xuICAgICAgY29uc3QgZCA9IGsoe1xuICAgICAgICB0cmFuc2l0aW9uQ2xhc3M6IHRoaXMuX3RyYW5zaXRpb25DbGFzc1xuICAgICAgfSk7XG4gICAgICBkLnN0YXR1cyB8fCAodGhpcy5fZXJyb3JzLnB1c2goZC5lcnJvci5tZXNzYWdlKSwgZSA9ICExKTtcbiAgICB9XG4gICAgY29uc3QgbiA9IGMoXCJudW1iZXJcIiwge1xuICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uOiB0aGlzLl90cmFuc2l0aW9uRHVyYXRpb25cbiAgICB9KTtcbiAgICBuLnN0YXR1cyB8fCAodGhpcy5fZXJyb3JzLnB1c2gobi5lcnJvci5tZXNzYWdlKSwgZSA9ICExKTtcbiAgICBjb25zdCBpID0gYyhcIm51bWJlclwiLCB7XG4gICAgICBvcGVuRHVyYXRpb246IHRoaXMuX29wZW5EdXJhdGlvblxuICAgIH0pO1xuICAgIGkuc3RhdHVzIHx8ICh0aGlzLl9lcnJvcnMucHVzaChpLmVycm9yLm1lc3NhZ2UpLCBlID0gITEpO1xuICAgIGNvbnN0IGwgPSBjKFwibnVtYmVyXCIsIHtcbiAgICAgIGNsb3NlRHVyYXRpb246IHRoaXMuX2Nsb3NlRHVyYXRpb25cbiAgICB9KTtcbiAgICBsLnN0YXR1cyB8fCAodGhpcy5fZXJyb3JzLnB1c2gobC5lcnJvci5tZXNzYWdlKSwgZSA9ICExKTtcbiAgICBjb25zdCBoID0gYyhcImJvb2xlYW5cIiwgeyBpc1RvcExldmVsOiB0aGlzLl9yb290IH0pO1xuICAgIGlmIChoLnN0YXR1cyB8fCAodGhpcy5fZXJyb3JzLnB1c2goaC5lcnJvci5tZXNzYWdlKSwgZSA9ICExKSwgdGhpcy5fZWxlbWVudHMucGFyZW50TWVudSAhPT0gbnVsbCkge1xuICAgICAgY29uc3QgZCA9IEEodywge1xuICAgICAgICBwYXJlbnRNZW51OiB0aGlzLl9lbGVtZW50cy5wYXJlbnRNZW51XG4gICAgICB9KTtcbiAgICAgIGQuc3RhdHVzIHx8ICh0aGlzLl9lcnJvcnMucHVzaChkLmVycm9yLm1lc3NhZ2UpLCBlID0gITEpO1xuICAgIH1cbiAgICBjb25zdCBtID0gTih7IGhvdmVyVHlwZTogdGhpcy5faG92ZXJUeXBlIH0pO1xuICAgIG0uc3RhdHVzIHx8ICh0aGlzLl9lcnJvcnMucHVzaChtLmVycm9yLm1lc3NhZ2UpLCBlID0gITEpO1xuICAgIGNvbnN0IGEgPSBjKFwibnVtYmVyXCIsIHtcbiAgICAgIGhvdmVyRGVsYXk6IHRoaXMuX2hvdmVyRGVsYXlcbiAgICB9KTtcbiAgICBhLnN0YXR1cyB8fCAodGhpcy5fZXJyb3JzLnB1c2goYS5lcnJvci5tZXNzYWdlKSwgZSA9ICExKTtcbiAgICBjb25zdCBwID0gYyhcIm51bWJlclwiLCB7XG4gICAgICBlbnRlckRlbGF5OiB0aGlzLl9lbnRlckRlbGF5XG4gICAgfSk7XG4gICAgcC5zdGF0dXMgfHwgKHRoaXMuX2Vycm9ycy5wdXNoKHAuZXJyb3IubWVzc2FnZSksIGUgPSAhMSk7XG4gICAgY29uc3QgZiA9IGMoXCJudW1iZXJcIiwge1xuICAgICAgbGVhdmVEZWxheTogdGhpcy5fbGVhdmVEZWxheVxuICAgIH0pO1xuICAgIGYuc3RhdHVzIHx8ICh0aGlzLl9lcnJvcnMucHVzaChmLmVycm9yLm1lc3NhZ2UpLCBlID0gITEpO1xuICAgIGNvbnN0IGcgPSBjKFwic3RyaW5nXCIsIHsgcHJlZml4OiB0aGlzLl9wcmVmaXggfSk7XG4gICAgcmV0dXJuIGcuc3RhdHVzIHx8ICh0aGlzLl9lcnJvcnMucHVzaChnLmVycm9yLm1lc3NhZ2UpLCBlID0gITEpLCBlO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIERPTSBlbGVtZW50cyB3aXRoaW4gdGhlIG1lbnUuXG4gICAqXG4gICAqIEVsZW1lbnRzIHRoYXQgYXJlIG5vdCBzdG9yZWQgaW5zaWRlIGFuIGFycmF5IGNhbm5vdCBiZSBzZXQgdGhyb3VnaCB0aGlzIG1ldGhvZC5cbiAgICpcbiAgICogQHByb3RlY3RlZFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICBlbGVtZW50VHlwZSAgICAgICAgICAgIC0gVGhlIHR5cGUgb2YgZWxlbWVudCB0byBwb3B1bGF0ZS5cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gW2Jhc2UgPSB0aGlzLmRvbS5tZW51XSAtIFRoZSBlbGVtZW50IHVzZWQgYXMgdGhlIGJhc2UgZm9yIHRoZSBxdWVyeVNlbGVjdC5cbiAgICogQHBhcmFtIHtib29sZWFufSAgICAgW292ZXJ3cml0ZSA9IHRydWVdICAgICAtIEEgZmxhZyB0byBzZXQgaWYgdGhlIGV4aXN0aW5nIGVsZW1lbnRzIHdpbGwgYmUgb3ZlcndyaXR0ZW4uXG4gICAqL1xuICBfc2V0RE9NRWxlbWVudFR5cGUoZSwgdCA9IHRoaXMuZG9tLm1lbnUsIHMgPSAhMCkge1xuICAgIGlmICh0eXBlb2YgdGhpcy5zZWxlY3RvcnNbZV0gPT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRoaXMuZG9tW2VdKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBBY2Nlc3NpYmxlTWVudTogVGhlIFwiJHtlfVwiIGVsZW1lbnQgY2Fubm90IGJlIHNldCB0aHJvdWdoIF9zZXRET01FbGVtZW50VHlwZS5gXG4gICAgICAgICk7XG4gICAgICB0ICE9PSB0aGlzLmRvbS5tZW51ICYmIEEoSFRNTEVsZW1lbnQsIHsgYmFzZTogdCB9KTtcbiAgICAgIGNvbnN0IGkgPSBBcnJheS5mcm9tKFxuICAgICAgICB0LnF1ZXJ5U2VsZWN0b3JBbGwodGhpcy5zZWxlY3RvcnNbZV0pXG4gICAgICApLmZpbHRlcihcbiAgICAgICAgKGwpID0+IGwucGFyZW50RWxlbWVudCA9PT0gdFxuICAgICAgKTtcbiAgICAgIHMgPyB0aGlzLl9kb21bZV0gPSBpIDogdGhpcy5fZG9tW2VdID0gW1xuICAgICAgICAuLi50aGlzLl9kb21bZV0sXG4gICAgICAgIC4uLmlcbiAgICAgIF07XG4gICAgfSBlbHNlXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBBY2Nlc3NpYmxlTWVudTogXCIke2V9XCIgaXMgbm90IGEgdmFsaWQgZWxlbWVudCB0eXBlIHdpdGhpbiB0aGUgbWVudS5gXG4gICAgICApO1xuICB9XG4gIC8qKlxuICAgKiBSZXNldHMgRE9NIGVsZW1lbnRzIHdpdGhpbiB0aGUgbWVudS5cbiAgICpcbiAgICogRWxlbWVudHMgdGhhdCBhcmUgbm90IHN0b3JlZCBpbnNpZGUgYW4gYXJyYXkgY2Fubm90IGJlIHJlc2V0IHRocm91Z2ggdGhpcyBtZXRob2QuXG4gICAqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGVsZW1lbnRUeXBlIC0gVGhlIHR5cGUgb2YgZWxlbWVudCB0byBjbGVhci5cbiAgICovXG4gIF9yZXNldERPTUVsZW1lbnRUeXBlKGUpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuZG9tW2VdIDwgXCJ1XCIpIHtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0aGlzLmRvbVtlXSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgQWNjZXNzaWJsZU1lbnU6IFRoZSBcIiR7ZX1cIiBlbGVtZW50IGNhbm5vdCBiZSByZXNldCB0aHJvdWdoIF9yZXNldERPTUVsZW1lbnRUeXBlLmBcbiAgICAgICAgKTtcbiAgICAgIHRoaXMuX2RvbVtlXSA9IFtdO1xuICAgIH0gZWxzZVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQWNjZXNzaWJsZU1lbnU6IFwiJHtlfVwiIGlzIG5vdCBhIHZhbGlkIGVsZW1lbnQgdHlwZSB3aXRoaW4gdGhlIG1lbnUuYFxuICAgICAgKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyBhbGwgRE9NIGVsZW1lbnRzIHdpdGhpbiB0aGUgbWVudS5cbiAgICpcbiAgICogVXRpbGl6ZXMgX3NldERPTUVsZW1lbnRUeXBlIGFuZFxuICAgKiBfcmVzZXRET01FbGVtZW50VHlwZS5cbiAgICpcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX3NldERPTUVsZW1lbnRzKCkge1xuICAgIHRoaXMuX3NldERPTUVsZW1lbnRUeXBlKFwibWVudUl0ZW1zXCIpLCB0aGlzLnNlbGVjdG9ycy5zdWJtZW51SXRlbXMgIT09IFwiXCIgJiYgKHRoaXMuX3NldERPTUVsZW1lbnRUeXBlKFwic3VibWVudUl0ZW1zXCIpLCB0aGlzLl9yZXNldERPTUVsZW1lbnRUeXBlKFwic3VibWVudVRvZ2dsZXNcIiksIHRoaXMuX3Jlc2V0RE9NRWxlbWVudFR5cGUoXCJzdWJtZW51c1wiKSwgdGhpcy5kb20uc3VibWVudUl0ZW1zLmZvckVhY2goKGUpID0+IHtcbiAgICAgIHRoaXMuX3NldERPTUVsZW1lbnRUeXBlKFwic3VibWVudVRvZ2dsZXNcIiwgZSwgITEpLCB0aGlzLl9zZXRET01FbGVtZW50VHlwZShcInN1Ym1lbnVzXCIsIGUsICExKTtcbiAgICB9KSk7XG4gIH1cbiAgLyoqXG4gICAqIEZpbmRzIHRoZSByb290IG1lbnUgZWxlbWVudC5cbiAgICpcbiAgICogQHByb3RlY3RlZFxuICAgKlxuICAgKiBAcGFyYW0ge0Jhc2VNZW51fSBtZW51IC0gVGhlIG1lbnUgdG8gY2hlY2suXG4gICAqL1xuICBfZmluZFJvb3RNZW51KGUpIHtcbiAgICBpZiAoZS5pc1RvcExldmVsKVxuICAgICAgdGhpcy5fZWxlbWVudHMucm9vdE1lbnUgPSBlO1xuICAgIGVsc2UgaWYgKGUuZWxlbWVudHMucGFyZW50TWVudSAhPT0gbnVsbClcbiAgICAgIHRoaXMuX2ZpbmRSb290TWVudShlLmVsZW1lbnRzLnBhcmVudE1lbnUpO1xuICAgIGVsc2VcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIHJvb3QgbWVudS5cIik7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW5kIGluaXRpYWxpemVzIGFsbCBtZW51IGl0ZW1zIGFuZCBzdWJtZW51cy5cbiAgICpcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX2NyZWF0ZUNoaWxkRWxlbWVudHMoKSB7XG4gICAgdGhpcy5kb20ubWVudUl0ZW1zLmZvckVhY2goKGUpID0+IHtcbiAgICAgIGxldCB0O1xuICAgICAgaWYgKHRoaXMuZG9tLnN1Ym1lbnVJdGVtcy5pbmNsdWRlcyhlKSkge1xuICAgICAgICBjb25zdCBzID0gZS5xdWVyeVNlbGVjdG9yKHRoaXMuc2VsZWN0b3JzLnN1Ym1lbnVUb2dnbGVzKSwgbiA9IGUucXVlcnlTZWxlY3Rvcih0aGlzLnNlbGVjdG9ycy5zdWJtZW51cyksIGkgPSBuZXcgdGhpcy5fTWVudVR5cGUoe1xuICAgICAgICAgIG1lbnVFbGVtZW50OiBuLFxuICAgICAgICAgIG1lbnVJdGVtU2VsZWN0b3I6IHRoaXMuc2VsZWN0b3JzLm1lbnVJdGVtcyxcbiAgICAgICAgICBtZW51TGlua1NlbGVjdG9yOiB0aGlzLnNlbGVjdG9ycy5tZW51TGlua3MsXG4gICAgICAgICAgc3VibWVudUl0ZW1TZWxlY3RvcjogdGhpcy5zZWxlY3RvcnMuc3VibWVudUl0ZW1zLFxuICAgICAgICAgIHN1Ym1lbnVUb2dnbGVTZWxlY3RvcjogdGhpcy5zZWxlY3RvcnMuc3VibWVudVRvZ2dsZXMsXG4gICAgICAgICAgc3VibWVudVNlbGVjdG9yOiB0aGlzLnNlbGVjdG9ycy5zdWJtZW51cyxcbiAgICAgICAgICBvcGVuQ2xhc3M6IHRoaXMub3BlbkNsYXNzLFxuICAgICAgICAgIGNsb3NlQ2xhc3M6IHRoaXMuY2xvc2VDbGFzcyxcbiAgICAgICAgICB0cmFuc2l0aW9uQ2xhc3M6IHRoaXMudHJhbnNpdGlvbkNsYXNzLFxuICAgICAgICAgIHRyYW5zaXRpb25EdXJhdGlvbjogdGhpcy50cmFuc2l0aW9uRHVyYXRpb24sXG4gICAgICAgICAgb3BlbkR1cmF0aW9uOiB0aGlzLm9wZW5EdXJhdGlvbixcbiAgICAgICAgICBjbG9zZUR1cmF0aW9uOiB0aGlzLmNsb3NlRHVyYXRpb24sXG4gICAgICAgICAgaXNUb3BMZXZlbDogITEsXG4gICAgICAgICAgcGFyZW50TWVudTogdGhpcyxcbiAgICAgICAgICBob3ZlclR5cGU6IHRoaXMuaG92ZXJUeXBlLFxuICAgICAgICAgIGhvdmVyRGVsYXk6IHRoaXMuaG92ZXJEZWxheSxcbiAgICAgICAgICBlbnRlckRlbGF5OiB0aGlzLmVudGVyRGVsYXksXG4gICAgICAgICAgbGVhdmVEZWxheTogdGhpcy5sZWF2ZURlbGF5XG4gICAgICAgIH0pLCBsID0gbmV3IHRoaXMuX01lbnVUb2dnbGVUeXBlKHtcbiAgICAgICAgICBtZW51VG9nZ2xlRWxlbWVudDogcyxcbiAgICAgICAgICBwYXJlbnRFbGVtZW50OiBlLFxuICAgICAgICAgIGNvbnRyb2xsZWRNZW51OiBpLFxuICAgICAgICAgIHBhcmVudE1lbnU6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRzLnN1Ym1lbnVUb2dnbGVzLnB1c2gobCksIHQgPSBuZXcgdGhpcy5fTWVudUl0ZW1UeXBlKHtcbiAgICAgICAgICBtZW51SXRlbUVsZW1lbnQ6IGUsXG4gICAgICAgICAgbWVudUxpbmtFbGVtZW50OiBzLFxuICAgICAgICAgIHBhcmVudE1lbnU6IHRoaXMsXG4gICAgICAgICAgaXNTdWJtZW51SXRlbTogITAsXG4gICAgICAgICAgY2hpbGRNZW51OiBpLFxuICAgICAgICAgIHRvZ2dsZTogbFxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHMgPSBlLnF1ZXJ5U2VsZWN0b3IodGhpcy5zZWxlY3RvcnMubWVudUxpbmtzKTtcbiAgICAgICAgdCA9IG5ldyB0aGlzLl9NZW51SXRlbVR5cGUoe1xuICAgICAgICAgIG1lbnVJdGVtRWxlbWVudDogZSxcbiAgICAgICAgICBtZW51TGlua0VsZW1lbnQ6IHMsXG4gICAgICAgICAgcGFyZW50TWVudTogdGhpc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2VsZW1lbnRzLm1lbnVJdGVtcy5wdXNoKHQpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDbGVhcnMgdGhlIGhvdmVyIHRpbWVvdXQuXG4gICAqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9jbGVhclRpbWVvdXQoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX2hvdmVyVGltZW91dCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIGhvdmVyIHRpbWVvdXQuXG4gICAqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gZXhlY3V0ZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9ICAgZGVsYXkgICAgLSBUaGUgZGVsYXkgdGltZSBpbiBtaWxsaXNlY29uZHMuXG4gICAqL1xuICBfc2V0VGltZW91dChlLCB0KSB7XG4gICAgYyhcImZ1bmN0aW9uXCIsIHsgY2FsbGJhY2s6IGUgfSksIGMoXCJudW1iZXJcIiwgeyBkZWxheTogdCB9KSwgdGhpcy5faG92ZXJUaW1lb3V0ID0gc2V0VGltZW91dChlLCB0KTtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlcyBmb2N1cyBldmVudHMgdGhyb3VnaG91dCB0aGUgbWVudSBmb3IgcHJvcGVyIG1lbnUgdXNlLlxuICAgKlxuICAgKiAtIEFkZHMgYSBgZm9jdXNgIGxpc3RlbmVyIHRvIGV2ZXJ5IG1lbnUgaXRlbSBzbyB3aGVuIGl0IGdhaW5zIGZvY3VzLFxuICAgKiAgIGl0IHdpbGwgc2V0IHRoZSBpdGVtJ3MgY29udGFpbmluZyBtZW51J3MgZm9jdXMgc3RhdGVcbiAgICogICB0byBcInNlbGZcIi5cbiAgICogLSBBZGRzIGEgYGZvY3Vzb3V0YCBsaXN0ZW5lciB0byB0aGUgbWVudSBzbyB3aGVuIHRoZSBtZW51IGxvc2VzIGZvY3VzLFxuICAgKiAgIGl0IHdpbGwgY2xvc2UuXG4gICAqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9oYW5kbGVGb2N1cygpIHtcbiAgICB0aGlzLmVsZW1lbnRzLm1lbnVJdGVtcy5mb3JFYWNoKChlLCB0KSA9PiB7XG4gICAgICBlLmRvbS5saW5rLmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuZm9jdXNTdGF0ZSA9IFwic2VsZlwiLCB0aGlzLmN1cnJlbnRDaGlsZCA9IHQ7XG4gICAgICB9KTtcbiAgICB9KSwgdGhpcy5kb20ubWVudS5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNvdXRcIiwgKGUpID0+IHtcbiAgICAgIHRoaXMuY3VycmVudEV2ZW50ICE9PSBcImtleWJvYXJkXCIgfHwgZS5yZWxhdGVkVGFyZ2V0ID09PSBudWxsIHx8IHRoaXMuZG9tLm1lbnUuY29udGFpbnMoZS5yZWxhdGVkVGFyZ2V0KSB8fCAodGhpcy5mb2N1c1N0YXRlID0gXCJub25lXCIsIHRoaXMuY2xvc2VDaGlsZHJlbigpKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlcyBjbGljayBldmVudHMgdGhyb3VnaG91dCB0aGUgbWVudSBmb3IgcHJvcGVyIHVzZS5cbiAgICpcbiAgICogLSBBZGRzIGEgYHBvaW50ZXJkb3duYCBsaXN0ZW5lciB0byBldmVyeSBtZW51IGl0ZW0gdGhhdCB3aWxsIGJsdXJcbiAgICogICBhbGwgbWVudSBpdGVtcyBpbiB0aGUgZW50aXJlIG1lbnUgc3RydWN0dXJlIChzdGFydGluZyBhdCB0aGUgcm9vdCBtZW51KSBhbmRcbiAgICogICB0aGVuIHByb3Blcmx5IGZvY3VzIHRoZSBjbGlja2VkIGl0ZW0uXG4gICAqIC0gQWRkcyBhIGBwb2ludGVydXBgIGxpc3RlbmVyIHRvIGV2ZXJ5IHN1Ym1lbnUgaXRlbSB0aGF0IHdpbGwgcHJvcGVybHlcbiAgICogICB0b2dnbGUgdGhlIHN1Ym1lbnUgb3Blbi9jbG9zZWQuXG4gICAqIC0gQWRkcyBhIGBwb2ludGVydXBgIGxpc3RlbmVyIHRvIHRoZSBtZW51J3MgY29udHJvbGxlclxuICAgKiAgIChpZiB0aGUgbWVudSBpcyB0aGUgcm9vdCBtZW51KSBzbyB3aGVuIGl0IGlzIGNsaWNrZWQgaXQgd2lsbCBwcm9wZXJseVxuICAgKiAgIHRvZ2dsZSBvcGVuL2Nsb3NlZC5cbiAgICpcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX2hhbmRsZUNsaWNrKCkge1xuICAgIGZ1bmN0aW9uIGUodCwgcywgbikge1xuICAgICAgbyhuKSwgbi5idXR0b24gPT09IDAgJiYgKHMudG9nZ2xlKCksIHMuaXNPcGVuICYmICh0LmZvY3VzU3RhdGUgPSBcInNlbGZcIiwgcy5lbGVtZW50cy5jb250cm9sbGVkTWVudS5mb2N1c1N0YXRlID0gXCJub25lXCIpKTtcbiAgICB9XG4gICAgdGhpcy5lbGVtZW50cy5tZW51SXRlbXMuZm9yRWFjaCgodCwgcykgPT4ge1xuICAgICAgdC5kb20ubGluay5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICBcInBvaW50ZXJkb3duXCIsXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICB0aGlzLmN1cnJlbnRFdmVudCA9IFwibW91c2VcIiwgdGhpcy5lbGVtZW50cy5yb290TWVudS5ibHVyQ2hpbGRyZW4oKSwgdGhpcy5fY2xlYXJUaW1lb3V0KCksIHRoaXMuZm9jdXNDaGlsZChzKTtcbiAgICAgICAgfSxcbiAgICAgICAgeyBwYXNzaXZlOiAhMCB9XG4gICAgICApLCB0LmlzU3VibWVudUl0ZW0gJiYgdC5lbGVtZW50cy50b2dnbGUuZG9tLnRvZ2dsZS5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICBcInBvaW50ZXJ1cFwiLFxuICAgICAgICAobikgPT4ge1xuICAgICAgICAgIHRoaXMuY3VycmVudEV2ZW50ID0gXCJtb3VzZVwiLCBlKHRoaXMsIHQuZWxlbWVudHMudG9nZ2xlLCBuKTtcbiAgICAgICAgfVxuICAgICAgKTtcbiAgICB9KSwgdGhpcy5pc1RvcExldmVsICYmIHRoaXMuZWxlbWVudHMuY29udHJvbGxlciAmJiB0aGlzLmVsZW1lbnRzLmNvbnRyb2xsZXIuZG9tLnRvZ2dsZS5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgXCJwb2ludGVydXBcIixcbiAgICAgICh0KSA9PiB7XG4gICAgICAgIHRoaXMuY3VycmVudEV2ZW50ID0gXCJtb3VzZVwiLCBlKHRoaXMsIHRoaXMuZWxlbWVudHMuY29udHJvbGxlciwgdCk7XG4gICAgICB9XG4gICAgKSwgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCAodCkgPT4ge1xuICAgICAgdGhpcy5mb2N1c1N0YXRlICE9PSBcIm5vbmVcIiAmJiAodGhpcy5jdXJyZW50RXZlbnQgPSBcIm1vdXNlXCIsICF0aGlzLmRvbS5tZW51LmNvbnRhaW5zKHQudGFyZ2V0KSAmJiAhdGhpcy5kb20ubWVudSAhPT0gdC50YXJnZXQgJiYgKHRoaXMuZWxlbWVudHMucm9vdE1lbnUuaGFzT3BlbmVkID0gdGhpcy5lbGVtZW50cy5zdWJtZW51VG9nZ2xlcy5zb21lKFxuICAgICAgICAocykgPT4gcy5pc09wZW5cbiAgICAgICkpKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlcyBob3ZlciBldmVudHMgdGhyb3VnaG91dCB0aGUgbWVudSBmb3IgcHJvcGVyIHVzZS5cbiAgICpcbiAgICogQWRkcyBgcG9pbnRlcmVudGVyYCBsaXN0ZW5lcnMgdG8gYWxsIG1lbnUgaXRlbXMgYW5kIGBwb2ludGVybGVhdmVgIGxpc3RlbmVyc1xuICAgKiB0byBhbGwgc3VibWVudSBpdGVtcyB3aGljaCBmdW5jdGlvbiBkaWZmZXJlbnRseSBkZXBlbmRpbmcgb25cbiAgICogdGhlIG1lbnUncyBob3ZlciB0eXBlLlxuICAgKlxuICAgKiBCZWZvcmUgZXhlY3V0aW5nIGFueXRoaW5nLCB0aGUgZXZlbnQgaXMgY2hlY2tlZCB0byBtYWtlIHN1cmUgdGhlIGV2ZW50IHdhc24ndFxuICAgKiB0cmlnZ2VyZWQgYnkgYSBwZW4gb3IgdG91Y2guXG4gICAqXG4gICAqIDxzdHJvbmc+SG92ZXIgVHlwZSBcIm9uXCI8L3N0cm9uZz5cbiAgICogLSBXaGVuIGEgYHBvaW50ZXJlbnRlcmAgZXZlbnQgdHJpZ2dlcnMgb24gYW55IG1lbnUgaXRlbSB0aGUgbWVudSdzXG4gICAqICAgIGN1cnJlbnQgY2hpbGQgdmFsdWUgd2lsbCBjaGFuZ2UgdG8gdGhhdFxuICAgKiAgIG1lbnUgaXRlbS5cbiAgICogLSBXaGVuIGEgYHBvaW50ZXJlbnRlcmAgZXZlbnQgdHJpZ2dlcnMgb24gYSBzdWJtZW51IGl0ZW0gdGhlXG4gICAqICAgcHJldmlldyBtZXRob2QgZm9yIHRoZSBzdWJtZW51IGl0ZW0nc1xuICAgKiAgIHRvZ2dsZSB3aWxsIGJlIGNhbGxlZC5cbiAgICogLSBXaGVuIGEgYHBvaW50ZXJsZWF2ZWAgZXZlbnQgdHJpZ2dlcnMgb24gYW4gb3BlbiBzdWJtZW51IGl0ZW0gdGhlXG4gICAqICAgY2xvc2UgbWV0aG9kIGZvciB0aGUgc3VibWVudSBpdGVtJ3MgdG9nZ2xlXG4gICAqICAgd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgYSBkZWxheSBzZXQgYnkgdGhlIG1lbnUncyBob3ZlciBkZWxheS5cbiAgICpcbiAgICogPHN0cm9uZz5Ib3ZlciBUeXBlIFwiZHluYW1pY1wiPC9zdHJvbmc+XG4gICAqIC0gV2hlbiBhIGBwb2ludGVyZW50ZXJgIGV2ZW50IHRyaWdnZXJzIG9uIGFueSBtZW51IGl0ZW0gdGhlIG1lbnUnc1xuICAgKiAgIGN1cnJlbnQgY2hpbGQgdmFsdWUgd2lsbCBjaGFuZ2UgdG8gdGhhdCBtZW51IGl0ZW0uXG4gICAqIC0gV2hlbiBhIGBwb2ludGVyZW50ZXJgIGV2ZW50IHRyaWdnZXJzIG9uIGFueSBtZW51IGl0ZW0sIGFuZCB0aGUgbWVudSdzXG4gICAqICAgZm9jdXMgc3RhdGUgaXMgbm90IFwibm9uZVwiLCB0aGUgbWVudSBpdGVtXG4gICAqICAgd2lsbCBiZSBmb2N1c2VkLlxuICAgKiAtIFdoZW4gYSBgcG9pbnRlcmVudGVyYCBldmVudCB0cmlnZ2VycyBvbiBhIHN1Ym1lbnUgaXRlbSwgYW5kIGEgc3VibWVudSBpc1xuICAgKiAgIGFscmVhZHkgb3BlbiwgdGhlIHByZXZpZXcgbWV0aG9kIGZvciB0aGUgc3VibWVudSBpdGVtJ3MgdG9nZ2xlIHdpbGwgYmUgY2FsbGVkLlxuICAgKiAtIFdoZW4gYSBgcG9pbnRlcmVudGVyYCBldmVudCB0cmlnZ2VycyBvbiBhIG5vbi1zdWJtZW51IGl0ZW0sIGFuZCBhIHN1Ym1lbnVcbiAgICogICBpcyBhbHJlYWR5IG9wZW4sIHRoZSBjbG9zZUNoaWxkcmVuIG1ldGhvZCBmb3IgdGhlIG1lbnUgd2lsbCBiZSBjYWxsZWQuXG4gICAqIC0gV2hlbiBhIGBwb2ludGVyZW50ZXJgIGV2ZW50IHRyaWdnZXJzIG9uIGEgc3VibWVudSBpdGVtLCBhbmQgbm8gc3VibWVudSBpc1xuICAgKiAgIG9wZW4sIG5vIHN1Ym1lbnUtc3BlY2lmaWMgbWV0aG9kcyB3aWxsIGJlIGNhbGxlZC5cbiAgICogLSBXaGVuIGEgYHBvaW50ZXJsZWF2ZWAgZXZlbnQgdHJpZ2dlcnMgb24gYW4gb3BlbiBzdWJtZW51IGl0ZW0gdGhhdCBpcyBub3QgYVxuICAgKiAgIHJvb3QtbGV2ZWwgc3VibWVudSBpdGVtIHRoZSBjbG9zZSBtZXRob2QgZm9yIHRoZSBzdWJtZW51IGl0ZW0ncyB0b2dnbGVcbiAgICogICB3aWxsIGJlIGNhbGxlZCBhbmQgdGhlIHN1Ym1lbnUgaXRlbSB3aWxsIGJlIGZvY3VzZWQgYWZ0ZXIgYSBkZWxheSBzZXQgYnlcbiAgICogICB0aGUgbWVudSdzIGhvdmVyIGRlbGF5LlxuICAgKiAtIFdoZW4gYSBgcG9pbnRlcmxlYXZlYCBldmVudCB0cmlnZ2VycyBvbiBhbiBvcGVuIHN1Ym1lbnUgaXRlbSB0aGF0IGlzIGFcbiAgICogICByb290LWxldmVsIHN1Ym1lbnUgaXRlbSBubyBzdWJtZW51LXNwZWNpZmljIG1ldGhvZHMgd2lsbCBiZSBjYWxsZWQuXG4gICAqXG4gICAqIDxzdHJvbmc+SG92ZXIgVHlwZSBcIm9mZlwiPC9zdHJvbmc+XG4gICAqIEFsbCBgcG9pbnRlcmVudGVyYCBhbmQgYHBvaW50ZXJsZWF2ZWAgZXZlbnRzIGFyZSBpZ25vcmVkLlxuICAgKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfaGFuZGxlSG92ZXIoKSB7XG4gICAgdGhpcy5lbGVtZW50cy5tZW51SXRlbXMuZm9yRWFjaCgoZSwgdCkgPT4ge1xuICAgICAgZS5kb20ubGluay5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmVudGVyXCIsIChzKSA9PiB7XG4gICAgICAgIHMucG9pbnRlclR5cGUgPT09IFwicGVuXCIgfHwgcy5wb2ludGVyVHlwZSA9PT0gXCJ0b3VjaFwiIHx8ICh0aGlzLmhvdmVyVHlwZSA9PT0gXCJvblwiID8gKHRoaXMuY3VycmVudEV2ZW50ID0gXCJtb3VzZVwiLCB0aGlzLmVsZW1lbnRzLnJvb3RNZW51LmJsdXJDaGlsZHJlbigpLCB0aGlzLmZvY3VzQ2hpbGQodCksIGUuaXNTdWJtZW51SXRlbSAmJiAodGhpcy5lbnRlckRlbGF5ID4gMCA/ICh0aGlzLl9jbGVhclRpbWVvdXQoKSwgdGhpcy5fc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgZS5lbGVtZW50cy50b2dnbGUucHJldmlldygpO1xuICAgICAgICB9LCB0aGlzLmVudGVyRGVsYXkpKSA6IGUuZWxlbWVudHMudG9nZ2xlLnByZXZpZXcoKSkpIDogdGhpcy5ob3ZlclR5cGUgPT09IFwiZHluYW1pY1wiICYmICh0aGlzLmN1cnJlbnRDaGlsZCA9IHQsICghdGhpcy5pc1RvcExldmVsIHx8IHRoaXMuZm9jdXNTdGF0ZSAhPT0gXCJub25lXCIpICYmICh0aGlzLmN1cnJlbnRFdmVudCA9IFwibW91c2VcIiwgdGhpcy5lbGVtZW50cy5yb290TWVudS5ibHVyQ2hpbGRyZW4oKSwgdGhpcy5mb2N1c0N1cnJlbnRDaGlsZCgpKSwgKCF0aGlzLmlzVG9wTGV2ZWwgfHwgdGhpcy5oYXNPcGVuZWQpICYmICh0aGlzLmN1cnJlbnRFdmVudCA9IFwibW91c2VcIiwgdGhpcy5lbGVtZW50cy5yb290TWVudS5ibHVyQ2hpbGRyZW4oKSwgdGhpcy5mb2N1c0N1cnJlbnRDaGlsZCgpLCBlLmlzU3VibWVudUl0ZW0gPyB0aGlzLmVudGVyRGVsYXkgPiAwID8gKHRoaXMuX2NsZWFyVGltZW91dCgpLCB0aGlzLl9zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBlLmVsZW1lbnRzLnRvZ2dsZS5wcmV2aWV3KCk7XG4gICAgICAgIH0sIHRoaXMuZW50ZXJEZWxheSkpIDogZS5lbGVtZW50cy50b2dnbGUucHJldmlldygpIDogdGhpcy5lbnRlckRlbGF5ID4gMCA/ICh0aGlzLl9jbGVhclRpbWVvdXQoKSwgdGhpcy5fc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5jbG9zZUNoaWxkcmVuKCk7XG4gICAgICAgIH0sIHRoaXMuZW50ZXJEZWxheSkpIDogdGhpcy5jbG9zZUNoaWxkcmVuKCkpKSk7XG4gICAgICB9KSwgZS5pc1N1Ym1lbnVJdGVtICYmIChlLmRvbS5pdGVtLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybGVhdmVcIiwgKHMpID0+IHtcbiAgICAgICAgcy5wb2ludGVyVHlwZSA9PT0gXCJwZW5cIiB8fCBzLnBvaW50ZXJUeXBlID09PSBcInRvdWNoXCIgfHwgKHRoaXMuaG92ZXJUeXBlID09PSBcIm9uXCIgPyB0aGlzLmxlYXZlRGVsYXkgPiAwID8gKHRoaXMuX2NsZWFyVGltZW91dCgpLCB0aGlzLl9zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLmN1cnJlbnRFdmVudCA9IFwibW91c2VcIiwgZS5lbGVtZW50cy50b2dnbGUuY2xvc2UoKTtcbiAgICAgICAgfSwgdGhpcy5sZWF2ZURlbGF5KSkgOiAodGhpcy5jdXJyZW50RXZlbnQgPSBcIm1vdXNlXCIsIGUuZWxlbWVudHMudG9nZ2xlLmNsb3NlKCkpIDogdGhpcy5ob3ZlclR5cGUgPT09IFwiZHluYW1pY1wiICYmICh0aGlzLmxlYXZlRGVsYXkgPiAwID8gKHRoaXMuX2NsZWFyVGltZW91dCgpLCB0aGlzLl9zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLmN1cnJlbnRFdmVudCA9IFwibW91c2VcIjtcbiAgICAgICAgfSwgdGhpcy5sZWF2ZURlbGF5KSkgOiB0aGlzLmN1cnJlbnRFdmVudCA9IFwibW91c2VcIikpO1xuICAgICAgfSksIGUuZG9tLml0ZW0uYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJlbnRlclwiLCAocykgPT4ge1xuICAgICAgICBzLnBvaW50ZXJUeXBlID09PSBcInBlblwiIHx8IHMucG9pbnRlclR5cGUgPT09IFwidG91Y2hcIiB8fCBlLmlzU3VibWVudUl0ZW0gJiYgKHRoaXMuaG92ZXJUeXBlID09PSBcIm9uXCIgfHwgdGhpcy5ob3ZlclR5cGUgPT09IFwiZHluYW1pY1wiKSAmJiB0aGlzLmxlYXZlRGVsYXkgPiAwICYmIHRoaXMuX2NsZWFyVGltZW91dCgpO1xuICAgICAgfSkpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGVzIGtleWRvd24gZXZlbnRzIHRocm91Z2hvdXQgdGhlIG1lbnUgZm9yIHByb3BlciBtZW51IHVzZS5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgZXhpc3RzIHRvIGFzc2lzdCB0aGUgX2hhbmRsZUtleXVwIG1ldGhvZC5cbiAgICpcbiAgICogLSBBZGRzIGEgYGtleWRvd25gIGxpc3RlbmVyIHRvIHRoZSBtZW51J3MgY29udHJvbGxlciAoaWYgdGhlIG1lbnUgaXMgdGhlIHJvb3QgbWVudSkuXG4gICAqICAgLSBCbG9ja3MgcHJvcGFnYXRpb24gb24gXCJTcGFjZVwiLCBcIkVudGVyXCIsIGFuZCBcIkVzY2FwZVwiIGtleXMuXG4gICAqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9oYW5kbGVLZXlkb3duKCkge1xuICAgIHRoaXMuaXNUb3BMZXZlbCAmJiB0aGlzLmVsZW1lbnRzLmNvbnRyb2xsZXIgJiYgdGhpcy5lbGVtZW50cy5jb250cm9sbGVyLmRvbS50b2dnbGUuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgIFwia2V5ZG93blwiLFxuICAgICAgKGUpID0+IHtcbiAgICAgICAgdGhpcy5jdXJyZW50RXZlbnQgPSBcImtleWJvYXJkXCI7XG4gICAgICAgIGNvbnN0IHQgPSBfKGUpO1xuICAgICAgICAodCA9PT0gXCJTcGFjZVwiIHx8IHQgPT09IFwiRW50ZXJcIikgJiYgbyhlKTtcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGVzIGtleXVwIGV2ZW50cyB0aHJvdWdob3V0IHRoZSBtZW51IGZvciBwcm9wZXIgbWVudSB1c2UuXG4gICAqXG4gICAqIC0gQWRkcyBhIGBrZXl1cGAgbGlzdGVuZXIgdG8gdGhlIG1lbnUncyBjb250cm9sbGVyIChpZiB0aGUgbWVudSBpcyB0aGUgcm9vdCBtZW51KS5cbiAgICogICAtIFRvZ2dsZXMgdGhlIG1lbnUgd2hlbiB0aGUgdXNlciBoaXRzIFwiU3BhY2VcIiBvciBcIkVudGVyXCIuXG4gICAqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9oYW5kbGVLZXl1cCgpIHtcbiAgICB0aGlzLmlzVG9wTGV2ZWwgJiYgdGhpcy5lbGVtZW50cy5jb250cm9sbGVyICYmIHRoaXMuZWxlbWVudHMuY29udHJvbGxlci5kb20udG9nZ2xlLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCAoZSkgPT4ge1xuICAgICAgdGhpcy5jdXJyZW50RXZlbnQgPSBcImtleWJvYXJkXCI7XG4gICAgICBjb25zdCB0ID0gXyhlKTtcbiAgICAgICh0ID09PSBcIlNwYWNlXCIgfHwgdCA9PT0gXCJFbnRlclwiKSAmJiAobyhlKSwgdGhpcy5lbGVtZW50cy5jb250cm9sbGVyLnRvZ2dsZSgpLCB0aGlzLmVsZW1lbnRzLmNvbnRyb2xsZXIuaXNPcGVuICYmIHRoaXMuZm9jdXNGaXJzdENoaWxkKCkpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIHRoZSB0cmFuc2l0aW9uIGR1cmF0aW9ucyBvZiB0aGUgbWVudSBhcyBhIENTUyBjdXN0b20gcHJvcGVydGllcy5cbiAgICpcbiAgICogVGhlIGN1c3RvbSBwcm9wZXJ0aWVzIGFyZTpcbiAgICogICAtIGAtLWFtLXRyYW5zaXRpb24tZHVyYXRpb25gLFxuICAgKiAgIC0gYC0tYW0tb3Blbi10cmFuc2l0aW9uLWR1cmF0aW9uYCwgYW5kXG4gICAqICAgLSBgLS1hbS1jbG9zZS10cmFuc2l0aW9uLWR1cmF0aW9uYC5cbiAgICpcbiAgICogVGhlIHByZWZpeCBvZiBgYW0tYCBjYW4gYmUgY2hhbmdlZCBieSBzZXR0aW5nIHRoZSBtZW51J3MgcHJlZml4IHZhbHVlLlxuICAgKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfc2V0VHJhbnNpdGlvbkR1cmF0aW9ucygpIHtcbiAgICB0aGlzLmRvbS5tZW51LnN0eWxlLnNldFByb3BlcnR5KFxuICAgICAgYC0tJHt0aGlzLnByZWZpeH10cmFuc2l0aW9uLWR1cmF0aW9uYCxcbiAgICAgIGAke3RoaXMudHJhbnNpdGlvbkR1cmF0aW9ufW1zYFxuICAgICksIHRoaXMuZG9tLm1lbnUuc3R5bGUuc2V0UHJvcGVydHkoXG4gICAgICBgLS0ke3RoaXMucHJlZml4fW9wZW4tdHJhbnNpdGlvbi1kdXJhdGlvbmAsXG4gICAgICBgJHt0aGlzLm9wZW5EdXJhdGlvbn1tc2BcbiAgICApLCB0aGlzLmRvbS5tZW51LnN0eWxlLnNldFByb3BlcnR5KFxuICAgICAgYC0tJHt0aGlzLnByZWZpeH1jbG9zZS10cmFuc2l0aW9uLWR1cmF0aW9uYCxcbiAgICAgIGAke3RoaXMuY2xvc2VEdXJhdGlvbn1tc2BcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBGb2N1cyB0aGUgbWVudS5cbiAgICpcbiAgICogU2V0cyB0aGUgbWVudSdzIGZvY3VzIHN0YXRlIHRvIFwic2VsZlwiIGFuZFxuICAgKiBmb2N1c3NlcyB0aGUgbWVudSBpZiB0aGUgbWVudSdzIHNob3VsZEZvY3VzXG4gICAqIHZhbHVlIGlzIGB0cnVlYC5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZm9jdXMoKSB7XG4gICAgdGhpcy5mb2N1c1N0YXRlID0gXCJzZWxmXCIsIHRoaXMuc2hvdWxkRm9jdXMgJiYgdGhpcy5kb20ubWVudS5mb2N1cygpO1xuICB9XG4gIC8qKlxuICAgKiBVbmZvY3VzIHRoZSBtZW51LlxuICAgKlxuICAgKiBTZXRzIHRoZSBtZW51J3MgZm9jdXMgc3RhdGUgdG8gXCJub25lXCJcbiAgICogYW5kIGJsdXJzIHRoZSBtZW51IGlmIHRoZSBtZW51J3Mgc2hvdWxkRm9jdXNcbiAgICogdmFsdWUgaXMgYHRydWVgLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBibHVyKCkge1xuICAgIHRoaXMuZm9jdXNTdGF0ZSA9IFwibm9uZVwiLCB0aGlzLnNob3VsZEZvY3VzICYmIHRoaXMuZG9tLm1lbnUuYmx1cigpO1xuICB9XG4gIC8qKlxuICAgKiBGb2N1cyB0aGUgbWVudSdzIGN1cnJlbnQgY2hpbGQuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGZvY3VzQ3VycmVudENoaWxkKCkge1xuICAgIHRoaXMuZm9jdXNTdGF0ZSA9IFwic2VsZlwiLCB0aGlzLmN1cnJlbnRDaGlsZCAhPT0gLTEgJiYgdGhpcy5jdXJyZW50TWVudUl0ZW0uZm9jdXMoKTtcbiAgfVxuICAvKipcbiAgICogRm9jdXNlcyB0aGUgbWVudSdzIGNoaWxkIGF0IGEgZ2l2ZW4gaW5kZXguXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSBjaGlsZCB0byBmb2N1cy5cbiAgICovXG4gIGZvY3VzQ2hpbGQoZSkge1xuICAgIHRoaXMuYmx1ckN1cnJlbnRDaGlsZCgpLCB0aGlzLmN1cnJlbnRDaGlsZCA9IGUsIHRoaXMuZm9jdXNDdXJyZW50Q2hpbGQoKTtcbiAgfVxuICAvKipcbiAgICogRm9jdXNlcyB0aGUgbWVudSdzIGZpcnN0IGNoaWxkLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBmb2N1c0ZpcnN0Q2hpbGQoKSB7XG4gICAgdGhpcy5mb2N1c0NoaWxkKDApO1xuICB9XG4gIC8qKlxuICAgKiBGb2N1cyB0aGUgbWVudSdzIGxhc3QgY2hpbGQuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGZvY3VzTGFzdENoaWxkKCkge1xuICAgIHRoaXMuZm9jdXNDaGlsZCh0aGlzLmVsZW1lbnRzLm1lbnVJdGVtcy5sZW5ndGggLSAxKTtcbiAgfVxuICAvKipcbiAgICogRm9jdXMgdGhlIG1lbnUncyBuZXh0IGNoaWxkLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBmb2N1c05leHRDaGlsZCgpIHtcbiAgICB0aGlzLmN1cnJlbnRDaGlsZCA8IHRoaXMuZWxlbWVudHMubWVudUl0ZW1zLmxlbmd0aCAtIDEgPyB0aGlzLmZvY3VzQ2hpbGQodGhpcy5jdXJyZW50Q2hpbGQgKyAxKSA6IHRoaXMuZm9jdXNDdXJyZW50Q2hpbGQoKTtcbiAgfVxuICAvKipcbiAgICogRm9jdXMgdGhlIG1lbnUncyBwcmV2aW91cyBjaGlsZC5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZm9jdXNQcmV2aW91c0NoaWxkKCkge1xuICAgIHRoaXMuY3VycmVudENoaWxkID4gMCA/IHRoaXMuZm9jdXNDaGlsZCh0aGlzLmN1cnJlbnRDaGlsZCAtIDEpIDogdGhpcy5mb2N1c0N1cnJlbnRDaGlsZCgpO1xuICB9XG4gIC8qKlxuICAgKiBCbHVycyB0aGUgbWVudSdzIGN1cnJlbnQgY2hpbGQuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGJsdXJDdXJyZW50Q2hpbGQoKSB7XG4gICAgdGhpcy5mb2N1c1N0YXRlID0gXCJub25lXCIsIHRoaXMuY3VycmVudENoaWxkICE9PSAtMSAmJiB0aGlzLmN1cnJlbnRNZW51SXRlbS5ibHVyKCk7XG4gIH1cbiAgLyoqXG4gICAqIEZvY3VzIHRoZSBtZW51J3MgY29udHJvbGxlci5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZm9jdXNDb250cm9sbGVyKCkge1xuICAgIHRoaXMuZG9tLmNvbnRyb2xsZXIgJiYgKHRoaXMuc2hvdWxkRm9jdXMgJiYgdGhpcy5kb20uY29udHJvbGxlci5mb2N1cygpLCB0aGlzLmZvY3VzU3RhdGUgPSBcIm5vbmVcIik7XG4gIH1cbiAgLyoqXG4gICAqIEZvY3VzIHRoZSBtZW51J3MgY29udGFpbmVyLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBmb2N1c0NvbnRhaW5lcigpIHtcbiAgICB0aGlzLmRvbS5jb250YWluZXIgJiYgKHRoaXMuc2hvdWxkRm9jdXMgJiYgdGhpcy5kb20uY29udGFpbmVyLmZvY3VzKCksIHRoaXMuZm9jdXNTdGF0ZSA9IFwibm9uZVwiKTtcbiAgfVxuICAvKipcbiAgICogQ2xvc2UgYWxsIHN1Ym1lbnUgY2hpbGRyZW4uXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNsb3NlQ2hpbGRyZW4oKSB7XG4gICAgdGhpcy5lbGVtZW50cy5zdWJtZW51VG9nZ2xlcy5mb3JFYWNoKChlKSA9PiBlLmNsb3NlKCkpO1xuICB9XG4gIC8qKlxuICAgKiBCbHVycyBhbGwgY2hpbGRyZW4gYW5kIHN1Ym1lbnUncyBjaGlsZHJlbi5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgYmx1ckNoaWxkcmVuKCkge1xuICAgIHRoaXMuZWxlbWVudHMubWVudUl0ZW1zLmZvckVhY2goKGUpID0+IHtcbiAgICAgIGUuYmx1cigpLCBlLmlzU3VibWVudUl0ZW0gJiYgZS5lbGVtZW50cy5jaGlsZE1lbnUuYmx1ckNoaWxkcmVuKCk7XG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIFogZXh0ZW5kcyBPIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgYERpc2Nsb3N1cmVNZW51SXRlbWAuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgICAgICAgICAgICAgICBvcHRpb25zICAgICAgICAgICAgICAgICAgICAgICAgIC0gVGhlIG9wdGlvbnMgZm9yIGdlbmVyYXRpbmcgdGhlIG1lbnUgaXRlbS5cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gICAgICAgICAgIG9wdGlvbnMubWVudUl0ZW1FbGVtZW50ICAgICAgICAgLSBUaGUgbWVudSBpdGVtIGluIHRoZSBET00uXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9ICAgICAgICAgICBvcHRpb25zLm1lbnVMaW5rRWxlbWVudCAgICAgICAgIC0gVGhlIG1lbnUgaXRlbSdzIGxpbmsgaW4gdGhlIERPTS5cbiAgICogQHBhcmFtIHtEaXNjbG9zdXJlTWVudX0gICAgICAgIG9wdGlvbnMucGFyZW50TWVudSAgICAgICAgICAgICAgLSBUaGUgcGFyZW50IG1lbnUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgICAgICAgICAgICBbb3B0aW9ucy5pc1N1Ym1lbnVJdGVtID0gZmFsc2VdIC0gQSBmbGFnIHRvIG1hcmsgaWYgdGhlIG1lbnUgaXRlbSBpcyBjb250cm9sbGluZyBhIHN1Ym1lbnUuXG4gICAqIEBwYXJhbSB7P0Rpc2Nsb3N1cmVNZW51fSAgICAgICBbb3B0aW9ucy5jaGlsZE1lbnUgPSBudWxsXSAgICAgIC0gVGhlIGNoaWxkIG1lbnUuXG4gICAqIEBwYXJhbSB7P0Rpc2Nsb3N1cmVNZW51VG9nZ2xlfSBbb3B0aW9ucy50b2dnbGUgPSBudWxsXSAgICAgICAgIC0gVGhlIGNvbnRyb2xsZXIgZm9yIHRoZSBjaGlsZCBtZW51LlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICAgICAgICAgICAgW29wdGlvbnMuaW5pdGlhbGl6ZSA9IHRydWVdICAgICAtIEEgZmxhZyB0byBpbml0aWFsaXplIHRoZSBtZW51IGl0ZW0gaW1tZWRpYXRlbHkgdXBvbiBjcmVhdGlvbi5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBtZW51SXRlbUVsZW1lbnQ6IGUsXG4gICAgbWVudUxpbmtFbGVtZW50OiB0LFxuICAgIHBhcmVudE1lbnU6IHMsXG4gICAgaXNTdWJtZW51SXRlbTogbiA9ICExLFxuICAgIGNoaWxkTWVudTogaSA9IG51bGwsXG4gICAgdG9nZ2xlOiBsID0gbnVsbCxcbiAgICBpbml0aWFsaXplOiBoID0gITBcbiAgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIG1lbnVJdGVtRWxlbWVudDogZSxcbiAgICAgIG1lbnVMaW5rRWxlbWVudDogdCxcbiAgICAgIHBhcmVudE1lbnU6IHMsXG4gICAgICBpc1N1Ym1lbnVJdGVtOiBuLFxuICAgICAgY2hpbGRNZW51OiBpLFxuICAgICAgdG9nZ2xlOiBsXG4gICAgfSksIGggJiYgdGhpcy5pbml0aWFsaXplKCk7XG4gIH1cbn1cbmNsYXNzIFEgZXh0ZW5kcyBMIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgYERpc2Nsb3N1cmVNZW51VG9nZ2xlYC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9ICAgICAgICAgIG9wdGlvbnMgICAgICAgICAgICAgICAgICAgICAtIFRoZSBvcHRpb25zIGZvciBnZW5lcmF0aW5nIHRoZSBtZW51IHRvZ2dsZS5cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gICAgIG9wdGlvbnMubWVudVRvZ2dsZUVsZW1lbnQgICAtIFRoZSB0b2dnbGUgZWxlbWVudCBpbiB0aGUgRE9NLlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSAgICAgb3B0aW9ucy5wYXJlbnRFbGVtZW50ICAgICAgIC0gVGhlIGVsZW1lbnQgY29udGFpbmluZyB0aGUgY29udHJvbGxlZCBtZW51LlxuICAgKiBAcGFyYW0ge0Rpc2Nsb3N1cmVNZW51fSAgb3B0aW9ucy5jb250cm9sbGVkTWVudSAgICAgIC0gVGhlIG1lbnUgY29udHJvbGxlZCBieSB0aGlzIHRvZ2dsZS5cbiAgICogQHBhcmFtIHs/RGlzY2xvc3VyZU1lbnV9IFtvcHRpb25zLnBhcmVudE1lbnUgPSBudWxsXSAtIFRoZSBtZW51IGNvbnRhaW5pbmcgdGhpcyB0b2dnbGUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgICAgICBbb3B0aW9ucy5pbml0aWFsaXplID0gdHJ1ZV0gLSBBIGZsYWcgdG8gaW5pdGlhbGl6ZSB0aGUgbWVudSB0b2dnbGUgaW1tZWRpYXRlbHkgdXBvbiBjcmVhdGlvbi5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBtZW51VG9nZ2xlRWxlbWVudDogZSxcbiAgICBwYXJlbnRFbGVtZW50OiB0LFxuICAgIGNvbnRyb2xsZWRNZW51OiBzLFxuICAgIHBhcmVudE1lbnU6IG4gPSBudWxsLFxuICAgIGluaXRpYWxpemU6IGkgPSAhMFxuICB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgbWVudVRvZ2dsZUVsZW1lbnQ6IGUsXG4gICAgICBwYXJlbnRFbGVtZW50OiB0LFxuICAgICAgY29udHJvbGxlZE1lbnU6IHMsXG4gICAgICBwYXJlbnRNZW51OiBuXG4gICAgfSksIGkgJiYgdGhpcy5pbml0aWFsaXplKCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIEFSSUEgYXR0cmlidXRlcyBvbiB0aGUgdG9nZ2xlIGFuZCBjb250cm9sbGVkIG1lbnUuXG4gICAqXG4gICAqIENhbGxzIHRoZSBCYXNlTWVudVRvZ2dsZSdzIF9zZXRBcmlhQXR0cmlidXRlcyBtZXRob2QuXG4gICAqXG4gICAqIEVuc3VyZXMgdGhlIHRvZ2dsZSBlbGVtZW50IGhhcyBhIGByb2xlYCBvZiBcImJ1dHRvblwiIGlmIGl0IGlzIG5vdFxuICAgKiBhbHJlYWR5IGEgYnV0dG9uLlxuICAgKlxuICAgKiBUaGVuIHVzaW5nIHRoZSB0b2dnbGUgYW5kIG1lbnUncyBJRHMsIHRoZSB0b2dnbGUncyBgYXJpYS1jb250cm9sc2BcbiAgICogaXMgc2V0IHRvIHRoZSBtZW51J3MgSUQuXG4gICAqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9zZXRBcmlhQXR0cmlidXRlcygpIHtcbiAgICBzdXBlci5fc2V0QXJpYUF0dHJpYnV0ZXMoKSwgRihcImJ1dHRvblwiLCB7IHRvZ2dsZTogdGhpcy5kb20udG9nZ2xlIH0pIHx8IHRoaXMuZG9tLnRvZ2dsZS5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwiYnV0dG9uXCIpLCB0aGlzLmRvbS50b2dnbGUuc2V0QXR0cmlidXRlKFxuICAgICAgXCJhcmlhLWNvbnRyb2xzXCIsXG4gICAgICB0aGlzLmVsZW1lbnRzLmNvbnRyb2xsZWRNZW51LmRvbS5tZW51LmlkXG4gICAgKTtcbiAgfVxuICAvKipcbiAgICogT3BlbnMgdGhlIGNvbnRyb2xsZWQgbWVudS5cbiAgICpcbiAgICogQ2FsbHMgdGhlICBjbG9zZVNpYmxpbmdzIG1ldGhvZFxuICAgKiBhbmQgX3RoZW5fIEJhc2VNZW51VG9nZ2xlJ3Mgb3BlbiBtZXRob2QuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIG9wZW4oKSB7XG4gICAgdGhpcy5jbG9zZVNpYmxpbmdzKCksIHN1cGVyLm9wZW4oKTtcbiAgfVxuICAvKipcbiAgICogT3BlbnMgdGhlIGNvbnRyb2xsZWQgbWVudSB3aXRob3V0IHRoZSBjdXJyZW50IGZvY3VzIGVudGVyaW5nIGl0LlxuICAgKlxuICAgKiBDYWxscyB0aGUgIGNsb3NlU2libGluZ3MgbWV0aG9kXG4gICAqIGFuZCBfdGhlbl8gQmFzZU1lbnVUb2dnbGUncyBwcmV2aWV3IG1ldGhvZC5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcHJldmlldygpIHtcbiAgICB0aGlzLmNsb3NlU2libGluZ3MoKSwgc3VwZXIucHJldmlldygpO1xuICB9XG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIGNvbnRyb2xsZWQgbWVudS5cbiAgICpcbiAgICogQ2FsbHMgdGhlICBjbG9zZUNoaWxkcmVuIG1ldGhvZFxuICAgKiBhbmQgX3RoZW5fIEJhc2VNZW51VG9nZ2xlJ3MgY2xvc2UgbWV0aG9kLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBjbG9zZSgpIHtcbiAgICB0aGlzLmlzT3BlbiAmJiB0aGlzLmNsb3NlQ2hpbGRyZW4oKSwgc3VwZXIuY2xvc2UoKTtcbiAgfVxufVxuY2xhc3MgeiBleHRlbmRzIHcge1xuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBgRGlzY2xvc3VyZU1lbnVgLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gICAgICAgICAgICAgb3B0aW9ucyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gVGhlIG9wdGlvbnMgZm9yIGdlbmVyYXRpbmcgdGhlIG1lbnUuXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9ICAgICAgICBvcHRpb25zLm1lbnVFbGVtZW50ICAgICAgICAgICAgICAgICAgICAgICAgLSBUaGUgbWVudSBlbGVtZW50IGluIHRoZSBET00uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICBbb3B0aW9ucy5tZW51SXRlbVNlbGVjdG9yID0gbGldICAgICAgICAgICAgLSBUaGUgcXVlcnkgc2VsZWN0b3Igc3RyaW5nIGZvciBtZW51IGl0ZW1zLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgW29wdGlvbnMubWVudUxpbmtTZWxlY3RvciA9IGFdICAgICAgICAgICAgIC0gVGhlIHF1ZXJ5IHNlbGVjdG9yIHN0cmluZyBmb3IgbWVudSBsaW5rcy5cbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgIFtvcHRpb25zLnN1Ym1lbnVJdGVtU2VsZWN0b3IgPSBsaTpoYXModWwpXSAtIFRoZSBxdWVyeSBzZWxlY3RvciBzdHJpbmcgZm9yIG1lbnUgaXRlbXMgY29udGFpbmluZyBzdWJtZW51cy5cbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgIFtvcHRpb25zLnN1Ym1lbnVUb2dnbGVTZWxlY3RvciA9IGJ1dHRvbl0gICAtIFRoZSBxdWVyeSBzZWxlY3RvciBzdHJpbmcgZm9yIHN1Ym1lbnUgdG9nZ2xlIGJ1dHRvbnMvbGlua3MuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICBbb3B0aW9ucy5zdWJtZW51U2VsZWN0b3IgPSB1bF0gICAgICAgICAgICAgLSBUaGUgcXVlcnkgc2VsZWN0b3Igc3RyaW5nIGZvciBzdWJtZW51cy5cbiAgICogQHBhcmFtIHs/SFRNTEVsZW1lbnR9ICAgICAgIFtvcHRpb25zLmNvbnRyb2xsZXJFbGVtZW50ID0gbnVsbF0gICAgICAgICAtIFRoZSBlbGVtZW50IGNvbnRyb2xsaW5nIHRoZSBtZW51IGluIHRoZSBET00uXG4gICAqIEBwYXJhbSB7P0hUTUxFbGVtZW50fSAgICAgICBbb3B0aW9ucy5jb250YWluZXJFbGVtZW50ID0gbnVsbF0gICAgICAgICAgLSBUaGUgZWxlbWVudCBjb250YWluaW5nIHRoZSBtZW51IGluIHRoZSBET00uXG4gICAqIEBwYXJhbSB7PyhzdHJpbmd8c3RyaW5nW10pfSBbb3B0aW9ucy5vcGVuQ2xhc3MgPSBzaG93XSAgICAgICAgICAgICAgICAgLSBUaGUgY2xhc3MgdG8gYXBwbHkgd2hlbiBhIG1lbnUgaXMgXCJvcGVuXCIuXG4gICAqIEBwYXJhbSB7PyhzdHJpbmd8c3RyaW5nW10pfSBbb3B0aW9ucy5jbG9zZUNsYXNzID0gaGlkZV0gICAgICAgICAgICAgICAgLSBUaGUgY2xhc3MgdG8gYXBwbHkgd2hlbiBhIG1lbnUgaXMgXCJjbG9zZWRcIi5cbiAgICogQHBhcmFtIHs/KHN0cmluZ3xzdHJpbmdbXSl9IFtvcHRpb25zLnRyYW5zaXRpb25DbGFzcyA9IHRyYW5zaXRpb25pbmddICAtIFRoZSBjbGFzcyB0byBhcHBseSB3aGVuIGEgbWVudSBpcyB0cmFuc2l0aW9uaW5nIGJldHdlZW4gXCJvcGVuXCIgYW5kIFwiY2xvc2VkXCIgc3RhdGVzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gICAgICAgICAgICAgW29wdGlvbnMudHJhbnNpdGlvbkR1cmF0aW9uID0gMjUwXSAgICAgICAgIC0gVGhlIGR1cmF0aW9uIG9mIHRoZSB0cmFuc2l0aW9uIGJldHdlZW4gXCJvcGVuXCIgYW5kIFwiY2xvc2VkXCIgc3RhdGVzIChpbiBtaWxsaXNlY29uZHMpLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICAgICAgICAgW29wdGlvbnMub3BlbkR1cmF0aW9uID0gLTFdICAgICAgICAgICAgICAgIC0gVGhlIGR1cmF0aW9uIG9mIHRoZSB0cmFuc2l0aW9uIGZyb20gXCJjbG9zZWRcIiB0byBcIm9wZW5cIiBzdGF0ZXMgKGluIG1pbGxpc2Vjb25kcykuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgICAgICAgICBbb3B0aW9ucy5jbG9zZUR1cmF0aW9uID0gLTFdICAgICAgICAgICAgICAgLSBUaGUgZHVyYXRpb24gb2YgdGhlIHRyYW5zaXRpb24gZnJvbSBcIm9wZW5cIiB0byBcImNsb3NlZFwiIHN0YXRlcyAoaW4gbWlsbGlzZWNvbmRzKS5cbiAgICogQHBhcmFtIHtib29sZWFufSAgICAgICAgICAgIFtvcHRpb25zLmlzVG9wTGV2ZWwgPSB0cnVlXSAgICAgICAgICAgICAgICAtIEEgZmxhZyB0byBtYXJrIHRoZSByb290IG1lbnUuXG4gICAqIEBwYXJhbSB7P0Rpc2Nsb3N1cmVNZW51fSAgICBbb3B0aW9ucy5wYXJlbnRNZW51ID0gbnVsbF0gICAgICAgICAgICAgICAgLSBUaGUgcGFyZW50IG1lbnUgdG8gdGhpcyBtZW51LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgW29wdGlvbnMuaG92ZXJUeXBlID0gb2ZmXSAgICAgICAgICAgICAgICAgIC0gVGhlIHR5cGUgb2YgaG92ZXJhYmlsaXR5IGEgbWVudSBoYXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSAgICAgICAgICAgICBbb3B0aW9ucy5ob3ZlckRlbGF5ID0gMjUwXSAgICAgICAgICAgICAgICAgLSBUaGUgZGVsYXkgZm9yIG9wZW5pbmcgYW5kIGNsb3NpbmcgbWVudXMgaWYgdGhlIG1lbnUgaXMgaG92ZXJhYmxlIChpbiBtaWxsaXNlY29uZHMpLlxuICAgKiBAcGFyYW0ge251bWJlcn0gICAgICAgICAgICAgW29wdGlvbnMuZW50ZXJEZWxheSA9IC0xXSAgICAgICAgICAgICAgICAgIC0gVGhlIGRlbGF5IGZvciBvcGVuaW5nIGEgbWVudSBpZiB0aGUgbWVudSBpcyBmb2N1c2FibGUgKGluIG1pbGxpc2Vjb25kcykuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSAgICAgICAgICAgICBbb3B0aW9ucy5sZWF2ZURlbGF5ID0gLTFdICAgICAgICAgICAgICAgICAgLSBUaGUgZGVsYXkgZm9yIGNsb3NpbmcgYSBtZW51IGlmIHRoZSBtZW51IGlzIGZvY3VzYWJsZSAoaW4gbWlsbGlzZWNvbmRzKS5cbiAgICogQHBhcmFtIHtib29sZWFufSAgICAgICAgICAgIFtvcHRpb25zLm9wdGlvbmFsS2V5U3VwcG9ydCA9IGZhbHNlXSAgICAgICAtIEEgZmxhZyB0byBhZGQgb3B0aW9uYWwga2V5Ym9hcmQgc3VwcG9ydCAoQXJyb3cga2V5cywgSG9tZSwgYW5kIEVuZCkgdG8gdGhlIG1lbnUuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gICAgICAgICAgICBbb3B0aW9ucy5wcmVmaXggPSBhbS1dICAgICAgICAgICAgICAgICAgICAgLSBUaGUgcHJlZml4IHRvIHVzZSBmb3IgQ1NTIGN1c3RvbSBwcm9wZXJ0aWVzLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICAgICAgICAgW29wdGlvbnMuaW5pdGlhbGl6ZSA9IHRydWVdICAgICAgICAgICAgICAgIC0gQSBmbGFnIHRvIGluaXRpYWxpemUgdGhlIG1lbnUgaW1tZWRpYXRlbHkgdXBvbiBjcmVhdGlvbi5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBtZW51RWxlbWVudDogdCxcbiAgICBtZW51SXRlbVNlbGVjdG9yOiBzID0gXCJsaVwiLFxuICAgIG1lbnVMaW5rU2VsZWN0b3I6IG4gPSBcImFcIixcbiAgICBzdWJtZW51SXRlbVNlbGVjdG9yOiBpID0gXCJsaTpoYXModWwpXCIsXG4gICAgc3VibWVudVRvZ2dsZVNlbGVjdG9yOiBsID0gXCJidXR0b25cIixcbiAgICBzdWJtZW51U2VsZWN0b3I6IGggPSBcInVsXCIsXG4gICAgY29udHJvbGxlckVsZW1lbnQ6IG0gPSBudWxsLFxuICAgIGNvbnRhaW5lckVsZW1lbnQ6IGEgPSBudWxsLFxuICAgIG9wZW5DbGFzczogcCA9IFwic2hvd1wiLFxuICAgIGNsb3NlQ2xhc3M6IGYgPSBcImhpZGVcIixcbiAgICB0cmFuc2l0aW9uQ2xhc3M6IGcgPSBcInRyYW5zaXRpb25pbmdcIixcbiAgICB0cmFuc2l0aW9uRHVyYXRpb246IGQgPSAyNTAsXG4gICAgb3BlbkR1cmF0aW9uOiBNID0gLTEsXG4gICAgY2xvc2VEdXJhdGlvbjogeSA9IC0xLFxuICAgIGlzVG9wTGV2ZWw6IGIgPSAhMCxcbiAgICBwYXJlbnRNZW51OiBDID0gbnVsbCxcbiAgICBob3ZlclR5cGU6IFQgPSBcIm9mZlwiLFxuICAgIGhvdmVyRGVsYXk6IEUgPSAyNTAsXG4gICAgZW50ZXJEZWxheTogdiA9IC0xLFxuICAgIGxlYXZlRGVsYXk6IEkgPSAtMSxcbiAgICBvcHRpb25hbEtleVN1cHBvcnQ6IEsgPSAhMSxcbiAgICBwcmVmaXg6ICQgPSBcImFtLVwiLFxuICAgIGluaXRpYWxpemU6IFYgPSAhMFxuICB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgbWVudUVsZW1lbnQ6IHQsXG4gICAgICBtZW51SXRlbVNlbGVjdG9yOiBzLFxuICAgICAgbWVudUxpbmtTZWxlY3RvcjogbixcbiAgICAgIHN1Ym1lbnVJdGVtU2VsZWN0b3I6IGksXG4gICAgICBzdWJtZW51VG9nZ2xlU2VsZWN0b3I6IGwsXG4gICAgICBzdWJtZW51U2VsZWN0b3I6IGgsXG4gICAgICBjb250cm9sbGVyRWxlbWVudDogbSxcbiAgICAgIGNvbnRhaW5lckVsZW1lbnQ6IGEsXG4gICAgICBvcGVuQ2xhc3M6IHAsXG4gICAgICBjbG9zZUNsYXNzOiBmLFxuICAgICAgdHJhbnNpdGlvbkNsYXNzOiBnLFxuICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uOiBkLFxuICAgICAgb3BlbkR1cmF0aW9uOiBNLFxuICAgICAgY2xvc2VEdXJhdGlvbjogeSxcbiAgICAgIGlzVG9wTGV2ZWw6IGIsXG4gICAgICBwYXJlbnRNZW51OiBDLFxuICAgICAgaG92ZXJUeXBlOiBULFxuICAgICAgaG92ZXJEZWxheTogRSxcbiAgICAgIGVudGVyRGVsYXk6IHYsXG4gICAgICBsZWF2ZURlbGF5OiBJLFxuICAgICAgcHJlZml4OiAkXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogVGhlIGNsYXNzIHRvIHVzZSB3aGVuIGdlbmVyYXRpbmcgc3VibWVudXMuXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICpcbiAgICAgKiBAdHlwZSB7dHlwZW9mIERpc2Nsb3N1cmVNZW51fVxuICAgICAqL1xuICAgIHUodGhpcywgXCJfTWVudVR5cGVcIiwgeik7XG4gICAgLyoqXG4gICAgICogVGhlIGNsYXNzIHRvIHVzZSB3aGVuIGdlbmVyYXRpbmcgbWVudSBpdGVtcy5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKlxuICAgICAqIEB0eXBlIHt0eXBlb2YgRGlzY2xvc3VyZU1lbnVJdGVtfVxuICAgICAqL1xuICAgIHUodGhpcywgXCJfTWVudUl0ZW1UeXBlXCIsIFopO1xuICAgIC8qKlxuICAgICAqIFRoZSBjbGFzcyB0byB1c2Ugd2hlbiBnZW5lcmF0aW5nIHN1Ym1lbnUgdG9nZ2xlcy5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKlxuICAgICAqIEB0eXBlIHt0eXBlb2YgRGlzY2xvc3VyZU1lbnVUb2dnbGV9XG4gICAgICovXG4gICAgdSh0aGlzLCBcIl9NZW51VG9nZ2xlVHlwZVwiLCBRKTtcbiAgICAvKipcbiAgICAgKiBUaGUgaW5kZXggb2YgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBtZW51IGl0ZW0gaW4gdGhlIG1lbnUuXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICpcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIHUodGhpcywgXCJfY3VycmVudENoaWxkXCIsIC0xKTtcbiAgICAvKipcbiAgICAgKiBBIGZsYWcgdG8gYWRkIG9wdGlvbmFsIGtleWJvYXJkIHN1cHBvcnQgKEFycm93IGtleXMsIFwiSG9tZVwiLCBhbmQgXCJFbmRcIikgdG8gdGhlIG1lbnUuXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB1KHRoaXMsIFwiX29wdGlvbmFsU3VwcG9ydFwiLCAhMSk7XG4gICAgdGhpcy5fb3B0aW9uYWxTdXBwb3J0ID0gSywgViAmJiB0aGlzLmluaXRpYWxpemUoKTtcbiAgfVxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIG1lbnUuXG4gICAqXG4gICAqIEluaXRpYWxpemUgd2lsbCBjYWxsIEJhc2VNZW51J3MgaW5pdGlhbGl6ZSBtZXRob2RcbiAgICogYXMgd2VsbCBhcyBzZXQgdXAgZm9jdXMsXG4gICAqIGNsaWNrLFxuICAgKiBob3ZlcixcbiAgICoga2V5ZG93biwgYW5kXG4gICAqIGtleXVwIGV2ZW50cyBmb3IgdGhlIG1lbnUuXG4gICAqXG4gICAqIElmIHRoZSBCYXNlTWVudSdzIGluaXRpYWxpemUgbWV0aG9kIHRocm93cyBhbiBlcnJvcixcbiAgICogdGhpcyB3aWxsIGNhdGNoIGl0IGFuZCBsb2cgaXQgdG8gdGhlIGNvbnNvbGUuXG4gICAqL1xuICBpbml0aWFsaXplKCkge1xuICAgIHRyeSB7XG4gICAgICBzdXBlci5pbml0aWFsaXplKCksIHRoaXMuX2hhbmRsZUZvY3VzKCksIHRoaXMuX2hhbmRsZUNsaWNrKCksIHRoaXMuX2hhbmRsZUhvdmVyKCksIHRoaXMuX2hhbmRsZUtleWRvd24oKSwgdGhpcy5faGFuZGxlS2V5dXAoKTtcbiAgICB9IGNhdGNoICh0KSB7XG4gICAgICBjb25zb2xlLmVycm9yKHQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQSBmbGFnIHRvIGFkZCBvcHRpb25hbCBrZXlib2FyZCBzdXBwb3J0IChBcnJvdyBrZXlzLCBcIkhvbWVcIiwgYW5kIFwiRW5kXCIpIHRvIHRoZSBtZW51LlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9ucyBkaWZmZXJlbnRseSBmb3Igcm9vdCB2cy4gc3VibWVudXMuXG4gICAqIFN1Ym1lbnVzIHdpbGwgYWx3YXlzIGluaGVyaXQgdGhlaXIgcm9vdCBtZW51J3Mgb3B0aW9uYWxLZXlTdXBwb3J0LlxuICAgKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICpcbiAgICogQHNlZSBfb3B0aW9uYWxTdXBwb3J0XG4gICAqL1xuICBnZXQgb3B0aW9uYWxLZXlTdXBwb3J0KCkge1xuICAgIHJldHVybiB0aGlzLmlzVG9wTGV2ZWwgPyB0aGlzLl9vcHRpb25hbFN1cHBvcnQgOiB0aGlzLmVsZW1lbnRzLnJvb3RNZW51Lm9wdGlvbmFsS2V5U3VwcG9ydDtcbiAgfVxuICBzZXQgb3B0aW9uYWxLZXlTdXBwb3J0KHQpIHtcbiAgICBjKFwiYm9vbGVhblwiLCB7IG9wdGlvbmFsS2V5U3VwcG9ydDogdCB9KSwgdGhpcy5fb3B0aW9uYWxTdXBwb3J0ID0gdDtcbiAgfVxuICAvKipcbiAgICogVmFsaWRhdGVzIGFsbCBhc3BlY3RzIG9mIHRoZSBtZW51IHRvIGVuc3VyZSBwcm9wZXIgZnVuY3Rpb25hbGl0eS5cbiAgICpcbiAgICogQHByb3RlY3RlZFxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSAtIFRoZSByZXN1bHQgb2YgdGhlIHZhbGlkYXRpb24uXG4gICAqL1xuICBfdmFsaWRhdGUoKSB7XG4gICAgbGV0IHQgPSBzdXBlci5fdmFsaWRhdGUoKTtcbiAgICBjb25zdCBzID0gYyhcImJvb2xlYW5cIiwge1xuICAgICAgb3B0aW9uYWxLZXlTdXBwb3J0OiB0aGlzLl9vcHRpb25hbFN1cHBvcnRcbiAgICB9KTtcbiAgICByZXR1cm4gcy5zdGF0dXMgfHwgKHRoaXMuX2Vycm9ycy5wdXNoKHMuZXJyb3IubWVzc2FnZSksIHQgPSAhMSksIHQ7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZXMgY2xpY2sgZXZlbnRzIHRocm91Z2hvdXQgdGhlIG1lbnUgZm9yIHByb3BlciB1c2UuXG4gICAqXG4gICAqIC0gQWRkcyBhbGwgZXZlbnQgbGlzdGVuZXJzIGxpc3RlZCBpblxuICAgKiAgIEJhc2VNZW51J3MgX2hhbmRsZUNsaWNrIG1ldGhvZC5cbiAgICogLSBBZGRzIGEgYHBvaW50ZXJ1cGAgbGlzdGVuZXIgdG8gdGhlIGBkb2N1bWVudGAgc28gaWYgdGhlIHVzZXJcbiAgICogICBjbGlja3Mgb3V0c2lkZSBvZiB0aGUgbWVudSBpdCB3aWxsIGNsb3NlIGlmIGl0IGlzIG9wZW4uXG4gICAqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9oYW5kbGVDbGljaygpIHtcbiAgICBzdXBlci5faGFuZGxlQ2xpY2soKSwgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCAodCkgPT4ge1xuICAgICAgdGhpcy5mb2N1c1N0YXRlICE9PSBcIm5vbmVcIiAmJiAodGhpcy5jdXJyZW50RXZlbnQgPSBcIm1vdXNlXCIsICF0aGlzLmRvbS5tZW51LmNvbnRhaW5zKHQudGFyZ2V0KSAmJiAhdGhpcy5kb20ubWVudSAhPT0gdC50YXJnZXQgJiYgKHRoaXMuY2xvc2VDaGlsZHJlbigpLCB0aGlzLmJsdXIoKSwgdGhpcy5lbGVtZW50cy5jb250cm9sbGVyICYmIHRoaXMuZWxlbWVudHMuY29udHJvbGxlci5jbG9zZSgpLCB0aGlzLmVsZW1lbnRzLnJvb3RNZW51Lmhhc09wZW5lZCA9ICExKSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZXMga2V5ZG93biBldmVudHMgdGhyb3VnaG91dCB0aGUgbWVudSBmb3IgcHJvcGVyIG1lbnUgdXNlLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBleGlzdHMgdG8gYXNzaXN0IHRoZSBfaGFuZGxlS2V5dXAgbWV0aG9kLlxuICAgKiAtIEFkZHMgYWxsIGBrZXlkb3duYCBsaXN0ZW5lcnMgZnJvbSBCYXNlTWVudSdzIF9oYW5kbGVLZXlkb3duIG1ldGhvZFxuICAgKiAtIEFkZHMgYSBga2V5ZG93bmAgbGlzdGVuZXIgdG8gdGhlIG1lbnUvYWxsIHN1Ym1lbnVzLlxuICAgKiAgIC0gQmxvY2tzIHByb3BhZ2F0aW9uIG9uIHRoZSBmb2xsb3dpbmcga2V5czogXCJTcGFjZVwiLCBcIkVudGVyXCIsIGFuZCBcIkVzY2FwZVwiLlxuICAgKiAgIC0gX0lmXyBvcHRpb25hbCBrZXlib2FyZCBzdXBwb3J0XG4gICAqICAgICBpcyBlbmFibGVkLCBibG9ja3MgcHJvcGFnYXRpb24gb24gdGhlIGZvbGxvd2luZyBrZXlzOlxuICAgKiAgICAgXCJBcnJvd1VwXCIsIFwiQXJyb3dSaWdodFwiLCBcIkFycm93RG93blwiLCBcIkFycm93TGVmdFwiLCBcIkhvbWVcIiwgYW5kIFwiRW5kXCIuXG4gICAqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9oYW5kbGVLZXlkb3duKCkge1xuICAgIHN1cGVyLl9oYW5kbGVLZXlkb3duKCksIHRoaXMuZG9tLm1lbnUuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgKHQpID0+IHtcbiAgICAgIHRoaXMuY3VycmVudEV2ZW50ID0gXCJrZXlib2FyZFwiO1xuICAgICAgY29uc3QgcyA9IF8odCk7XG4gICAgICBpZiAodGhpcy5mb2N1c1N0YXRlID09PSBcInNlbGZcIikge1xuICAgICAgICBjb25zdCBuID0gW1wiU3BhY2VcIiwgXCJFbnRlclwiXSwgaSA9IFtcIkVzY2FwZVwiXSwgbCA9IFtcIkVzY2FwZVwiXSwgaCA9IFtcbiAgICAgICAgICBcIkFycm93VXBcIixcbiAgICAgICAgICBcIkFycm93UmlnaHRcIixcbiAgICAgICAgICBcIkFycm93RG93blwiLFxuICAgICAgICAgIFwiQXJyb3dMZWZ0XCIsXG4gICAgICAgICAgXCJIb21lXCIsXG4gICAgICAgICAgXCJFbmRcIlxuICAgICAgICBdO1xuICAgICAgICAobi5pbmNsdWRlcyhzKSB8fCB0aGlzLm9wdGlvbmFsS2V5U3VwcG9ydCAmJiBoLmluY2x1ZGVzKHMpIHx8IHRoaXMuZWxlbWVudHMuY29udHJvbGxlciAmJiBpLmluY2x1ZGVzKHMpIHx8IHRoaXMuZWxlbWVudHMucGFyZW50TWVudSAmJiBsLmluY2x1ZGVzKHMpKSAmJiBvKHQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGVzIGtleXVwIGV2ZW50cyB0aHJvdWdob3V0IHRoZSBtZW51IGZvciBwcm9wZXIgbWVudSB1c2UuXG4gICAqXG4gICAqIEFkZHMgYWxsIGBrZXl1cGAgbGlzdGVuZXJzIGZyb20gQmFzZU1lbnUncyBfaGFuZGxlS2V5dXAgbWV0aG9kLlxuICAgKlxuICAgKiBBZGRzIHRoZSBmb2xsb3dpbmcga2V5YmluZGluZ3MgKGV4cGxhbmF0aW9ucyBhcmUgdGFrZW4gZnJvbSB0aGVcbiAgICogV0FJIEFSSUEgUHJhY3RpY2VzIEV4YW1wbGUgRGlzY2xvc3VyZSBmb3IgTmF2aWdhdGlvbiBNZW51cyk6XG4gICAqXG4gICAqIHwgS2V5IHwgRnVuY3Rpb24gfFxuICAgKiB8IC0tLSB8IC0tLSB8XG4gICAqIHwgX1RhYl8gb3IgX1NoaWZ0ICsgVGFiXyB8IE1vdmUga2V5Ym9hcmQgZm9jdXMgYW1vbmcgdG9wLWxldmVsIGJ1dHRvbnMsIGFuZCBpZiBhIGRyb3Bkb3duIGlzIG9wZW4sIGludG8gYW5kIHRocm91Z2ggbGlua3MgaW4gdGhlIGRyb3Bkb3duLiB8XG4gICAqIHwgX1NwYWNlXyBvciBfRW50ZXJfIHwgPHVsPjxsaT5JZiBmb2N1cyBpcyBvbiBhIGRpc2Nsb3N1cmUgYnV0dG9uLCBhY3RpdmF0ZXMgdGhlIGJ1dHRvbiwgd2hpY2ggdG9nZ2xlcyB0aGUgdmlzaWJpbGl0eSBvZiB0aGUgZHJvcGRvd24uPC9saT48bGk+SWYgZm9jdXMgaXMgb24gYSBsaW5rOjx1bD48bGk+SWYgYW55IGxpbmsgaGFzIGFyaWEtY3VycmVudCBzZXQsIHJlbW92ZXMgaXQuPC9saT48bGk+U2V0cyBhcmlhLWN1cnJlbnQ9XCJwYWdlXCIgb24gdGhlIGZvY3VzZWQgbGluay48L2xpPjxsaT5BY3RpdmF0ZXMgdGhlIGZvY3VzZWQgbGluay48L2xpPjwvdWw+PC9saT48L3VsPiB8XG4gICAqIHwgX0VzY2FwZV8gfCBJZiBhIGRyb3Bkb3duIGlzIG9wZW4sIGNsb3NlcyBpdCBhbmQgc2V0cyBmb2N1cyBvbiB0aGUgYnV0dG9uIHRoYXQgY29udHJvbHMgdGhhdCBkcm9wZG93bi4gfFxuICAgKiB8IF9Eb3duIEFycm93XyBvciBfUmlnaHQgQXJyb3dfIChPcHRpb25hbH0pIHwgPHVsPjxsaT5JZiBmb2N1cyBpcyBvbiBhIGJ1dHRvbiBhbmQgaXRzIGRyb3Bkb3duIGlzIGNvbGxhcHNlZCwgYW5kIGl0IGlzIG5vdCB0aGUgbGFzdCBidXR0b24sIG1vdmVzIGZvY3VzIHRvIHRoZSBuZXh0IGJ1dHRvbi48L2xpPjxsaT5pZiBmb2N1cyBpcyBvbiBhIGJ1dHRvbiBhbmQgaXRzIGRyb3Bkb3duIGlzIGV4cGFuZGVkLCBtb3ZlcyBmb2N1cyB0byB0aGUgZmlyc3QgbGluayBpbiB0aGUgZHJvcGRvd24uPC9saT48bGk+SWYgZm9jdXMgaXMgb24gYSBsaW5rLCBhbmQgaXQgaXMgbm90IHRoZSBsYXN0IGxpbmssIG1vdmVzIGZvY3VzIHRvIHRoZSBuZXh0IGxpbmsuPC9saT48L3VsPiB8XG4gICAqIHwgX1VwIEFycm93XyBvciBfTGVmdCBBcnJvd18gKE9wdGlvbmFsfSkgfCA8dWw+PGxpPklmIGZvY3VzIGlzIG9uIGEgYnV0dG9uLCBhbmQgaXQgaXMgbm90IHRoZSBmaXJzdCBidXR0b24sIG1vdmVzIGZvY3VzIHRvIHRoZSBwcmV2aW91cyBidXR0b24uPC9saT48bGk+SWYgZm9jdXMgaXMgb24gYSBsaW5rLCBhbmQgaXQgaXMgbm90IHRoZSBmaXJzdCBsaW5rLCBtb3ZlcyBmb2N1cyB0byB0aGUgcHJldmlvdXMgbGluay48L2xpPjwvdWw+IHxcbiAgICogfCBfSG9tZV8gKE9wdGlvbmFsKSB8IDx1bD48bGk+SWYgZm9jdXMgaXMgb24gYSBidXR0b24sIGFuZCBpdCBpcyBub3QgdGhlIGZpcnN0IGJ1dHRvbiwgbW92ZXMgZm9jdXMgdG8gdGhlIGZpcnN0IGJ1dHRvbi48L2xpPjxsaT5JZiBmb2N1cyBpcyBvbiBhIGxpbmssIGFuZCBpdCBpcyBub3QgdGhlIGZpcnN0IGxpbmssIG1vdmVzIGZvY3VzIHRvIHRoZSBmaXJzdCBsaW5rLjwvbGk+PC91bD4gfFxuICAgKiB8IF9FbmRfIChPcHRpb25hbCkgfCA8dWw+PGxpPklmIGZvY3VzIGlzIG9uIGEgYnV0dG9uLCBhbmQgaXQgaXMgbm90IHRoZSBsYXN0IGJ1dHRvbiwgbW92ZXMgZm9jdXMgdG8gdGhlIGxhc3QgYnV0dG9uLjwvbGk+PGxpPklmIGZvY3VzIGlzIG9uIGEgbGluaywgYW5kIGl0IGlzIG5vdCB0aGUgbGFzdCBsaW5rLCBtb3ZlcyBmb2N1cyB0byB0aGUgbGFzdCBsaW5rLjwvbGk+PC91bD4gfFxuICAgKlxuICAgKiBUaGUgb3B0aW9uYWwga2V5YmluZGluZ3MgYXJlIGNvbnRyb2xsZWQgYnkgdGhlIG1lbnUncyBvcHRpb25hbEtleVN1cHBvcnQgdmFsdWUuXG4gICAqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9oYW5kbGVLZXl1cCgpIHtcbiAgICBzdXBlci5faGFuZGxlS2V5dXAoKSwgdGhpcy5kb20ubWVudS5hZGRFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgKHQpID0+IHtcbiAgICAgIHRoaXMuY3VycmVudEV2ZW50ID0gXCJrZXlib2FyZFwiO1xuICAgICAgY29uc3QgcyA9IF8odCk7XG4gICAgICB0aGlzLmZvY3VzU3RhdGUgPT09IFwic2VsZlwiICYmIChzID09PSBcIlNwYWNlXCIgfHwgcyA9PT0gXCJFbnRlclwiID8gKG8odCksIHRoaXMuY3VycmVudE1lbnVJdGVtLmlzU3VibWVudUl0ZW0gPyB0aGlzLmN1cnJlbnRNZW51SXRlbS5lbGVtZW50cy50b2dnbGUuaXNPcGVuID8gdGhpcy5jdXJyZW50TWVudUl0ZW0uZWxlbWVudHMudG9nZ2xlLmNsb3NlKCkgOiB0aGlzLmN1cnJlbnRNZW51SXRlbS5lbGVtZW50cy50b2dnbGUucHJldmlldygpIDogdGhpcy5jdXJyZW50TWVudUl0ZW0uZG9tLmxpbmsuY2xpY2soKSkgOiBzID09PSBcIkVzY2FwZVwiID8gdGhpcy5lbGVtZW50cy5zdWJtZW51VG9nZ2xlcy5zb21lKFxuICAgICAgICAoaSkgPT4gaS5pc09wZW5cbiAgICAgICkgPyAobyh0KSwgdGhpcy5jbG9zZUNoaWxkcmVuKCkpIDogdGhpcy5lbGVtZW50cy5wYXJlbnRNZW51ID8gKG8odCksIHRoaXMuZWxlbWVudHMucGFyZW50TWVudS5jdXJyZW50RXZlbnQgPSB0aGlzLmN1cnJlbnRFdmVudCwgdGhpcy5lbGVtZW50cy5wYXJlbnRNZW51LmNsb3NlQ2hpbGRyZW4oKSwgdGhpcy5lbGVtZW50cy5wYXJlbnRNZW51LmZvY3VzQ3VycmVudENoaWxkKCkpIDogdGhpcy5pc1RvcExldmVsICYmIHRoaXMuZWxlbWVudHMuY29udHJvbGxlciAmJiB0aGlzLmVsZW1lbnRzLmNvbnRyb2xsZXIuaXNPcGVuICYmICh0aGlzLmVsZW1lbnRzLmNvbnRyb2xsZXIuY2xvc2UoKSwgdGhpcy5mb2N1c0NvbnRyb2xsZXIoKSkgOiB0aGlzLm9wdGlvbmFsS2V5U3VwcG9ydCAmJiAocyA9PT0gXCJBcnJvd0Rvd25cIiB8fCBzID09PSBcIkFycm93UmlnaHRcIiA/IChvKHQpLCB0aGlzLmN1cnJlbnRNZW51SXRlbS5pc1N1Ym1lbnVJdGVtICYmIHRoaXMuY3VycmVudE1lbnVJdGVtLmVsZW1lbnRzLnRvZ2dsZS5pc09wZW4gPyAodGhpcy5jdXJyZW50TWVudUl0ZW0uZWxlbWVudHMuY2hpbGRNZW51LmN1cnJlbnRFdmVudCA9IFwia2V5Ym9hcmRcIiwgdGhpcy5jdXJyZW50TWVudUl0ZW0uZWxlbWVudHMuY2hpbGRNZW51LmZvY3VzRmlyc3RDaGlsZCgpKSA6IHRoaXMuZm9jdXNOZXh0Q2hpbGQoKSkgOiBzID09PSBcIkFycm93VXBcIiB8fCBzID09PSBcIkFycm93TGVmdFwiID8gKG8odCksIHRoaXMuZm9jdXNQcmV2aW91c0NoaWxkKCkpIDogcyA9PT0gXCJIb21lXCIgPyAobyh0KSwgdGhpcy5mb2N1c0ZpcnN0Q2hpbGQoKSkgOiBzID09PSBcIkVuZFwiICYmIChvKHQpLCB0aGlzLmZvY3VzTGFzdENoaWxkKCkpKSk7XG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIEIgZXh0ZW5kcyBPIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgYE1lbnViYXJJdGVtYC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9ICAgICAgICAgb3B0aW9ucyAgICAgICAgICAgICAgICAgICAgICAgICAtIFRoZSBvcHRpb25zIGZvciBnZW5lcmF0aW5nIHRoZSBtZW51IGl0ZW0uXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9ICAgIG9wdGlvbnMubWVudUl0ZW1FbGVtZW50ICAgICAgICAgLSBUaGUgbWVudSBpdGVtIGluIHRoZSBET00uXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9ICAgIG9wdGlvbnMubWVudUxpbmtFbGVtZW50ICAgICAgICAgLSBUaGUgbWVudSBpdGVtJ3MgbGluayBpbiB0aGUgRE9NLlxuICAgKiBAcGFyYW0ge01lbnViYXJ9ICAgICAgICBvcHRpb25zLnBhcmVudE1lbnUgICAgICAgICAgICAgIC0gVGhlIHBhcmVudCBtZW51LlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICAgICBbb3B0aW9ucy5pc1N1Ym1lbnVJdGVtID0gZmFsc2VdIC0gQSBmbGFnIHRvIG1hcmsgaWYgdGhlIG1lbnUgaXRlbSBpcyBjb250cm9sbGluZyBhIHN1Ym1lbnUuXG4gICAqIEBwYXJhbSB7P01lbnViYXJ9ICAgICAgIFtvcHRpb25zLmNoaWxkTWVudSA9IG51bGxdICAgICAgLSBUaGUgY2hpbGQgbWVudS5cbiAgICogQHBhcmFtIHs/TWVudWJhclRvZ2dsZX0gW29wdGlvbnMudG9nZ2xlID0gbnVsbF0gICAgICAgICAtIFRoZSBjb250cm9sbGVyIGZvciB0aGUgY2hpbGQgbWVudS5cbiAgICogQHBhcmFtIHtib29sZWFufSAgICAgICAgW29wdGlvbnMuaW5pdGlhbGl6ZSA9IHRydWVdICAgICAtIEEgZmxhZyB0byBpbml0aWFsaXplIHRoZSBtZW51IGl0ZW0gaW1tZWRpYXRlbHkgdXBvbiBjcmVhdGlvbi5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBtZW51SXRlbUVsZW1lbnQ6IGUsXG4gICAgbWVudUxpbmtFbGVtZW50OiB0LFxuICAgIHBhcmVudE1lbnU6IHMsXG4gICAgaXNTdWJtZW51SXRlbTogbiA9ICExLFxuICAgIGNoaWxkTWVudTogaSA9IG51bGwsXG4gICAgdG9nZ2xlOiBsID0gbnVsbCxcbiAgICBpbml0aWFsaXplOiBoID0gITBcbiAgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIG1lbnVJdGVtRWxlbWVudDogZSxcbiAgICAgIG1lbnVMaW5rRWxlbWVudDogdCxcbiAgICAgIHBhcmVudE1lbnU6IHMsXG4gICAgICBpc1N1Ym1lbnVJdGVtOiBuLFxuICAgICAgY2hpbGRNZW51OiBpLFxuICAgICAgdG9nZ2xlOiBsXG4gICAgfSksIGggJiYgdGhpcy5pbml0aWFsaXplKCk7XG4gIH1cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgdGhlIG1lbnUgaXRlbS5cbiAgICpcbiAgICogSW5pdGlhbGl6ZSB3aWxsIGNhbGwgdGhlIEJhc2VNZW51SXRlbSdzIGluaXRpYWxpemUgbWV0aG9kXG4gICAqIGFzIHdlbGwgYXMgc2V0IHRoZSBtZW51IGl0ZW0ncyBgcm9sZWAgdG8gXCJub25lXCIsXG4gICAqIHRoZSBtZW51IGxpbmsncyBgcm9sZWAgdG8gXCJtZW51aXRlbVwiLCBhbmRcbiAgICogdGhlIG1lbnUgbGluaydzIGB0YWJJbmRleGAgdG8gLTEgaW4gdGhlIERPTS5cbiAgICovXG4gIGluaXRpYWxpemUoKSB7XG4gICAgc3VwZXIuaW5pdGlhbGl6ZSgpLCB0aGlzLmRvbS5pdGVtLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJub25lXCIpLCB0aGlzLmRvbS5saW5rLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJtZW51aXRlbVwiKSwgdGhpcy5kb20ubGluay50YWJJbmRleCA9IC0xO1xuICB9XG4gIC8qKlxuICAgKiBGb2N1c2VzIHRoZSBtZW51IGl0ZW0ncyBsaW5rIGlmIHRoZSBwYXJlbnQgbWVudSdzXG4gICAqIHNob3VsZEZvY3VzIHZhbHVlIGlzIGB0cnVlYC5cbiAgICpcbiAgICogVGhpcyB3aWxsIGNhbGwgdGhlIEJhc2VNZW51SXRlbSdzIGZvY3VzIG1ldGhvZFxuICAgKiBhcyB3ZWxsIGFzIHNldCB0aGUgbWVudSBsaW5rJ3MgYHRhYkluZGV4YCB0byAwIGlmIHRoZSBwYXJlbnQgbWVudVxuICAgKiBpcyB0aGUgcm9vdCBtZW51LlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBmb2N1cygpIHtcbiAgICBzdXBlci5mb2N1cygpLCB0aGlzLmVsZW1lbnRzLnBhcmVudE1lbnUuaXNUb3BMZXZlbCAmJiAodGhpcy5kb20ubGluay50YWJJbmRleCA9IDApO1xuICB9XG4gIC8qKlxuICAgKiBCbHVycyB0aGUgbWVudSBpdGVtJ3MgbGluayBpZiB0aGUgcGFyZW50IG1lbnUnc1xuICAgKiBzaG91bGRGb2N1cyB2YWx1ZSBpcyBgdHJ1ZWAuXG4gICAqXG4gICAqIFRoaXMgd2lsbCBjYWxsIHRoZSBCYXNlTWVudUl0ZW0ncyBibHVyIG1ldGhvZFxuICAgKiBhcyB3ZWxsIGFzIHNldCB0aGUgbWVudSBsaW5rJ3MgYHRhYkluZGV4YCB0byAtMSBpZiB0aGUgcGFyZW50IG1lbnVcbiAgICogaXMgdGhlIHJvb3QgbWVudS5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgYmx1cigpIHtcbiAgICBzdXBlci5ibHVyKCksIHRoaXMuZWxlbWVudHMucGFyZW50TWVudS5pc1RvcExldmVsICYmICh0aGlzLmRvbS5saW5rLnRhYkluZGV4ID0gLTEpO1xuICB9XG59XG5jbGFzcyBHIGV4dGVuZHMgTCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGBNZW51YmFyVG9nZ2xlYC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9ICAgICAgb3B0aW9ucyAgICAgICAgICAgICAgICAgICAgIC0gVGhlIG9wdGlvbnMgZm9yIGdlbmVyYXRpbmcgdGhlIG1lbnUgdG9nZ2xlLlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBvcHRpb25zLm1lbnVUb2dnbGVFbGVtZW50ICAgLSBUaGUgdG9nZ2xlIGVsZW1lbnQgaW4gdGhlIERPTS5cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gb3B0aW9ucy5wYXJlbnRFbGVtZW50ICAgICAgIC0gVGhlIGVsZW1lbnQgY29udGFpbmluZyB0aGUgY29udHJvbGxlZCBtZW51LlxuICAgKiBAcGFyYW0ge01lbnViYXJ9ICAgICBvcHRpb25zLmNvbnRyb2xsZWRNZW51ICAgICAgLSBUaGUgbWVudSBjb250cm9sbGVkIGJ5IHRoaXMgdG9nZ2xlLlxuICAgKiBAcGFyYW0gez9NZW51YmFyfSAgICBbb3B0aW9ucy5wYXJlbnRNZW51ID0gbnVsbF0gLSBUaGUgbWVudSBjb250YWluaW5nIHRoaXMgdG9nZ2xlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICBbb3B0aW9ucy5pbml0aWFsaXplID0gdHJ1ZV0gLSBBIGZsYWcgdG8gaW5pdGlhbGl6ZSB0aGUgbWVudSB0b2dnbGUgaW1tZWRpYXRlbHkgdXBvbiBjcmVhdGlvbi5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBtZW51VG9nZ2xlRWxlbWVudDogZSxcbiAgICBwYXJlbnRFbGVtZW50OiB0LFxuICAgIGNvbnRyb2xsZWRNZW51OiBzLFxuICAgIHBhcmVudE1lbnU6IG4gPSBudWxsLFxuICAgIGluaXRpYWxpemU6IGkgPSAhMFxuICB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgbWVudVRvZ2dsZUVsZW1lbnQ6IGUsXG4gICAgICBwYXJlbnRFbGVtZW50OiB0LFxuICAgICAgY29udHJvbGxlZE1lbnU6IHMsXG4gICAgICBwYXJlbnRNZW51OiBuXG4gICAgfSksIGkgJiYgdGhpcy5pbml0aWFsaXplKCk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgdGhlIEFSSUEgYXR0cmlidXRlcyBvbiB0aGUgdG9nZ2xlIGFuZCBjb250cm9sbGVkIG1lbnUuXG4gICAqXG4gICAqIENhbGxzIHRoZSBCYXNlTWVudVRvZ2dsZSdzIF9zZXRBcmlhQXR0cmlidXRlcyBtZXRob2QuXG4gICAqXG4gICAqIFRoZW4gc2V0cyB0aGUgdG9nZ2xlJ3MgYGFyaWEtaGFzcG9wdXBgIGF0dHJpYnV0ZSB0byBcInRydWVcIi5cbiAgICpcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX3NldEFyaWFBdHRyaWJ1dGVzKCkge1xuICAgIHN1cGVyLl9zZXRBcmlhQXR0cmlidXRlcygpLCB0aGlzLmRvbS50b2dnbGUuc2V0QXR0cmlidXRlKFwiYXJpYS1oYXNwb3B1cFwiLCBcInRydWVcIik7XG4gIH1cbiAgLyoqXG4gICAqIE9wZW5zIHRoZSBjb250cm9sbGVkIG1lbnUuXG4gICAqXG4gICAqIENhbGxzIHRoZSAgY2xvc2VTaWJsaW5ncyBtZXRob2RcbiAgICogYW5kIF90aGVuXyBCYXNlTWVudVRvZ2dsZSdzIG9wZW4gbWV0aG9kLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBvcGVuKCkge1xuICAgIHRoaXMuY2xvc2VTaWJsaW5ncygpLCBzdXBlci5vcGVuKCk7XG4gIH1cbiAgLyoqXG4gICAqIE9wZW5zIHRoZSBjb250cm9sbGVkIG1lbnUgd2l0aG91dCB0aGUgY3VycmVudCBmb2N1cyBlbnRlcmluZyBpdC5cbiAgICpcbiAgICogQ2FsbHMgdGhlICBjbG9zZVNpYmxpbmdzIG1ldGhvZFxuICAgKiBhbmQgX3RoZW5fIEJhc2VNZW51VG9nZ2xlJ3MgcHJldmlldyBtZXRob2QuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHByZXZpZXcoKSB7XG4gICAgdGhpcy5jbG9zZVNpYmxpbmdzKCksIHN1cGVyLnByZXZpZXcoKTtcbiAgfVxuICAvKipcbiAgICogQ2xvc2VzIHRoZSBjb250cm9sbGVkIG1lbnUuXG4gICAqXG4gICAqIENhbGxzIHRoZSAgY2xvc2VDaGlsZHJlbiBtZXRob2RcbiAgICogYW5kIF90aGVuXyBCYXNlTWVudVRvZ2dsZSdzIGNsb3NlIG1ldGhvZC5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY2xvc2UoKSB7XG4gICAgdGhpcy5pc09wZW4gJiYgKHRoaXMuY2xvc2VDaGlsZHJlbigpLCB0aGlzLmVsZW1lbnRzLnBhcmVudE1lbnUgJiYgdGhpcy5lbGVtZW50cy5wYXJlbnRNZW51LmZvY3VzQ3VycmVudENoaWxkKCkpLCBzdXBlci5jbG9zZSgpO1xuICB9XG59XG5jbGFzcyBIIGV4dGVuZHMgdyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGBNZW51YmFyYC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9ICAgICAgICAgICAgIG9wdGlvbnMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIFRoZSBvcHRpb25zIGZvciBnZW5lcmF0aW5nIHRoZSBtZW51LlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSAgICAgICAgb3B0aW9ucy5tZW51RWxlbWVudCAgICAgICAgICAgICAgICAgICAgICAgIC0gVGhlIG1lbnUgZWxlbWVudCBpbiB0aGUgRE9NLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgW29wdGlvbnMubWVudUl0ZW1TZWxlY3RvciA9IGxpXSAgICAgICAgICAgIC0gVGhlIHF1ZXJ5IHNlbGVjdG9yIHN0cmluZyBmb3IgbWVudSBpdGVtcy5cbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgIFtvcHRpb25zLm1lbnVMaW5rU2VsZWN0b3IgPSBhXSAgICAgICAgICAgICAtIFRoZSBxdWVyeSBzZWxlY3RvciBzdHJpbmcgZm9yIG1lbnUgbGlua3MuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICBbb3B0aW9ucy5zdWJtZW51SXRlbVNlbGVjdG9yID0gbGk6aGFzKHVsKV0gLSBUaGUgcXVlcnkgc2VsZWN0b3Igc3RyaW5nIGZvciBtZW51IGl0ZW1zIGNvbnRhaW5pbmcgc3VibWVudXMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICBbb3B0aW9ucy5zdWJtZW51VG9nZ2xlU2VsZWN0b3IgPSBhXSAgICAgICAgLSBUaGUgcXVlcnkgc2VsZWN0b3Igc3RyaW5nIGZvciBzdWJtZW51IHRvZ2dsZSBidXR0b25zL2xpbmtzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgW29wdGlvbnMuc3VibWVudVNlbGVjdG9yID0gdWxdICAgICAgICAgICAgIC0gVGhlIHF1ZXJ5IHNlbGVjdG9yIHN0cmluZyBmb3Igc3VibWVudXMuXG4gICAqIEBwYXJhbSB7P0hUTUxFbGVtZW50fSAgICAgICBbb3B0aW9ucy5jb250cm9sbGVyRWxlbWVudCA9IG51bGxdICAgICAgICAgLSBUaGUgZWxlbWVudCBjb250cm9sbGluZyB0aGUgbWVudSBpbiB0aGUgRE9NLlxuICAgKiBAcGFyYW0gez9IVE1MRWxlbWVudH0gICAgICAgW29wdGlvbnMuY29udGFpbmVyRWxlbWVudCA9IG51bGxdICAgICAgICAgIC0gVGhlIGVsZW1lbnQgY29udGFpbmluZyB0aGUgbWVudSBpbiB0aGUgRE9NLlxuICAgKiBAcGFyYW0gez8oc3RyaW5nfHN0cmluZ1tdKX0gW29wdGlvbnMub3BlbkNsYXNzID0gc2hvd10gICAgICAgICAgICAgICAgIC0gVGhlIGNsYXNzIHRvIGFwcGx5IHdoZW4gYSBtZW51IGlzIFwib3BlblwiLlxuICAgKiBAcGFyYW0gez8oc3RyaW5nfHN0cmluZ1tdKX0gW29wdGlvbnMuY2xvc2VDbGFzcyA9IGhpZGVdICAgICAgICAgICAgICAgIC0gVGhlIGNsYXNzIHRvIGFwcGx5IHdoZW4gYSBtZW51IGlzIFwiY2xvc2VkXCIuXG4gICAqIEBwYXJhbSB7PyhzdHJpbmd8c3RyaW5nW10pfSBbb3B0aW9ucy50cmFuc2l0aW9uQ2xhc3MgPSB0cmFuc2l0aW9uaW5nXSAgLSBUaGUgY2xhc3MgdG8gYXBwbHkgd2hlbiBhIG1lbnUgaXMgdHJhbnNpdGlvbmluZyBiZXR3ZWVuIFwib3BlblwiIGFuZCBcImNsb3NlZFwiIHN0YXRlcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9ICAgICAgICAgICAgIFtvcHRpb25zLnRyYW5zaXRpb25EdXJhdGlvbiA9IDI1MF0gICAgICAgICAtIFRoZSBkdXJhdGlvbiBvZiB0aGUgdHJhbnNpdGlvbiBiZXR3ZWVuIFwib3BlblwiIGFuZCBcImNsb3NlZFwiIHN0YXRlcyAoaW4gbWlsbGlzZWNvbmRzKS5cbiAgICogQHBhcmFtIHtib29sZWFufSAgICAgICAgICAgIFtvcHRpb25zLmlzVG9wTGV2ZWwgPSB0cnVlXSAgICAgICAgICAgICAgICAtIEEgZmxhZyB0byBtYXJrIHRoZSByb290IG1lbnUuXG4gICAqIEBwYXJhbSB7P01lbnViYXJ9ICAgICAgICAgICBbb3B0aW9ucy5wYXJlbnRNZW51ID0gbnVsbF0gICAgICAgICAgICAgICAgLSBUaGUgcGFyZW50IG1lbnUgdG8gdGhpcyBtZW51LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgW29wdGlvbnMuaG92ZXJUeXBlID0gb2ZmXSAgICAgICAgICAgICAgICAgIC0gVGhlIHR5cGUgb2YgaG92ZXJhYmlsaXR5IGEgbWVudSBoYXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSAgICAgICAgICAgICBbb3B0aW9ucy5ob3ZlckRlbGF5ID0gMjUwXSAgICAgICAgICAgICAgICAgLSBUaGUgZGVsYXkgZm9yIG9wZW5pbmcgYW5kIGNsb3NpbmcgbWVudXMgaWYgdGhlIG1lbnUgaXMgaG92ZXJhYmxlIChpbiBtaWxsaXNlY29uZHMpLlxuICAgKiBAcGFyYW0ge251bWJlcn0gICAgICAgICAgICAgW29wdGlvbnMuZW50ZXJEZWxheSA9IC0xXSAgICAgICAgICAgICAgICAgIC0gVGhlIGRlbGF5IGZvciBvcGVuaW5nIGEgbWVudSBpZiB0aGUgbWVudSBpcyBmb2N1c2FibGUgKGluIG1pbGxpc2Vjb25kcykuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSAgICAgICAgICAgICBbb3B0aW9ucy5sZWF2ZURlbGF5ID0gLTFdICAgICAgICAgICAgICAgICAgLSBUaGUgZGVsYXkgZm9yIGNsb3NpbmcgYSBtZW51IGlmIHRoZSBtZW51IGlzIGZvY3VzYWJsZSAoaW4gbWlsbGlzZWNvbmRzKS5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSAgICAgICAgICAgIFtvcHRpb25zLnByZWZpeCA9IGFtLV0gICAgICAgICAgICAgICAgICAgICAtIFRoZSBwcmVmaXggdG8gdXNlIGZvciBDU1MgY3VzdG9tIHByb3BlcnRpZXMuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgICAgICAgICBbb3B0aW9ucy5pbml0aWFsaXplID0gdHJ1ZV0gICAgICAgICAgICAgICAgLSBBIGZsYWcgdG8gaW5pdGlhbGl6ZSB0aGUgbWVudSBpbW1lZGlhdGVseSB1cG9uIGNyZWF0aW9uLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIG1lbnVFbGVtZW50OiB0LFxuICAgIG1lbnVJdGVtU2VsZWN0b3I6IHMgPSBcImxpXCIsXG4gICAgbWVudUxpbmtTZWxlY3RvcjogbiA9IFwiYVwiLFxuICAgIHN1Ym1lbnVJdGVtU2VsZWN0b3I6IGkgPSBcImxpOmhhcyh1bClcIixcbiAgICBzdWJtZW51VG9nZ2xlU2VsZWN0b3I6IGwgPSBcImFcIixcbiAgICBzdWJtZW51U2VsZWN0b3I6IGggPSBcInVsXCIsXG4gICAgY29udHJvbGxlckVsZW1lbnQ6IG0gPSBudWxsLFxuICAgIGNvbnRhaW5lckVsZW1lbnQ6IGEgPSBudWxsLFxuICAgIG9wZW5DbGFzczogcCA9IFwic2hvd1wiLFxuICAgIGNsb3NlQ2xhc3M6IGYgPSBcImhpZGVcIixcbiAgICB0cmFuc2l0aW9uQ2xhc3M6IGcgPSBcInRyYW5zaXRpb25pbmdcIixcbiAgICB0cmFuc2l0aW9uRHVyYXRpb246IGQgPSAyNTAsXG4gICAgaXNUb3BMZXZlbDogTSA9ICEwLFxuICAgIHBhcmVudE1lbnU6IHkgPSBudWxsLFxuICAgIGhvdmVyVHlwZTogYiA9IFwib2ZmXCIsXG4gICAgaG92ZXJEZWxheTogQyA9IDI1MCxcbiAgICBlbnRlckRlbGF5OiBUID0gLTEsXG4gICAgbGVhdmVEZWxheTogRSA9IC0xLFxuICAgIHByZWZpeDogdiA9IFwiYW0tXCIsXG4gICAgaW5pdGlhbGl6ZTogSSA9ICEwXG4gIH0pIHtcbiAgICBzdXBlcih7XG4gICAgICBtZW51RWxlbWVudDogdCxcbiAgICAgIG1lbnVJdGVtU2VsZWN0b3I6IHMsXG4gICAgICBtZW51TGlua1NlbGVjdG9yOiBuLFxuICAgICAgc3VibWVudUl0ZW1TZWxlY3RvcjogaSxcbiAgICAgIHN1Ym1lbnVUb2dnbGVTZWxlY3RvcjogbCxcbiAgICAgIHN1Ym1lbnVTZWxlY3RvcjogaCxcbiAgICAgIGNvbnRyb2xsZXJFbGVtZW50OiBtLFxuICAgICAgY29udGFpbmVyRWxlbWVudDogYSxcbiAgICAgIG9wZW5DbGFzczogcCxcbiAgICAgIGNsb3NlQ2xhc3M6IGYsXG4gICAgICB0cmFuc2l0aW9uQ2xhc3M6IGcsXG4gICAgICB0cmFuc2l0aW9uRHVyYXRpb246IGQsXG4gICAgICBpc1RvcExldmVsOiBNLFxuICAgICAgcGFyZW50TWVudTogeSxcbiAgICAgIGhvdmVyVHlwZTogYixcbiAgICAgIGhvdmVyRGVsYXk6IEMsXG4gICAgICBlbnRlckRlbGF5OiBULFxuICAgICAgbGVhdmVEZWxheTogRSxcbiAgICAgIHByZWZpeDogdlxuICAgIH0pO1xuICAgIC8qKlxuICAgICAqIFRoZSBjbGFzcyB0byB1c2Ugd2hlbiBnZW5lcmF0aW5nIHN1Ym1lbnVzLlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqXG4gICAgICogQHR5cGUge3R5cGVvZiBNZW51YmFyfVxuICAgICAqL1xuICAgIHUodGhpcywgXCJfTWVudVR5cGVcIiwgSCk7XG4gICAgLyoqXG4gICAgICogVGhlIGNsYXNzIHRvIHVzZSB3aGVuIGdlbmVyYXRpbmcgbWVudSBpdGVtcy5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKlxuICAgICAqIEB0eXBlIHt0eXBlb2YgTWVudWJhckl0ZW19XG4gICAgICovXG4gICAgdSh0aGlzLCBcIl9NZW51SXRlbVR5cGVcIiwgQik7XG4gICAgLyoqXG4gICAgICogVGhlIGNsYXNzIHRvIHVzZSB3aGVuIGdlbmVyYXRpbmcgc3VibWVudSB0b2dnbGVzLlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqXG4gICAgICogQHR5cGUge3R5cGVvZiBNZW51YmFyVG9nZ2xlfVxuICAgICAqL1xuICAgIHUodGhpcywgXCJfTWVudVRvZ2dsZVR5cGVcIiwgRyk7XG4gICAgSSAmJiB0aGlzLmluaXRpYWxpemUoKTtcbiAgfVxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIG1lbnUuXG4gICAqXG4gICAqIEluaXRpYWxpemUgd2lsbCBjYWxsIHRoZSBCYXNlTWVudSdzIGluaXRpYWxpemUgbWV0aG9kXG4gICAqIGFzIHdlbGwgYXMgc2V0IHVwIGZvY3VzLFxuICAgKiBjbGljayxcbiAgICogaG92ZXIsXG4gICAqIGtleWRvd24sIGFuZFxuICAgKiBrZXl1cCBldmVudHMgZm9yIHRoZSBtZW51LlxuICAgKlxuICAgKiBUaGlzIHdpbGwgYWxzbyBzZXQgdGhlIG1lbnUncyBgcm9sZWAgdG8gXCJtZW51YmFyXCIgaW4gdGhlIERPTS5cbiAgICpcbiAgICogSWYgdGhlIG1lbnUgaXMgYSByb290IG1lbnUgdGhlIGZpcnN0IG1lbnUgaXRlbSdzIGB0YWJJbmRleGAgd2lsbCBiZSBzZXQgdG9cbiAgICogMCBpbiB0aGUgRE9NLlxuICAgKlxuICAgKiBJZiB0aGUgQmFzZU1lbnUncyBpbml0aWFsaXplIG1ldGhvZCB0aHJvd3MgYW4gZXJyb3IsXG4gICAqIHRoaXMgd2lsbCBjYXRjaCBpdCBhbmQgbG9nIGl0IHRvIHRoZSBjb25zb2xlLlxuICAgKi9cbiAgaW5pdGlhbGl6ZSgpIHtcbiAgICB0cnkge1xuICAgICAgc3VwZXIuaW5pdGlhbGl6ZSgpLCB0aGlzLmlzVG9wTGV2ZWwgPyB0aGlzLmRvbS5tZW51LnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJtZW51YmFyXCIpIDogdGhpcy5kb20ubWVudS5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwibWVudVwiKSwgdGhpcy5faGFuZGxlRm9jdXMoKSwgdGhpcy5faGFuZGxlQ2xpY2soKSwgdGhpcy5faGFuZGxlSG92ZXIoKSwgdGhpcy5faGFuZGxlS2V5ZG93bigpLCB0aGlzLl9oYW5kbGVLZXl1cCgpLCB0aGlzLmlzVG9wTGV2ZWwgJiYgKHRoaXMuZWxlbWVudHMubWVudUl0ZW1zWzBdLmRvbS5saW5rLnRhYkluZGV4ID0gMCwgdGhpcy5lbGVtZW50cy5jb250cm9sbGVyICYmIHRoaXMuZWxlbWVudHMuY29udHJvbGxlci5kb20udG9nZ2xlLnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtaGFzcG9wdXBcIikpO1xuICAgIH0gY2F0Y2ggKHQpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IodCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBIYW5kbGVzIGNsaWNrIGV2ZW50cyB0aHJvdWdob3V0IHRoZSBtZW51IGZvciBwcm9wZXIgdXNlLlxuICAgKlxuICAgKiAtIEFkZHMgYWxsIGV2ZW50IGxpc3RlbmVycyBsaXN0ZWQgaW5cbiAgICogICBCYXNlTWVudSdzIF9oYW5kbGVDbGljayBtZXRob2QuXG4gICAqIC0gQWRkcyBhIGBwb2ludGVydXBgIGxpc3RlbmVyIHRvIHRoZSBgZG9jdW1lbnRgIHNvIGlmIHRoZSB1c2VyXG4gICAqICAgY2xpY2tzIG91dHNpZGUgb2YgdGhlIG1lbnUgaXQgd2lsbCBjbG9zZSBpZiBpdCBpcyBvcGVuLlxuICAgKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfaGFuZGxlQ2xpY2soKSB7XG4gICAgc3VwZXIuX2hhbmRsZUNsaWNrKCksIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgKHQpID0+IHtcbiAgICAgIHRoaXMuZm9jdXNTdGF0ZSAhPT0gXCJub25lXCIgJiYgKHRoaXMuY3VycmVudEV2ZW50ID0gXCJtb3VzZVwiLCAhdGhpcy5kb20ubWVudS5jb250YWlucyh0LnRhcmdldCkgJiYgIXRoaXMuZG9tLm1lbnUgIT09IHQudGFyZ2V0ICYmICh0aGlzLmNsb3NlQ2hpbGRyZW4oKSwgdGhpcy5ibHVyKCksIHRoaXMuZWxlbWVudHMuY29udHJvbGxlciAmJiB0aGlzLmVsZW1lbnRzLmNvbnRyb2xsZXIuY2xvc2UoKSwgdGhpcy5lbGVtZW50cy5yb290TWVudS5oYXNPcGVuZWQgPSAhMSkpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGVzIGtleWRvd24gZXZlbnRzIHRocm91Z2hvdXQgdGhlIG1lbnUgZm9yIHByb3BlciBtZW51IHVzZS5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgZXhpc3RzIHRvIGFzc2lzdCB0aGUgX2hhbmRsZUtleXVwIG1ldGhvZC5cbiAgICogLSBBZGRzIGFsbCBga2V5ZG93bmAgbGlzdGVuZXJzIGZyb20gQmFzZU1lbnUncyBfaGFuZGxlS2V5ZG93biBtZXRob2RcbiAgICogLSBBZGRzIGEgYGtleWRvd25gIGxpc3RlbmVyIHRvIHRoZSBtZW51L2FsbCBzdWJtZW51cy5cbiAgICogICAtIEJsb2NrcyBwcm9wYWdhdGlvbiBvbiB0aGUgZm9sbG93aW5nIGtleXM6IFwiQXJyb3dVcFwiLCBcIkFycm93UmlnaHRcIixcbiAgICogICAgIFwiQXJyb3dEb3duXCIsIFwiQXJyb3dMZWZ0XCIsIFwiSG9tZVwiLCBcIkVuZFwiLCBcIlNwYWNlXCIsIFwiRW50ZXJcIiwgXCJFc2NhcGVcIixcbiAgICogICAgIGFuZCBcIkFcIiB0aHJvdWdoIFwiWlwiLlxuICAgKiAgIC0gQ29tcGxldGVseSBjbG9zZXMgdGhlIG1lbnUgYW5kIG1vdmVzIGZvY3VzIG91dCBpZiB0aGUgXCJUYWJcIiBrZXkgaXMgcHJlc3NlZC5cbiAgICpcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX2hhbmRsZUtleWRvd24oKSB7XG4gICAgc3VwZXIuX2hhbmRsZUtleWRvd24oKSwgdGhpcy5kb20ubWVudS5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCAodCkgPT4ge1xuICAgICAgdGhpcy5jdXJyZW50RXZlbnQgPSBcImtleWJvYXJkXCI7XG4gICAgICBjb25zdCBzID0gXyh0KTtcbiAgICAgIGlmIChzID09PSBcIlRhYlwiICYmICh0aGlzLmVsZW1lbnRzLnJvb3RNZW51LmZvY3VzU3RhdGUgIT09IFwibm9uZVwiID8gKHRoaXMuZWxlbWVudHMucm9vdE1lbnUuYmx1cigpLCB0aGlzLmVsZW1lbnRzLnJvb3RNZW51LmNsb3NlQ2hpbGRyZW4oKSkgOiB0aGlzLmVsZW1lbnRzLnJvb3RNZW51LmZvY3VzKCkpLCBzID09PSBcIkNoYXJhY3RlclwiKVxuICAgICAgICBvKHQpO1xuICAgICAgZWxzZSBpZiAodGhpcy5pc1RvcExldmVsKSB7XG4gICAgICAgIGlmICh0aGlzLmZvY3VzU3RhdGUgPT09IFwic2VsZlwiKSB7XG4gICAgICAgICAgY29uc3QgbiA9IFtcbiAgICAgICAgICAgIFwiU3BhY2VcIixcbiAgICAgICAgICAgIFwiRW50ZXJcIixcbiAgICAgICAgICAgIFwiQXJyb3dSaWdodFwiLFxuICAgICAgICAgICAgXCJBcnJvd0xlZnRcIixcbiAgICAgICAgICAgIFwiSG9tZVwiLFxuICAgICAgICAgICAgXCJFbmRcIlxuICAgICAgICAgIF0sIGkgPSBbXCJBcnJvd0Rvd25cIiwgXCJBcnJvd1VwXCJdLCBsID0gW1wiRXNjYXBlXCJdO1xuICAgICAgICAgIChuLmluY2x1ZGVzKHMpIHx8IHRoaXMuY3VycmVudE1lbnVJdGVtLmlzU3VibWVudUl0ZW0gJiYgaS5pbmNsdWRlcyhzKSB8fCB0aGlzLmVsZW1lbnRzLmNvbnRyb2xsZXIgJiYgbC5pbmNsdWRlcyhzKSkgJiYgbyh0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlXG4gICAgICAgIFtcbiAgICAgICAgICBcIlNwYWNlXCIsXG4gICAgICAgICAgXCJFbnRlclwiLFxuICAgICAgICAgIFwiRXNjYXBlXCIsXG4gICAgICAgICAgXCJBcnJvd1JpZ2h0XCIsXG4gICAgICAgICAgXCJBcnJvd0xlZnRcIixcbiAgICAgICAgICBcIkFycm93RG93blwiLFxuICAgICAgICAgIFwiQXJyb3dVcFwiLFxuICAgICAgICAgIFwiSG9tZVwiLFxuICAgICAgICAgIFwiRW5kXCJcbiAgICAgICAgXS5pbmNsdWRlcyhzKSAmJiBvKHQpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGVzIGtleXVwIGV2ZW50cyB0aHJvdWdob3V0IHRoZSBtZW51IGZvciBwcm9wZXIgbWVudSB1c2UuXG4gICAqXG4gICAqIEFkZHMgYWxsIGBrZXl1cGAgbGlzdGVuZXJzIGZyb20gQmFzZU1lbnUncyBfaGFuZGxlS2V5dXAgbWV0aG9kLlxuICAgKlxuICAgKiBBZGRzIHRoZSBmb2xsb3dpbmcga2V5YmluZGluZ3MgKGV4cGxhbmF0aW9ucyBhcmUgdGFrZW4gZnJvbSB0aGVcbiAgICogTmF2aWdhdGlvbiBNZW51YmFyIEV4YW1wbGUpOlxuICAgKlxuICAgKiA8c3Ryb25nPk1lbnViYXI8L3N0cm9uZz5cbiAgICpcbiAgICogfCBLZXkgfCBGdW5jdGlvbiB8XG4gICAqIHwgLS0tIHwgLS0tIHxcbiAgICogfCBfU3BhY2VfIG9yIF9FbnRlcl8gfCBPcGVucyBzdWJtZW51IGFuZCBtb3ZlcyBmb2N1cyB0byBmaXJzdCBpdGVtIGluIHRoZSBzdWJtZW51LiB8XG4gICAqIHwgX1JpZ2h0IEFycm93XyB8IDx1bD48bGk+TW92ZXMgZm9jdXMgdG8gdGhlIG5leHQgaXRlbSBpbiB0aGUgbWVudWJhci48L2xpPjxsaT5JZiBmb2N1cyBpcyBvbiB0aGUgbGFzdCBpdGVtLCBtb3ZlcyBmb2N1cyB0byB0aGUgZmlyc3QgaXRlbS48L2xpPjwvdWw+IHxcbiAgICogfCBfTGVmdCBBcnJvd18gfCA8dWw+PGxpPk1vdmVzIGZvY3VzIHRvIHRoZSBwcmV2aW91cyBpdGVtIGluIHRoZSBtZW51YmFyLjwvbGk+PGxpPklmIGZvY3VzIGlzIG9uIHRoZSBmaXJzdCBpdGVtLCBtb3ZlcyBmb2N1cyB0byB0aGUgbGFzdCBpdGVtLjwvbGk+PC91bD4gfFxuICAgKiB8IF9Eb3duIEFycm93XyB8IE9wZW5zIHN1Ym1lbnUgYW5kIG1vdmVzIGZvY3VzIHRvIGZpcnN0IGl0ZW0gaW4gdGhlIHN1Ym1lbnUuIHxcbiAgICogfCBfVXAgQXJyb3dfIHwgT3BlbnMgc3VibWVudSBhbmQgbW92ZXMgZm9jdXMgdG8gbGFzdCBpdGVtIGluIHRoZSBzdWJtZW51LiB8XG4gICAqIHwgX0hvbWVfIHwgTW92ZXMgZm9jdXMgdG8gZmlyc3QgaXRlbSBpbiB0aGUgbWVudWJhci4gfFxuICAgKiB8IF9FbmRfIHwgTW92ZXMgZm9jdXMgdG8gbGFzdCBpdGVtIGluIHRoZSBtZW51YmFyLiB8XG4gICAqIHwgX0NoYXJhY3Rlcl8gfCA8dWw+PGxpPk1vdmVzIGZvY3VzIHRvIG5leHQgaXRlbSBpbiB0aGUgbWVudWJhciBoYXZpbmcgYSBuYW1lIHRoYXQgc3RhcnRzIHdpdGggdGhlIHR5cGVkIGNoYXJhY3Rlci48L2xpPjxsaT5JZiBub25lIG9mIHRoZSBpdGVtcyBoYXZlIGEgbmFtZSBzdGFydGluZyB3aXRoIHRoZSB0eXBlZCBjaGFyYWN0ZXIsIGZvY3VzIGRvZXMgbm90IG1vdmUuPC9saT48L3VsPiB8XG4gICAqXG4gICAqIDxzdHJvbmc+U3VibWVudTwvc3Ryb25nPlxuICAgKlxuICAgKiB8IEtleSB8IEZ1bmN0aW9uIHxcbiAgICogfCAtLS0gfCAtLS0gfFxuICAgKiB8IF9TcGFjZV8gb3IgX0VudGVyXyB8IDx1bD48bGk+QWN0aXZhdGVzIG1lbnUgaXRlbSwgY2F1c2luZyB0aGUgbGluayB0byBiZSBhY3RpdmF0ZWQuPC9saT48bGk+Tk9URTogdGhlIGxpbmtzIGdvIHRvIGR1bW15IHBhZ2VzOyB1c2UgdGhlIGJyb3dzZXIgZ28tYmFjayBmdW5jdGlvbiB0byByZXR1cm4gdG8gdGhpcyBtZW51YmFyIGV4YW1wbGUgcGFnZS48L2xpPjwvdWw+IHxcbiAgICogfCBfRXNjYXBlXyB8IDx1bD48bGk+Q2xvc2VzIHN1Ym1lbnUuPC9saT48bGk+TW92ZXMgZm9jdXMgdG8gcGFyZW50IG1lbnViYXIgaXRlbS48L2xpPjwvdWw+IHxcbiAgICogfCBfUmlnaHQgQXJyb3dfIHwgPHVsPjxsaT5JZiBmb2N1cyBpcyBvbiBhbiBpdGVtIHdpdGggYSBzdWJtZW51LCBvcGVucyB0aGUgc3VibWVudSBhbmQgcGxhY2VzIGZvY3VzIG9uIHRoZSBmaXJzdCBpdGVtLjwvbGk+PGxpPklmIGZvY3VzIGlzIG9uIGFuIGl0ZW0gdGhhdCBkb2VzIG5vdCBoYXZlIGEgc3VibWVudTo8dWw+PGxpPkNsb3NlcyBzdWJtZW51LjwvbGk+PGxpPk1vdmVzIGZvY3VzIHRvIG5leHQgaXRlbSBpbiB0aGUgbWVudWJhci48L2xpPjxsaT5PcGVucyBzdWJtZW51IG9mIG5ld2x5IGZvY3VzZWQgbWVudWJhciBpdGVtLCBrZWVwaW5nIGZvY3VzIG9uIHRoYXQgcGFyZW50IG1lbnViYXIgaXRlbS48L2xpPjwvdWw+PC9saT48L3VsPiB8XG4gICAqIHwgX0xlZnQgQXJyb3dfIHwgPHVsPjxsaT5DbG9zZXMgc3VibWVudSBhbmQgbW92ZXMgZm9jdXMgdG8gcGFyZW50IG1lbnUgaXRlbS48L2xpPjxsaT5JZiBwYXJlbnQgbWVudSBpdGVtIGlzIGluIHRoZSBtZW51YmFyLCBhbHNvOjx1bD48bGk+bW92ZXMgZm9jdXMgdG8gcHJldmlvdXMgaXRlbSBpbiB0aGUgbWVudWJhci48L2xpPjxsaT5PcGVucyBzdWJtZW51IG9mIG5ld2x5IGZvY3VzZWQgbWVudWJhciBpdGVtLCBrZWVwaW5nIGZvY3VzIG9uIHRoYXQgcGFyZW50IG1lbnViYXIgaXRlbS48L2xpPjwvdWw+PC9saT48L3VsPiB8XG4gICAqIHwgX0Rvd24gQXJyb3dfIHwgPHVsPjxsaT5Nb3ZlcyBmb2N1cyB0byB0aGUgbmV4dCBpdGVtIGluIHRoZSBzdWJtZW51LjwvbGk+PGxpPklmIGZvY3VzIGlzIG9uIHRoZSBsYXN0IGl0ZW0sIG1vdmVzIGZvY3VzIHRvIHRoZSBmaXJzdCBpdGVtLjwvbGk+PC91bD4gfFxuICAgKiB8IF9VcCBBcnJvd18gfCA8dWw+PGxpPk1vdmVzIGZvY3VzIHRvIHByZXZpb3VzIGl0ZW0gaW4gdGhlIHN1Ym1lbnUuPC9saT48bGk+SWYgZm9jdXMgaXMgb24gdGhlIGZpcnN0IGl0ZW0sIG1vdmVzIGZvY3VzIHRvIHRoZSBsYXN0IGl0ZW0uPC9saT48L3VsPiB8XG4gICAqIHwgSG9tZSB8IE1vdmVzIGZvY3VzIHRvIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBzdWJtZW51LiB8XG4gICAqIHwgRW5kIHwgTW92ZXMgZm9jdXMgdG8gdGhlIGxhc3QgaXRlbSBpbiB0aGUgc3VibWVudS4gfFxuICAgKiB8IF9DaGFyYWN0ZXJfIHwgPHVsPjxsaT5Nb3ZlcyBmb2N1cyB0byB0aGUgbmV4dCBpdGVtIGhhdmluZyBhIG5hbWUgdGhhdCBzdGFydHMgd2l0aCB0aGUgdHlwZWQgY2hhcmFjdGVyLjwvbGk+PGxpPklmIG5vbmUgb2YgdGhlIGl0ZW1zIGhhdmUgYSBuYW1lIHN0YXJ0aW5nIHdpdGggdGhlIHR5cGVkIGNoYXJhY3RlciwgZm9jdXMgZG9lcyBub3QgbW92ZS48L2xpPjwvdWw+IHxcbiAgICpcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX2hhbmRsZUtleXVwKCkge1xuICAgIHN1cGVyLl9oYW5kbGVLZXl1cCgpLCB0aGlzLmRvbS5tZW51LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXl1cFwiLCAodCkgPT4ge1xuICAgICAgdGhpcy5jdXJyZW50RXZlbnQgPSBcImtleWJvYXJkXCI7XG4gICAgICBjb25zdCBzID0gXyh0KSwgeyBhbHRLZXk6IG4sIGNydGxLZXk6IGksIG1ldGFLZXk6IGwgfSA9IHQ7XG4gICAgICBpZiAocyA9PT0gXCJDaGFyYWN0ZXJcIiAmJiAhKG4gfHwgaSB8fCBsKSlcbiAgICAgICAgbyh0KSwgdGhpcy5lbGVtZW50cy5yb290TWVudS5jdXJyZW50RXZlbnQgPSBcImNoYXJhY3RlclwiLCB0aGlzLmZvY3VzTmV4dENoaWxkV2l0aENoYXJhY3Rlcih0LmtleSk7XG4gICAgICBlbHNlIGlmICh0aGlzLmlzVG9wTGV2ZWwpIHtcbiAgICAgICAgaWYgKHRoaXMuZm9jdXNTdGF0ZSA9PT0gXCJzZWxmXCIpXG4gICAgICAgICAgaWYgKHMgPT09IFwiU3BhY2VcIiB8fCBzID09PSBcIkVudGVyXCIpXG4gICAgICAgICAgICBvKHQpLCB0aGlzLmN1cnJlbnRNZW51SXRlbS5pc1N1Ym1lbnVJdGVtID8gKHRoaXMuY3VycmVudE1lbnVJdGVtLmVsZW1lbnRzLmNoaWxkTWVudS5jdXJyZW50RXZlbnQgPSBcImtleWJvYXJkXCIsIHRoaXMuY3VycmVudE1lbnVJdGVtLmVsZW1lbnRzLnRvZ2dsZS5vcGVuKCksIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuY3VycmVudE1lbnVJdGVtLmVsZW1lbnRzLmNoaWxkTWVudS5mb2N1c0ZpcnN0Q2hpbGQoKTtcbiAgICAgICAgICAgIH0pKSA6IHRoaXMuY3VycmVudE1lbnVJdGVtLmRvbS5saW5rLmNsaWNrKCk7XG4gICAgICAgICAgZWxzZSBpZiAocyA9PT0gXCJBcnJvd1JpZ2h0XCIpIHtcbiAgICAgICAgICAgIG8odCk7XG4gICAgICAgICAgICBjb25zdCBtID0gdGhpcy5jdXJyZW50TWVudUl0ZW0uaXNTdWJtZW51SXRlbSAmJiB0aGlzLmN1cnJlbnRNZW51SXRlbS5lbGVtZW50cy50b2dnbGUuaXNPcGVuO1xuICAgICAgICAgICAgdGhpcy5mb2N1c05leHRDaGlsZCgpLCBtICYmICh0aGlzLmN1cnJlbnRNZW51SXRlbS5pc1N1Ym1lbnVJdGVtID8gKHRoaXMuY3VycmVudE1lbnVJdGVtLmVsZW1lbnRzLmNoaWxkTWVudS5jdXJyZW50RXZlbnQgPSBcImtleWJvYXJkXCIsIHRoaXMuY3VycmVudE1lbnVJdGVtLmVsZW1lbnRzLnRvZ2dsZS5wcmV2aWV3KCkpIDogdGhpcy5jbG9zZUNoaWxkcmVuKCkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocyA9PT0gXCJBcnJvd0xlZnRcIikge1xuICAgICAgICAgICAgbyh0KTtcbiAgICAgICAgICAgIGNvbnN0IG0gPSB0aGlzLmN1cnJlbnRNZW51SXRlbS5pc1N1Ym1lbnVJdGVtICYmIHRoaXMuY3VycmVudE1lbnVJdGVtLmVsZW1lbnRzLnRvZ2dsZS5pc09wZW47XG4gICAgICAgICAgICB0aGlzLmZvY3VzUHJldmlvdXNDaGlsZCgpLCBtICYmICh0aGlzLmN1cnJlbnRNZW51SXRlbS5pc1N1Ym1lbnVJdGVtID8gKHRoaXMuY3VycmVudE1lbnVJdGVtLmVsZW1lbnRzLmNoaWxkTWVudS5jdXJyZW50RXZlbnQgPSBcImtleWJvYXJkXCIsIHRoaXMuY3VycmVudE1lbnVJdGVtLmVsZW1lbnRzLnRvZ2dsZS5wcmV2aWV3KCkpIDogdGhpcy5jbG9zZUNoaWxkcmVuKCkpO1xuICAgICAgICAgIH0gZWxzZSBzID09PSBcIkFycm93RG93blwiID8gdGhpcy5jdXJyZW50TWVudUl0ZW0uaXNTdWJtZW51SXRlbSAmJiAobyh0KSwgdGhpcy5jdXJyZW50TWVudUl0ZW0uZWxlbWVudHMuY2hpbGRNZW51LmN1cnJlbnRFdmVudCA9IFwia2V5Ym9hcmRcIiwgdGhpcy5jdXJyZW50TWVudUl0ZW0uZWxlbWVudHMudG9nZ2xlLm9wZW4oKSwgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudE1lbnVJdGVtLmVsZW1lbnRzLmNoaWxkTWVudS5mb2N1c0ZpcnN0Q2hpbGQoKTtcbiAgICAgICAgICB9KSkgOiBzID09PSBcIkFycm93VXBcIiA/IHRoaXMuY3VycmVudE1lbnVJdGVtLmlzU3VibWVudUl0ZW0gJiYgKG8odCksIHRoaXMuY3VycmVudE1lbnVJdGVtLmVsZW1lbnRzLmNoaWxkTWVudS5jdXJyZW50RXZlbnQgPSBcImtleWJvYXJkXCIsIHRoaXMuY3VycmVudE1lbnVJdGVtLmVsZW1lbnRzLnRvZ2dsZS5vcGVuKCksIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRNZW51SXRlbS5lbGVtZW50cy5jaGlsZE1lbnUuZm9jdXNMYXN0Q2hpbGQoKTtcbiAgICAgICAgICB9KSkgOiBzID09PSBcIkhvbWVcIiA/IChvKHQpLCB0aGlzLmZvY3VzRmlyc3RDaGlsZCgpKSA6IHMgPT09IFwiRW5kXCIgPyAobyh0KSwgdGhpcy5mb2N1c0xhc3RDaGlsZCgpKSA6IHMgPT09IFwiRXNjYXBlXCIgJiYgKHRoaXMuZWxlbWVudHMuc3VibWVudVRvZ2dsZXMuc29tZShcbiAgICAgICAgICAgIChhKSA9PiBhLmlzT3BlblxuICAgICAgICAgICkgPyAobyh0KSwgdGhpcy5jbG9zZUNoaWxkcmVuKCkpIDogdGhpcy5pc1RvcExldmVsICYmIHRoaXMuZWxlbWVudHMuY29udHJvbGxlciAmJiB0aGlzLmVsZW1lbnRzLmNvbnRyb2xsZXIuaXNPcGVuICYmIChvKHQpLCB0aGlzLmVsZW1lbnRzLmNvbnRyb2xsZXIuY2xvc2UoKSwgdGhpcy5mb2N1c0NvbnRyb2xsZXIoKSkpO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHMgPT09IFwiU3BhY2VcIiB8fCBzID09PSBcIkVudGVyXCIgPyAobyh0KSwgdGhpcy5jdXJyZW50TWVudUl0ZW0uaXNTdWJtZW51SXRlbSA/ICh0aGlzLmN1cnJlbnRNZW51SXRlbS5lbGVtZW50cy5jaGlsZE1lbnUuY3VycmVudEV2ZW50ID0gXCJrZXlib2FyZFwiLCB0aGlzLmN1cnJlbnRNZW51SXRlbS5lbGVtZW50cy50b2dnbGUub3BlbigpLCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuY3VycmVudE1lbnVJdGVtLmVsZW1lbnRzLmNoaWxkTWVudS5mb2N1c0ZpcnN0Q2hpbGQoKTtcbiAgICAgICAgfSkpIDogdGhpcy5jdXJyZW50TWVudUl0ZW0uZG9tLmxpbmsuY2xpY2soKSkgOiBzID09PSBcIkVzY2FwZVwiID8gKG8odCksIHRoaXMuZWxlbWVudHMucm9vdE1lbnUuY2xvc2VDaGlsZHJlbigpLCB0aGlzLmVsZW1lbnRzLnJvb3RNZW51LmZvY3VzQ3VycmVudENoaWxkKCkpIDogcyA9PT0gXCJBcnJvd1JpZ2h0XCIgPyB0aGlzLmN1cnJlbnRNZW51SXRlbS5pc1N1Ym1lbnVJdGVtID8gKG8odCksIHRoaXMuY3VycmVudE1lbnVJdGVtLmVsZW1lbnRzLmNoaWxkTWVudS5jdXJyZW50RXZlbnQgPSBcImtleWJvYXJkXCIsIHRoaXMuY3VycmVudE1lbnVJdGVtLmVsZW1lbnRzLnRvZ2dsZS5vcGVuKCksIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5jdXJyZW50TWVudUl0ZW0uZWxlbWVudHMuY2hpbGRNZW51LmZvY3VzRmlyc3RDaGlsZCgpO1xuICAgICAgICB9KSkgOiAobyh0KSwgdGhpcy5lbGVtZW50cy5yb290TWVudS5jbG9zZUNoaWxkcmVuKCksIHRoaXMuZWxlbWVudHMucm9vdE1lbnUuZm9jdXNOZXh0Q2hpbGQoKSwgdGhpcy5lbGVtZW50cy5yb290TWVudS5jdXJyZW50TWVudUl0ZW0uaXNTdWJtZW51SXRlbSAmJiB0aGlzLmVsZW1lbnRzLnJvb3RNZW51LmN1cnJlbnRNZW51SXRlbS5lbGVtZW50cy50b2dnbGUucHJldmlldygpKSA6IHMgPT09IFwiQXJyb3dMZWZ0XCIgPyB0aGlzLmVsZW1lbnRzLnBhcmVudE1lbnUuY3VycmVudE1lbnVJdGVtLmlzU3VibWVudUl0ZW0gJiYgKG8odCksIHRoaXMuZWxlbWVudHMucGFyZW50TWVudS5jdXJyZW50TWVudUl0ZW0uZWxlbWVudHMudG9nZ2xlLmNsb3NlKCksIHRoaXMuZWxlbWVudHMucGFyZW50TWVudS5mb2N1c0N1cnJlbnRDaGlsZCgpLCB0aGlzLmVsZW1lbnRzLnBhcmVudE1lbnUgPT09IHRoaXMuZWxlbWVudHMucm9vdE1lbnUgJiYgKHRoaXMuZWxlbWVudHMucm9vdE1lbnUuY2xvc2VDaGlsZHJlbigpLCB0aGlzLmVsZW1lbnRzLnJvb3RNZW51LmZvY3VzUHJldmlvdXNDaGlsZCgpLCB0aGlzLmVsZW1lbnRzLnJvb3RNZW51LmN1cnJlbnRNZW51SXRlbS5pc1N1Ym1lbnVJdGVtICYmICh0aGlzLmVsZW1lbnRzLnJvb3RNZW51LmN1cnJlbnRNZW51SXRlbS5lbGVtZW50cy5jaGlsZE1lbnUuY3VycmVudEV2ZW50ID0gXCJrZXlib2FyZFwiLCB0aGlzLmVsZW1lbnRzLnJvb3RNZW51LmN1cnJlbnRNZW51SXRlbS5lbGVtZW50cy50b2dnbGUucHJldmlldygpKSkpIDogcyA9PT0gXCJBcnJvd0Rvd25cIiA/IChvKHQpLCB0aGlzLmZvY3VzTmV4dENoaWxkKCkpIDogcyA9PT0gXCJBcnJvd1VwXCIgPyAobyh0KSwgdGhpcy5mb2N1c1ByZXZpb3VzQ2hpbGQoKSkgOiBzID09PSBcIkhvbWVcIiA/IChvKHQpLCB0aGlzLmZvY3VzRmlyc3RDaGlsZCgpKSA6IHMgPT09IFwiRW5kXCIgJiYgKG8odCksIHRoaXMuZm9jdXNMYXN0Q2hpbGQoKSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEZvY3VzIHRoZSBtZW51J3MgbmV4dCBjaGlsZC5cbiAgICpcbiAgICogSWYgdGhlIGN1cnJlbnRseSBmb2N1c3NlZCBjaGlsZCBpbiB0aGUgbWVudSBpcyB0aGUgbGFzdCBjaGlsZCB0aGVuIHRoaXMgd2lsbFxuICAgKiBmb2N1cyB0aGUgZmlyc3QgY2hpbGQgaW4gdGhlIG1lbnUuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGZvY3VzTmV4dENoaWxkKCkge1xuICAgIHRoaXMuY3VycmVudENoaWxkID09PSB0aGlzLmVsZW1lbnRzLm1lbnVJdGVtcy5sZW5ndGggLSAxID8gdGhpcy5mb2N1c0ZpcnN0Q2hpbGQoKSA6IHRoaXMuZm9jdXNDaGlsZCh0aGlzLmN1cnJlbnRDaGlsZCArIDEpO1xuICB9XG4gIC8qKlxuICAgKiBGb2N1cyB0aGUgbWVudSdzIHByZXZpb3VzIGNoaWxkLlxuICAgKlxuICAgKiBJZiB0aGUgY3VycmVudGx5IGZvY3Vzc2VkIGNoaWxkIGluIHRoZSBtZW51IGlzIHRoZSBmaXJzdCBjaGlsZCB0aGVuIHRoaXMgd2lsbFxuICAgKiBmb2N1cyB0aGUgbGFzdCBjaGlsZCBpbiB0aGUgbWVudS5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZm9jdXNQcmV2aW91c0NoaWxkKCkge1xuICAgIHRoaXMuY3VycmVudENoaWxkID09PSAwID8gdGhpcy5mb2N1c0xhc3RDaGlsZCgpIDogdGhpcy5mb2N1c0NoaWxkKHRoaXMuY3VycmVudENoaWxkIC0gMSk7XG4gIH1cbiAgLyoqXG4gICAqIEZvY3VzIHRoZSBtZW51J3MgbmV4dCBjaGlsZCBzdGFydGluZyB3aXRoIGEgc3BlY2lmaWMgbGV0dGVyLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFyIC0gVGhlIGNoYXJhY3RlciB0byBsb29rIGZvci5cbiAgICovXG4gIGZvY3VzTmV4dENoaWxkV2l0aENoYXJhY3Rlcih0KSB7XG4gICAgY29uc3QgcyA9IHQudG9Mb3dlckNhc2UoKTtcbiAgICBsZXQgbiA9IHRoaXMuY3VycmVudENoaWxkICsgMSwgaSA9ICExO1xuICAgIGZvciAoOyAhaSAmJiBuIDwgdGhpcy5lbGVtZW50cy5tZW51SXRlbXMubGVuZ3RoOyApIHtcbiAgICAgIGxldCBsID0gXCJcIjtcbiAgICAgIHRoaXMuZWxlbWVudHMubWVudUl0ZW1zW25dLmRvbS5pdGVtLmlubmVyVGV4dCA/IGwgPSB0aGlzLmVsZW1lbnRzLm1lbnVJdGVtc1tuXS5kb20uaXRlbS5pbm5lclRleHQgOiBsID0gdGhpcy5lbGVtZW50cy5tZW51SXRlbXNbbl0uZG9tLml0ZW0udGV4dENvbnRlbnQsIGwgPSBsLnJlcGxhY2UoL1tcXHNdL2csIFwiXCIpLnRvTG93ZXJDYXNlKCkuY2hhckF0KDApLCBsID09PSBzICYmIChpID0gITAsIHRoaXMuZm9jdXNDaGlsZChuKSksIG4rKztcbiAgICB9XG4gIH1cbn1cbmNsYXNzIEogZXh0ZW5kcyBPIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgYFRvcExpbmtEaXNjbG9zdXJlTWVudUl0ZW1gLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMgICAgICAgICAgICAgICAgICAgICAgICAgLSBUaGUgb3B0aW9ucyBmb3IgZ2VuZXJhdGluZyB0aGUgbWVudSBpdGVtLlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSAgICAgICAgICAgICAgICAgIG9wdGlvbnMubWVudUl0ZW1FbGVtZW50ICAgICAgICAgLSBUaGUgbWVudSBpdGVtIGluIHRoZSBET00uXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9ICAgICAgICAgICAgICAgICAgb3B0aW9ucy5tZW51TGlua0VsZW1lbnQgICAgICAgICAtIFRoZSBtZW51IGl0ZW0ncyBsaW5rIGluIHRoZSBET00uXG4gICAqIEBwYXJhbSB7VG9wTGlua0Rpc2Nsb3N1cmVNZW51fSAgICAgICAgb3B0aW9ucy5wYXJlbnRNZW51ICAgICAgICAgICAgICAtIFRoZSBwYXJlbnQgbWVudS5cbiAgICogQHBhcmFtIHtib29sZWFufSAgICAgICAgICAgICAgICAgICAgICBbb3B0aW9ucy5pc1N1Ym1lbnVJdGVtID0gZmFsc2VdIC0gQSBmbGFnIHRvIG1hcmsgaWYgdGhlIG1lbnUgaXRlbSBpcyBjb250cm9sbGluZyBhIHN1Ym1lbnUuXG4gICAqIEBwYXJhbSB7P1RvcExpbmtEaXNjbG9zdXJlTWVudX0gICAgICAgW29wdGlvbnMuY2hpbGRNZW51ID0gbnVsbF0gICAgICAtIFRoZSBjaGlsZCBtZW51LlxuICAgKiBAcGFyYW0gez9Ub3BMaW5rRGlzY2xvc3VyZU1lbnVUb2dnbGV9IFtvcHRpb25zLnRvZ2dsZSA9IG51bGxdICAgICAgICAgLSBUaGUgY29udHJvbGxlciBmb3IgdGhlIGNoaWxkIG1lbnUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgICAgICAgICAgICAgICAgICAgW29wdGlvbnMuaW5pdGlhbGl6ZSA9IHRydWVdICAgICAtIEEgZmxhZyB0byBpbml0aWFsaXplIHRoZSBtZW51IGl0ZW0gaW1tZWRpYXRlbHkgdXBvbiBjcmVhdGlvbi5cbiAgICogQHBhcmFtIHs/VG9wTGlua0Rpc2Nsb3N1cmVNZW51SXRlbX0gICBbb3B0aW9ucy5zdWJtZW51U2libGluZyA9IG51bGxdIC0gVGhlIHNpYmxpbmcgbWVudSBpdGVtIHRoYXQgY29udHJvbHMgYSBzdWJtZW51LlxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIG1lbnVJdGVtRWxlbWVudDogdCxcbiAgICBtZW51TGlua0VsZW1lbnQ6IHMsXG4gICAgcGFyZW50TWVudTogbixcbiAgICBpc1N1Ym1lbnVJdGVtOiBpID0gITEsXG4gICAgY2hpbGRNZW51OiBsID0gbnVsbCxcbiAgICB0b2dnbGU6IGggPSBudWxsLFxuICAgIGluaXRpYWxpemU6IG0gPSAhMCxcbiAgICBzdWJtZW51U2libGluZzogYSA9IG51bGxcbiAgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIG1lbnVJdGVtRWxlbWVudDogdCxcbiAgICAgIG1lbnVMaW5rRWxlbWVudDogcyxcbiAgICAgIHBhcmVudE1lbnU6IG4sXG4gICAgICBpc1N1Ym1lbnVJdGVtOiBpLFxuICAgICAgY2hpbGRNZW51OiBsLFxuICAgICAgdG9nZ2xlOiBoXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogVGhlIGRlY2xhcmVkIGFjY2Vzc2libGUtbWVudSBlbGVtZW50cyB3aXRoaW4gdGhlIG1lbnUgaXRlbS5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtPYmplY3Q8VG9wTGlua0Rpc2Nsb3N1cmVNZW51LCBUb3BMaW5rRGlzY2xvc3VyZU1lbnVUb2dnbGU+fVxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHtUb3BMaW5rRGlzY2xvc3VyZU1lbnV9ICAgICAgICAgICAgICAgICAgIHBhcmVudE1lbnUgLSBUaGUgbWVudSBjb250YWluaW5nIHRoaXMgbWVudSBpdGVtLlxuICAgICAqIEBwcm9wZXJ0eSB7P1RvcExpbmtEaXNjbG9zdXJlTWVudX0gICAgICAgICAgICAgICAgICBjaGlsZE1lbnUgIC0gVGhlIG1lbnUgY29udGFpbmVkIHdpdGhpbiB0aGlzIG1lbnUgaXRlbS5cbiAgICAgKiBAcHJvcGVydHkgez9Ub3BMaW5rRGlzY2xvc3VyZU1lbnVUb2dnbGV9ICAgICAgICAgICAgdG9nZ2xlICAgICAtIFRoZSBtZW51IHRvZ2dsZSB3aXRoaW4gdGhpcyBtZW51IGl0ZW0gdGhhdCBjb250cm9scyB0aGUgYGNoaWxkTWVudWAuXG4gICAgICogQHByb3BlcnR5IHs/VG9wTGlua0Rpc2Nsb3N1cmVNZW51SXRlbX0gICAgICAgICAgICAgIHNpYmxpbmcgICAgLSBUaGUgc2libGluZyBtZW51IGl0ZW0gdGhhdCBpcyBhIHN1Ym1lbnUgaXRlbS5cbiAgICAgKi9cbiAgICB1KHRoaXMsIFwiX2VsZW1lbnRzXCIsIHtcbiAgICAgIHBhcmVudE1lbnU6IG51bGwsXG4gICAgICBjaGlsZE1lbnU6IG51bGwsXG4gICAgICB0b2dnbGU6IG51bGwsXG4gICAgICBzaWJsaW5nOiBudWxsXG4gICAgfSk7XG4gICAgdGhpcy5fZWxlbWVudHMucGFyZW50TWVudSA9IG4sIHRoaXMuX2VsZW1lbnRzLmNoaWxkTWVudSA9IGwsIHRoaXMuX2VsZW1lbnRzLnRvZ2dsZSA9IGgsIHRoaXMuX2VsZW1lbnRzLnNpYmxpbmcgPSBhLCBtICYmIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICB9XG59XG5jbGFzcyBYIGV4dGVuZHMgTCB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGBUb3BMaW5rRGlzY2xvc3VyZU1lbnVUb2dnbGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gICAgICAgICAgICAgICAgIG9wdGlvbnMgICAgICAgICAgICAgICAgICAgICAtIFRoZSBvcHRpb25zIGZvciBnZW5lcmF0aW5nIHRoZSBtZW51IHRvZ2dsZS5cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gICAgICAgICAgICBvcHRpb25zLm1lbnVUb2dnbGVFbGVtZW50ICAgLSBUaGUgdG9nZ2xlIGVsZW1lbnQgaW4gdGhlIERPTS5cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gICAgICAgICAgICBvcHRpb25zLnBhcmVudEVsZW1lbnQgICAgICAgLSBUaGUgZWxlbWVudCBjb250YWluaW5nIHRoZSBjb250cm9sbGVkIG1lbnUuXG4gICAqIEBwYXJhbSB7VG9wTGlua0Rpc2Nsb3N1cmVNZW51fSAgb3B0aW9ucy5jb250cm9sbGVkTWVudSAgICAgIC0gVGhlIG1lbnUgY29udHJvbGxlZCBieSB0aGlzIHRvZ2dsZS5cbiAgICogQHBhcmFtIHs/VG9wTGlua0Rpc2Nsb3N1cmVNZW51fSBbb3B0aW9ucy5wYXJlbnRNZW51ID0gbnVsbF0gLSBUaGUgbWVudSBjb250YWluaW5nIHRoaXMgdG9nZ2xlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICAgICAgICAgICAgIFtvcHRpb25zLmluaXRpYWxpemUgPSB0cnVlXSAtIEEgZmxhZyB0byBpbml0aWFsaXplIHRoZSBtZW51IHRvZ2dsZSBpbW1lZGlhdGVseSB1cG9uIGNyZWF0aW9uLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioe1xuICAgIG1lbnVUb2dnbGVFbGVtZW50OiBlLFxuICAgIHBhcmVudEVsZW1lbnQ6IHQsXG4gICAgY29udHJvbGxlZE1lbnU6IHMsXG4gICAgcGFyZW50TWVudTogbiA9IG51bGwsXG4gICAgaW5pdGlhbGl6ZTogaSA9ICEwXG4gIH0pIHtcbiAgICBzdXBlcih7XG4gICAgICBtZW51VG9nZ2xlRWxlbWVudDogZSxcbiAgICAgIHBhcmVudEVsZW1lbnQ6IHQsXG4gICAgICBjb250cm9sbGVkTWVudTogcyxcbiAgICAgIHBhcmVudE1lbnU6IG5cbiAgICB9KSwgaSAmJiB0aGlzLmluaXRpYWxpemUoKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgQVJJQSBhdHRyaWJ1dGVzIG9uIHRoZSB0b2dnbGUgYW5kIGNvbnRyb2xsZWQgbWVudS5cbiAgICpcbiAgICogQ2FsbHMgdGhlIEJhc2VNZW51VG9nZ2xlJ3MgX3NldEFyaWFBdHRyaWJ1dGVzIG1ldGhvZC5cbiAgICpcbiAgICogRW5zdXJlcyB0aGUgdG9nZ2xlIGVsZW1lbnQgaGFzIGEgYHJvbGVgIG9mIFwiYnV0dG9uXCIgaWYgaXQgaXMgbm90XG4gICAqIGFscmVhZHkgYSBidXR0b24uXG4gICAqXG4gICAqIFRoZW4gdXNpbmcgdGhlIHRvZ2dsZSBhbmQgbWVudSdzIElEcywgdGhlIHRvZ2dsZSdzIGBhcmlhLWNvbnRyb2xzYFxuICAgKiBpcyBzZXQgdG8gdGhlIG1lbnUncyBJRC5cbiAgICpcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX3NldEFyaWFBdHRyaWJ1dGVzKCkge1xuICAgIHN1cGVyLl9zZXRBcmlhQXR0cmlidXRlcygpLCBGKFwiYnV0dG9uXCIsIHsgdG9nZ2xlOiB0aGlzLmRvbS50b2dnbGUgfSkgfHwgdGhpcy5kb20udG9nZ2xlLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJidXR0b25cIiksIHRoaXMuZG9tLnRvZ2dsZS5zZXRBdHRyaWJ1dGUoXG4gICAgICBcImFyaWEtY29udHJvbHNcIixcbiAgICAgIHRoaXMuZWxlbWVudHMuY29udHJvbGxlZE1lbnUuZG9tLm1lbnUuaWRcbiAgICApO1xuICB9XG4gIC8qKlxuICAgKiBPcGVucyB0aGUgY29udHJvbGxlZCBtZW51LlxuICAgKlxuICAgKiBDYWxscyB0aGUgIGNsb3NlU2libGluZ3MgbWV0aG9kXG4gICAqIGFuZCBfdGhlbl8gQmFzZU1lbnVUb2dnbGUncyBvcGVuIG1ldGhvZC5cbiAgICovXG4gIG9wZW4oKSB7XG4gICAgdGhpcy5jbG9zZVNpYmxpbmdzKCksIHN1cGVyLm9wZW4oKTtcbiAgfVxuICAvKipcbiAgICogT3BlbnMgdGhlIGNvbnRyb2xsZWQgbWVudSB3aXRob3V0IHRoZSBjdXJyZW50IGZvY3VzIGVudGVyaW5nIGl0LlxuICAgKlxuICAgKiBDYWxscyB0aGUgIGNsb3NlU2libGluZ3MgbWV0aG9kXG4gICAqIGFuZCBfdGhlbl8gQmFzZU1lbnVUb2dnbGUncyBwcmV2aWV3IG1ldGhvZC5cbiAgICovXG4gIHByZXZpZXcoKSB7XG4gICAgdGhpcy5jbG9zZVNpYmxpbmdzKCksIHN1cGVyLnByZXZpZXcoKTtcbiAgfVxuICAvKipcbiAgICogQ2xvc2VzIHRoZSBjb250cm9sbGVkIG1lbnUuXG4gICAqXG4gICAqIENhbGxzIHRoZSAgY2xvc2VDaGlsZHJlbiBtZXRob2RcbiAgICogYW5kIF90aGVuXyBCYXNlTWVudVRvZ2dsZSdzIGNsb3NlIG1ldGhvZC5cbiAgICovXG4gIGNsb3NlKCkge1xuICAgIHRoaXMuaXNPcGVuICYmIHRoaXMuY2xvc2VDaGlsZHJlbigpLCBzdXBlci5jbG9zZSgpO1xuICB9XG59XG5jbGFzcyBxIGV4dGVuZHMgdyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGBUb3BMaW5rRGlzY2xvc3VyZU1lbnVgLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gICAgICAgICAgICAgICAgIG9wdGlvbnMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIFRoZSBvcHRpb25zIGZvciBnZW5lcmF0aW5nIHRoZSBtZW51LlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSAgICAgICAgICAgIG9wdGlvbnMubWVudUVsZW1lbnQgICAgICAgICAgICAgICAgICAgICAgICAtIFRoZSBtZW51IGVsZW1lbnQgaW4gdGhlIERPTS5cbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgICAgICBbb3B0aW9ucy5tZW51SXRlbVNlbGVjdG9yID0gbGldICAgICAgICAgICAgLSBUaGUgcXVlcnkgc2VsZWN0b3Igc3RyaW5nIGZvciBtZW51IGl0ZW1zLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgICAgIFtvcHRpb25zLm1lbnVMaW5rU2VsZWN0b3IgPSBhXSAgICAgICAgICAgICAtIFRoZSBxdWVyeSBzZWxlY3RvciBzdHJpbmcgZm9yIG1lbnUgbGlua3MuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgICAgW29wdGlvbnMuc3VibWVudUl0ZW1TZWxlY3RvciA9IGxpOmhhcyh1bCldIC0gVGhlIHF1ZXJ5IHNlbGVjdG9yIHN0cmluZyBmb3IgbWVudSBpdGVtcyBjb250YWluaW5nIHN1Ym1lbnVzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgICAgIFtvcHRpb25zLnN1Ym1lbnVUb2dnbGVTZWxlY3RvciA9IGJ1dHRvbl0gICAtIFRoZSBxdWVyeSBzZWxlY3RvciBzdHJpbmcgZm9yIHN1Ym1lbnUgdG9nZ2xlIGJ1dHRvbnMvbGlua3MuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgICAgW29wdGlvbnMuc3VibWVudVNlbGVjdG9yID0gdWxdICAgICAgICAgICAgIC0gVGhlIHF1ZXJ5IHNlbGVjdG9yIHN0cmluZyBmb3Igc3VibWVudXMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICAgICAgW29wdGlvbnMuc3VibWVudVN1YnRvZ2dsZVNlbGVjdG9yID0gYV0gICAgIC0gVGhlIHF1ZXJ5IHNlbGVjdG9yIHN0cmluZyBmb3Igc3VibWVudSB0b2dnbGUgYnV0dG9ucy9saW5rcyBiZWxvdyB0aGUgdG9wIGxldmVsLlxuICAgKiBAcGFyYW0gez9IVE1MRWxlbWVudH0gICAgICAgICAgIFtvcHRpb25zLmNvbnRyb2xsZXJFbGVtZW50ID0gbnVsbF0gICAgICAgICAtIFRoZSBlbGVtZW50IGNvbnRyb2xsaW5nIHRoZSBtZW51IGluIHRoZSBET00uXG4gICAqIEBwYXJhbSB7P0hUTUxFbGVtZW50fSAgICAgICAgICAgW29wdGlvbnMuY29udGFpbmVyRWxlbWVudCA9IG51bGxdICAgICAgICAgIC0gVGhlIGVsZW1lbnQgY29udGFpbmluZyB0aGUgbWVudSBpbiB0aGUgRE9NLlxuICAgKiBAcGFyYW0gez8oc3RyaW5nfHN0cmluZ1tdKX0gICAgIFtvcHRpb25zLm9wZW5DbGFzcyA9IHNob3ddICAgICAgICAgICAgICAgICAtIFRoZSBjbGFzcyB0byBhcHBseSB3aGVuIGEgbWVudSBpcyBcIm9wZW5cIi5cbiAgICogQHBhcmFtIHs/KHN0cmluZ3xzdHJpbmdbXSl9ICAgICBbb3B0aW9ucy5jbG9zZUNsYXNzID0gaGlkZV0gICAgICAgICAgICAgICAgLSBUaGUgY2xhc3MgdG8gYXBwbHkgd2hlbiBhIG1lbnUgaXMgXCJjbG9zZWRcIi5cbiAgICogQHBhcmFtIHs/KHN0cmluZ3xzdHJpbmdbXSl9ICAgICBbb3B0aW9ucy50cmFuc2l0aW9uQ2xhc3MgPSB0cmFuc2l0aW9uaW5nXSAgLSBUaGUgY2xhc3MgdG8gYXBwbHkgd2hlbiBhIG1lbnUgaXMgdHJhbnNpdGlvbmluZyBiZXR3ZWVuIFwib3BlblwiIGFuZCBcImNsb3NlZFwiIHN0YXRlcy5cbiAgICogQHBhcmFtIHtudW1iZXJ9ICAgICAgICAgICAgICAgICBbb3B0aW9ucy50cmFuc2l0aW9uRHVyYXRpb24gPSAyNTBdICAgICAgICAgLSBUaGUgZHVyYXRpb24gb2YgdGhlIHRyYW5zaXRpb24gYmV0d2VlbiBcIm9wZW5cIiBhbmQgXCJjbG9zZWRcIiBzdGF0ZXMgKGluIG1pbGxpc2Vjb25kcykuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgICAgICAgICAgICAgW29wdGlvbnMuaXNUb3BMZXZlbCA9IHRydWVdICAgICAgICAgICAgICAgIC0gQSBmbGFnIHRvIG1hcmsgdGhlIHJvb3QgbWVudS5cbiAgICogQHBhcmFtIHs/VG9wTGlua0Rpc2Nsb3N1cmVNZW51fSBbb3B0aW9ucy5wYXJlbnRNZW51ID0gbnVsbF0gICAgICAgICAgICAgICAgLSBUaGUgcGFyZW50IG1lbnUgdG8gdGhpcyBtZW51LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgICAgIFtvcHRpb25zLmhvdmVyVHlwZSA9IG9mZl0gICAgICAgICAgICAgICAgICAtIFRoZSB0eXBlIG9mIGhvdmVyYWJpbGl0eSBhIG1lbnUgaGFzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gICAgICAgICAgICAgICAgIFtvcHRpb25zLmhvdmVyRGVsYXkgPSAyNTBdICAgICAgICAgICAgICAgICAtIFRoZSBkZWxheSBmb3Igb3BlbmluZyBhbmQgY2xvc2luZyBtZW51cyBpZiB0aGUgbWVudSBpcyBob3ZlcmFibGUgKGluIG1pbGxpc2Vjb25kcykuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSAgICAgICAgICAgICAgICAgW29wdGlvbnMuZW50ZXJEZWxheSA9IC0xXSAgICAgICAgICAgICAgICAgIC0gVGhlIGRlbGF5IGZvciBvcGVuaW5nIGEgbWVudSBpZiB0aGUgbWVudSBpcyBmb2N1c2FibGUgKGluIG1pbGxpc2Vjb25kcykuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSAgICAgICAgICAgICAgICAgW29wdGlvbnMubGVhdmVEZWxheSA9IC0xXSAgICAgICAgICAgICAgICAgIC0gVGhlIGRlbGF5IGZvciBjbG9zaW5nIGEgbWVudSBpZiB0aGUgbWVudSBpcyBmb2N1c2FibGUgKGluIG1pbGxpc2Vjb25kcykuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgICAgICAgICAgICAgW29wdGlvbnMub3B0aW9uYWxLZXlTdXBwb3J0ID0gZmFsc2VdICAgICAgIC0gQSBmbGFnIHRvIGFkZCBvcHRpb25hbCBrZXlib2FyZCBzdXBwb3J0IChBcnJvdyBrZXlzLCBIb21lLCBhbmQgRW5kKSB0byB0aGUgbWVudS5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSAgICAgICAgICAgICAgICBbb3B0aW9ucy5wcmVmaXggPSBhbS1dICAgICAgICAgICAgICAgICAgICAgLSBUaGUgcHJlZml4IHRvIHVzZSBmb3IgQ1NTIGN1c3RvbSBwcm9wZXJ0aWVzLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICAgICAgICAgICAgIFtvcHRpb25zLmluaXRpYWxpemUgPSB0cnVlXSAgICAgICAgICAgICAgICAtIEEgZmxhZyB0byBpbml0aWFsaXplIHRoZSBtZW51IGltbWVkaWF0ZWx5IHVwb24gY3JlYXRpb24uXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbWVudUVsZW1lbnQ6IHQsXG4gICAgbWVudUl0ZW1TZWxlY3RvcjogcyA9IFwibGlcIixcbiAgICBtZW51TGlua1NlbGVjdG9yOiBuID0gXCJhXCIsXG4gICAgc3VibWVudUl0ZW1TZWxlY3RvcjogaSA9IFwibGk6aGFzKHVsKVwiLFxuICAgIHN1Ym1lbnVUb2dnbGVTZWxlY3RvcjogbCA9IFwiYnV0dG9uXCIsXG4gICAgc3VibWVudVNlbGVjdG9yOiBoID0gXCJ1bFwiLFxuICAgIHN1Ym1lbnVTdWJ0b2dnbGVTZWxlY3RvcjogbSA9IFwiYVwiLFxuICAgIGNvbnRyb2xsZXJFbGVtZW50OiBhID0gbnVsbCxcbiAgICBjb250YWluZXJFbGVtZW50OiBwID0gbnVsbCxcbiAgICBvcGVuQ2xhc3M6IGYgPSBcInNob3dcIixcbiAgICBjbG9zZUNsYXNzOiBnID0gXCJoaWRlXCIsXG4gICAgdHJhbnNpdGlvbkNsYXNzOiBkID0gXCJ0cmFuc2l0aW9uaW5nXCIsXG4gICAgdHJhbnNpdGlvbkR1cmF0aW9uOiBNID0gMjUwLFxuICAgIGlzVG9wTGV2ZWw6IHkgPSAhMCxcbiAgICBwYXJlbnRNZW51OiBiID0gbnVsbCxcbiAgICBob3ZlclR5cGU6IEMgPSBcIm9mZlwiLFxuICAgIGhvdmVyRGVsYXk6IFQgPSAyNTAsXG4gICAgZW50ZXJEZWxheTogRSA9IC0xLFxuICAgIGxlYXZlRGVsYXk6IHYgPSAtMSxcbiAgICBvcHRpb25hbEtleVN1cHBvcnQ6IEkgPSAhMSxcbiAgICBwcmVmaXg6IEsgPSBcImFtLVwiLFxuICAgIGluaXRpYWxpemU6ICQgPSAhMFxuICB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgbWVudUVsZW1lbnQ6IHQsXG4gICAgICBtZW51SXRlbVNlbGVjdG9yOiBzLFxuICAgICAgbWVudUxpbmtTZWxlY3RvcjogbixcbiAgICAgIHN1Ym1lbnVJdGVtU2VsZWN0b3I6IGksXG4gICAgICBzdWJtZW51U2VsZWN0b3I6IGgsXG4gICAgICBzdWJtZW51VG9nZ2xlU2VsZWN0b3I6IGwsXG4gICAgICBjb250cm9sbGVyRWxlbWVudDogYSxcbiAgICAgIGNvbnRhaW5lckVsZW1lbnQ6IHAsXG4gICAgICBvcGVuQ2xhc3M6IGYsXG4gICAgICBjbG9zZUNsYXNzOiBnLFxuICAgICAgdHJhbnNpdGlvbkNsYXNzOiBkLFxuICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uOiBNLFxuICAgICAgaXNUb3BMZXZlbDogeSxcbiAgICAgIHBhcmVudE1lbnU6IGIsXG4gICAgICBob3ZlclR5cGU6IEMsXG4gICAgICBob3ZlckRlbGF5OiBULFxuICAgICAgZW50ZXJEZWxheTogRSxcbiAgICAgIGxlYXZlRGVsYXk6IHYsXG4gICAgICBwcmVmaXg6IEtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBUaGUgY2xhc3MgdG8gdXNlIHdoZW4gZ2VuZXJhdGluZyBzdWJtZW51cy5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKlxuICAgICAqIEB0eXBlIHt0eXBlb2YgVG9wTGlua0Rpc2Nsb3N1cmVNZW51fVxuICAgICAqL1xuICAgIHUodGhpcywgXCJfTWVudVR5cGVcIiwgcSk7XG4gICAgLyoqXG4gICAgICogVGhlIGNsYXNzIHRvIHVzZSB3aGVuIGdlbmVyYXRpbmcgbWVudSBpdGVtcy5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKlxuICAgICAqIEB0eXBlIHt0eXBlb2YgVG9wTGlua0Rpc2Nsb3N1cmVNZW51SXRlbX1cbiAgICAgKi9cbiAgICB1KHRoaXMsIFwiX01lbnVJdGVtVHlwZVwiLCBKKTtcbiAgICAvKipcbiAgICAgKiBUaGUgY2xhc3MgdG8gdXNlIHdoZW4gZ2VuZXJhdGluZyBzdWJtZW51IHRvZ2dsZXMuXG4gICAgICpcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICpcbiAgICAgKiBAdHlwZSB7dHlwZW9mIFRvcExpbmtEaXNjbG9zdXJlTWVudVRvZ2dsZX1cbiAgICAgKi9cbiAgICB1KHRoaXMsIFwiX01lbnVUb2dnbGVUeXBlXCIsIFgpO1xuICAgIC8qKlxuICAgICAqIFRoZSBpbmRleCBvZiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIG1lbnUgaXRlbSBpbiB0aGUgbWVudS5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICovXG4gICAgdSh0aGlzLCBcIl9jdXJyZW50Q2hpbGRcIiwgLTEpO1xuICAgIC8qKlxuICAgICAqIFRoZSBxdWVyeSBzZWxlY3RvcnMgdXNlZCBieSB0aGUgbWVudSB0byBwb3B1bGF0ZSB0aGUgZG9tLlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqXG4gICAgICogQHR5cGUge09iamVjdDxzdHJpbmc+fVxuICAgICAqXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IG1lbnVJdGVtcyAgICAgICAgIC0gVGhlIHF1ZXJ5IHNlbGVjdG9yIGZvciBtZW51IGl0ZW1zLlxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtZW51TGlua3MgICAgICAgICAtIFRoZSBxdWVyeSBzZWxlY3RvciBmb3IgbWVudSBsaW5rcy5cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gc3VibWVudUl0ZW1zICAgICAgLSBUaGUgcXVlcnkgc2VsZWN0b3IgZm9yIG1lbnUgaXRlbXMgY29udGFpbmluZyBzdWJtZW51cy5cbiAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gc3VibWVudVRvZ2dsZXMgICAgLSBUaGUgcXVlcnkgc2VsZWN0b3IgZm9yIG1lbnUgbGlua3MgdGhhdCBmdW5jdGlvbiBhcyBzdWJtZW51IHRvZ2dsZXMuXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHN1Ym1lbnVzICAgICAgICAgIC0gVGhlIHF1ZXJ5IHNlbGVjdG9yIGZvciBmb3Igc3VibWVudXMuXG4gICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHN1Ym1lbnVTdWJ0b2dnbGVzIC0gVGhlIHF1ZXJ5IHNlbGVjdG9yIGZvciBtZW51IGxpbmtzIHRoYXQgZnVuY3Rpb24gYXMgc3VibWVudSB0b2dnbGVzIGJlbG93IHRoZSB0b3AgbGV2ZWwuXG4gICAgICovXG4gICAgdSh0aGlzLCBcIl9zZWxlY3RvcnNcIiwge1xuICAgICAgbWVudUl0ZW1zOiBcIlwiLFxuICAgICAgbWVudUxpbmtzOiBcIlwiLFxuICAgICAgc3VibWVudUl0ZW1zOiBcIlwiLFxuICAgICAgc3VibWVudVRvZ2dsZXM6IFwiXCIsXG4gICAgICBzdWJtZW51czogXCJcIixcbiAgICAgIHN1Ym1lbnVTdWJ0b2dnbGVzOiBcIlwiXG4gICAgfSk7XG4gICAgLyoqXG4gICAgICogQSBmbGFnIHRvIGFkZCBvcHRpb25hbCBrZXlib2FyZCBzdXBwb3J0IChBcnJvdyBrZXlzLCBcIkhvbWVcIiwgYW5kIFwiRW5kXCIpIHRvIHRoZSBtZW51LlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdSh0aGlzLCBcIl9vcHRpb25hbFN1cHBvcnRcIiwgITEpO1xuICAgIHRoaXMuX29wdGlvbmFsU3VwcG9ydCA9IEksIHRoaXMuX3NlbGVjdG9ycy5tZW51SXRlbXMgPSBzLCB0aGlzLl9zZWxlY3RvcnMuc3VibWVudUl0ZW1zID0gaSwgdGhpcy5fc2VsZWN0b3JzLnN1Ym1lbnVUb2dnbGVzID0gbCwgdGhpcy5fc2VsZWN0b3JzLnN1Ym1lbnVzID0gaCwgdGhpcy5fc2VsZWN0b3JzLnN1Ym1lbnVTdWJ0b2dnbGVzID0gbSwgdGhpcy5fc2VsZWN0b3JzLm1lbnVMaW5rcyA9IFtcbiAgICAgIC4uLi8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KFtuLCBsXSlcbiAgICBdLmpvaW4oXCIsXCIpLCAkICYmIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgbWVudS5cbiAgICpcbiAgICogSW5pdGlhbGl6ZSB3aWxsIGNhbGwgdGhlIEJhc2VNZW51J3MgaW5pdGlhbGl6ZSBtZXRob2RcbiAgICogYXMgd2VsbCBhcyBzZXQgdXAgZm9jdXMsXG4gICAqIGNsaWNrLFxuICAgKiBob3ZlcixcbiAgICoga2V5ZG93biwgYW5kXG4gICAqIGtleXVwIGV2ZW50cyBmb3IgdGhlIG1lbnUuXG4gICAqXG4gICAqIElmIHRoZSBCYXNlTWVudSdzIGluaXRpYWxpemUgbWV0aG9kIHRocm93cyBhbiBlcnJvcixcbiAgICogdGhpcyB3aWxsIGNhdGNoIGl0IGFuZCBsb2cgaXQgdG8gdGhlIGNvbnNvbGUuXG4gICAqL1xuICBpbml0aWFsaXplKCkge1xuICAgIHRyeSB7XG4gICAgICBzdXBlci5pbml0aWFsaXplKCksIHRoaXMuX2hhbmRsZUZvY3VzKCksIHRoaXMuX2hhbmRsZUNsaWNrKCksIHRoaXMuX2hhbmRsZUhvdmVyKCksIHRoaXMuX2hhbmRsZUtleWRvd24oKSwgdGhpcy5faGFuZGxlS2V5dXAoKTtcbiAgICB9IGNhdGNoICh0KSB7XG4gICAgICBjb25zb2xlLmVycm9yKHQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQSBmbGFnIHRvIGFkZCBvcHRpb25hbCBrZXlib2FyZCBzdXBwb3J0IChBcnJvdyBrZXlzLCBcIkhvbWVcIiwgYW5kIFwiRW5kXCIpIHRvIHRoZSBtZW51LlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9ucyBkaWZmZXJlbnRseSBmb3Igcm9vdCB2cy4gc3VibWVudXMuXG4gICAqIFN1Ym1lbnVzIHdpbGwgYWx3YXlzIGluaGVyaXQgdGhlaXIgcm9vdCBtZW51J3Mgb3B0aW9uYWxLZXlTdXBwb3J0LlxuICAgKlxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICpcbiAgICogQHNlZSBfb3B0aW9uYWxTdXBwb3J0XG4gICAqL1xuICBnZXQgb3B0aW9uYWxLZXlTdXBwb3J0KCkge1xuICAgIHJldHVybiB0aGlzLmlzVG9wTGV2ZWwgPyB0aGlzLl9vcHRpb25hbFN1cHBvcnQgOiB0aGlzLmVsZW1lbnRzLnJvb3RNZW51Lm9wdGlvbmFsS2V5U3VwcG9ydDtcbiAgfVxuICBzZXQgb3B0aW9uYWxLZXlTdXBwb3J0KHQpIHtcbiAgICBjKFwiYm9vbGVhblwiLCB7IG9wdGlvbmFsS2V5U3VwcG9ydDogdCB9KSwgdGhpcy5fb3B0aW9uYWxTdXBwb3J0ID0gdDtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlcyBhbmQgaW5pdGlhbGl6ZXMgYWxsIG1lbnUgaXRlbXMgYW5kIHN1Ym1lbnVzLlxuICAgKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfY3JlYXRlQ2hpbGRFbGVtZW50cygpIHtcbiAgICB0aGlzLmRvbS5tZW51SXRlbXMuZm9yRWFjaCgodCkgPT4ge1xuICAgICAgbGV0IHMsIG47XG4gICAgICBjb25zdCBpID0gdC5xdWVyeVNlbGVjdG9yKHRoaXMuc2VsZWN0b3JzLm1lbnVMaW5rcyk7XG4gICAgICBpZiAodGhpcy5kb20uc3VibWVudUl0ZW1zLmluY2x1ZGVzKHQpKSB7XG4gICAgICAgIGNvbnN0IGwgPSB0LnF1ZXJ5U2VsZWN0b3IodGhpcy5zZWxlY3RvcnMuc3VibWVudVRvZ2dsZXMpLCBoID0gdC5xdWVyeVNlbGVjdG9yKHRoaXMuc2VsZWN0b3JzLnN1Ym1lbnVzKSwgbSA9IG5ldyB0aGlzLl9NZW51VHlwZSh7XG4gICAgICAgICAgbWVudUVsZW1lbnQ6IGgsXG4gICAgICAgICAgbWVudUl0ZW1TZWxlY3RvcjogdGhpcy5zZWxlY3RvcnMubWVudUl0ZW1zLFxuICAgICAgICAgIG1lbnVMaW5rU2VsZWN0b3I6IHRoaXMuc2VsZWN0b3JzLm1lbnVMaW5rcyxcbiAgICAgICAgICBzdWJtZW51SXRlbVNlbGVjdG9yOiB0aGlzLnNlbGVjdG9ycy5zdWJtZW51SXRlbXMsXG4gICAgICAgICAgc3VibWVudVRvZ2dsZVNlbGVjdG9yOiB0aGlzLnNlbGVjdG9ycy5zdWJtZW51U3VidG9nZ2xlcyxcbiAgICAgICAgICBzdWJtZW51U2VsZWN0b3I6IHRoaXMuc2VsZWN0b3JzLnN1Ym1lbnVzLFxuICAgICAgICAgIHN1Ym1lbnVTdWJ0b2dnbGVTZWxlY3RvcjogdGhpcy5zZWxlY3RvcnMuc3VibWVudVN1YnRvZ2dsZXMsXG4gICAgICAgICAgb3BlbkNsYXNzOiB0aGlzLm9wZW5DbGFzcyxcbiAgICAgICAgICBjbG9zZUNsYXNzOiB0aGlzLmNsb3NlQ2xhc3MsXG4gICAgICAgICAgdHJhbnNpdGlvbkNsYXNzOiB0aGlzLnRyYW5zaXRpb25DbGFzcyxcbiAgICAgICAgICBpc1RvcExldmVsOiAhMSxcbiAgICAgICAgICBwYXJlbnRNZW51OiB0aGlzLFxuICAgICAgICAgIGhvdmVyVHlwZTogdGhpcy5ob3ZlclR5cGUsXG4gICAgICAgICAgaG92ZXJEZWxheTogdGhpcy5ob3ZlckRlbGF5LFxuICAgICAgICAgIGVudGVyRGVsYXk6IHRoaXMuZW50ZXJEZWxheSxcbiAgICAgICAgICBsZWF2ZURlbGF5OiB0aGlzLmxlYXZlRGVsYXlcbiAgICAgICAgfSksIGEgPSBuZXcgdGhpcy5fTWVudVRvZ2dsZVR5cGUoe1xuICAgICAgICAgIG1lbnVUb2dnbGVFbGVtZW50OiBsLFxuICAgICAgICAgIHBhcmVudEVsZW1lbnQ6IHQsXG4gICAgICAgICAgY29udHJvbGxlZE1lbnU6IG0sXG4gICAgICAgICAgcGFyZW50TWVudTogdGhpc1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fZWxlbWVudHMuc3VibWVudVRvZ2dsZXMucHVzaChhKSwgbCAhPT0gaSA/IChuID0gbmV3IHRoaXMuX01lbnVJdGVtVHlwZSh7XG4gICAgICAgICAgbWVudUl0ZW1FbGVtZW50OiB0LFxuICAgICAgICAgIG1lbnVMaW5rRWxlbWVudDogbCxcbiAgICAgICAgICBwYXJlbnRNZW51OiB0aGlzLFxuICAgICAgICAgIGlzU3VibWVudUl0ZW06ICEwLFxuICAgICAgICAgIGNoaWxkTWVudTogbSxcbiAgICAgICAgICB0b2dnbGU6IGFcbiAgICAgICAgfSksIHMgPSBuZXcgdGhpcy5fTWVudUl0ZW1UeXBlKHtcbiAgICAgICAgICBtZW51SXRlbUVsZW1lbnQ6IHQsXG4gICAgICAgICAgbWVudUxpbmtFbGVtZW50OiBpLFxuICAgICAgICAgIHBhcmVudE1lbnU6IHRoaXMsXG4gICAgICAgICAgc3VibWVudVNpYmxpbmc6IG5cbiAgICAgICAgfSkpIDogcyA9IG5ldyB0aGlzLl9NZW51SXRlbVR5cGUoe1xuICAgICAgICAgIG1lbnVJdGVtRWxlbWVudDogdCxcbiAgICAgICAgICBtZW51TGlua0VsZW1lbnQ6IGksXG4gICAgICAgICAgcGFyZW50TWVudTogdGhpcyxcbiAgICAgICAgICBpc1N1Ym1lbnVJdGVtOiAhMCxcbiAgICAgICAgICBjaGlsZE1lbnU6IG0sXG4gICAgICAgICAgdG9nZ2xlOiBhXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlXG4gICAgICAgIHMgPSBuZXcgdGhpcy5fTWVudUl0ZW1UeXBlKHtcbiAgICAgICAgICBtZW51SXRlbUVsZW1lbnQ6IHQsXG4gICAgICAgICAgbWVudUxpbmtFbGVtZW50OiBpLFxuICAgICAgICAgIHBhcmVudE1lbnU6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICB0aGlzLl9lbGVtZW50cy5tZW51SXRlbXMucHVzaChzKSwgdHlwZW9mIG4gPCBcInVcIiAmJiB0aGlzLl9lbGVtZW50cy5tZW51SXRlbXMucHVzaChuKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogVmFsaWRhdGVzIGFsbCBhc3BlY3RzIG9mIHRoZSBtZW51IHRvIGVuc3VyZSBwcm9wZXIgZnVuY3Rpb25hbGl0eS5cbiAgICpcbiAgICogQHByb3RlY3RlZFxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSAtIFRoZSByZXN1bHQgb2YgdGhlIHZhbGlkYXRpb24uXG4gICAqL1xuICBfdmFsaWRhdGUoKSB7XG4gICAgbGV0IHQgPSBzdXBlci5fdmFsaWRhdGUoKTtcbiAgICBjb25zdCBzID0geCh7XG4gICAgICBzdWJtZW51U3VidG9nZ2xlU2VsZWN0b3I6IHRoaXMuX3NlbGVjdG9ycy5zdWJtZW51U3VidG9nZ2xlc1xuICAgIH0pO1xuICAgIHMuc3RhdHVzIHx8ICh0aGlzLl9lcnJvcnMucHVzaChzLmVycm9yLm1lc3NhZ2UpLCB0ID0gITEpO1xuICAgIGNvbnN0IG4gPSBjKFwiYm9vbGVhblwiLCB7XG4gICAgICBvcHRpb25hbEtleVN1cHBvcnQ6IHRoaXMuX29wdGlvbmFsU3VwcG9ydFxuICAgIH0pO1xuICAgIHJldHVybiBuLnN0YXR1cyB8fCAodGhpcy5fZXJyb3JzLnB1c2gobi5lcnJvci5tZXNzYWdlKSwgdCA9ICExKSwgdDtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlcyBjbGljayBldmVudHMgdGhyb3VnaG91dCB0aGUgbWVudSBmb3IgcHJvcGVyIHVzZS5cbiAgICpcbiAgICogLSBBZGRzIGFsbCBldmVudCBsaXN0ZW5lcnMgbGlzdGVkIGluXG4gICAqICAgQmFzZU1lbnUncyBfaGFuZGxlQ2xpY2sgbWV0aG9kLCBhbmRcbiAgICogLSBhZGRzIGEgYHBvaW50ZXJ1cGAgbGlzdGVuZXIgdG8gdGhlIGBkb2N1bWVudGAgc28gaWYgdGhlIHVzZXJcbiAgICogICBjbGlja3Mgb3V0c2lkZSBvZiB0aGUgbWVudSBpdCB3aWxsIGNsb3NlIGlmIGl0IGlzIG9wZW4uXG4gICAqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9oYW5kbGVDbGljaygpIHtcbiAgICBzdXBlci5faGFuZGxlQ2xpY2soKSwgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCAodCkgPT4ge1xuICAgICAgdGhpcy5mb2N1c1N0YXRlICE9PSBcIm5vbmVcIiAmJiAodGhpcy5jdXJyZW50RXZlbnQgPSBcIm1vdXNlXCIsICF0aGlzLmRvbS5tZW51LmNvbnRhaW5zKHQudGFyZ2V0KSAmJiAhdGhpcy5kb20ubWVudSAhPT0gdC50YXJnZXQgJiYgKHRoaXMuY2xvc2VDaGlsZHJlbigpLCB0aGlzLmJsdXIoKSwgdGhpcy5lbGVtZW50cy5jb250cm9sbGVyICYmIHRoaXMuZWxlbWVudHMuY29udHJvbGxlci5jbG9zZSgpLCB0aGlzLmVsZW1lbnRzLnJvb3RNZW51Lmhhc09wZW5lZCA9ICExKSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZXMgaG92ZXIgZXZlbnRzIHRocm91Z2hvdXQgdGhlIG1lbnUgZm9yIHByb3BlciB1c2UuXG4gICAqXG4gICAqIEFkZHMgYHBvaW50ZXJlbnRlcmAgbGlzdGVuZXJzIHRvIGFsbCBtZW51IGl0ZW1zIGFuZCBgcG9pbnRlcmxlYXZlYCBsaXN0ZW5lcnNcbiAgICogdG8gYWxsIHN1Ym1lbnUgaXRlbXMgd2hpY2ggZnVuY3Rpb24gZGlmZmVyZW50bHkgZGVwZW5kaW5nIG9uXG4gICAqIHRoZSBtZW51J3MgaG92ZXIgdHlwZS5cbiAgICpcbiAgICogQmVmb3JlIGV4ZWN1dGluZyBhbnl0aGluZywgdGhlIGV2ZW50IGlzIGNoZWNrZWQgdG8gbWFrZSBzdXJlIHRoZSBldmVudCB3YXNuJ3RcbiAgICogdHJpZ2dlcmVkIGJ5IGEgcGVuIG9yIHRvdWNoLlxuICAgKlxuICAgKiA8c3Ryb25nPkhvdmVyIFR5cGUgXCJvblwiPC9zdHJvbmc+XG4gICAqIC0gV2hlbiBhIGBwb2ludGVyZW50ZXJgIGV2ZW50IHRyaWdnZXJzIG9uIGFueSBtZW51IGl0ZW0gdGhlIG1lbnUnc1xuICAgKiAgICBjdXJyZW50IGNoaWxkIHZhbHVlIHdpbGwgY2hhbmdlIHRvIHRoYXRcbiAgICogICBtZW51IGl0ZW0uXG4gICAqIC0gV2hlbiBhIGBwb2ludGVyZW50ZXJgIGV2ZW50IHRyaWdnZXJzIG9uIGEgc3VibWVudSBpdGVtIHRoZVxuICAgKiAgIHByZXZpZXcgbWV0aG9kIGZvciB0aGUgc3VibWVudSBpdGVtJ3NcbiAgICogICB0b2dnbGUgd2lsbCBiZSBjYWxsZWQuXG4gICAqIC0gV2hlbiBhIGBwb2ludGVybGVhdmVgIGV2ZW50IHRyaWdnZXJzIG9uIGFuIG9wZW4gc3VibWVudSBpdGVtIHRoZVxuICAgKiAgIGNsb3NlIG1ldGhvZCBmb3IgdGhlIHN1Ym1lbnUgaXRlbSdzIHRvZ2dsZVxuICAgKiAgIHdpbGwgYmUgY2FsbGVkIGFmdGVyIGEgZGVsYXkgc2V0IGJ5IHRoZSBtZW51J3MgaG92ZXIgZGVsYXkuXG4gICAqXG4gICAqIDxzdHJvbmc+SG92ZXIgVHlwZSBcImR5bmFtaWNcIjwvc3Ryb25nPlxuICAgKiAtIFdoZW4gYSBgcG9pbnRlcmVudGVyYCBldmVudCB0cmlnZ2VycyBvbiBhbnkgbWVudSBpdGVtIHRoZSBtZW51J3NcbiAgICogICBjdXJyZW50IGNoaWxkIHZhbHVlIHdpbGwgY2hhbmdlIHRvIHRoYXQgbWVudSBpdGVtLlxuICAgKiAtIFdoZW4gYSBgcG9pbnRlcmVudGVyYCBldmVudCB0cmlnZ2VycyBvbiBhbnkgbWVudSBpdGVtLCBhbmQgdGhlIG1lbnUnc1xuICAgKiAgIGZvY3VzIHN0YXRlIGlzIG5vdCBcIm5vbmVcIiwgdGhlIG1lbnUgaXRlbVxuICAgKiAgIHdpbGwgYmUgZm9jdXNlZC5cbiAgICogLSBXaGVuIGEgYHBvaW50ZXJlbnRlcmAgZXZlbnQgdHJpZ2dlcnMgb24gYSBzdWJtZW51IGl0ZW0sIGFuZCBhIHN1Ym1lbnUgaXNcbiAgICogICBhbHJlYWR5IG9wZW4sIHRoZSBwcmV2aWV3IG1ldGhvZCBmb3IgdGhlIHN1Ym1lbnUgaXRlbSdzIHRvZ2dsZSB3aWxsIGJlIGNhbGxlZC5cbiAgICogLSBXaGVuIGEgYHBvaW50ZXJlbnRlcmAgZXZlbnQgdHJpZ2dlcnMgb24gYSBub24tc3VibWVudSBpdGVtLCBhbmQgYSBzdWJtZW51XG4gICAqICAgaXMgYWxyZWFkeSBvcGVuLCB0aGUgY2xvc2VDaGlsZHJlbiBtZXRob2QgZm9yIHRoZSBtZW51IHdpbGwgYmUgY2FsbGVkLlxuICAgKiAtIFdoZW4gYSBgcG9pbnRlcmVudGVyYCBldmVudCB0cmlnZ2VycyBvbiBhIHN1Ym1lbnUgaXRlbSwgYW5kIG5vIHN1Ym1lbnUgaXNcbiAgICogICBvcGVuLCBubyBzdWJtZW51LXNwZWNpZmljIG1ldGhvZHMgd2lsbCBiZSBjYWxsZWQuXG4gICAqIC0gV2hlbiBhIGBwb2ludGVybGVhdmVgIGV2ZW50IHRyaWdnZXJzIG9uIGFuIG9wZW4gc3VibWVudSBpdGVtIHRoYXQgaXMgbm90IGFcbiAgICogICByb290LWxldmVsIHN1Ym1lbnUgaXRlbSB0aGUgY2xvc2UgbWV0aG9kIGZvciB0aGUgc3VibWVudSBpdGVtJ3MgdG9nZ2xlXG4gICAqICAgd2lsbCBiZSBjYWxsZWQgYW5kIHRoZSBzdWJtZW51IGl0ZW0gd2lsbCBiZSBmb2N1c2VkIGFmdGVyIGEgZGVsYXkgc2V0IGJ5XG4gICAqICAgdGhlIG1lbnUncyBob3ZlciBkZWxheS5cbiAgICogLSBXaGVuIGEgYHBvaW50ZXJsZWF2ZWAgZXZlbnQgdHJpZ2dlcnMgb24gYW4gb3BlbiBzdWJtZW51IGl0ZW0gdGhhdCBpcyBhXG4gICAqICAgcm9vdC1sZXZlbCBzdWJtZW51IGl0ZW0gbm8gc3VibWVudS1zcGVjaWZpYyBtZXRob2RzIHdpbGwgYmUgY2FsbGVkLlxuICAgKlxuICAgKiA8c3Ryb25nPkhvdmVyIFR5cGUgXCJvZmZcIjwvc3Ryb25nPlxuICAgKiBBbGwgYHBvaW50ZXJlbnRlcmAgYW5kIGBwb2ludGVybGVhdmVgIGV2ZW50cyBhcmUgaWdub3JlZC5cbiAgICpcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX2hhbmRsZUhvdmVyKCkge1xuICAgIHRoaXMuZWxlbWVudHMubWVudUl0ZW1zLmZvckVhY2goKHQsIHMpID0+IHtcbiAgICAgIHQuZG9tLmxpbmsuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJlbnRlclwiLCAobikgPT4ge1xuICAgICAgICBpZiAoIShuLnBvaW50ZXJUeXBlID09PSBcInBlblwiIHx8IG4ucG9pbnRlclR5cGUgPT09IFwidG91Y2hcIikpIHtcbiAgICAgICAgICBpZiAodGhpcy5ob3ZlclR5cGUgPT09IFwib25cIikge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50RXZlbnQgPSBcIm1vdXNlXCIsIHRoaXMuZWxlbWVudHMucm9vdE1lbnUuYmx1ckNoaWxkcmVuKCksIHRoaXMuZm9jdXNDaGlsZChzKTtcbiAgICAgICAgICAgIGxldCBpID0gdC5pc1N1Ym1lbnVJdGVtID8gdC5lbGVtZW50cy50b2dnbGUgOiBudWxsO1xuICAgICAgICAgICAgaWYgKHQuZWxlbWVudHMuc2libGluZyAhPT0gbnVsbCAmJiAoaSA9IHQuZWxlbWVudHMuc2libGluZy5lbGVtZW50cy50b2dnbGUpLCBpID09PSBudWxsKSByZXR1cm47XG4gICAgICAgICAgICB0aGlzLmVudGVyRGVsYXkgPiAwID8gKHRoaXMuX2NsZWFyVGltZW91dCgpLCB0aGlzLl9zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgaS5wcmV2aWV3KCk7XG4gICAgICAgICAgICB9LCB0aGlzLmVudGVyRGVsYXkpKSA6IGkucHJldmlldygpO1xuICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5ob3ZlclR5cGUgPT09IFwiZHluYW1pY1wiICYmICh0aGlzLmN1cnJlbnRDaGlsZCA9IHMsICghdGhpcy5pc1RvcExldmVsIHx8IHRoaXMuZm9jdXNTdGF0ZSAhPT0gXCJub25lXCIpICYmICh0aGlzLmN1cnJlbnRFdmVudCA9IFwibW91c2VcIiwgdGhpcy5lbGVtZW50cy5yb290TWVudS5ibHVyQ2hpbGRyZW4oKSwgdGhpcy5mb2N1c0N1cnJlbnRDaGlsZCgpKSwgIXRoaXMuaXNUb3BMZXZlbCB8fCB0aGlzLmhhc09wZW5lZCkpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEV2ZW50ID0gXCJtb3VzZVwiLCB0aGlzLmVsZW1lbnRzLnJvb3RNZW51LmJsdXJDaGlsZHJlbigpLCB0aGlzLmZvY3VzQ3VycmVudENoaWxkKCk7XG4gICAgICAgICAgICBsZXQgaSA9IHQuaXNTdWJtZW51SXRlbSA/IHQuZWxlbWVudHMudG9nZ2xlIDogbnVsbDtcbiAgICAgICAgICAgIHQuZWxlbWVudHMuc2libGluZyAhPT0gbnVsbCAmJiAoaSA9IHQuZWxlbWVudHMuc2libGluZy5lbGVtZW50cy50b2dnbGUpLCBpICE9PSBudWxsID8gdGhpcy5lbnRlckRlbGF5ID4gMCA/ICh0aGlzLl9jbGVhclRpbWVvdXQoKSwgdGhpcy5fc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgIGkucHJldmlldygpO1xuICAgICAgICAgICAgfSwgdGhpcy5lbnRlckRlbGF5KSkgOiBpLnByZXZpZXcoKSA6IHRoaXMuZW50ZXJEZWxheSA+IDAgPyAodGhpcy5fY2xlYXJUaW1lb3V0KCksIHRoaXMuX3NldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICB0aGlzLmNsb3NlQ2hpbGRyZW4oKTtcbiAgICAgICAgICAgIH0sIHRoaXMuZW50ZXJEZWxheSkpIDogdGhpcy5jbG9zZUNoaWxkcmVuKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KSwgdC5pc1N1Ym1lbnVJdGVtICYmICh0LmRvbS5pdGVtLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybGVhdmVcIiwgKG4pID0+IHtcbiAgICAgICAgbi5wb2ludGVyVHlwZSA9PT0gXCJwZW5cIiB8fCBuLnBvaW50ZXJUeXBlID09PSBcInRvdWNoXCIgfHwgKHRoaXMuaG92ZXJUeXBlID09PSBcIm9uXCIgPyB0aGlzLmxlYXZlRGVsYXkgPiAwID8gKHRoaXMuX2NsZWFyVGltZW91dCgpLCB0aGlzLl9zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLmN1cnJlbnRFdmVudCA9IFwibW91c2VcIiwgdC5lbGVtZW50cy50b2dnbGUuY2xvc2UoKTtcbiAgICAgICAgfSwgdGhpcy5sZWF2ZURlbGF5KSkgOiAodGhpcy5jdXJyZW50RXZlbnQgPSBcIm1vdXNlXCIsIHQuZWxlbWVudHMudG9nZ2xlLmNsb3NlKCkpIDogdGhpcy5ob3ZlclR5cGUgPT09IFwiZHluYW1pY1wiICYmICh0aGlzLmxlYXZlRGVsYXkgPiAwID8gKHRoaXMuX2NsZWFyVGltZW91dCgpLCB0aGlzLl9zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLmN1cnJlbnRFdmVudCA9IFwibW91c2VcIjtcbiAgICAgICAgfSwgdGhpcy5sZWF2ZURlbGF5KSkgOiB0aGlzLmN1cnJlbnRFdmVudCA9IFwibW91c2VcIikpO1xuICAgICAgfSksIHQuZG9tLml0ZW0uYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJlbnRlclwiLCAobikgPT4ge1xuICAgICAgICBuLnBvaW50ZXJUeXBlID09PSBcInBlblwiIHx8IG4ucG9pbnRlclR5cGUgPT09IFwidG91Y2hcIiB8fCB0LmlzU3VibWVudUl0ZW0gJiYgKHRoaXMuaG92ZXJUeXBlID09PSBcIm9uXCIgfHwgdGhpcy5ob3ZlclR5cGUgPT09IFwiZHluYW1pY1wiKSAmJiB0aGlzLmxlYXZlRGVsYXkgPiAwICYmIHRoaXMuX2NsZWFyVGltZW91dCgpO1xuICAgICAgfSkpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGVzIGtleWRvd24gZXZlbnRzIHRocm91Z2hvdXQgdGhlIG1lbnUgZm9yIHByb3BlciBtZW51IHVzZS5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgZXhpc3RzIHRvIGFzc2lzdCB0aGUgX2hhbmRsZUtleXVwIG1ldGhvZC5cbiAgICogLSBBZGRzIGFsbCBga2V5ZG93bmAgbGlzdGVuZXJzIGZyb20gQmFzZU1lbnUncyBfaGFuZGxlS2V5ZG93biBtZXRob2RcbiAgICogLSBBZGRzIGEgYGtleWRvd25gIGxpc3RlbmVyIHRvIHRoZSBtZW51L2FsbCBzdWJtZW51cy5cbiAgICogICAtIEJsb2NrcyBwcm9wYWdhdGlvbiBvbiB0aGUgZm9sbG93aW5nIGtleXM6IFwiU3BhY2VcIiwgXCJFbnRlclwiLCBhbmQgXCJFc2NhcGVcIi5cbiAgICogICAtIF9JZl8gb3B0aW9uYWwga2V5Ym9hcmQgc3VwcG9ydFxuICAgKiAgICAgaXMgZW5hYmxlZCwgYmxvY2tzIHByb3BhZ2F0aW9uIG9uIHRoZSBmb2xsb3dpbmcga2V5czpcbiAgICogICAgIFwiQXJyb3dVcFwiLCBcIkFycm93UmlnaHRcIiwgXCJBcnJvd0Rvd25cIiwgXCJBcnJvd0xlZnRcIiwgXCJIb21lXCIsIGFuZCBcIkVuZFwiLlxuICAgKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfaGFuZGxlS2V5ZG93bigpIHtcbiAgICBzdXBlci5faGFuZGxlS2V5ZG93bigpLCB0aGlzLmRvbS5tZW51LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsICh0KSA9PiB7XG4gICAgICB0aGlzLmN1cnJlbnRFdmVudCA9IFwia2V5Ym9hcmRcIjtcbiAgICAgIGNvbnN0IHMgPSBfKHQpO1xuICAgICAgaWYgKHRoaXMuZm9jdXNTdGF0ZSA9PT0gXCJzZWxmXCIpIHtcbiAgICAgICAgY29uc3QgbiA9IFtcIlNwYWNlXCIsIFwiRW50ZXJcIl0sIGkgPSBbXCJFc2NhcGVcIl0sIGwgPSBbXCJFc2NhcGVcIl0sIGggPSBbXG4gICAgICAgICAgXCJBcnJvd1VwXCIsXG4gICAgICAgICAgXCJBcnJvd1JpZ2h0XCIsXG4gICAgICAgICAgXCJBcnJvd0Rvd25cIixcbiAgICAgICAgICBcIkFycm93TGVmdFwiLFxuICAgICAgICAgIFwiSG9tZVwiLFxuICAgICAgICAgIFwiRW5kXCJcbiAgICAgICAgXTtcbiAgICAgICAgKG4uaW5jbHVkZXMocykgfHwgdGhpcy5vcHRpb25hbEtleVN1cHBvcnQgJiYgaC5pbmNsdWRlcyhzKSB8fCB0aGlzLmVsZW1lbnRzLmNvbnRyb2xsZXIgJiYgaS5pbmNsdWRlcyhzKSB8fCB0aGlzLmVsZW1lbnRzLnBhcmVudE1lbnUgJiYgbC5pbmNsdWRlcyhzKSkgJiYgbyh0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlcyBrZXl1cCBldmVudHMgdGhyb3VnaG91dCB0aGUgbWVudSBmb3IgcHJvcGVyIG1lbnUgdXNlLlxuICAgKlxuICAgKiBBZGRzIGFsbCBga2V5dXBgIGxpc3RlbmVycyBmcm9tIEJhc2VNZW51J3MgX2hhbmRsZUtleXVwIG1ldGhvZC5cbiAgICpcbiAgICogQWRkcyB0aGUgZm9sbG93aW5nIGtleWJpbmRpbmdzIChleHBsYW5hdGlvbnMgYXJlIHRha2VuIGZyb20gdGhlXG4gICAqIFdBSSBBUklBIFByYWN0aWNlcyBFeGFtcGxlIERpc2Nsb3N1cmUgZm9yIE5hdmlnYXRpb24gTWVudXMpOlxuICAgKlxuICAgKiB8IEtleSB8IEZ1bmN0aW9uIHxcbiAgICogfCAtLS0gfCAtLS0gfFxuICAgKiB8IF9UYWJfIG9yIF9TaGlmdCArIFRhYl8gfCBNb3ZlIGtleWJvYXJkIGZvY3VzIGFtb25nIHRvcC1sZXZlbCBidXR0b25zLCBhbmQgaWYgYSBkcm9wZG93biBpcyBvcGVuLCBpbnRvIGFuZCB0aHJvdWdoIGxpbmtzIGluIHRoZSBkcm9wZG93bi4gfFxuICAgKiB8IF9TcGFjZV8gb3IgX0VudGVyXyB8IDx1bD48bGk+SWYgZm9jdXMgaXMgb24gYSBkaXNjbG9zdXJlIGJ1dHRvbiwgYWN0aXZhdGVzIHRoZSBidXR0b24sIHdoaWNoIHRvZ2dsZXMgdGhlIHZpc2liaWxpdHkgb2YgdGhlIGRyb3Bkb3duLjwvbGk+PGxpPklmIGZvY3VzIGlzIG9uIGEgbGluazo8dWw+PGxpPklmIGFueSBsaW5rIGhhcyBhcmlhLWN1cnJlbnQgc2V0LCByZW1vdmVzIGl0LjwvbGk+PGxpPlNldHMgYXJpYS1jdXJyZW50PVwicGFnZVwiIG9uIHRoZSBmb2N1c2VkIGxpbmsuPC9saT48bGk+QWN0aXZhdGVzIHRoZSBmb2N1c2VkIGxpbmsuPC9saT48L3VsPjwvbGk+PC91bD4gfFxuICAgKiB8IF9Fc2NhcGVfIHwgSWYgYSBkcm9wZG93biBpcyBvcGVuLCBjbG9zZXMgaXQgYW5kIHNldHMgZm9jdXMgb24gdGhlIGJ1dHRvbiB0aGF0IGNvbnRyb2xzIHRoYXQgZHJvcGRvd24uIHxcbiAgICogfCBfRG93biBBcnJvd18gb3IgX1JpZ2h0IEFycm93XyAoT3B0aW9uYWx9KSB8IDx1bD48bGk+SWYgZm9jdXMgaXMgb24gYSBidXR0b24gYW5kIGl0cyBkcm9wZG93biBpcyBjb2xsYXBzZWQsIGFuZCBpdCBpcyBub3QgdGhlIGxhc3QgYnV0dG9uLCBtb3ZlcyBmb2N1cyB0byB0aGUgbmV4dCBidXR0b24uPC9saT48bGk+aWYgZm9jdXMgaXMgb24gYSBidXR0b24gYW5kIGl0cyBkcm9wZG93biBpcyBleHBhbmRlZCwgbW92ZXMgZm9jdXMgdG8gdGhlIGZpcnN0IGxpbmsgaW4gdGhlIGRyb3Bkb3duLjwvbGk+PGxpPklmIGZvY3VzIGlzIG9uIGEgbGluaywgYW5kIGl0IGlzIG5vdCB0aGUgbGFzdCBsaW5rLCBtb3ZlcyBmb2N1cyB0byB0aGUgbmV4dCBsaW5rLjwvbGk+PC91bD4gfFxuICAgKiB8IF9VcCBBcnJvd18gb3IgX0xlZnQgQXJyb3dfIChPcHRpb25hbH0pIHwgPHVsPjxsaT5JZiBmb2N1cyBpcyBvbiBhIGJ1dHRvbiwgYW5kIGl0IGlzIG5vdCB0aGUgZmlyc3QgYnV0dG9uLCBtb3ZlcyBmb2N1cyB0byB0aGUgcHJldmlvdXMgYnV0dG9uLjwvbGk+PGxpPklmIGZvY3VzIGlzIG9uIGEgbGluaywgYW5kIGl0IGlzIG5vdCB0aGUgZmlyc3QgbGluaywgbW92ZXMgZm9jdXMgdG8gdGhlIHByZXZpb3VzIGxpbmsuPC9saT48L3VsPiB8XG4gICAqIHwgX0hvbWVfIChPcHRpb25hbH0pIHwgPHVsPjxsaT5JZiBmb2N1cyBpcyBvbiBhIGJ1dHRvbiwgYW5kIGl0IGlzIG5vdCB0aGUgZmlyc3QgYnV0dG9uLCBtb3ZlcyBmb2N1cyB0byB0aGUgZmlyc3QgYnV0dG9uLjwvbGk+PGxpPklmIGZvY3VzIGlzIG9uIGEgbGluaywgYW5kIGl0IGlzIG5vdCB0aGUgZmlyc3QgbGluaywgbW92ZXMgZm9jdXMgdG8gdGhlIGZpcnN0IGxpbmsuPC9saT48L3VsPiB8XG4gICAqIHwgX0VuZF8gKE9wdGlvbmFsfSkgfCA8dWw+PGxpPklmIGZvY3VzIGlzIG9uIGEgYnV0dG9uLCBhbmQgaXQgaXMgbm90IHRoZSBsYXN0IGJ1dHRvbiwgbW92ZXMgZm9jdXMgdG8gdGhlIGxhc3QgYnV0dG9uLjwvbGk+PGxpPklmIGZvY3VzIGlzIG9uIGEgbGluaywgYW5kIGl0IGlzIG5vdCB0aGUgbGFzdCBsaW5rLCBtb3ZlcyBmb2N1cyB0byB0aGUgbGFzdCBsaW5rLjwvbGk+PC91bD4gfFxuICAgKlxuICAgKiBUaGUgb3B0aW9uYWwga2V5YmluZGluZ3MgYXJlIGNvbnRyb2xsZWQgYnkgdGhlIG1lbnUncyBvcHRpb25hbEtleVN1cHBvcnQgdmFsdWUuXG4gICAqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9oYW5kbGVLZXl1cCgpIHtcbiAgICBzdXBlci5faGFuZGxlS2V5dXAoKSwgdGhpcy5kb20ubWVudS5hZGRFdmVudExpc3RlbmVyKFwia2V5dXBcIiwgKHQpID0+IHtcbiAgICAgIHRoaXMuY3VycmVudEV2ZW50ID0gXCJrZXlib2FyZFwiO1xuICAgICAgY29uc3QgcyA9IF8odCk7XG4gICAgICB0aGlzLmZvY3VzU3RhdGUgPT09IFwic2VsZlwiICYmIChzID09PSBcIlNwYWNlXCIgfHwgcyA9PT0gXCJFbnRlclwiID8gKG8odCksIHRoaXMuY3VycmVudE1lbnVJdGVtLmlzU3VibWVudUl0ZW0gPyB0aGlzLmN1cnJlbnRNZW51SXRlbS5lbGVtZW50cy50b2dnbGUuaXNPcGVuID8gdGhpcy5jdXJyZW50TWVudUl0ZW0uZWxlbWVudHMudG9nZ2xlLmNsb3NlKCkgOiB0aGlzLmN1cnJlbnRNZW51SXRlbS5lbGVtZW50cy50b2dnbGUucHJldmlldygpIDogdGhpcy5jdXJyZW50TWVudUl0ZW0uZG9tLmxpbmsuY2xpY2soKSkgOiBzID09PSBcIkVzY2FwZVwiID8gdGhpcy5lbGVtZW50cy5zdWJtZW51VG9nZ2xlcy5zb21lKFxuICAgICAgICAoaSkgPT4gaS5pc09wZW5cbiAgICAgICkgPyAobyh0KSwgdGhpcy5jbG9zZUNoaWxkcmVuKCkpIDogdGhpcy5lbGVtZW50cy5wYXJlbnRNZW51ID8gKG8odCksIHRoaXMuZWxlbWVudHMucGFyZW50TWVudS5jdXJyZW50RXZlbnQgPSB0aGlzLmN1cnJlbnRFdmVudCwgdGhpcy5lbGVtZW50cy5wYXJlbnRNZW51LmNsb3NlQ2hpbGRyZW4oKSwgdGhpcy5lbGVtZW50cy5wYXJlbnRNZW51LmZvY3VzQ3VycmVudENoaWxkKCkpIDogdGhpcy5pc1RvcExldmVsICYmIHRoaXMuZWxlbWVudHMuY29udHJvbGxlciAmJiB0aGlzLmVsZW1lbnRzLmNvbnRyb2xsZXIuaXNPcGVuICYmICh0aGlzLmVsZW1lbnRzLmNvbnRyb2xsZXIuY2xvc2UoKSwgdGhpcy5mb2N1c0NvbnRyb2xsZXIoKSkgOiB0aGlzLm9wdGlvbmFsS2V5U3VwcG9ydCAmJiAocyA9PT0gXCJBcnJvd0Rvd25cIiB8fCBzID09PSBcIkFycm93UmlnaHRcIiA/IChvKHQpLCB0aGlzLmN1cnJlbnRNZW51SXRlbS5pc1N1Ym1lbnVJdGVtICYmIHRoaXMuY3VycmVudE1lbnVJdGVtLmVsZW1lbnRzLnRvZ2dsZS5pc09wZW4gPyAodGhpcy5jdXJyZW50TWVudUl0ZW0uZWxlbWVudHMuY2hpbGRNZW51LmN1cnJlbnRFdmVudCA9IFwia2V5Ym9hcmRcIiwgdGhpcy5jdXJyZW50TWVudUl0ZW0uZWxlbWVudHMuY2hpbGRNZW51LmZvY3VzRmlyc3RDaGlsZCgpKSA6IHRoaXMuZm9jdXNOZXh0Q2hpbGQoKSkgOiBzID09PSBcIkFycm93VXBcIiB8fCBzID09PSBcIkFycm93TGVmdFwiID8gKG8odCksIHRoaXMuZm9jdXNQcmV2aW91c0NoaWxkKCkpIDogcyA9PT0gXCJIb21lXCIgPyAobyh0KSwgdGhpcy5mb2N1c0ZpcnN0Q2hpbGQoKSkgOiBzID09PSBcIkVuZFwiICYmIChvKHQpLCB0aGlzLmZvY3VzTGFzdENoaWxkKCkpKSk7XG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIFkgZXh0ZW5kcyBPIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgYFRyZWV2aWV3SXRlbWAuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgICAgICAgICBvcHRpb25zICAgICAgICAgICAgICAgICAgICAgICAgIC0gVGhlIG9wdGlvbnMgZm9yIGdlbmVyYXRpbmcgdGhlIG1lbnUgaXRlbS5cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gICAgIG9wdGlvbnMubWVudUl0ZW1FbGVtZW50ICAgICAgICAgLSBUaGUgbWVudSBpdGVtIGluIHRoZSBET00uXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9ICAgICBvcHRpb25zLm1lbnVMaW5rRWxlbWVudCAgICAgICAgIC0gVGhlIG1lbnUgaXRlbSdzIGxpbmsgaW4gdGhlIERPTS5cbiAgICogQHBhcmFtIHtUcmVldmlld30gICAgICAgIG9wdGlvbnMucGFyZW50TWVudSAgICAgICAgICAgICAgLSBUaGUgcGFyZW50IG1lbnUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgICAgICBbb3B0aW9ucy5pc1N1Ym1lbnVJdGVtID0gZmFsc2VdIC0gQSBmbGFnIHRvIG1hcmsgaWYgdGhlIG1lbnUgaXRlbSBpcyBjb250cm9sbGluZyBhIHN1Ym1lbnUuXG4gICAqIEBwYXJhbSB7P1RyZWV2aWV3fSAgICAgICBbb3B0aW9ucy5jaGlsZE1lbnUgPSBudWxsXSAgICAgIC0gVGhlIGNoaWxkIG1lbnUuXG4gICAqIEBwYXJhbSB7P1RyZWV2aWV3VG9nZ2xlfSBbb3B0aW9ucy50b2dnbGUgPSBudWxsXSAgICAgICAgIC0gVGhlIGNvbnRyb2xsZXIgZm9yIHRoZSBjaGlsZCBtZW51LlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICAgICAgW29wdGlvbnMuaW5pdGlhbGl6ZSA9IHRydWVdICAgICAtIEEgZmxhZyB0byBpbml0aWFsaXplIHRoZSBtZW51IGl0ZW0gaW1tZWRpYXRlbHkgdXBvbiBjcmVhdGlvbi5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBtZW51SXRlbUVsZW1lbnQ6IGUsXG4gICAgbWVudUxpbmtFbGVtZW50OiB0LFxuICAgIHBhcmVudE1lbnU6IHMsXG4gICAgaXNTdWJtZW51SXRlbTogbiA9ICExLFxuICAgIGNoaWxkTWVudTogaSA9IG51bGwsXG4gICAgdG9nZ2xlOiBsID0gbnVsbCxcbiAgICBpbml0aWFsaXplOiBoID0gITBcbiAgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIG1lbnVJdGVtRWxlbWVudDogZSxcbiAgICAgIG1lbnVMaW5rRWxlbWVudDogdCxcbiAgICAgIHBhcmVudE1lbnU6IHMsXG4gICAgICBpc1N1Ym1lbnVJdGVtOiBuLFxuICAgICAgY2hpbGRNZW51OiBpLFxuICAgICAgdG9nZ2xlOiBsXG4gICAgfSksIGggJiYgdGhpcy5pbml0aWFsaXplKCk7XG4gIH1cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgdGhlIG1lbnUgaXRlbS5cbiAgICpcbiAgICogSW5pdGlhbGl6ZSB3aWxsIGNhbGwgdGhlIEJhc2VNZW51SXRlbSdzIGluaXRpYWxpemUgbWV0aG9kXG4gICAqIGFzIHdlbGwgYXMgc2V0IHRoZSBtZW51IGl0ZW0ncyBgcm9sZWAgdG8gXCJub25lXCIsXG4gICAqIHRoZSBtZW51IGxpbmsncyBgcm9sZWAgdG8gXCJ0cmVlaXRlbVwiLCBhbmRcbiAgICogdGhlIG1lbnUgbGluaydzIGB0YWJJbmRleGAgdG8gLTEgaW4gdGhlIERPTS5cbiAgICovXG4gIGluaXRpYWxpemUoKSB7XG4gICAgc3VwZXIuaW5pdGlhbGl6ZSgpLCB0aGlzLmRvbS5pdGVtLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJub25lXCIpLCB0aGlzLmRvbS5saW5rLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJ0cmVlaXRlbVwiKSwgdGhpcy5kb20ubGluay50YWJJbmRleCA9IC0xO1xuICB9XG4gIC8qKlxuICAgKiBGb2N1c2VzIHRoZSBtZW51IGl0ZW0ncyBsaW5rIGlmIHRoZSBwYXJlbnQgbWVudSdzXG4gICAqIHNob3VsZEZvY3VzIHZhbHVlIGlzIGB0cnVlYC5cbiAgICpcbiAgICogVGhpcyB3aWxsIGNhbGwgdGhlIEJhc2VNZW51SXRlbSdzIGZvY3VzIG1ldGhvZFxuICAgKiBhcyB3ZWxsIGFzIHNldCB0aGUgbWVudSBsaW5rJ3MgYHRhYkluZGV4YCB0byAwLlxuICAgKi9cbiAgZm9jdXMoKSB7XG4gICAgc3VwZXIuZm9jdXMoKSwgdGhpcy5kb20ubGluay50YWJJbmRleCA9IDA7XG4gIH1cbiAgLyoqXG4gICAqIEJsdXJzIHRoZSBtZW51IGl0ZW0ncyBsaW5rIGlmIHRoZSBwYXJlbnQgbWVudSdzXG4gICAqIHNob3VsZEZvY3VzIHZhbHVlIGlzIGB0cnVlYC5cbiAgICpcbiAgICogVGhpcyB3aWxsIGNhbGwgdGhlIEJhc2VNZW51SXRlbSdzIGJsdXIgbWV0aG9kXG4gICAqIGFzIHdlbGwgYXMgc2V0IHRoZSBtZW51IGxpbmsncyBgdGFiSW5kZXhgIHRvIC0xLlxuICAgKi9cbiAgYmx1cigpIHtcbiAgICBzdXBlci5ibHVyKCksIHRoaXMuZG9tLmxpbmsudGFiSW5kZXggPSAtMTtcbiAgfVxufVxuY2xhc3MgZWUgZXh0ZW5kcyBMIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgYFRyZWV2aWV3VG9nZ2xlYC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9ICAgICAgb3B0aW9ucyAgICAgICAgICAgICAgICAgICAgIC0gVGhlIG9wdGlvbnMgZm9yIGdlbmVyYXRpbmcgdGhlIG1lbnUgdG9nZ2xlLlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBvcHRpb25zLm1lbnVUb2dnbGVFbGVtZW50ICAgLSBUaGUgdG9nZ2xlIGVsZW1lbnQgaW4gdGhlIERPTS5cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gb3B0aW9ucy5wYXJlbnRFbGVtZW50ICAgICAgIC0gVGhlIGVsZW1lbnQgY29udGFpbmluZyB0aGUgY29udHJvbGxlZCBtZW51LlxuICAgKiBAcGFyYW0ge1RyZWV2aWV3fSAgICBvcHRpb25zLmNvbnRyb2xsZWRNZW51ICAgICAgLSBUaGUgbWVudSBjb250cm9sbGVkIGJ5IHRoaXMgdG9nZ2xlLlxuICAgKiBAcGFyYW0gez9UcmVldmlld30gICBbb3B0aW9ucy5wYXJlbnRNZW51ID0gbnVsbF0gLSBUaGUgbWVudSBjb250YWluaW5nIHRoaXMgdG9nZ2xlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICBbb3B0aW9ucy5pbml0aWFsaXplID0gdHJ1ZV0gLSBBIGZsYWcgdG8gaW5pdGlhbGl6ZSB0aGUgbWVudSB0b2dnbGUgaW1tZWRpYXRlbHkgdXBvbiBjcmVhdGlvbi5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBtZW51VG9nZ2xlRWxlbWVudDogZSxcbiAgICBwYXJlbnRFbGVtZW50OiB0LFxuICAgIGNvbnRyb2xsZWRNZW51OiBzLFxuICAgIHBhcmVudE1lbnU6IG4gPSBudWxsLFxuICAgIGluaXRpYWxpemU6IGkgPSAhMFxuICB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgbWVudVRvZ2dsZUVsZW1lbnQ6IGUsXG4gICAgICBwYXJlbnRFbGVtZW50OiB0LFxuICAgICAgY29udHJvbGxlZE1lbnU6IHMsXG4gICAgICBwYXJlbnRNZW51OiBuXG4gICAgfSksIGkgJiYgdGhpcy5pbml0aWFsaXplKCk7XG4gIH1cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBtZW51IHRvZ2dsZS5cbiAgICpcbiAgICogVGhlIGZpcnN0IHN0ZXBzIGFyZSB0byBlbnN1cmUgdGhhdCB0aGUgdG9nZ2xlIGFuZCBjb250cm9sbGVkIG1lbnUgaGF2ZSBJRHNcbiAgICogdXNpbmcgdGhlIHNldElkcyBtZXRob2QsIGFuZCB0byBzZXQgdGhlIEFSSUEgYXR0cmlidXRlcyBvbiB0aGUgdG9nZ2xlXG4gICAqIGFuZCBjb250cm9sbGVkIG1lbnUgdXNpbmcgdGhlIHNldEFyaWFBdHRyaWJ1dGVzIG1ldGhvZC5cbiAgICpcbiAgICogVGhlbiB0aGUgb3BlbiBvciBjb2xsYXBzZSBtZXRob2QgaXMgY2FsbGVkIGJhc2VkIG9uIHRoZSBzdGF0ZSBvZiB0aGVcbiAgICogdG9nZ2xlJ3MgYXJpYS1leHBhbmRlZCBhdHRyaWJ1dGUuXG4gICAqL1xuICBpbml0aWFsaXplKCkge1xuICAgIHRoaXMuX3NldElkcygpLCB0aGlzLl9zZXRBcmlhQXR0cmlidXRlcygpLCB0aGlzLmRvbS50b2dnbGUuZ2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiKSA9PT0gXCJ0cnVlXCIgPyB0aGlzLm9wZW4oKSA6IHRoaXMuX2NvbGxhcHNlKCExKTtcbiAgfVxuICAvKipcbiAgICogU2V0cyB0aGUgQVJJQSBhdHRyaWJ1dGVzIG9uIHRoZSB0b2dnbGUgYW5kIGNvbnRyb2xsZWQgbWVudS5cbiAgICpcbiAgICogVGhlIGZpcnN0IHN0ZXBzIGFyZSB0byBlbnN1cmUgdGhhdCB0aGUgdG9nZ2xlIGhhcyBgYXJpYS1leHBhbmRlZGBcbiAgICogc2V0IHRvIFwiZmFsc2VcIiBpZiBpdCdzIG5vdCBhbHJlYWR5IHNldCBleHBsaWNpdGx5IHRvIFwidHJ1ZVwiLlxuICAgKlxuICAgKiBUaGVuIHVzaW5nIHRoZSB0b2dnbGUgYW5kIG1lbnUncyBJRHMsIHRoZSBtZW51J3MgYGFyaWEtbGFiZWxsZWRieWAgaXMgc2V0IHRvXG4gICAqIHRoZSB0b2dnbGUncyBJRCwgYW5kIHRoZSB0b2dnbGUncyBgYXJpYS1vd25zYCBpcyBzZXQgdG8gdGhlIG1lbnUncyBJRC5cbiAgICpcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX3NldEFyaWFBdHRyaWJ1dGVzKCkge1xuICAgIHRoaXMuZG9tLnRvZ2dsZS5nZXRBdHRyaWJ1dGUoXCJhcmlhLWV4cGFuZGVkXCIpICE9PSBcInRydWVcIiAmJiB0aGlzLmRvbS50b2dnbGUuc2V0QXR0cmlidXRlKFwiYXJpYS1leHBhbmRlZFwiLCBcImZhbHNlXCIpLCB0aGlzLmVsZW1lbnRzLmNvbnRyb2xsZWRNZW51LmRvbS5tZW51LnNldEF0dHJpYnV0ZShcbiAgICAgIFwiYXJpYS1sYWJlbGxlZGJ5XCIsXG4gICAgICB0aGlzLmRvbS50b2dnbGUuaWRcbiAgICApLCB0aGlzLmRvbS50b2dnbGUuc2V0QXR0cmlidXRlKFxuICAgICAgXCJhcmlhLW93bnNcIixcbiAgICAgIHRoaXMuZWxlbWVudHMuY29udHJvbGxlZE1lbnUuZG9tLm1lbnUuaWRcbiAgICApO1xuICB9XG59XG5jbGFzcyBqIGV4dGVuZHMgdyB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGBUcmVldmlld2AuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSAgICAgICAgICAgICBvcHRpb25zICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBUaGUgb3B0aW9ucyBmb3IgZ2VuZXJhdGluZyB0aGUgbWVudS5cbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gICAgICAgIG9wdGlvbnMubWVudUVsZW1lbnQgICAgICAgICAgICAgICAgICAgICAgICAtIFRoZSBtZW51IGVsZW1lbnQgaW4gdGhlIERPTS5cbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgIFtvcHRpb25zLm1lbnVJdGVtU2VsZWN0b3IgPSBsaV0gICAgICAgICAgICAtIFRoZSBxdWVyeSBzZWxlY3RvciBzdHJpbmcgZm9yIG1lbnUgaXRlbXMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSAgICAgICAgICAgICBbb3B0aW9ucy5tZW51TGlua1NlbGVjdG9yID0gYV0gICAgICAgICAgICAgLSBUaGUgcXVlcnkgc2VsZWN0b3Igc3RyaW5nIGZvciBtZW51IGxpbmtzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgW29wdGlvbnMuc3VibWVudUl0ZW1TZWxlY3RvciA9IGxpOmhhcyh1bCldIC0gVGhlIHF1ZXJ5IHNlbGVjdG9yIHN0cmluZyBmb3IgbWVudSBpdGVtcyBjb250YWluaW5nIHN1Ym1lbnVzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gICAgICAgICAgICAgW29wdGlvbnMuc3VibWVudVRvZ2dsZVNlbGVjdG9yID0gYV0gICAgICAgIC0gVGhlIHF1ZXJ5IHNlbGVjdG9yIHN0cmluZyBmb3Igc3VibWVudSB0b2dnbGUgYnV0dG9ucy9saW5rcy5cbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgIFtvcHRpb25zLnN1Ym1lbnVTZWxlY3RvciA9IHVsXSAgICAgICAgICAgICAtIFRoZSBxdWVyeSBzZWxlY3RvciBzdHJpbmcgZm9yIHN1Ym1lbnVzLlxuICAgKiBAcGFyYW0gez9IVE1MRWxlbWVudH0gICAgICAgW29wdGlvbnMuY29udHJvbGxlckVsZW1lbnQgPSBudWxsXSAgICAgICAgIC0gVGhlIGVsZW1lbnQgY29udHJvbGxpbmcgdGhlIG1lbnUgaW4gdGhlIERPTS5cbiAgICogQHBhcmFtIHs/SFRNTEVsZW1lbnR9ICAgICAgIFtvcHRpb25zLmNvbnRhaW5lckVsZW1lbnQgPSBudWxsXSAgICAgICAgICAtIFRoZSBlbGVtZW50IGNvbnRhaW5pbmcgdGhlIG1lbnUgaW4gdGhlIERPTS5cbiAgICogQHBhcmFtIHs/KHN0cmluZ3xzdHJpbmdbXSl9IFtvcHRpb25zLm9wZW5DbGFzcyA9IHNob3ddICAgICAgICAgICAgICAgICAtIFRoZSBjbGFzcyB0byBhcHBseSB3aGVuIGEgbWVudSBpcyBcIm9wZW5cIi5cbiAgICogQHBhcmFtIHs/KHN0cmluZ3xzdHJpbmdbXSl9IFtvcHRpb25zLmNsb3NlQ2xhc3MgPSBoaWRlXSAgICAgICAgICAgICAgICAtIFRoZSBjbGFzcyB0byBhcHBseSB3aGVuIGEgbWVudSBpcyBcImNsb3NlZFwiLlxuICAgKiBAcGFyYW0gez8oc3RyaW5nfHN0cmluZ1tdKX0gW29wdGlvbnMudHJhbnNpdGlvbkNsYXNzID0gdHJhbnNpdGlvbmluZ10gIC0gVGhlIGNsYXNzIHRvIGFwcGx5IHdoZW4gYSBtZW51IGlzIHRyYW5zaXRpb25pbmcgYmV0d2VlbiBcIm9wZW5cIiBhbmQgXCJjbG9zZWRcIiBzdGF0ZXMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSAgICAgICAgICAgICBbb3B0aW9ucy50cmFuc2l0aW9uRHVyYXRpb24gPSAyNTBdICAgICAgICAgLSBUaGUgZHVyYXRpb24gb2YgdGhlIHRyYW5zaXRpb24gYmV0d2VlbiBcIm9wZW5cIiBhbmQgXCJjbG9zZWRcIiBzdGF0ZXMgKGluIG1pbGxpc2Vjb25kcykuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gICAgICAgICAgICBbb3B0aW9ucy5pc1RvcExldmVsID0gdHJ1ZV0gICAgICAgICAgICAgICAgLSBBIGZsYWcgdG8gbWFyayB0aGUgcm9vdCBtZW51LlxuICAgKiBAcGFyYW0gez9UcmVldmlld30gICAgICAgICAgW29wdGlvbnMucGFyZW50TWVudSA9IG51bGxdICAgICAgICAgICAgICAgIC0gVGhlIHBhcmVudCBtZW51IHRvIHRoaXMgbWVudS5cbiAgICogQHBhcmFtIHtzdHJpbmd9ICAgICAgICAgICAgIFtvcHRpb25zLmhvdmVyVHlwZSA9IG9mZl0gICAgICAgICAgICAgICAgICAtIFRoZSB0eXBlIG9mIGhvdmVyYWJpbGl0eSBhIG1lbnUgaGFzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gICAgICAgICAgICAgW29wdGlvbnMuaG92ZXJEZWxheSA9IDI1MF0gICAgICAgICAgICAgICAgIC0gVGhlIGRlbGF5IGZvciBvcGVuaW5nIGFuZCBjbG9zaW5nIG1lbnVzIGlmIHRoZSBtZW51IGlzIGhvdmVyYWJsZSAoaW4gbWlsbGlzZWNvbmRzKS5cbiAgICogQHBhcmFtIHtudW1iZXJ9ICAgICAgICAgICAgIFtvcHRpb25zLmVudGVyRGVsYXkgPSAtMV0gICAgICAgICAgICAgICAgICAtIFRoZSBkZWxheSBmb3Igb3BlbmluZyBhIG1lbnUgaWYgdGhlIG1lbnUgaXMgZm9jdXNhYmxlIChpbiBtaWxsaXNlY29uZHMpLlxuICAgKiBAcGFyYW0ge251bWJlcn0gICAgICAgICAgICAgW29wdGlvbnMubGVhdmVEZWxheSA9IC0xXSAgICAgICAgICAgICAgICAgIC0gVGhlIGRlbGF5IGZvciBjbG9zaW5nIGEgbWVudSBpZiB0aGUgbWVudSBpcyBmb2N1c2FibGUgKGluIG1pbGxpc2Vjb25kcykuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gICAgICAgICAgICBbb3B0aW9ucy5wcmVmaXggPSBhbS1dICAgICAgICAgICAgICAgICAgICAgLSBUaGUgcHJlZml4IHRvIHVzZSBmb3IgQ1NTIGN1c3RvbSBwcm9wZXJ0aWVzLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59ICAgICAgICAgICAgW29wdGlvbnMuaW5pdGlhbGl6ZSA9IHRydWVdICAgICAgICAgICAgICAgIC0gQSBmbGFnIHRvIGluaXRpYWxpemUgdGhlIG1lbnUgaW1tZWRpYXRlbHkgdXBvbiBjcmVhdGlvbi5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBtZW51RWxlbWVudDogdCxcbiAgICBtZW51SXRlbVNlbGVjdG9yOiBzID0gXCJsaVwiLFxuICAgIG1lbnVMaW5rU2VsZWN0b3I6IG4gPSBcImFcIixcbiAgICBzdWJtZW51SXRlbVNlbGVjdG9yOiBpID0gXCJsaTpoYXModWwpXCIsXG4gICAgc3VibWVudVRvZ2dsZVNlbGVjdG9yOiBsID0gXCJhXCIsXG4gICAgc3VibWVudVNlbGVjdG9yOiBoID0gXCJ1bFwiLFxuICAgIGNvbnRyb2xsZXJFbGVtZW50OiBtID0gbnVsbCxcbiAgICBjb250YWluZXJFbGVtZW50OiBhID0gbnVsbCxcbiAgICBvcGVuQ2xhc3M6IHAgPSBcInNob3dcIixcbiAgICBjbG9zZUNsYXNzOiBmID0gXCJoaWRlXCIsXG4gICAgdHJhbnNpdGlvbkNsYXNzOiBnID0gXCJ0cmFuc2l0aW9uaW5nXCIsXG4gICAgdHJhbnNpdGlvbkR1cmF0aW9uOiBkID0gMjUwLFxuICAgIGlzVG9wTGV2ZWw6IE0gPSAhMCxcbiAgICBwYXJlbnRNZW51OiB5ID0gbnVsbCxcbiAgICBob3ZlclR5cGU6IGIgPSBcIm9mZlwiLFxuICAgIGhvdmVyRGVsYXk6IEMgPSAyNTAsXG4gICAgZW50ZXJEZWxheTogVCA9IC0xLFxuICAgIGxlYXZlRGVsYXk6IEUgPSAtMSxcbiAgICBwcmVmaXg6IHYgPSBcImFtLVwiLFxuICAgIGluaXRpYWxpemU6IEkgPSAhMFxuICB9KSB7XG4gICAgc3VwZXIoe1xuICAgICAgbWVudUVsZW1lbnQ6IHQsXG4gICAgICBtZW51SXRlbVNlbGVjdG9yOiBzLFxuICAgICAgbWVudUxpbmtTZWxlY3RvcjogbixcbiAgICAgIHN1Ym1lbnVJdGVtU2VsZWN0b3I6IGksXG4gICAgICBzdWJtZW51VG9nZ2xlU2VsZWN0b3I6IGwsXG4gICAgICBzdWJtZW51U2VsZWN0b3I6IGgsXG4gICAgICBjb250cm9sbGVyRWxlbWVudDogbSxcbiAgICAgIGNvbnRhaW5lckVsZW1lbnQ6IGEsXG4gICAgICBvcGVuQ2xhc3M6IHAsXG4gICAgICBjbG9zZUNsYXNzOiBmLFxuICAgICAgdHJhbnNpdGlvbkNsYXNzOiBnLFxuICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uOiBkLFxuICAgICAgaXNUb3BMZXZlbDogTSxcbiAgICAgIHBhcmVudE1lbnU6IHksXG4gICAgICBob3ZlclR5cGU6IGIsXG4gICAgICBob3ZlckRlbGF5OiBDLFxuICAgICAgZW50ZXJEZWxheTogVCxcbiAgICAgIGxlYXZlRGVsYXk6IEUsXG4gICAgICBwcmVmaXg6IHZcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBUaGUgY2xhc3MgdG8gdXNlIHdoZW4gZ2VuZXJhdGluZyBzdWJtZW51cy5cbiAgICAgKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKlxuICAgICAqIEB0eXBlIHt0eXBlb2YgVHJlZXZpZXd9XG4gICAgICovXG4gICAgdSh0aGlzLCBcIl9NZW51VHlwZVwiLCBqKTtcbiAgICAvKipcbiAgICAgKiBUaGUgY2xhc3MgdG8gdXNlIHdoZW4gZ2VuZXJhdGluZyBtZW51IGl0ZW1zLlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqXG4gICAgICogQHR5cGUge3R5cGVvZiBUcmVldmlld0l0ZW19XG4gICAgICovXG4gICAgdSh0aGlzLCBcIl9NZW51SXRlbVR5cGVcIiwgWSk7XG4gICAgLyoqXG4gICAgICogVGhlIGNsYXNzIHRvIHVzZSB3aGVuIGdlbmVyYXRpbmcgc3VibWVudSB0b2dnbGVzLlxuICAgICAqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqXG4gICAgICogQHR5cGUge3R5cGVvZiBUcmVldmlld1RvZ2dsZX1cbiAgICAgKi9cbiAgICB1KHRoaXMsIFwiX01lbnVUb2dnbGVUeXBlXCIsIGVlKTtcbiAgICBJICYmIHRoaXMuaW5pdGlhbGl6ZSgpO1xuICB9XG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgbWVudS5cbiAgICpcbiAgICogSW5pdGlhbGl6ZSB3aWxsIGNhbGwgdGhlIEJhc2VNZW51J3MgaW5pdGlhbGl6ZSBtZXRob2RcbiAgICogYXMgd2VsbCBhcyBzZXQgdXAgZm9jdXMsXG4gICAqIGNsaWNrLFxuICAgKiBob3ZlcixcbiAgICoga2V5ZG93biwgYW5kXG4gICAqIGtleXVwIGV2ZW50cyBmb3IgdGhlIG1lbnUuXG4gICAqXG4gICAqIElmIHRoZSBtZW51IGlzIGEgcm9vdCBtZW51IGl0J3MgYHJvbGVgIHdpbGwgYmUgc2V0IHRvIFwidHJlZVwiIGFuZCB0aGUgZmlyc3RcbiAgICogbWVudSBpdGVtJ3MgYHRhYkluZGV4YCB3aWxsIGJlIHNldCB0byAwIGluIHRoZSBET00uXG4gICAqXG4gICAqIElmIHRoZSBtZW51IGlzIF9ub3RfIGEgcm9vdCBtZW51IGl0J3MgYHJvbGVgIHdpbGwgYmUgc2V0IHRvIFwiZ3JvdXBcIi5cbiAgICpcbiAgICogSWYgdGhlIEJhc2VNZW51J3MgaW5pdGlhbGl6ZSBtZXRob2QgdGhyb3dzIGFuIGVycm9yLFxuICAgKiB0aGlzIHdpbGwgY2F0Y2ggaXQgYW5kIGxvZyBpdCB0byB0aGUgY29uc29sZS5cbiAgICovXG4gIGluaXRpYWxpemUoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHN1cGVyLmluaXRpYWxpemUoKSwgdGhpcy5pc1RvcExldmVsID8gKHRoaXMuZG9tLm1lbnUuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcInRyZWVcIiksIHRoaXMuZWxlbWVudHMubWVudUl0ZW1zWzBdLmRvbS5saW5rLnRhYkluZGV4ID0gMCkgOiB0aGlzLmRvbS5tZW51LnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJncm91cFwiKSwgdGhpcy5faGFuZGxlRm9jdXMoKSwgdGhpcy5faGFuZGxlQ2xpY2soKSwgdGhpcy5faGFuZGxlSG92ZXIoKSwgdGhpcy5faGFuZGxlS2V5ZG93bigpLCB0aGlzLl9oYW5kbGVLZXl1cCgpLCB0aGlzLmlzVG9wTGV2ZWwgJiYgdGhpcy5lbGVtZW50cy5jb250cm9sbGVyICYmIHRoaXMuZWxlbWVudHMuY29udHJvbGxlci5kb20udG9nZ2xlLnJlbW92ZUF0dHJpYnV0ZShcImFyaWEtb3duc1wiKTtcbiAgICB9IGNhdGNoICh0KSB7XG4gICAgICBjb25zb2xlLmVycm9yKHQpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogSGFuZGxlcyBob3ZlciBldmVudHMgdGhyb3VnaG91dCB0aGUgbWVudSBmb3IgcHJvcGVyIHVzZS5cbiAgICpcbiAgICogQWRkcyBgcG9pbnRlcmVudGVyYCBsaXN0ZW5lcnMgdG8gYWxsIG1lbnUgaXRlbXMgYW5kIGBwb2ludGVybGVhdmVgIGxpc3RlbmVyc1xuICAgKiB0byBhbGwgc3VibWVudSBpdGVtcyB3aGljaCBmdW5jdGlvbiBkaWZmZXJlbnRseSBkZXBlbmRpbmcgb25cbiAgICogdGhlIG1lbnUncyBob3ZlciB0eXBlLlxuICAgKlxuICAgKiBCZWZvcmUgZXhlY3V0aW5nIGFueXRoaW5nLCB0aGUgZXZlbnQgaXMgY2hlY2tlZCB0byBtYWtlIHN1cmUgdGhlIGV2ZW50IHdhc24ndFxuICAgKiB0cmlnZ2VyZWQgYnkgYSBwZW4gb3IgdG91Y2guXG4gICAqXG4gICAqIDxzdHJvbmc+SG92ZXIgVHlwZSBcIm9uXCI8L3N0cm9uZz5cbiAgICogLSBXaGVuIGEgYHBvaW50ZXJlbnRlcmAgZXZlbnQgdHJpZ2dlcnMgb24gYW55IG1lbnUgaXRlbSB0aGUgbWVudSdzXG4gICAqICAgIGN1cnJlbnQgY2hpbGQgdmFsdWUgd2lsbCBjaGFuZ2UgdG8gdGhhdFxuICAgKiAgIG1lbnUgaXRlbS5cbiAgICogLSBXaGVuIGEgYHBvaW50ZXJlbnRlcmAgZXZlbnQgdHJpZ2dlcnMgb24gYSBzdWJtZW51IGl0ZW0gdGhlXG4gICAqICAgcHJldmlldyBtZXRob2QgZm9yIHRoZSBzdWJtZW51IGl0ZW0nc1xuICAgKiAgIHRvZ2dsZSB3aWxsIGJlIGNhbGxlZC5cbiAgICogLSBXaGVuIGEgYHBvaW50ZXJsZWF2ZWAgZXZlbnQgdHJpZ2dlcnMgb24gdGhlIG1lbnUgaXRzZWxmIHRoZVxuICAgKiAgIGNsb3NlQ2hpbGRyZW4gbWV0aG9kIHdpbGwgYmUgY2FsbGVkIGFmdGVyIGEgZGVsYXlcbiAgICogICBzZXQgYnkgdGhlIG1lbnUncyBob3ZlciBkZWxheS5cbiAgICpcbiAgICogPHN0cm9uZz5Ib3ZlciBUeXBlIFwiZHluYW1pY1wiPC9zdHJvbmc+XG4gICAqIC0gV2hlbiBhIGBwb2ludGVyZW50ZXJgIGV2ZW50IHRyaWdnZXJzIG9uIGFueSBtZW51IGl0ZW0gdGhlIG1lbnUnc1xuICAgKiAgIGN1cnJlbnQgY2hpbGQgdmFsdWUgd2lsbCBjaGFuZ2UgdG8gdGhhdCBtZW51IGl0ZW0uXG4gICAqIC0gV2hlbiBhIGBwb2ludGVyZW50ZXJgIGV2ZW50IHRyaWdnZXJzIG9uIGFueSBtZW51IGl0ZW0sIGFuZCB0aGUgbWVudSdzXG4gICAqICAgZm9jdXMgc3RhdGUgaXMgbm90IFwibm9uZVwiLCB0aGUgbWVudSBpdGVtXG4gICAqICAgd2lsbCBiZSBmb2N1c2VkLlxuICAgKiAtIFdoZW4gYSBgcG9pbnRlcmVudGVyYCBldmVudCB0cmlnZ2VycyBvbiBhIHN1Ym1lbnUgaXRlbSwgYW5kIGEgc3VibWVudSBpc1xuICAgKiAgIGFscmVhZHkgb3BlbiwgdGhlIHByZXZpZXcgbWV0aG9kIGZvciB0aGUgc3VibWVudSBpdGVtJ3MgdG9nZ2xlIHdpbGwgYmUgY2FsbGVkLlxuICAgKiAtIFdoZW4gYSBgcG9pbnRlcmVudGVyYCBldmVudCB0cmlnZ2VycyBvbiBhIG5vbi1zdWJtZW51IGl0ZW0sIGFuZCBhIHN1Ym1lbnVcbiAgICogICBpcyBhbHJlYWR5IG9wZW4sIHRoZSBjbG9zZUNoaWxkcmVuIG1ldGhvZCBmb3IgdGhlIG1lbnUgd2lsbCBiZSBjYWxsZWQuXG4gICAqIC0gV2hlbiBhIGBwb2ludGVyZW50ZXJgIGV2ZW50IHRyaWdnZXJzIG9uIGEgc3VibWVudSBpdGVtLCBhbmQgbm8gc3VibWVudSBpc1xuICAgKiAgIG9wZW4sIG5vIHN1Ym1lbnUtc3BlY2lmaWMgbWV0aG9kcyB3aWxsIGJlIGNhbGxlZC5cbiAgICpcbiAgICogPHN0cm9uZz5Ib3ZlciBUeXBlIFwib2ZmXCI8L3N0cm9uZz5cbiAgICogQWxsIGBwb2ludGVyZW50ZXJgIGFuZCBgcG9pbnRlcmxlYXZlYCBldmVudHMgYXJlIGlnbm9yZWQuXG4gICAqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9oYW5kbGVIb3ZlcigpIHtcbiAgICB0aGlzLmVsZW1lbnRzLm1lbnVJdGVtcy5mb3JFYWNoKCh0LCBzKSA9PiB7XG4gICAgICB0LmRvbS5saW5rLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZW50ZXJcIiwgKG4pID0+IHtcbiAgICAgICAgbi5wb2ludGVyVHlwZSA9PT0gXCJwZW5cIiB8fCBuLnBvaW50ZXJUeXBlID09PSBcInRvdWNoXCIgfHwgKHRoaXMuaG92ZXJUeXBlID09PSBcIm9uXCIgPyAodGhpcy5jdXJyZW50RXZlbnQgPSBcIm1vdXNlXCIsIHRoaXMuZWxlbWVudHMucm9vdE1lbnUuYmx1ckNoaWxkcmVuKCksIHRoaXMuZm9jdXNDaGlsZChzKSwgdC5pc1N1Ym1lbnVJdGVtICYmICh0aGlzLmVudGVyRGVsYXkgPiAwID8gKHRoaXMuX2NsZWFyVGltZW91dCgpLCB0aGlzLl9zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0LmVsZW1lbnRzLnRvZ2dsZS5wcmV2aWV3KCk7XG4gICAgICAgIH0sIHRoaXMuZW50ZXJEZWxheSkpIDogdC5lbGVtZW50cy50b2dnbGUucHJldmlldygpKSkgOiB0aGlzLmhvdmVyVHlwZSA9PT0gXCJkeW5hbWljXCIgJiYgKHRoaXMuY3VycmVudENoaWxkID0gcywgKCF0aGlzLmlzVG9wTGV2ZWwgfHwgdGhpcy5mb2N1c1N0YXRlICE9PSBcIm5vbmVcIikgJiYgKHRoaXMuY3VycmVudEV2ZW50ID0gXCJtb3VzZVwiLCB0aGlzLmVsZW1lbnRzLnJvb3RNZW51LmJsdXJDaGlsZHJlbigpLCB0aGlzLmZvY3VzQ3VycmVudENoaWxkKCkpLCAoIXRoaXMuaXNUb3BMZXZlbCB8fCB0aGlzLmhhc09wZW5lZCkgJiYgKHRoaXMuY3VycmVudEV2ZW50ID0gXCJtb3VzZVwiLCB0aGlzLmVsZW1lbnRzLnJvb3RNZW51LmJsdXJDaGlsZHJlbigpLCB0aGlzLmZvY3VzQ3VycmVudENoaWxkKCksIHQuaXNTdWJtZW51SXRlbSA/IHRoaXMuZW50ZXJEZWxheSA+IDAgPyAodGhpcy5fY2xlYXJUaW1lb3V0KCksIHRoaXMuX3NldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHQuZWxlbWVudHMudG9nZ2xlLnByZXZpZXcoKTtcbiAgICAgICAgfSwgdGhpcy5lbnRlckRlbGF5KSkgOiB0LmVsZW1lbnRzLnRvZ2dsZS5wcmV2aWV3KCkgOiB0aGlzLmVudGVyRGVsYXkgPiAwICYmIHRoaXMuX2NsZWFyVGltZW91dCgpKSkpO1xuICAgICAgfSksIHQuaXNTdWJtZW51SXRlbSAmJiAodC5kb20uaXRlbS5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmxlYXZlXCIsIChuKSA9PiB7XG4gICAgICAgIG4ucG9pbnRlclR5cGUgPT09IFwicGVuXCIgfHwgbi5wb2ludGVyVHlwZSA9PT0gXCJ0b3VjaFwiIHx8ICh0aGlzLmhvdmVyVHlwZSA9PT0gXCJvblwiID8gdGhpcy5sZWF2ZURlbGF5ID4gMCAmJiB0aGlzLl9jbGVhclRpbWVvdXQoKSA6IHRoaXMuaG92ZXJUeXBlID09PSBcImR5bmFtaWNcIiAmJiAodGhpcy5sZWF2ZURlbGF5ID4gMCA/ICh0aGlzLl9jbGVhclRpbWVvdXQoKSwgdGhpcy5fc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5jdXJyZW50RXZlbnQgPSBcIm1vdXNlXCI7XG4gICAgICAgIH0sIHRoaXMubGVhdmVEZWxheSkpIDogdGhpcy5jdXJyZW50RXZlbnQgPSBcIm1vdXNlXCIpKTtcbiAgICAgIH0pLCB0LmRvbS5pdGVtLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZW50ZXJcIiwgKG4pID0+IHtcbiAgICAgICAgbi5wb2ludGVyVHlwZSA9PT0gXCJwZW5cIiB8fCBuLnBvaW50ZXJUeXBlID09PSBcInRvdWNoXCIgfHwgdC5pc1N1Ym1lbnVJdGVtICYmICh0aGlzLmhvdmVyVHlwZSA9PT0gXCJvblwiIHx8IHRoaXMuaG92ZXJUeXBlID09PSBcImR5bmFtaWNcIikgJiYgdGhpcy5sZWF2ZURlbGF5ID4gMCAmJiB0aGlzLl9jbGVhclRpbWVvdXQoKTtcbiAgICAgIH0pKSwgdGhpcy5pc1RvcExldmVsICYmIHRoaXMuZG9tLm1lbnUuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJsZWF2ZVwiLCAobikgPT4ge1xuICAgICAgICBuLnBvaW50ZXJUeXBlID09PSBcInBlblwiIHx8IG4ucG9pbnRlclR5cGUgPT09IFwidG91Y2hcIiB8fCB0aGlzLmhvdmVyVHlwZSA9PT0gXCJvblwiICYmICh0aGlzLmxlYXZlRGVsYXkgPiAwID8gKHRoaXMuX2NsZWFyVGltZW91dCgpLCB0aGlzLl9zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICB0aGlzLmNsb3NlQ2hpbGRyZW4oKSwgdGhpcy5ibHVyKCk7XG4gICAgICAgIH0sIHRoaXMubGVhdmVEZWxheSkpIDogKHRoaXMuY2xvc2VDaGlsZHJlbigpLCB0aGlzLmJsdXIoKSkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZXMga2V5ZG93biBldmVudHMgdGhyb3VnaG91dCB0aGUgbWVudSBmb3IgcHJvcGVyIG1lbnUgdXNlLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBleGlzdHMgdG8gYXNzaXN0IHRoZSBfaGFuZGxlS2V5dXAgbWV0aG9kLlxuICAgKiAtIEFkZHMgYWxsIGBrZXlkb3duYCBsaXN0ZW5lcnMgZnJvbSBCYXNlTWVudSdzIF9oYW5kbGVLZXlkb3duIG1ldGhvZFxuICAgKiAtIEFkZHMgYSBga2V5ZG93bmAgbGlzdGVuZXIgdG8gdGhlIG1lbnUvYWxsIHN1Ym1lbnVzLlxuICAgKiAgIC0gQmxvY2tzIHByb3BhZ2F0aW9uIG9uIHRoZSBmb2xsb3dpbmcga2V5czogXCJBcnJvd1VwXCIsIFwiQXJyb3dSaWdodFwiLFxuICAgKiAgICAgXCJBcnJvd0Rvd25cIiwgXCJBcnJvd0xlZnRcIiwgXCJIb21lXCIsIFwiRW5kXCIsIFwiU3BhY2VcIiwgXCJFbnRlclwiLCBcIkVzY2FwZVwiLFxuICAgKiAgICAgXCIqXCIgKGFzdGVyaXNrKSwgYW5kIFwiQVwiIHRocm91Z2ggXCJaXCIuXG4gICAqICAgLSBNb3ZlcyBmb2N1cyBvdXQgaWYgdGhlIFwiVGFiXCIga2V5IGlzIHByZXNzZWQuXG4gICAqXG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIF9oYW5kbGVLZXlkb3duKCkge1xuICAgIHN1cGVyLl9oYW5kbGVLZXlkb3duKCksIHRoaXMuZG9tLm1lbnUuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgKHQpID0+IHtcbiAgICAgIHRoaXMuY3VycmVudEV2ZW50ID0gXCJrZXlib2FyZFwiO1xuICAgICAgY29uc3QgcyA9IF8odCk7XG4gICAgICBpZiAocyA9PT0gXCJUYWJcIiAmJiAodGhpcy5lbGVtZW50cy5yb290TWVudS5mb2N1c1N0YXRlICE9PSBcIm5vbmVcIiA/IHRoaXMuZWxlbWVudHMucm9vdE1lbnUuYmx1cigpIDogdGhpcy5lbGVtZW50cy5yb290TWVudS5mb2N1cygpKSwgdGhpcy5mb2N1c1N0YXRlID09PSBcInNlbGZcIikge1xuICAgICAgICBjb25zdCBuID0gW1xuICAgICAgICAgIFwiU3BhY2VcIixcbiAgICAgICAgICBcIkVudGVyXCIsXG4gICAgICAgICAgXCJBcnJvd1VwXCIsXG4gICAgICAgICAgXCJBcnJvd0Rvd25cIixcbiAgICAgICAgICBcIkFycm93TGVmdFwiLFxuICAgICAgICAgIFwiQXN0ZXJpc2tcIixcbiAgICAgICAgICBcIkhvbWVcIixcbiAgICAgICAgICBcIkVuZFwiXG4gICAgICAgIF0sIGkgPSBbXCJBcnJvd1JpZ2h0XCJdLCBsID0gW1wiRXNjYXBlXCJdO1xuICAgICAgICAobi5pbmNsdWRlcyhzKSB8fCB0aGlzLmN1cnJlbnRNZW51SXRlbS5pc1N1Ym1lbnVJdGVtICYmIGkuaW5jbHVkZXMocykgfHwgdGhpcy5lbGVtZW50cy5jb250cm9sbGVyICYmIGwuaW5jbHVkZXMocykpICYmIG8odCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZXMga2V5dXAgZXZlbnRzIHRocm91Z2hvdXQgdGhlIG1lbnUgZm9yIHByb3BlciBtZW51IHVzZS5cbiAgICpcbiAgICogQWRkcyBhbGwgYGtleXVwYCBsaXN0ZW5lcnMgZnJvbSBCYXNlTWVudSdzIF9oYW5kbGVLZXl1cCBtZXRob2QuXG4gICAqXG4gICAqIEFkZHMgdGhlIGZvbGxvd2luZyBrZXliaW5kaW5ncyAoZXhwbGFuYXRpb25zIGFyZSB0YWtlbiBmcm9tIHRoZVxuICAgKiBOYXZpZ2F0aW9uIFRyZWV2aWV3IEV4YW1wbGUgVXNpbmcgQ29tcHV0ZWQgUHJvcGVydGllcyk6XG4gICAqXG4gICAqIHwgS2V5IHwgRnVuY3Rpb24gfFxuICAgKiB8IC0tLSB8IC0tLSB8XG4gICAqIHwgX0VudGVyXyBvciBfU3BhY2VfIHwgUGVyZm9ybXMgdGhlIGRlZmF1bHQgYWN0aW9uIChlLmcuIG9uY2xpY2sgZXZlbnQpIGZvciB0aGUgZm9jdXNlZCBub2RlLiB8XG4gICAqIHwgX0Rvd24gYXJyb3dfIHwgPHVsPjxsaT5Nb3ZlcyBmb2N1cyB0byB0aGUgbmV4dCBub2RlIHRoYXQgaXMgZm9jdXNhYmxlIHdpdGhvdXQgb3BlbmluZyBvciBjbG9zaW5nIGEgbm9kZS48L2xpPjxsaT5JZiBmb2N1cyBpcyBvbiB0aGUgbGFzdCBub2RlLCBkb2VzIG5vdGhpbmcuPC9saT48L3VsPiB8XG4gICAqIHwgX1VwIGFycm93XyB8IDx1bD48bGk+TW92ZXMgZm9jdXMgdG8gdGhlIHByZXZpb3VzIG5vZGUgdGhhdCBpcyBmb2N1c2FibGUgd2l0aG91dCBvcGVuaW5nIG9yIGNsb3NpbmcgYSBub2RlLjwvbGk+PGxpPklmIGZvY3VzIGlzIG9uIHRoZSBmaXJzdCBub2RlLCBkb2VzIG5vdGhpbmcuPC9saT48L3VsPiB8XG4gICAqIHwgX1JpZ2h0IGFycm93XyB8IDx1bD48bGk+V2hlbiBmb2N1cyBpcyBvbiBhIGNsb3NlZCBub2RlLCBvcGVucyB0aGUgbm9kZTsgZm9jdXMgZG9lcyBub3QgbW92ZS48L2xpPjxsaT5XaGVuIGZvY3VzIGlzIG9uIGEgb3BlbiBub2RlLCBtb3ZlcyBmb2N1cyB0byB0aGUgZmlyc3QgY2hpbGQgbm9kZS48L2xpPjxsaT5XaGVuIGZvY3VzIGlzIG9uIGFuIGVuZCBub2RlLCBkb2VzIG5vdGhpbmcuPC9saT48L3VsPiB8XG4gICAqIHwgX0xlZnQgYXJyb3dfIHwgPHVsPjxsaT5XaGVuIGZvY3VzIGlzIG9uIGFuIG9wZW4gbm9kZSwgY2xvc2VzIHRoZSBub2RlLjwvbGk+PGxpPldoZW4gZm9jdXMgaXMgb24gYSBjaGlsZCBub2RlIHRoYXQgaXMgYWxzbyBlaXRoZXIgYW4gZW5kIG5vZGUgb3IgYSBjbG9zZWQgbm9kZSwgbW92ZXMgZm9jdXMgdG8gaXRzIHBhcmVudCBub2RlLjwvbGk+PGxpPldoZW4gZm9jdXMgaXMgb24gYSByb290IG5vZGUgdGhhdCBpcyBhbHNvIGVpdGhlciBhbiBlbmQgbm9kZSBvciBhIGNsb3NlZCBub2RlLCBkb2VzIG5vdGhpbmcuPC9saT48L3VsPiB8XG4gICAqIHwgX0hvbWVfIHwgTW92ZXMgZm9jdXMgdG8gZmlyc3Qgbm9kZSB3aXRob3V0IG9wZW5pbmcgb3IgY2xvc2luZyBhIG5vZGUuIHxcbiAgICogfCBfRW5kXyB8IE1vdmVzIGZvY3VzIHRvIHRoZSBsYXN0IG5vZGUgdGhhdCBjYW4gYmUgZm9jdXNlZCB3aXRob3V0IGV4cGFuZGluZyBhbnkgbm9kZXMgdGhhdCBhcmUgY2xvc2VkLiB8XG4gICAqIHwgX2Etel8sIF9BLVpfIHwgPHVsPjxsaT5Gb2N1cyBtb3ZlcyB0byB0aGUgbmV4dCBub2RlIHdpdGggYSBuYW1lIHRoYXQgc3RhcnRzIHdpdGggdGhlIHR5cGVkIGNoYXJhY3Rlci48L2xpPjxsaT5TZWFyY2ggd3JhcHMgdG8gZmlyc3Qgbm9kZSBpZiBhIG1hdGNoaW5nIG5hbWUgaXMgbm90IGZvdW5kIGFtb25nIHRoZSBub2RlcyB0aGF0IGZvbGxvdyB0aGUgZm9jdXNlZCBub2RlLjwvbGk+PGxpPlNlYXJjaCBpZ25vcmVzIG5vZGVzIHRoYXQgYXJlIGRlc2NlbmRhbnRzIG9mIGNsb3NlZCBub2Rlcy48L2xpPjwvdWw+IHxcbiAgICogfCBfKiAoYXN0ZXJpc2spXyB8IDx1bD48bGk+RXhwYW5kcyBhbGwgY2xvc2VkIHNpYmxpbmcgbm9kZXMgdGhhdCBhcmUgYXQgdGhlIHNhbWUgbGV2ZWwgYXMgdGhlIGZvY3VzZWQgbm9kZS48L2xpPjxsaT5Gb2N1cyBkb2VzIG5vdCBtb3ZlLjwvbGk+PC91bD4gfFxuICAgKiB8IF9Fc2NhcGVfIHwgSWYgdGhlIHJvb3QgbWVudSBpcyBjb2xsYXBzaWJsZSwgY29sbGFwc2VzIHRoZSBtZW51IGFuZCBmb2N1c2VzIHRoZSBtZW51J3MgY29udHJvbGxpbmcgZWxlbWVudC4gfFxuICAgKlxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBfaGFuZGxlS2V5dXAoKSB7XG4gICAgc3VwZXIuX2hhbmRsZUtleXVwKCksIHRoaXMuZG9tLm1lbnUuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsICh0KSA9PiB7XG4gICAgICB0aGlzLmN1cnJlbnRFdmVudCA9IFwia2V5Ym9hcmRcIjtcbiAgICAgIGNvbnN0IHMgPSBfKHQpLCB7IGFsdEtleTogbiwgY3J0bEtleTogaSwgbWV0YUtleTogbCB9ID0gdDtcbiAgICAgIGlmIChzID09PSBcIkNoYXJhY3RlclwiICYmICEobiB8fCBpIHx8IGwpKVxuICAgICAgICBvKHQpLCB0aGlzLmVsZW1lbnRzLnJvb3RNZW51LmN1cnJlbnRFdmVudCA9IFwiY2hhcmFjdGVyXCIsIHRoaXMuZm9jdXNOZXh0Tm9kZVdpdGhDaGFyYWN0ZXIodC5rZXkpO1xuICAgICAgZWxzZSBpZiAodGhpcy5mb2N1c1N0YXRlID09PSBcInNlbGZcIilcbiAgICAgICAgaWYgKHMgPT09IFwiRW50ZXJcIiB8fCBzID09PSBcIlNwYWNlXCIpXG4gICAgICAgICAgbyh0KSwgdGhpcy5jdXJyZW50TWVudUl0ZW0uaXNTdWJtZW51SXRlbSA/IHRoaXMuY3VycmVudE1lbnVJdGVtLmVsZW1lbnRzLnRvZ2dsZS5pc09wZW4gPyB0aGlzLmN1cnJlbnRNZW51SXRlbS5lbGVtZW50cy50b2dnbGUuY2xvc2UoKSA6IHRoaXMuY3VycmVudE1lbnVJdGVtLmVsZW1lbnRzLnRvZ2dsZS5wcmV2aWV3KCkgOiB0aGlzLmN1cnJlbnRNZW51SXRlbS5kb20ubGluay5jbGljaygpO1xuICAgICAgICBlbHNlIGlmIChzID09PSBcIkVzY2FwZVwiKVxuICAgICAgICAgIHRoaXMuaXNUb3BMZXZlbCAmJiB0aGlzLmVsZW1lbnRzLmNvbnRyb2xsZXIgJiYgdGhpcy5lbGVtZW50cy5jb250cm9sbGVyLmlzT3BlbiAmJiAodGhpcy5lbGVtZW50cy5jb250cm9sbGVyLmNsb3NlKCksIHRoaXMuZm9jdXNDb250cm9sbGVyKCkpO1xuICAgICAgICBlbHNlIGlmIChzID09PSBcIkFycm93RG93blwiKVxuICAgICAgICAgIG8odCksIHRoaXMuY3VycmVudE1lbnVJdGVtLmlzU3VibWVudUl0ZW0gJiYgdGhpcy5jdXJyZW50TWVudUl0ZW0uZWxlbWVudHMudG9nZ2xlLmlzT3BlbiA/ICh0aGlzLmJsdXJDdXJyZW50Q2hpbGQoKSwgdGhpcy5jdXJyZW50TWVudUl0ZW0uZWxlbWVudHMuY2hpbGRNZW51LmN1cnJlbnRFdmVudCA9IHRoaXMuY3VycmVudEV2ZW50LCB0aGlzLmN1cnJlbnRNZW51SXRlbS5lbGVtZW50cy5jaGlsZE1lbnUuZm9jdXNGaXJzdENoaWxkKCkpIDogIXRoaXMuaXNUb3BMZXZlbCAmJiB0aGlzLmN1cnJlbnRDaGlsZCA9PT0gdGhpcy5lbGVtZW50cy5tZW51SXRlbXMubGVuZ3RoIC0gMSA/IHRoaXMuZm9jdXNQYXJlbnRzTmV4dENoaWxkKCkgOiB0aGlzLmZvY3VzTmV4dENoaWxkKCk7XG4gICAgICAgIGVsc2UgaWYgKHMgPT09IFwiQXJyb3dVcFwiKSB7XG4gICAgICAgICAgbyh0KTtcbiAgICAgICAgICBjb25zdCBtID0gdGhpcy5lbGVtZW50cy5tZW51SXRlbXNbdGhpcy5jdXJyZW50Q2hpbGQgLSAxXTtcbiAgICAgICAgICBtICYmIG0uaXNTdWJtZW51SXRlbSAmJiBtLmVsZW1lbnRzLnRvZ2dsZS5pc09wZW4gPyAodGhpcy5ibHVyQ3VycmVudENoaWxkKCksIHRoaXMuY3VycmVudENoaWxkID0gdGhpcy5jdXJyZW50Q2hpbGQgLSAxLCB0aGlzLmN1cnJlbnRNZW51SXRlbS5lbGVtZW50cy5jaGlsZE1lbnUuY3VycmVudEV2ZW50ID0gdGhpcy5jdXJyZW50RXZlbnQsIHRoaXMuZm9jdXNDaGlsZHNMYXN0Tm9kZSgpKSA6ICF0aGlzLmlzVG9wTGV2ZWwgJiYgdGhpcy5jdXJyZW50Q2hpbGQgPT09IDAgPyAodGhpcy5ibHVyQ3VycmVudENoaWxkKCksIHRoaXMuZWxlbWVudHMucGFyZW50TWVudS5jdXJyZW50RXZlbnQgPSB0aGlzLmN1cnJlbnRFdmVudCwgdGhpcy5lbGVtZW50cy5wYXJlbnRNZW51LmZvY3VzQ3VycmVudENoaWxkKCkpIDogdGhpcy5mb2N1c1ByZXZpb3VzQ2hpbGQoKTtcbiAgICAgICAgfSBlbHNlIHMgPT09IFwiQXJyb3dSaWdodFwiID8gdGhpcy5jdXJyZW50TWVudUl0ZW0uaXNTdWJtZW51SXRlbSAmJiAobyh0KSwgdGhpcy5jdXJyZW50TWVudUl0ZW0uZWxlbWVudHMudG9nZ2xlLmlzT3BlbiA/ICh0aGlzLmJsdXJDdXJyZW50Q2hpbGQoKSwgdGhpcy5jdXJyZW50TWVudUl0ZW0uZWxlbWVudHMuY2hpbGRNZW51LmN1cnJlbnRFdmVudCA9IHRoaXMuY3VycmVudEV2ZW50LCB0aGlzLmN1cnJlbnRNZW51SXRlbS5lbGVtZW50cy5jaGlsZE1lbnUuZm9jdXNGaXJzdENoaWxkKCkpIDogdGhpcy5jdXJyZW50TWVudUl0ZW0uZWxlbWVudHMudG9nZ2xlLnByZXZpZXcoKSkgOiBzID09PSBcIkFycm93TGVmdFwiID8gKG8odCksIHRoaXMuY3VycmVudE1lbnVJdGVtLmlzU3VibWVudUl0ZW0gJiYgdGhpcy5jdXJyZW50TWVudUl0ZW0uZWxlbWVudHMudG9nZ2xlLmlzT3BlbiA/ICh0aGlzLmN1cnJlbnRNZW51SXRlbS5lbGVtZW50cy5jaGlsZE1lbnUuYmx1ckN1cnJlbnRDaGlsZCgpLCB0aGlzLmN1cnJlbnRNZW51SXRlbS5lbGVtZW50cy50b2dnbGUuY2xvc2UoKSkgOiB0aGlzLmlzVG9wTGV2ZWwgfHwgKHRoaXMuYmx1ckN1cnJlbnRDaGlsZCgpLCB0aGlzLmVsZW1lbnRzLnBhcmVudE1lbnUuY3VycmVudEV2ZW50ID0gdGhpcy5jdXJyZW50RXZlbnQsIHRoaXMuZWxlbWVudHMucGFyZW50TWVudS5mb2N1c0N1cnJlbnRDaGlsZCgpKSkgOiBzID09PSBcIkhvbWVcIiA/IChvKHQpLCB0aGlzLmJsdXJDdXJyZW50Q2hpbGQoKSwgdGhpcy5lbGVtZW50cy5yb290TWVudS5mb2N1c0ZpcnN0Q2hpbGQoKSkgOiBzID09PSBcIkVuZFwiID8gKG8odCksIHRoaXMuYmx1ckN1cnJlbnRDaGlsZCgpLCB0aGlzLmVsZW1lbnRzLnJvb3RNZW51LmZvY3VzTGFzdE5vZGUoKSkgOiBzID09PSBcIkFzdGVyaXNrXCIgJiYgKG8odCksIHRoaXMub3BlbkNoaWxkcmVuKCkpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBGb2N1cyB0aGUgbWVudSdzIGxhc3Qgbm9kZSBvZiB0aGUgZW50aXJlIGV4cGFuZGVkIG1lbnUuXG4gICAqXG4gICAqIFRoaXMgaW5jbHVkZXMgYWxsIF9vcGVuXyBjaGlsZCBtZW51IGl0ZW1zLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBmb2N1c0xhc3ROb2RlKCkge1xuICAgIGNvbnN0IHQgPSB0aGlzLmVsZW1lbnRzLm1lbnVJdGVtcy5sZW5ndGggLSAxLCBzID0gdGhpcy5lbGVtZW50cy5tZW51SXRlbXNbdF07XG4gICAgcy5pc1N1Ym1lbnVJdGVtICYmIHMuZWxlbWVudHMudG9nZ2xlLmlzT3BlbiA/ICh0aGlzLmN1cnJlbnRDaGlsZCA9IHQsIHMuZWxlbWVudHMuY2hpbGRNZW51LmN1cnJlbnRFdmVudCA9IHRoaXMuY3VycmVudEV2ZW50LCBzLmVsZW1lbnRzLmNoaWxkTWVudS5mb2N1c0xhc3ROb2RlKCkpIDogdGhpcy5mb2N1c0xhc3RDaGlsZCgpO1xuICB9XG4gIC8qKlxuICAgKiBPcGVuIGFsbCBzdWJtZW51IGNoaWxkcmVuLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBvcGVuQ2hpbGRyZW4oKSB7XG4gICAgdGhpcy5lbGVtZW50cy5zdWJtZW51VG9nZ2xlcy5mb3JFYWNoKCh0KSA9PiB0LnByZXZpZXcoKSk7XG4gIH1cbiAgLyoqXG4gICAqIEZvY3VzIHRoZSBtZW51J3MgbmV4dCBub2RlIHN0YXJ0aW5nIHdpdGggYSBzcGVjaWZpYyBsZXR0ZXIuXG4gICAqXG4gICAqIFRoaXMgaW5jbHVkZXMgYWxsIF9vcGVuXyBjaGlsZCBtZW51IGl0ZW1zLlxuICAgKlxuICAgKiBXcmFwcyB0byB0aGUgZmlyc3Qgbm9kZSBpZiBubyBtYXRjaCBpcyBmb3VuZCBhZnRlciB0aGUgY3VycmVudCBub2RlLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjaGFyIC0gVGhlIGNoYXJhY3RlciB0byBsb29rIGZvci5cbiAgICovXG4gIGZvY3VzTmV4dE5vZGVXaXRoQ2hhcmFjdGVyKHQpIHtcbiAgICBmdW5jdGlvbiBzKHApIHtcbiAgICAgIGxldCBmID0gW107XG4gICAgICByZXR1cm4gcC5lbGVtZW50cy5tZW51SXRlbXMuZm9yRWFjaCgoZykgPT4ge1xuICAgICAgICBmLnB1c2goZyksIGcuaXNTdWJtZW51SXRlbSAmJiBnLmVsZW1lbnRzLnRvZ2dsZS5pc09wZW4gJiYgKGYgPSBbXG4gICAgICAgICAgLi4uZixcbiAgICAgICAgICAuLi5zKFxuICAgICAgICAgICAgZy5lbGVtZW50cy50b2dnbGUuZWxlbWVudHMuY29udHJvbGxlZE1lbnVcbiAgICAgICAgICApXG4gICAgICAgIF0pO1xuICAgICAgfSksIGY7XG4gICAgfVxuICAgIGNvbnN0IG4gPSB0LnRvTG93ZXJDYXNlKCksIGkgPSBzKHRoaXMuZWxlbWVudHMucm9vdE1lbnUpLCBsID0gaS5pbmRleE9mKHRoaXMuY3VycmVudE1lbnVJdGVtKSArIDEsIGggPSBbXG4gICAgICAuLi5pLnNsaWNlKGwpLFxuICAgICAgLi4uaS5zbGljZSgwLCBsKVxuICAgIF07XG4gICAgbGV0IG0gPSAwLCBhID0gITE7XG4gICAgZm9yICg7ICFhICYmIG0gPCBoLmxlbmd0aDsgKSB7XG4gICAgICBsZXQgcCA9IFwiXCI7XG4gICAgICBpZiAoaFttXS5kb20uaXRlbS5pbm5lclRleHQgPyBwID0gaFttXS5kb20uaXRlbS5pbm5lclRleHQgOiBwID0gaFttXS5kb20uaXRlbS50ZXh0Q29udGVudCwgcCA9IHAucmVwbGFjZSgvW1xcc10vZywgXCJcIikudG9Mb3dlckNhc2UoKS5jaGFyQXQoMCksIHAgPT09IG4pIHtcbiAgICAgICAgYSA9ICEwO1xuICAgICAgICBjb25zdCBmID0gaFttXS5lbGVtZW50cy5wYXJlbnRNZW51LCBnID0gZi5lbGVtZW50cy5tZW51SXRlbXMuaW5kZXhPZihoW21dKTtcbiAgICAgICAgdGhpcy5lbGVtZW50cy5yb290TWVudS5ibHVyQ2hpbGRyZW4oKSwgZi5mb2N1c0NoaWxkKGcpO1xuICAgICAgfVxuICAgICAgbSsrO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogRm9jdXMgdGhlIHBhcmVudCBtZW51J3MgbmV4dCBjaGlsZC5cbiAgICpcbiAgICogVGhpcyB3aWxsIGNhc2NhZGUgdXAgdGhyb3VnaCB0byB0aGUgcm9vdCBtZW51LlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBmb2N1c1BhcmVudHNOZXh0Q2hpbGQoKSB7XG4gICAgdGhpcy5lbGVtZW50cy5wYXJlbnRNZW51ICYmICh0aGlzLmVsZW1lbnRzLnBhcmVudE1lbnUuY3VycmVudEV2ZW50ID0gdGhpcy5jdXJyZW50RXZlbnQsIHRoaXMuZWxlbWVudHMucGFyZW50TWVudS5jdXJyZW50Q2hpbGQgPT09IHRoaXMuZWxlbWVudHMucGFyZW50TWVudS5lbGVtZW50cy5tZW51SXRlbXMubGVuZ3RoIC0gMSA/ICh0aGlzLmVsZW1lbnRzLnBhcmVudE1lbnUuYmx1ckN1cnJlbnRDaGlsZCgpLCB0aGlzLmVsZW1lbnRzLnBhcmVudE1lbnUuZm9jdXNQYXJlbnRzTmV4dENoaWxkKCkpIDogKHRoaXMuYmx1ckNoaWxkcmVuKCksIHRoaXMuZWxlbWVudHMucGFyZW50TWVudS5mb2N1c05leHRDaGlsZCgpKSk7XG4gIH1cbiAgLyoqXG4gICAqIEZvY3VzIHRoZSBsYXN0IGNoaWxkIG9mIHRoZSBjdXJyZW50IGNoaWxkJ3Mgc3VibWVudS5cbiAgICpcbiAgICogVGhpcyB3aWxsIGNhc2NhZGUgZG93biB0aHJvdWdoIHRvIHRoZSBsYXN0IG9wZW4gbWVudS5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZm9jdXNDaGlsZHNMYXN0Tm9kZSgpIHtcbiAgICB0aGlzLmN1cnJlbnRNZW51SXRlbS5lbGVtZW50cy5jaGlsZE1lbnUuY3VycmVudEV2ZW50ID0gdGhpcy5jdXJyZW50RXZlbnQsIHRoaXMuY3VycmVudE1lbnVJdGVtLmVsZW1lbnRzLmNoaWxkTWVudS5mb2N1c0xhc3RDaGlsZCgpLCB0aGlzLmN1cnJlbnRNZW51SXRlbS5lbGVtZW50cy5jaGlsZE1lbnUuY3VycmVudE1lbnVJdGVtLmlzU3VibWVudUl0ZW0gJiYgdGhpcy5jdXJyZW50TWVudUl0ZW0uZWxlbWVudHMuY2hpbGRNZW51LmN1cnJlbnRNZW51SXRlbS5lbGVtZW50cy50b2dnbGUuaXNPcGVuICYmICh0aGlzLmN1cnJlbnRNZW51SXRlbS5lbGVtZW50cy5jaGlsZE1lbnUuYmx1ckN1cnJlbnRDaGlsZCgpLCB0aGlzLmN1cnJlbnRNZW51SXRlbS5lbGVtZW50cy5jaGlsZE1lbnUuZm9jdXNDaGlsZHNMYXN0Tm9kZSgpKTtcbiAgfVxufVxuY29uc3Qgc2UgPSB7XG4gIERpc2Nsb3N1cmVNZW51OiB6LFxuICBNZW51YmFyOiBILFxuICBUb3BMaW5rRGlzY2xvc3VyZU1lbnU6IHEsXG4gIFRyZWV2aWV3OiBqXG59O1xuZXhwb3J0IHtcbiAgc2UgYXMgZGVmYXVsdFxufTtcbiIsIi8qIVxuKiBmb2N1cy10cmFwIDcuNi41XG4qIEBsaWNlbnNlIE1JVCwgaHR0cHM6Ly9naXRodWIuY29tL2ZvY3VzLXRyYXAvZm9jdXMtdHJhcC9ibG9iL21hc3Rlci9MSUNFTlNFXG4qL1xuaW1wb3J0IHsgdGFiYmFibGUsIGZvY3VzYWJsZSwgaXNUYWJiYWJsZSwgZ2V0VGFiSW5kZXgsIGlzRm9jdXNhYmxlIH0gZnJvbSAndGFiYmFibGUnO1xuXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShyLCBhKSB7XG4gIChudWxsID09IGEgfHwgYSA+IHIubGVuZ3RoKSAmJiAoYSA9IHIubGVuZ3RoKTtcbiAgZm9yICh2YXIgZSA9IDAsIG4gPSBBcnJheShhKTsgZSA8IGE7IGUrKykgbltlXSA9IHJbZV07XG4gIHJldHVybiBuO1xufVxuZnVuY3Rpb24gX2FycmF5V2l0aG91dEhvbGVzKHIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShyKTtcbn1cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShlLCByLCB0KSB7XG4gIHJldHVybiAociA9IF90b1Byb3BlcnR5S2V5KHIpKSBpbiBlID8gT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIHtcbiAgICB2YWx1ZTogdCxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSA6IGVbcl0gPSB0LCBlO1xufVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShyKSB7XG4gIGlmIChcInVuZGVmaW5lZFwiICE9IHR5cGVvZiBTeW1ib2wgJiYgbnVsbCAhPSByW1N5bWJvbC5pdGVyYXRvcl0gfHwgbnVsbCAhPSByW1wiQEBpdGVyYXRvclwiXSkgcmV0dXJuIEFycmF5LmZyb20ocik7XG59XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuZnVuY3Rpb24gb3duS2V5cyhlLCByKSB7XG4gIHZhciB0ID0gT2JqZWN0LmtleXMoZSk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIG8gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO1xuICAgIHIgJiYgKG8gPSBvLmZpbHRlcihmdW5jdGlvbiAocikge1xuICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgcikuZW51bWVyYWJsZTtcbiAgICB9KSksIHQucHVzaC5hcHBseSh0LCBvKTtcbiAgfVxuICByZXR1cm4gdDtcbn1cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKGUpIHtcbiAgZm9yICh2YXIgciA9IDE7IHIgPCBhcmd1bWVudHMubGVuZ3RoOyByKyspIHtcbiAgICB2YXIgdCA9IG51bGwgIT0gYXJndW1lbnRzW3JdID8gYXJndW1lbnRzW3JdIDoge307XG4gICAgciAlIDIgPyBvd25LZXlzKE9iamVjdCh0KSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAocikge1xuICAgICAgX2RlZmluZVByb3BlcnR5KGUsIHIsIHRbcl0pO1xuICAgIH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhlLCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSkgOiBvd25LZXlzKE9iamVjdCh0KSkuZm9yRWFjaChmdW5jdGlvbiAocikge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsIHIsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodCwgcikpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBlO1xufVxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KHIpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhyKSB8fCBfaXRlcmFibGVUb0FycmF5KHIpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTtcbn1cbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZSh0LCByKSB7XG4gIGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiB0IHx8ICF0KSByZXR1cm4gdDtcbiAgdmFyIGUgPSB0W1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmICh2b2lkIDAgIT09IGUpIHtcbiAgICB2YXIgaSA9IGUuY2FsbCh0LCByKTtcbiAgICBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgaSkgcmV0dXJuIGk7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICB9XG4gIHJldHVybiAoXCJzdHJpbmdcIiA9PT0gciA/IFN0cmluZyA6IE51bWJlcikodCk7XG59XG5mdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleSh0KSB7XG4gIHZhciBpID0gX3RvUHJpbWl0aXZlKHQsIFwic3RyaW5nXCIpO1xuICByZXR1cm4gXCJzeW1ib2xcIiA9PSB0eXBlb2YgaSA/IGkgOiBpICsgXCJcIjtcbn1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShyLCBhKSB7XG4gIGlmIChyKSB7XG4gICAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIHIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShyLCBhKTtcbiAgICB2YXIgdCA9IHt9LnRvU3RyaW5nLmNhbGwocikuc2xpY2UoOCwgLTEpO1xuICAgIHJldHVybiBcIk9iamVjdFwiID09PSB0ICYmIHIuY29uc3RydWN0b3IgJiYgKHQgPSByLmNvbnN0cnVjdG9yLm5hbWUpLCBcIk1hcFwiID09PSB0IHx8IFwiU2V0XCIgPT09IHQgPyBBcnJheS5mcm9tKHIpIDogXCJBcmd1bWVudHNcIiA9PT0gdCB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdCh0KSA/IF9hcnJheUxpa2VUb0FycmF5KHIsIGEpIDogdm9pZCAwO1xuICB9XG59XG5cbnZhciBhY3RpdmVGb2N1c1RyYXBzID0ge1xuICBhY3RpdmF0ZVRyYXA6IGZ1bmN0aW9uIGFjdGl2YXRlVHJhcCh0cmFwU3RhY2ssIHRyYXApIHtcbiAgICBpZiAodHJhcFN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgIHZhciBhY3RpdmVUcmFwID0gdHJhcFN0YWNrW3RyYXBTdGFjay5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChhY3RpdmVUcmFwICE9PSB0cmFwKSB7XG4gICAgICAgIGFjdGl2ZVRyYXAuX3NldFBhdXNlZFN0YXRlKHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgdHJhcEluZGV4ID0gdHJhcFN0YWNrLmluZGV4T2YodHJhcCk7XG4gICAgaWYgKHRyYXBJbmRleCA9PT0gLTEpIHtcbiAgICAgIHRyYXBTdGFjay5wdXNoKHRyYXApO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBtb3ZlIHRoaXMgZXhpc3RpbmcgdHJhcCB0byB0aGUgZnJvbnQgb2YgdGhlIHF1ZXVlXG4gICAgICB0cmFwU3RhY2suc3BsaWNlKHRyYXBJbmRleCwgMSk7XG4gICAgICB0cmFwU3RhY2sucHVzaCh0cmFwKTtcbiAgICB9XG4gIH0sXG4gIGRlYWN0aXZhdGVUcmFwOiBmdW5jdGlvbiBkZWFjdGl2YXRlVHJhcCh0cmFwU3RhY2ssIHRyYXApIHtcbiAgICB2YXIgdHJhcEluZGV4ID0gdHJhcFN0YWNrLmluZGV4T2YodHJhcCk7XG4gICAgaWYgKHRyYXBJbmRleCAhPT0gLTEpIHtcbiAgICAgIHRyYXBTdGFjay5zcGxpY2UodHJhcEluZGV4LCAxKTtcbiAgICB9XG4gICAgaWYgKHRyYXBTdGFjay5sZW5ndGggPiAwICYmICF0cmFwU3RhY2tbdHJhcFN0YWNrLmxlbmd0aCAtIDFdLl9pc01hbnVhbGx5UGF1c2VkKCkpIHtcbiAgICAgIHRyYXBTdGFja1t0cmFwU3RhY2subGVuZ3RoIC0gMV0uX3NldFBhdXNlZFN0YXRlKGZhbHNlKTtcbiAgICB9XG4gIH1cbn07XG52YXIgaXNTZWxlY3RhYmxlSW5wdXQgPSBmdW5jdGlvbiBpc1NlbGVjdGFibGVJbnB1dChub2RlKSB7XG4gIHJldHVybiBub2RlLnRhZ05hbWUgJiYgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcgJiYgdHlwZW9mIG5vZGUuc2VsZWN0ID09PSAnZnVuY3Rpb24nO1xufTtcbnZhciBpc0VzY2FwZUV2ZW50ID0gZnVuY3Rpb24gaXNFc2NhcGVFdmVudChlKSB7XG4gIHJldHVybiAoZSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLmtleSkgPT09ICdFc2NhcGUnIHx8IChlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUua2V5KSA9PT0gJ0VzYycgfHwgKGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS5rZXlDb2RlKSA9PT0gMjc7XG59O1xudmFyIGlzVGFiRXZlbnQgPSBmdW5jdGlvbiBpc1RhYkV2ZW50KGUpIHtcbiAgcmV0dXJuIChlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUua2V5KSA9PT0gJ1RhYicgfHwgKGUgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS5rZXlDb2RlKSA9PT0gOTtcbn07XG5cbi8vIGNoZWNrcyBmb3IgVEFCIGJ5IGRlZmF1bHRcbnZhciBpc0tleUZvcndhcmQgPSBmdW5jdGlvbiBpc0tleUZvcndhcmQoZSkge1xuICByZXR1cm4gaXNUYWJFdmVudChlKSAmJiAhZS5zaGlmdEtleTtcbn07XG5cbi8vIGNoZWNrcyBmb3IgU0hJRlQrVEFCIGJ5IGRlZmF1bHRcbnZhciBpc0tleUJhY2t3YXJkID0gZnVuY3Rpb24gaXNLZXlCYWNrd2FyZChlKSB7XG4gIHJldHVybiBpc1RhYkV2ZW50KGUpICYmIGUuc2hpZnRLZXk7XG59O1xudmFyIGRlbGF5ID0gZnVuY3Rpb24gZGVsYXkoZm4pIHtcbiAgcmV0dXJuIHNldFRpbWVvdXQoZm4sIDApO1xufTtcblxuLyoqXG4gKiBHZXQgYW4gb3B0aW9uJ3MgdmFsdWUgd2hlbiBpdCBjb3VsZCBiZSBhIHBsYWluIHZhbHVlLCBvciBhIGhhbmRsZXIgdGhhdCBwcm92aWRlc1xuICogIHRoZSB2YWx1ZS5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgT3B0aW9uJ3MgdmFsdWUgdG8gY2hlY2suXG4gKiBAcGFyYW0gey4uLip9IFtwYXJhbXNdIEFueSBwYXJhbWV0ZXJzIHRvIHBhc3MgdG8gdGhlIGhhbmRsZXIsIGlmIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbi5cbiAqIEByZXR1cm5zIHsqfSBUaGUgYHZhbHVlYCwgb3IgdGhlIGhhbmRsZXIncyByZXR1cm5lZCB2YWx1ZS5cbiAqL1xudmFyIHZhbHVlT3JIYW5kbGVyID0gZnVuY3Rpb24gdmFsdWVPckhhbmRsZXIodmFsdWUpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHBhcmFtcyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgcGFyYW1zW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nID8gdmFsdWUuYXBwbHkodm9pZCAwLCBwYXJhbXMpIDogdmFsdWU7XG59O1xudmFyIGdldEFjdHVhbFRhcmdldCA9IGZ1bmN0aW9uIGdldEFjdHVhbFRhcmdldChldmVudCkge1xuICAvLyBOT1RFOiBJZiB0aGUgdHJhcCBpcyBfaW5zaWRlXyBhIHNoYWRvdyBET00sIGV2ZW50LnRhcmdldCB3aWxsIGFsd2F5cyBiZSB0aGVcbiAgLy8gIHNoYWRvdyBob3N0LiBIb3dldmVyLCBldmVudC50YXJnZXQuY29tcG9zZWRQYXRoKCkgd2lsbCBiZSBhbiBhcnJheSBvZlxuICAvLyAgbm9kZXMgXCJjbGlja2VkXCIgZnJvbSBpbm5lci1tb3N0ICh0aGUgYWN0dWFsIGVsZW1lbnQgaW5zaWRlIHRoZSBzaGFkb3cpIHRvXG4gIC8vICBvdXRlci1tb3N0ICh0aGUgaG9zdCBIVE1MIGRvY3VtZW50KS4gSWYgd2UgaGF2ZSBhY2Nlc3MgdG8gY29tcG9zZWRQYXRoKCksXG4gIC8vICB0aGVuIHVzZSBpdHMgZmlyc3QgZWxlbWVudDsgb3RoZXJ3aXNlLCBmYWxsIGJhY2sgdG8gZXZlbnQudGFyZ2V0IChhbmRcbiAgLy8gIHRoaXMgb25seSB3b3JrcyBmb3IgYW4gX29wZW5fIHNoYWRvdyBET007IG90aGVyd2lzZSxcbiAgLy8gIGNvbXBvc2VkUGF0aCgpWzBdID09PSBldmVudC50YXJnZXQgYWx3YXlzKS5cbiAgcmV0dXJuIGV2ZW50LnRhcmdldC5zaGFkb3dSb290ICYmIHR5cGVvZiBldmVudC5jb21wb3NlZFBhdGggPT09ICdmdW5jdGlvbicgPyBldmVudC5jb21wb3NlZFBhdGgoKVswXSA6IGV2ZW50LnRhcmdldDtcbn07XG5cbi8vIE5PVEU6IHRoaXMgbXVzdCBiZSBfb3V0c2lkZV8gYGNyZWF0ZUZvY3VzVHJhcCgpYCB0byBtYWtlIHN1cmUgYWxsIHRyYXBzIGluIHRoaXNcbi8vICBjdXJyZW50IGluc3RhbmNlIHVzZSB0aGUgc2FtZSBzdGFjayBpZiBgdXNlck9wdGlvbnMudHJhcFN0YWNrYCBpc24ndCBzcGVjaWZpZWRcbnZhciBpbnRlcm5hbFRyYXBTdGFjayA9IFtdO1xudmFyIGNyZWF0ZUZvY3VzVHJhcCA9IGZ1bmN0aW9uIGNyZWF0ZUZvY3VzVHJhcChlbGVtZW50cywgdXNlck9wdGlvbnMpIHtcbiAgLy8gU1NSOiBhIGxpdmUgdHJhcCBzaG91bGRuJ3QgYmUgY3JlYXRlZCBpbiB0aGlzIHR5cGUgb2YgZW52aXJvbm1lbnQgc28gdGhpc1xuICAvLyAgc2hvdWxkIGJlIHNhZmUgY29kZSB0byBleGVjdXRlIGlmIHRoZSBgZG9jdW1lbnRgIG9wdGlvbiBpc24ndCBzcGVjaWZpZWRcbiAgdmFyIGRvYyA9ICh1c2VyT3B0aW9ucyA9PT0gbnVsbCB8fCB1c2VyT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdXNlck9wdGlvbnMuZG9jdW1lbnQpIHx8IGRvY3VtZW50O1xuICB2YXIgdHJhcFN0YWNrID0gKHVzZXJPcHRpb25zID09PSBudWxsIHx8IHVzZXJPcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1c2VyT3B0aW9ucy50cmFwU3RhY2spIHx8IGludGVybmFsVHJhcFN0YWNrO1xuICB2YXIgY29uZmlnID0gX29iamVjdFNwcmVhZDIoe1xuICAgIHJldHVybkZvY3VzT25EZWFjdGl2YXRlOiB0cnVlLFxuICAgIGVzY2FwZURlYWN0aXZhdGVzOiB0cnVlLFxuICAgIGRlbGF5SW5pdGlhbEZvY3VzOiB0cnVlLFxuICAgIGlzS2V5Rm9yd2FyZDogaXNLZXlGb3J3YXJkLFxuICAgIGlzS2V5QmFja3dhcmQ6IGlzS2V5QmFja3dhcmRcbiAgfSwgdXNlck9wdGlvbnMpO1xuICB2YXIgc3RhdGUgPSB7XG4gICAgLy8gY29udGFpbmVycyBnaXZlbiB0byBjcmVhdGVGb2N1c1RyYXAoKVxuICAgIC8vIEB0eXBlIHtBcnJheTxIVE1MRWxlbWVudD59XG4gICAgY29udGFpbmVyczogW10sXG4gICAgLy8gbGlzdCBvZiBvYmplY3RzIGlkZW50aWZ5aW5nIHRhYmJhYmxlIG5vZGVzIGluIGBjb250YWluZXJzYCBpbiB0aGUgdHJhcFxuICAgIC8vIE5PVEU6IGl0J3MgcG9zc2libGUgdGhhdCBhIGdyb3VwIGhhcyBubyB0YWJiYWJsZSBub2RlcyBpZiBub2RlcyBnZXQgcmVtb3ZlZCB3aGlsZSB0aGUgdHJhcFxuICAgIC8vICBpcyBhY3RpdmUsIGJ1dCB0aGUgdHJhcCBzaG91bGQgbmV2ZXIgZ2V0IHRvIGEgc3RhdGUgd2hlcmUgdGhlcmUgaXNuJ3QgYXQgbGVhc3Qgb25lIGdyb3VwXG4gICAgLy8gIHdpdGggYXQgbGVhc3Qgb25lIHRhYmJhYmxlIG5vZGUgaW4gaXQgKHRoYXQgd291bGQgbGVhZCB0byBhbiBlcnJvciBjb25kaXRpb24gdGhhdCB3b3VsZFxuICAgIC8vICByZXN1bHQgaW4gYW4gZXJyb3IgYmVpbmcgdGhyb3duKVxuICAgIC8vIEB0eXBlIHtBcnJheTx7XG4gICAgLy8gICBjb250YWluZXI6IEhUTUxFbGVtZW50LFxuICAgIC8vICAgdGFiYmFibGVOb2RlczogQXJyYXk8SFRNTEVsZW1lbnQ+LCAvLyBlbXB0eSBpZiBub25lXG4gICAgLy8gICBmb2N1c2FibGVOb2RlczogQXJyYXk8SFRNTEVsZW1lbnQ+LCAvLyBlbXB0eSBpZiBub25lXG4gICAgLy8gICBwb3NUYWJJbmRleGVzRm91bmQ6IGJvb2xlYW4sXG4gICAgLy8gICBmaXJzdFRhYmJhYmxlTm9kZTogSFRNTEVsZW1lbnR8dW5kZWZpbmVkLFxuICAgIC8vICAgbGFzdFRhYmJhYmxlTm9kZTogSFRNTEVsZW1lbnR8dW5kZWZpbmVkLFxuICAgIC8vICAgZmlyc3REb21UYWJiYWJsZU5vZGU6IEhUTUxFbGVtZW50fHVuZGVmaW5lZCxcbiAgICAvLyAgIGxhc3REb21UYWJiYWJsZU5vZGU6IEhUTUxFbGVtZW50fHVuZGVmaW5lZCxcbiAgICAvLyAgIG5leHRUYWJiYWJsZU5vZGU6IChub2RlOiBIVE1MRWxlbWVudCwgZm9yd2FyZDogYm9vbGVhbikgPT4gSFRNTEVsZW1lbnR8dW5kZWZpbmVkXG4gICAgLy8gfT59XG4gICAgY29udGFpbmVyR3JvdXBzOiBbXSxcbiAgICAvLyBzYW1lIG9yZGVyL2xlbmd0aCBhcyBgY29udGFpbmVyc2AgbGlzdFxuXG4gICAgLy8gcmVmZXJlbmNlcyB0byBvYmplY3RzIGluIGBjb250YWluZXJHcm91cHNgLCBidXQgb25seSB0aG9zZSB0aGF0IGFjdHVhbGx5IGhhdmVcbiAgICAvLyAgdGFiYmFibGUgbm9kZXMgaW4gdGhlbVxuICAgIC8vIE5PVEU6IHNhbWUgb3JkZXIgYXMgYGNvbnRhaW5lcnNgIGFuZCBgY29udGFpbmVyR3JvdXBzYCwgYnV0IF9fbm90IG5lY2Vzc2FyaWx5X19cbiAgICAvLyAgdGhlIHNhbWUgbGVuZ3RoXG4gICAgdGFiYmFibGVHcm91cHM6IFtdLFxuICAgIG5vZGVGb2N1c2VkQmVmb3JlQWN0aXZhdGlvbjogbnVsbCxcbiAgICBtb3N0UmVjZW50bHlGb2N1c2VkTm9kZTogbnVsbCxcbiAgICBhY3RpdmU6IGZhbHNlLFxuICAgIHBhdXNlZDogZmFsc2UsXG4gICAgbWFudWFsbHlQYXVzZWQ6IGZhbHNlLFxuICAgIC8vIHRpbWVyIElEIGZvciB3aGVuIGRlbGF5SW5pdGlhbEZvY3VzIGlzIHRydWUgYW5kIGluaXRpYWwgZm9jdXMgaW4gdGhpcyB0cmFwXG4gICAgLy8gIGhhcyBiZWVuIGRlbGF5ZWQgZHVyaW5nIGFjdGl2YXRpb25cbiAgICBkZWxheUluaXRpYWxGb2N1c1RpbWVyOiB1bmRlZmluZWQsXG4gICAgLy8gdGhlIG1vc3QgcmVjZW50IEtleWJvYXJkRXZlbnQgZm9yIHRoZSBjb25maWd1cmVkIG5hdiBrZXkgKHR5cGljYWxseSBbU0hJRlQrXVRBQiksIGlmIGFueVxuICAgIHJlY2VudE5hdkV2ZW50OiB1bmRlZmluZWRcbiAgfTtcbiAgdmFyIHRyYXA7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcHJlZmVyLWNvbnN0IC0tIHNvbWUgcHJpdmF0ZSBmdW5jdGlvbnMgcmVmZXJlbmNlIGl0LCBhbmQgaXRzIG1ldGhvZHMgcmVmZXJlbmNlIHByaXZhdGUgZnVuY3Rpb25zLCBzbyB3ZSBtdXN0IGRlY2xhcmUgaGVyZSBhbmQgZGVmaW5lIGxhdGVyXG5cbiAgLyoqXG4gICAqIEdldHMgYSBjb25maWd1cmF0aW9uIG9wdGlvbiB2YWx1ZS5cbiAgICogQHBhcmFtIHtPYmplY3R8dW5kZWZpbmVkfSBjb25maWdPdmVycmlkZU9wdGlvbnMgSWYgdHJ1ZSwgYW5kIG9wdGlvbiBpcyBkZWZpbmVkIGluIHRoaXMgc2V0LFxuICAgKiAgdmFsdWUgd2lsbCBiZSB0YWtlbiBmcm9tIHRoaXMgb2JqZWN0LiBPdGhlcndpc2UsIHZhbHVlIHdpbGwgYmUgdGFrZW4gZnJvbSBiYXNlIGNvbmZpZ3VyYXRpb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25OYW1lIE5hbWUgb2YgdGhlIG9wdGlvbiB3aG9zZSB2YWx1ZSBpcyBzb3VnaHQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfHVuZGVmaW5lZH0gW2NvbmZpZ09wdGlvbk5hbWVdIE5hbWUgb2Ygb3B0aW9uIHRvIHVzZSBfX2luc3RlYWQgb2ZfXyBgb3B0aW9uTmFtZWBcbiAgICogIElJRiBgY29uZmlnT3ZlcnJpZGVPcHRpb25zYCBpcyBub3QgZGVmaW5lZC4gT3RoZXJ3aXNlLCBgb3B0aW9uTmFtZWAgaXMgdXNlZC5cbiAgICovXG4gIHZhciBnZXRPcHRpb24gPSBmdW5jdGlvbiBnZXRPcHRpb24oY29uZmlnT3ZlcnJpZGVPcHRpb25zLCBvcHRpb25OYW1lLCBjb25maWdPcHRpb25OYW1lKSB7XG4gICAgcmV0dXJuIGNvbmZpZ092ZXJyaWRlT3B0aW9ucyAmJiBjb25maWdPdmVycmlkZU9wdGlvbnNbb3B0aW9uTmFtZV0gIT09IHVuZGVmaW5lZCA/IGNvbmZpZ092ZXJyaWRlT3B0aW9uc1tvcHRpb25OYW1lXSA6IGNvbmZpZ1tjb25maWdPcHRpb25OYW1lIHx8IG9wdGlvbk5hbWVdO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGaW5kcyB0aGUgaW5kZXggb2YgdGhlIGNvbnRhaW5lciB0aGF0IGNvbnRhaW5zIHRoZSBlbGVtZW50LlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7RXZlbnR9IFtldmVudF0gSWYgYXZhaWxhYmxlLCBhbmQgYGVsZW1lbnRgIGlzbid0IGRpcmVjdGx5IGZvdW5kIGluIGFueSBjb250YWluZXIsXG4gICAqICB0aGUgZXZlbnQncyBjb21wb3NlZCBwYXRoIGlzIHVzZWQgdG8gc2VlIGlmIGluY2x1ZGVzIGFueSBrbm93biB0cmFwIGNvbnRhaW5lcnMgaW4gdGhlXG4gICAqICBjYXNlIHdoZXJlIHRoZSBlbGVtZW50IGlzIGluc2lkZSBhIFNoYWRvdyBET00uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IEluZGV4IG9mIHRoZSBjb250YWluZXIgaW4gZWl0aGVyIGBzdGF0ZS5jb250YWluZXJzYCBvclxuICAgKiAgYHN0YXRlLmNvbnRhaW5lckdyb3Vwc2AgKHRoZSBvcmRlci9sZW5ndGggb2YgdGhlc2UgbGlzdHMgYXJlIHRoZSBzYW1lKTsgLTFcbiAgICogIGlmIHRoZSBlbGVtZW50IGlzbid0IGZvdW5kLlxuICAgKi9cbiAgdmFyIGZpbmRDb250YWluZXJJbmRleCA9IGZ1bmN0aW9uIGZpbmRDb250YWluZXJJbmRleChlbGVtZW50LCBldmVudCkge1xuICAgIHZhciBjb21wb3NlZFBhdGggPSB0eXBlb2YgKGV2ZW50ID09PSBudWxsIHx8IGV2ZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBldmVudC5jb21wb3NlZFBhdGgpID09PSAnZnVuY3Rpb24nID8gZXZlbnQuY29tcG9zZWRQYXRoKCkgOiB1bmRlZmluZWQ7XG4gICAgLy8gTk9URTogc2VhcmNoIGBjb250YWluZXJHcm91cHNgIGJlY2F1c2UgaXQncyBwb3NzaWJsZSBhIGdyb3VwIGNvbnRhaW5zIG5vIHRhYmJhYmxlXG4gICAgLy8gIG5vZGVzLCBidXQgc3RpbGwgY29udGFpbnMgZm9jdXNhYmxlIG5vZGVzIChlLmcuIGlmIHRoZXkgYWxsIGhhdmUgYHRhYmluZGV4PS0xYClcbiAgICAvLyAgYW5kIHdlIHN0aWxsIG5lZWQgdG8gZmluZCB0aGUgZWxlbWVudCBpbiB0aGVyZVxuICAgIHJldHVybiBzdGF0ZS5jb250YWluZXJHcm91cHMuZmluZEluZGV4KGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICB2YXIgY29udGFpbmVyID0gX3JlZi5jb250YWluZXIsXG4gICAgICAgIHRhYmJhYmxlTm9kZXMgPSBfcmVmLnRhYmJhYmxlTm9kZXM7XG4gICAgICByZXR1cm4gY29udGFpbmVyLmNvbnRhaW5zKGVsZW1lbnQpIHx8ICgvLyBmYWxsIGJhY2sgdG8gZXhwbGljaXQgdGFiYmFibGUgc2VhcmNoIHdoaWNoIHdpbGwgdGFrZSBpbnRvIGNvbnNpZGVyYXRpb24gYW55XG4gICAgICAvLyAgd2ViIGNvbXBvbmVudHMgaWYgdGhlIGB0YWJiYWJsZU9wdGlvbnMuZ2V0U2hhZG93Um9vdGAgb3B0aW9uIHdhcyB1c2VkIGZvclxuICAgICAgLy8gIHRoZSB0cmFwLCBlbmFibGluZyBzaGFkb3cgRE9NIHN1cHBvcnQgaW4gdGFiYmFibGUgKGBOb2RlLmNvbnRhaW5zKClgIGRvZXNuJ3RcbiAgICAgIC8vICBsb29rIGluc2lkZSB3ZWIgY29tcG9uZW50cyBldmVuIGlmIG9wZW4pXG4gICAgICBjb21wb3NlZFBhdGggPT09IG51bGwgfHwgY29tcG9zZWRQYXRoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb21wb3NlZFBhdGguaW5jbHVkZXMoY29udGFpbmVyKSkgfHwgdGFiYmFibGVOb2Rlcy5maW5kKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiBub2RlID09PSBlbGVtZW50O1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIG5vZGUgZm9yIHRoZSBnaXZlbiBvcHRpb24sIHdoaWNoIGlzIGV4cGVjdGVkIHRvIGJlIGFuIG9wdGlvbiB0aGF0XG4gICAqICBjYW4gYmUgZWl0aGVyIGEgRE9NIG5vZGUsIGEgc3RyaW5nIHRoYXQgaXMgYSBzZWxlY3RvciB0byBnZXQgYSBub2RlLCBgZmFsc2VgXG4gICAqICAoaWYgYSBub2RlIGlzIGV4cGxpY2l0bHkgTk9UIGdpdmVuKSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW55IG9mIHRoZXNlXG4gICAqICB2YWx1ZXMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRpb25OYW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuaGFzRmFsbGJhY2tdIFRydWUgaWYgdGhlIG9wdGlvbiBjb3VsZCBiZSBhIHNlbGVjdG9yIHN0cmluZ1xuICAgKiAgYW5kIHRoZSBvcHRpb24gYWxsb3dzIGZvciBhIGZhbGxiYWNrIHNjZW5hcmlvIGluIHRoZSBjYXNlIHdoZXJlIHRoZSBzZWxlY3RvciBpc1xuICAgKiAgdmFsaWQgYnV0IGRvZXMgbm90IG1hdGNoIGEgbm9kZSAoaS5lLiB0aGUgcXVlcmllZCBub2RlIGRvZXNuJ3QgZXhpc3QgaW4gdGhlIERPTSkuXG4gICAqIEBwYXJhbSB7QXJyYXl9IFtvcHRpb25zLnBhcmFtc10gUGFyYW1zIHRvIHBhc3MgdG8gdGhlIG9wdGlvbiBpZiBpdCdzIGEgZnVuY3Rpb24uXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWQgfCBudWxsIHwgZmFsc2UgfCBIVE1MRWxlbWVudCB8IFNWR0VsZW1lbnR9IFJldHVybnNcbiAgICogIGB1bmRlZmluZWRgIGlmIHRoZSBvcHRpb24gaXMgbm90IHNwZWNpZmllZDsgYG51bGxgIGlmIHRoZSBvcHRpb24gZGlkbid0IHJlc29sdmVcbiAgICogIHRvIGEgbm9kZSBidXQgYG9wdGlvbnMuaGFzRmFsbGJhY2s9dHJ1ZWAsIGBmYWxzZWAgaWYgdGhlIG9wdGlvbiByZXNvbHZlZCB0byBgZmFsc2VgXG4gICAqICAobm9kZSBleHBsaWNpdGx5IG5vdCBnaXZlbik7IG90aGVyd2lzZSwgdGhlIHJlc29sdmVkIERPTSBub2RlLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIG9wdGlvbiBpcyBzZXQsIG5vdCBgZmFsc2VgLCBhbmQgaXMgbm90LCBvciBkb2VzIG5vdFxuICAgKiAgcmVzb2x2ZSB0byBhIG5vZGUsIHVubGVzcyB0aGUgb3B0aW9uIGlzIGEgc2VsZWN0b3Igc3RyaW5nIGFuZCBgb3B0aW9ucy5oYXNGYWxsYmFjaz10cnVlYC5cbiAgICovXG4gIHZhciBnZXROb2RlRm9yT3B0aW9uID0gZnVuY3Rpb24gZ2V0Tm9kZUZvck9wdGlvbihvcHRpb25OYW1lKSB7XG4gICAgdmFyIF9yZWYyID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fSxcbiAgICAgIF9yZWYyJGhhc0ZhbGxiYWNrID0gX3JlZjIuaGFzRmFsbGJhY2ssXG4gICAgICBoYXNGYWxsYmFjayA9IF9yZWYyJGhhc0ZhbGxiYWNrID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYyJGhhc0ZhbGxiYWNrLFxuICAgICAgX3JlZjIkcGFyYW1zID0gX3JlZjIucGFyYW1zLFxuICAgICAgcGFyYW1zID0gX3JlZjIkcGFyYW1zID09PSB2b2lkIDAgPyBbXSA6IF9yZWYyJHBhcmFtcztcbiAgICB2YXIgb3B0aW9uVmFsdWUgPSBjb25maWdbb3B0aW9uTmFtZV07XG4gICAgaWYgKHR5cGVvZiBvcHRpb25WYWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb3B0aW9uVmFsdWUgPSBvcHRpb25WYWx1ZS5hcHBseSh2b2lkIDAsIF90b0NvbnN1bWFibGVBcnJheShwYXJhbXMpKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvblZhbHVlID09PSB0cnVlKSB7XG4gICAgICBvcHRpb25WYWx1ZSA9IHVuZGVmaW5lZDsgLy8gdXNlIGRlZmF1bHQgdmFsdWVcbiAgICB9XG4gICAgaWYgKCFvcHRpb25WYWx1ZSkge1xuICAgICAgaWYgKG9wdGlvblZhbHVlID09PSB1bmRlZmluZWQgfHwgb3B0aW9uVmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25WYWx1ZTtcbiAgICAgIH1cbiAgICAgIC8vIGVsc2UsIGVtcHR5IHN0cmluZyAoaW52YWxpZCksIG51bGwgKGludmFsaWQpLCAwIChpbnZhbGlkKVxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgXCIuY29uY2F0KG9wdGlvbk5hbWUsIFwiYCB3YXMgc3BlY2lmaWVkIGJ1dCB3YXMgbm90IGEgbm9kZSwgb3IgZGlkIG5vdCByZXR1cm4gYSBub2RlXCIpKTtcbiAgICB9XG4gICAgdmFyIG5vZGUgPSBvcHRpb25WYWx1ZTsgLy8gY291bGQgYmUgSFRNTEVsZW1lbnQsIFNWR0VsZW1lbnQsIG9yIG5vbi1lbXB0eSBzdHJpbmcgYXQgdGhpcyBwb2ludFxuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25WYWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIG5vZGUgPSBkb2MucXVlcnlTZWxlY3RvcihvcHRpb25WYWx1ZSk7IC8vIHJlc29sdmUgdG8gbm9kZSwgb3IgbnVsbCBpZiBmYWlsc1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImBcIi5jb25jYXQob3B0aW9uTmFtZSwgXCJgIGFwcGVhcnMgdG8gYmUgYW4gaW52YWxpZCBzZWxlY3RvcjsgZXJyb3I9XFxcIlwiKS5jb25jYXQoZXJyLm1lc3NhZ2UsIFwiXFxcIlwiKSk7XG4gICAgICB9XG4gICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgaWYgKCFoYXNGYWxsYmFjaykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImBcIi5jb25jYXQob3B0aW9uTmFtZSwgXCJgIGFzIHNlbGVjdG9yIHJlZmVycyB0byBubyBrbm93biBub2RlXCIpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlbHNlLCBgbm9kZWAgTVVTVCBiZSBgbnVsbGAgYmVjYXVzZSB0aGF0J3Mgd2hhdCBgRG9jdW1lbnQucXVlcnlTZWxlY3RvcigpYCByZXR1cm5zXG4gICAgICAgIC8vICBpZiB0aGUgc2VsZWN0b3IgaXMgdmFsaWQgYnV0IGRvZXNuJ3QgbWF0Y2ggYW55dGhpbmdcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH07XG4gIHZhciBnZXRJbml0aWFsRm9jdXNOb2RlID0gZnVuY3Rpb24gZ2V0SW5pdGlhbEZvY3VzTm9kZSgpIHtcbiAgICB2YXIgbm9kZSA9IGdldE5vZGVGb3JPcHRpb24oJ2luaXRpYWxGb2N1cycsIHtcbiAgICAgIGhhc0ZhbGxiYWNrOiB0cnVlXG4gICAgfSk7XG5cbiAgICAvLyBmYWxzZSBleHBsaWNpdGx5IGluZGljYXRlcyB3ZSB3YW50IG5vIGluaXRpYWxGb2N1cyBhdCBhbGxcbiAgICBpZiAobm9kZSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG5vZGUgPT09IHVuZGVmaW5lZCB8fCBub2RlICYmICFpc0ZvY3VzYWJsZShub2RlLCBjb25maWcudGFiYmFibGVPcHRpb25zKSkge1xuICAgICAgLy8gb3B0aW9uIG5vdCBzcGVjaWZpZWQgbm9yIGZvY3VzYWJsZTogdXNlIGZhbGxiYWNrIG9wdGlvbnNcbiAgICAgIGlmIChmaW5kQ29udGFpbmVySW5kZXgoZG9jLmFjdGl2ZUVsZW1lbnQpID49IDApIHtcbiAgICAgICAgbm9kZSA9IGRvYy5hY3RpdmVFbGVtZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGZpcnN0VGFiYmFibGVHcm91cCA9IHN0YXRlLnRhYmJhYmxlR3JvdXBzWzBdO1xuICAgICAgICB2YXIgZmlyc3RUYWJiYWJsZU5vZGUgPSBmaXJzdFRhYmJhYmxlR3JvdXAgJiYgZmlyc3RUYWJiYWJsZUdyb3VwLmZpcnN0VGFiYmFibGVOb2RlO1xuXG4gICAgICAgIC8vIE5PVEU6IGBmYWxsYmFja0ZvY3VzYCBvcHRpb24gZnVuY3Rpb24gY2Fubm90IHJldHVybiBgZmFsc2VgIChub3Qgc3VwcG9ydGVkKVxuICAgICAgICBub2RlID0gZmlyc3RUYWJiYWJsZU5vZGUgfHwgZ2V0Tm9kZUZvck9wdGlvbignZmFsbGJhY2tGb2N1cycpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZSA9PT0gbnVsbCkge1xuICAgICAgLy8gb3B0aW9uIGlzIGEgVkFMSUQgc2VsZWN0b3Igc3RyaW5nIHRoYXQgZG9lc24ndCB5aWVsZCBhIG5vZGU6IHVzZSB0aGUgYGZhbGxiYWNrRm9jdXNgXG4gICAgICAvLyAgb3B0aW9uIGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgYmVoYXZpb3Igd2hlbiB0aGUgb3B0aW9uIGlzbid0IHNwZWNpZmllZCBhdCBhbGxcbiAgICAgIG5vZGUgPSBnZXROb2RlRm9yT3B0aW9uKCdmYWxsYmFja0ZvY3VzJyk7XG4gICAgfVxuICAgIGlmICghbm9kZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3VyIGZvY3VzLXRyYXAgbmVlZHMgdG8gaGF2ZSBhdCBsZWFzdCBvbmUgZm9jdXNhYmxlIGVsZW1lbnQnKTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG4gIH07XG4gIHZhciB1cGRhdGVUYWJiYWJsZU5vZGVzID0gZnVuY3Rpb24gdXBkYXRlVGFiYmFibGVOb2RlcygpIHtcbiAgICBzdGF0ZS5jb250YWluZXJHcm91cHMgPSBzdGF0ZS5jb250YWluZXJzLm1hcChmdW5jdGlvbiAoY29udGFpbmVyKSB7XG4gICAgICB2YXIgdGFiYmFibGVOb2RlcyA9IHRhYmJhYmxlKGNvbnRhaW5lciwgY29uZmlnLnRhYmJhYmxlT3B0aW9ucyk7XG5cbiAgICAgIC8vIE5PVEU6IGlmIHdlIGhhdmUgdGFiYmFibGUgbm9kZXMsIHdlIG11c3QgaGF2ZSBmb2N1c2FibGUgbm9kZXM7IGZvY3VzYWJsZSBub2Rlc1xuICAgICAgLy8gIGFyZSBhIHN1cGVyc2V0IG9mIHRhYmJhYmxlIG5vZGVzIHNpbmNlIG5vZGVzIHdpdGggbmVnYXRpdmUgYHRhYmluZGV4YCBhdHRyaWJ1dGVzXG4gICAgICAvLyAgYXJlIGZvY3VzYWJsZSBidXQgbm90IHRhYmJhYmxlXG4gICAgICB2YXIgZm9jdXNhYmxlTm9kZXMgPSBmb2N1c2FibGUoY29udGFpbmVyLCBjb25maWcudGFiYmFibGVPcHRpb25zKTtcbiAgICAgIHZhciBmaXJzdFRhYmJhYmxlTm9kZSA9IHRhYmJhYmxlTm9kZXMubGVuZ3RoID4gMCA/IHRhYmJhYmxlTm9kZXNbMF0gOiB1bmRlZmluZWQ7XG4gICAgICB2YXIgbGFzdFRhYmJhYmxlTm9kZSA9IHRhYmJhYmxlTm9kZXMubGVuZ3RoID4gMCA/IHRhYmJhYmxlTm9kZXNbdGFiYmFibGVOb2Rlcy5sZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciBmaXJzdERvbVRhYmJhYmxlTm9kZSA9IGZvY3VzYWJsZU5vZGVzLmZpbmQoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIGlzVGFiYmFibGUobm9kZSk7XG4gICAgICB9KTtcbiAgICAgIHZhciBsYXN0RG9tVGFiYmFibGVOb2RlID0gZm9jdXNhYmxlTm9kZXMuc2xpY2UoKS5yZXZlcnNlKCkuZmluZChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICByZXR1cm4gaXNUYWJiYWJsZShub2RlKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIHBvc1RhYkluZGV4ZXNGb3VuZCA9ICEhdGFiYmFibGVOb2Rlcy5maW5kKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiBnZXRUYWJJbmRleChub2RlKSA+IDA7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbnRhaW5lcjogY29udGFpbmVyLFxuICAgICAgICB0YWJiYWJsZU5vZGVzOiB0YWJiYWJsZU5vZGVzLFxuICAgICAgICBmb2N1c2FibGVOb2RlczogZm9jdXNhYmxlTm9kZXMsXG4gICAgICAgIC8qKiBUcnVlIGlmIGF0IGxlYXN0IG9uZSBub2RlIHdpdGggcG9zaXRpdmUgYHRhYmluZGV4YCB3YXMgZm91bmQgaW4gdGhpcyBjb250YWluZXIuICovXG4gICAgICAgIHBvc1RhYkluZGV4ZXNGb3VuZDogcG9zVGFiSW5kZXhlc0ZvdW5kLFxuICAgICAgICAvKiogRmlyc3QgdGFiYmFibGUgbm9kZSBpbiBjb250YWluZXIsIF9fdGFiaW5kZXhfXyBvcmRlcjsgYHVuZGVmaW5lZGAgaWYgbm9uZS4gKi9cbiAgICAgICAgZmlyc3RUYWJiYWJsZU5vZGU6IGZpcnN0VGFiYmFibGVOb2RlLFxuICAgICAgICAvKiogTGFzdCB0YWJiYWJsZSBub2RlIGluIGNvbnRhaW5lciwgX190YWJpbmRleF9fIG9yZGVyOyBgdW5kZWZpbmVkYCBpZiBub25lLiAqL1xuICAgICAgICBsYXN0VGFiYmFibGVOb2RlOiBsYXN0VGFiYmFibGVOb2RlLFxuICAgICAgICAvLyBOT1RFOiBET00gb3JkZXIgaXMgTk9UIE5FQ0VTU0FSSUxZIFwiZG9jdW1lbnQgcG9zaXRpb25cIiBvcmRlciwgYnV0IGZpZ3VyaW5nIHRoYXQgb3V0XG4gICAgICAgIC8vICB3b3VsZCByZXF1aXJlIG1vcmUgdGhhbiBqdXN0IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Ob2RlL2NvbXBhcmVEb2N1bWVudFBvc2l0aW9uXG4gICAgICAgIC8vICBiZWNhdXNlIHRoYXQgQVBJIGRvZXNuJ3Qgd29yayB3aXRoIFNoYWRvdyBET00gYXMgd2VsbCBhcyBpdCBzaG91bGQgKEBzZWVcbiAgICAgICAgLy8gIGh0dHBzOi8vZ2l0aHViLmNvbS93aGF0d2cvZG9tL2lzc3Vlcy8zMjApIGFuZCBzaW5jZSB0aGlzIGZpcnN0L2xhc3QgaXMgb25seSBuZWVkZWQsIHNvIGZhcixcbiAgICAgICAgLy8gIHRvIGFkZHJlc3MgYW4gZWRnZSBjYXNlIHJlbGF0ZWQgdG8gcG9zaXRpdmUgdGFiaW5kZXggc3VwcG9ydCwgdGhpcyBzZWVtcyBsaWtlIGEgbXVjaCBlYXNpZXIsXG4gICAgICAgIC8vICBcImNsb3NlIGVub3VnaCBtb3N0IG9mIHRoZSB0aW1lXCIgYWx0ZXJuYXRpdmUgZm9yIHBvc2l0aXZlIHRhYmluZGV4ZXMgd2hpY2ggc2hvdWxkIGdlbmVyYWxseVxuICAgICAgICAvLyAgYmUgYXZvaWRlZCBhbnl3YXkuLi5cbiAgICAgICAgLyoqIEZpcnN0IHRhYmJhYmxlIG5vZGUgaW4gY29udGFpbmVyLCBfX0RPTV9fIG9yZGVyOyBgdW5kZWZpbmVkYCBpZiBub25lLiAqL1xuICAgICAgICBmaXJzdERvbVRhYmJhYmxlTm9kZTogZmlyc3REb21UYWJiYWJsZU5vZGUsXG4gICAgICAgIC8qKiBMYXN0IHRhYmJhYmxlIG5vZGUgaW4gY29udGFpbmVyLCBfX0RPTV9fIG9yZGVyOyBgdW5kZWZpbmVkYCBpZiBub25lLiAqL1xuICAgICAgICBsYXN0RG9tVGFiYmFibGVOb2RlOiBsYXN0RG9tVGFiYmFibGVOb2RlLFxuICAgICAgICAvKipcbiAgICAgICAgICogRmluZHMgdGhlIF9fdGFiYmFibGVfXyBub2RlIHRoYXQgZm9sbG93cyB0aGUgZ2l2ZW4gbm9kZSBpbiB0aGUgc3BlY2lmaWVkIGRpcmVjdGlvbixcbiAgICAgICAgICogIGluIHRoaXMgY29udGFpbmVyLCBpZiBhbnkuXG4gICAgICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcbiAgICAgICAgICogQHBhcmFtIHtib29sZWFufSBbZm9yd2FyZF0gVHJ1ZSBpZiBnb2luZyBpbiBmb3J3YXJkIHRhYiBvcmRlcjsgZmFsc2UgaWYgZ29pbmdcbiAgICAgICAgICogIGluIHJldmVyc2UuXG4gICAgICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudHx1bmRlZmluZWR9IFRoZSBuZXh0IHRhYmJhYmxlIG5vZGUsIGlmIGFueS5cbiAgICAgICAgICovXG4gICAgICAgIG5leHRUYWJiYWJsZU5vZGU6IGZ1bmN0aW9uIG5leHRUYWJiYWJsZU5vZGUobm9kZSkge1xuICAgICAgICAgIHZhciBmb3J3YXJkID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgICAgICAgIHZhciBub2RlSWR4ID0gdGFiYmFibGVOb2Rlcy5pbmRleE9mKG5vZGUpO1xuICAgICAgICAgIGlmIChub2RlSWR4IDwgMCkge1xuICAgICAgICAgICAgLy8gZWl0aGVyIG5vdCB0YWJiYWJsZSBub3IgZm9jdXNhYmxlLCBvciB3YXMgZm9jdXNlZCBidXQgbm90IHRhYmJhYmxlIChuZWdhdGl2ZSB0YWJpbmRleCk6XG4gICAgICAgICAgICAvLyAgc2luY2UgYG5vZGVgIHNob3VsZCBhdCBsZWFzdCBoYXZlIGJlZW4gZm9jdXNhYmxlLCB3ZSBhc3N1bWUgdGhhdCdzIHRoZSBjYXNlIGFuZCBtaW1pY1xuICAgICAgICAgICAgLy8gIHdoYXQgYnJvd3NlcnMgZG8sIHdoaWNoIGlzIHNldCBmb2N1cyB0byB0aGUgbmV4dCBub2RlIGluIF9fZG9jdW1lbnQgcG9zaXRpb24gb3JkZXJfXyxcbiAgICAgICAgICAgIC8vICByZWdhcmRsZXNzIG9mIHBvc2l0aXZlIHRhYmluZGV4ZXMsIGlmIGFueSAtLSBhbmQgZm9yIHJlYXNvbnMgZXhwbGFpbmVkIGluIHRoZSBOT1RFXG4gICAgICAgICAgICAvLyAgYWJvdmUgcmVsYXRlZCB0byBgZmlyc3REb21UYWJiYWJsZWAgYW5kIGBsYXN0RG9tVGFiYmFibGVgIHByb3BlcnRpZXMsIHdlIGZhbGwgYmFjayB0b1xuICAgICAgICAgICAgLy8gIGJhc2ljIERPTSBvcmRlclxuICAgICAgICAgICAgaWYgKGZvcndhcmQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZvY3VzYWJsZU5vZGVzLnNsaWNlKGZvY3VzYWJsZU5vZGVzLmluZGV4T2Yobm9kZSkgKyAxKS5maW5kKGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpc1RhYmJhYmxlKGVsKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZm9jdXNhYmxlTm9kZXMuc2xpY2UoMCwgZm9jdXNhYmxlTm9kZXMuaW5kZXhPZihub2RlKSkucmV2ZXJzZSgpLmZpbmQoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgIHJldHVybiBpc1RhYmJhYmxlKGVsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGFiYmFibGVOb2Rlc1tub2RlSWR4ICsgKGZvcndhcmQgPyAxIDogLTEpXTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgICBzdGF0ZS50YWJiYWJsZUdyb3VwcyA9IHN0YXRlLmNvbnRhaW5lckdyb3Vwcy5maWx0ZXIoZnVuY3Rpb24gKGdyb3VwKSB7XG4gICAgICByZXR1cm4gZ3JvdXAudGFiYmFibGVOb2Rlcy5sZW5ndGggPiAwO1xuICAgIH0pO1xuXG4gICAgLy8gdGhyb3cgaWYgbm8gZ3JvdXBzIGhhdmUgdGFiYmFibGUgbm9kZXMgYW5kIHdlIGRvbid0IGhhdmUgYSBmYWxsYmFjayBmb2N1cyBub2RlIGVpdGhlclxuICAgIGlmIChzdGF0ZS50YWJiYWJsZUdyb3Vwcy5sZW5ndGggPD0gMCAmJiAhZ2V0Tm9kZUZvck9wdGlvbignZmFsbGJhY2tGb2N1cycpIC8vIHJldHVybmluZyBmYWxzZSBub3Qgc3VwcG9ydGVkIGZvciB0aGlzIG9wdGlvblxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3VyIGZvY3VzLXRyYXAgbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBjb250YWluZXIgd2l0aCBhdCBsZWFzdCBvbmUgdGFiYmFibGUgbm9kZSBpbiBpdCBhdCBhbGwgdGltZXMnKTtcbiAgICB9XG5cbiAgICAvLyBOT1RFOiBQb3NpdGl2ZSB0YWJpbmRleGVzIGFyZSBvbmx5IHByb3Blcmx5IHN1cHBvcnRlZCBpbiBzaW5nbGUtY29udGFpbmVyIHRyYXBzIGJlY2F1c2VcbiAgICAvLyAgZG9pbmcgaXQgYWNyb3NzIG11bHRpcGxlIGNvbnRhaW5lcnMgd2hlcmUgdGFiaW5kZXhlcyBjb3VsZCBiZSBhbGwgb3ZlciB0aGUgcGxhY2VcbiAgICAvLyAgd291bGQgcmVxdWlyZSBUYWJiYWJsZSB0byBzdXBwb3J0IG11bHRpcGxlIGNvbnRhaW5lcnMsIHdvdWxkIHJlcXVpcmUgYWRkaXRpb25hbFxuICAgIC8vICBzcGVjaWFsaXplZCBTaGFkb3cgRE9NIHN1cHBvcnQsIGFuZCB3b3VsZCByZXF1aXJlIFRhYmJhYmxlJ3MgbXVsdGktY29udGFpbmVyIHN1cHBvcnRcbiAgICAvLyAgdG8gbG9vayBhdCB0aG9zZSBjb250YWluZXJzIGluIGRvY3VtZW50IHBvc2l0aW9uIG9yZGVyIHJhdGhlciB0aGFuIHVzZXItcHJvdmlkZWRcbiAgICAvLyAgb3JkZXIgKGFzIHRoZXkgYXJlIHRyZWF0ZWQgaW4gRm9jdXMtdHJhcCwgZm9yIGxlZ2FjeSByZWFzb25zKS4gU2VlIGRpc2N1c3Npb24gb25cbiAgICAvLyAgaHR0cHM6Ly9naXRodWIuY29tL2ZvY3VzLXRyYXAvZm9jdXMtdHJhcC9pc3N1ZXMvMzc1IGZvciBtb3JlIGRldGFpbHMuXG4gICAgaWYgKHN0YXRlLmNvbnRhaW5lckdyb3Vwcy5maW5kKGZ1bmN0aW9uIChnKSB7XG4gICAgICByZXR1cm4gZy5wb3NUYWJJbmRleGVzRm91bmQ7XG4gICAgfSkgJiYgc3RhdGUuY29udGFpbmVyR3JvdXBzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkF0IGxlYXN0IG9uZSBub2RlIHdpdGggYSBwb3NpdGl2ZSB0YWJpbmRleCB3YXMgZm91bmQgaW4gb25lIG9mIHlvdXIgZm9jdXMtdHJhcCdzIG11bHRpcGxlIGNvbnRhaW5lcnMuIFBvc2l0aXZlIHRhYmluZGV4ZXMgYXJlIG9ubHkgc3VwcG9ydGVkIGluIHNpbmdsZS1jb250YWluZXIgZm9jdXMtdHJhcHMuXCIpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogR2V0cyB0aGUgY3VycmVudCBhY3RpdmVFbGVtZW50LiBJZiBpdCdzIGEgd2ViLWNvbXBvbmVudCBhbmQgaGFzIG9wZW4gc2hhZG93LXJvb3RcbiAgICogaXQgd2lsbCByZWN1cnNpdmVseSBzZWFyY2ggaW5zaWRlIHNoYWRvdyByb290cyBmb3IgdGhlIFwidHJ1ZVwiIGFjdGl2ZUVsZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7RG9jdW1lbnQgfCBTaGFkb3dSb290fSBlbFxuICAgKlxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IFRoZSBlbGVtZW50IHRoYXQgY3VycmVudGx5IGhhcyB0aGUgZm9jdXNcbiAgICoqL1xuICB2YXIgX2dldEFjdGl2ZUVsZW1lbnQgPSBmdW5jdGlvbiBnZXRBY3RpdmVFbGVtZW50KGVsKSB7XG4gICAgdmFyIGFjdGl2ZUVsZW1lbnQgPSBlbC5hY3RpdmVFbGVtZW50O1xuICAgIGlmICghYWN0aXZlRWxlbWVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoYWN0aXZlRWxlbWVudC5zaGFkb3dSb290ICYmIGFjdGl2ZUVsZW1lbnQuc2hhZG93Um9vdC5hY3RpdmVFbGVtZW50ICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gX2dldEFjdGl2ZUVsZW1lbnQoYWN0aXZlRWxlbWVudC5zaGFkb3dSb290KTtcbiAgICB9XG4gICAgcmV0dXJuIGFjdGl2ZUVsZW1lbnQ7XG4gIH07XG4gIHZhciBfdHJ5Rm9jdXMgPSBmdW5jdGlvbiB0cnlGb2N1cyhub2RlKSB7XG4gICAgaWYgKG5vZGUgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChub2RlID09PSBfZ2V0QWN0aXZlRWxlbWVudChkb2N1bWVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFub2RlIHx8ICFub2RlLmZvY3VzKSB7XG4gICAgICBfdHJ5Rm9jdXMoZ2V0SW5pdGlhbEZvY3VzTm9kZSgpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbm9kZS5mb2N1cyh7XG4gICAgICBwcmV2ZW50U2Nyb2xsOiAhIWNvbmZpZy5wcmV2ZW50U2Nyb2xsXG4gICAgfSk7XG4gICAgLy8gTk9URTogZm9jdXMoKSBBUEkgZG9lcyBub3QgdHJpZ2dlciBmb2N1c0luIGV2ZW50IHNvIHNldCBNUlUgbm9kZSBtYW51YWxseVxuICAgIHN0YXRlLm1vc3RSZWNlbnRseUZvY3VzZWROb2RlID0gbm9kZTtcbiAgICBpZiAoaXNTZWxlY3RhYmxlSW5wdXQobm9kZSkpIHtcbiAgICAgIG5vZGUuc2VsZWN0KCk7XG4gICAgfVxuICB9O1xuICB2YXIgZ2V0UmV0dXJuRm9jdXNOb2RlID0gZnVuY3Rpb24gZ2V0UmV0dXJuRm9jdXNOb2RlKHByZXZpb3VzQWN0aXZlRWxlbWVudCkge1xuICAgIHZhciBub2RlID0gZ2V0Tm9kZUZvck9wdGlvbignc2V0UmV0dXJuRm9jdXMnLCB7XG4gICAgICBwYXJhbXM6IFtwcmV2aW91c0FjdGl2ZUVsZW1lbnRdXG4gICAgfSk7XG4gICAgcmV0dXJuIG5vZGUgPyBub2RlIDogbm9kZSA9PT0gZmFsc2UgPyBmYWxzZSA6IHByZXZpb3VzQWN0aXZlRWxlbWVudDtcbiAgfTtcblxuICAvKipcbiAgICogRmluZHMgdGhlIG5leHQgbm9kZSAoaW4gZWl0aGVyIGRpcmVjdGlvbikgd2hlcmUgZm9jdXMgc2hvdWxkIG1vdmUgYWNjb3JkaW5nIHRvIGFcbiAgICogIGtleWJvYXJkIGZvY3VzLWluIGV2ZW50LlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zXG4gICAqIEBwYXJhbSB7Tm9kZX0gW3BhcmFtcy50YXJnZXRdIEtub3duIHRhcmdldCBfX2Zyb20gd2hpY2hfXyB0byBuYXZpZ2F0ZSwgaWYgYW55LlxuICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnR8Rm9jdXNFdmVudH0gW3BhcmFtcy5ldmVudF0gRXZlbnQgdG8gdXNlIGlmIGB0YXJnZXRgIGlzbid0IGtub3duIChldmVudFxuICAgKiAgd2lsbCBiZSB1c2VkIHRvIGRldGVybWluZSB0aGUgYHRhcmdldGApLiBJZ25vcmVkIGlmIGB0YXJnZXRgIGlzIHNwZWNpZmllZC5cbiAgICogQHBhcmFtIHtib29sZWFufSBbcGFyYW1zLmlzQmFja3dhcmRdIFRydWUgaWYgZm9jdXMgc2hvdWxkIG1vdmUgYmFja3dhcmQuXG4gICAqIEByZXR1cm5zIHtOb2RlfHVuZGVmaW5lZH0gVGhlIG5leHQgbm9kZSwgb3IgYHVuZGVmaW5lZGAgaWYgYSBuZXh0IG5vZGUgY291bGRuJ3QgYmVcbiAgICogIGRldGVybWluZWQgZ2l2ZW4gdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHRyYXAuXG4gICAqL1xuICB2YXIgZmluZE5leHROYXZOb2RlID0gZnVuY3Rpb24gZmluZE5leHROYXZOb2RlKF9yZWYzKSB7XG4gICAgdmFyIHRhcmdldCA9IF9yZWYzLnRhcmdldCxcbiAgICAgIGV2ZW50ID0gX3JlZjMuZXZlbnQsXG4gICAgICBfcmVmMyRpc0JhY2t3YXJkID0gX3JlZjMuaXNCYWNrd2FyZCxcbiAgICAgIGlzQmFja3dhcmQgPSBfcmVmMyRpc0JhY2t3YXJkID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYzJGlzQmFja3dhcmQ7XG4gICAgdGFyZ2V0ID0gdGFyZ2V0IHx8IGdldEFjdHVhbFRhcmdldChldmVudCk7XG4gICAgdXBkYXRlVGFiYmFibGVOb2RlcygpO1xuICAgIHZhciBkZXN0aW5hdGlvbk5vZGUgPSBudWxsO1xuICAgIGlmIChzdGF0ZS50YWJiYWJsZUdyb3Vwcy5sZW5ndGggPiAwKSB7XG4gICAgICAvLyBtYWtlIHN1cmUgdGhlIHRhcmdldCBpcyBhY3R1YWxseSBjb250YWluZWQgaW4gYSBncm91cFxuICAgICAgLy8gTk9URTogdGhlIHRhcmdldCBtYXkgYWxzbyBiZSB0aGUgY29udGFpbmVyIGl0c2VsZiBpZiBpdCdzIGZvY3VzYWJsZVxuICAgICAgLy8gIHdpdGggdGFiSW5kZXg9Jy0xJyBhbmQgd2FzIGdpdmVuIGluaXRpYWwgZm9jdXNcbiAgICAgIHZhciBjb250YWluZXJJbmRleCA9IGZpbmRDb250YWluZXJJbmRleCh0YXJnZXQsIGV2ZW50KTtcbiAgICAgIHZhciBjb250YWluZXJHcm91cCA9IGNvbnRhaW5lckluZGV4ID49IDAgPyBzdGF0ZS5jb250YWluZXJHcm91cHNbY29udGFpbmVySW5kZXhdIDogdW5kZWZpbmVkO1xuICAgICAgaWYgKGNvbnRhaW5lckluZGV4IDwgMCkge1xuICAgICAgICAvLyB0YXJnZXQgbm90IGZvdW5kIGluIGFueSBncm91cDogcXVpdGUgcG9zc2libGUgZm9jdXMgaGFzIGVzY2FwZWQgdGhlIHRyYXAsXG4gICAgICAgIC8vICBzbyBicmluZyBpdCBiYWNrIGludG8uLi5cbiAgICAgICAgaWYgKGlzQmFja3dhcmQpIHtcbiAgICAgICAgICAvLyAuLi50aGUgbGFzdCBub2RlIGluIHRoZSBsYXN0IGdyb3VwXG4gICAgICAgICAgZGVzdGluYXRpb25Ob2RlID0gc3RhdGUudGFiYmFibGVHcm91cHNbc3RhdGUudGFiYmFibGVHcm91cHMubGVuZ3RoIC0gMV0ubGFzdFRhYmJhYmxlTm9kZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyAuLi50aGUgZmlyc3Qgbm9kZSBpbiB0aGUgZmlyc3QgZ3JvdXBcbiAgICAgICAgICBkZXN0aW5hdGlvbk5vZGUgPSBzdGF0ZS50YWJiYWJsZUdyb3Vwc1swXS5maXJzdFRhYmJhYmxlTm9kZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc0JhY2t3YXJkKSB7XG4gICAgICAgIC8vIFJFVkVSU0VcblxuICAgICAgICAvLyBpcyB0aGUgdGFyZ2V0IHRoZSBmaXJzdCB0YWJiYWJsZSBub2RlIGluIGEgZ3JvdXA/XG4gICAgICAgIHZhciBzdGFydE9mR3JvdXBJbmRleCA9IHN0YXRlLnRhYmJhYmxlR3JvdXBzLmZpbmRJbmRleChmdW5jdGlvbiAoX3JlZjQpIHtcbiAgICAgICAgICB2YXIgZmlyc3RUYWJiYWJsZU5vZGUgPSBfcmVmNC5maXJzdFRhYmJhYmxlTm9kZTtcbiAgICAgICAgICByZXR1cm4gdGFyZ2V0ID09PSBmaXJzdFRhYmJhYmxlTm9kZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChzdGFydE9mR3JvdXBJbmRleCA8IDAgJiYgKGNvbnRhaW5lckdyb3VwLmNvbnRhaW5lciA9PT0gdGFyZ2V0IHx8IGlzRm9jdXNhYmxlKHRhcmdldCwgY29uZmlnLnRhYmJhYmxlT3B0aW9ucykgJiYgIWlzVGFiYmFibGUodGFyZ2V0LCBjb25maWcudGFiYmFibGVPcHRpb25zKSAmJiAhY29udGFpbmVyR3JvdXAubmV4dFRhYmJhYmxlTm9kZSh0YXJnZXQsIGZhbHNlKSkpIHtcbiAgICAgICAgICAvLyBhbiBleGNlcHRpb24gY2FzZSB3aGVyZSB0aGUgdGFyZ2V0IGlzIGVpdGhlciB0aGUgY29udGFpbmVyIGl0c2VsZiwgb3JcbiAgICAgICAgICAvLyAgYSBub24tdGFiYmFibGUgbm9kZSB0aGF0IHdhcyBnaXZlbiBmb2N1cyAoaS5lLiB0YWJpbmRleCBpcyBuZWdhdGl2ZVxuICAgICAgICAgIC8vICBhbmQgdXNlciBjbGlja2VkIG9uIGl0IG9yIG5vZGUgd2FzIHByb2dyYW1tYXRpY2FsbHkgZ2l2ZW4gZm9jdXMpXG4gICAgICAgICAgLy8gIGFuZCBpcyBub3QgZm9sbG93ZWQgYnkgYW55IG90aGVyIHRhYmJhYmxlIG5vZGUsIGluIHdoaWNoXG4gICAgICAgICAgLy8gIGNhc2UsIHdlIHNob3VsZCBoYW5kbGUgc2hpZnQrdGFiIGFzIGlmIGZvY3VzIHdlcmUgb24gdGhlIGNvbnRhaW5lcidzXG4gICAgICAgICAgLy8gIGZpcnN0IHRhYmJhYmxlIG5vZGUsIGFuZCBnbyB0byB0aGUgbGFzdCB0YWJiYWJsZSBub2RlIG9mIHRoZSBMQVNUIGdyb3VwXG4gICAgICAgICAgc3RhcnRPZkdyb3VwSW5kZXggPSBjb250YWluZXJJbmRleDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnRPZkdyb3VwSW5kZXggPj0gMCkge1xuICAgICAgICAgIC8vIFlFUzogdGhlbiBzaGlmdCt0YWIgc2hvdWxkIGdvIHRvIHRoZSBsYXN0IHRhYmJhYmxlIG5vZGUgaW4gdGhlXG4gICAgICAgICAgLy8gIHByZXZpb3VzIGdyb3VwIChhbmQgd3JhcCBhcm91bmQgdG8gdGhlIGxhc3QgdGFiYmFibGUgbm9kZSBvZlxuICAgICAgICAgIC8vICB0aGUgTEFTVCBncm91cCBpZiBpdCdzIHRoZSBmaXJzdCB0YWJiYWJsZSBub2RlIG9mIHRoZSBGSVJTVCBncm91cClcbiAgICAgICAgICB2YXIgZGVzdGluYXRpb25Hcm91cEluZGV4ID0gc3RhcnRPZkdyb3VwSW5kZXggPT09IDAgPyBzdGF0ZS50YWJiYWJsZUdyb3Vwcy5sZW5ndGggLSAxIDogc3RhcnRPZkdyb3VwSW5kZXggLSAxO1xuICAgICAgICAgIHZhciBkZXN0aW5hdGlvbkdyb3VwID0gc3RhdGUudGFiYmFibGVHcm91cHNbZGVzdGluYXRpb25Hcm91cEluZGV4XTtcbiAgICAgICAgICBkZXN0aW5hdGlvbk5vZGUgPSBnZXRUYWJJbmRleCh0YXJnZXQpID49IDAgPyBkZXN0aW5hdGlvbkdyb3VwLmxhc3RUYWJiYWJsZU5vZGUgOiBkZXN0aW5hdGlvbkdyb3VwLmxhc3REb21UYWJiYWJsZU5vZGU7XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzVGFiRXZlbnQoZXZlbnQpKSB7XG4gICAgICAgICAgLy8gdXNlciBtdXN0IGhhdmUgY3VzdG9taXplZCB0aGUgbmF2IGtleXMgc28gd2UgaGF2ZSB0byBtb3ZlIGZvY3VzIG1hbnVhbGx5IF93aXRoaW5fXG4gICAgICAgICAgLy8gIHRoZSBhY3RpdmUgZ3JvdXA6IGRvIHRoaXMgYmFzZWQgb24gdGhlIG9yZGVyIGRldGVybWluZWQgYnkgdGFiYmFibGUoKVxuICAgICAgICAgIGRlc3RpbmF0aW9uTm9kZSA9IGNvbnRhaW5lckdyb3VwLm5leHRUYWJiYWJsZU5vZGUodGFyZ2V0LCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZPUldBUkRcblxuICAgICAgICAvLyBpcyB0aGUgdGFyZ2V0IHRoZSBsYXN0IHRhYmJhYmxlIG5vZGUgaW4gYSBncm91cD9cbiAgICAgICAgdmFyIGxhc3RPZkdyb3VwSW5kZXggPSBzdGF0ZS50YWJiYWJsZUdyb3Vwcy5maW5kSW5kZXgoZnVuY3Rpb24gKF9yZWY1KSB7XG4gICAgICAgICAgdmFyIGxhc3RUYWJiYWJsZU5vZGUgPSBfcmVmNS5sYXN0VGFiYmFibGVOb2RlO1xuICAgICAgICAgIHJldHVybiB0YXJnZXQgPT09IGxhc3RUYWJiYWJsZU5vZGU7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobGFzdE9mR3JvdXBJbmRleCA8IDAgJiYgKGNvbnRhaW5lckdyb3VwLmNvbnRhaW5lciA9PT0gdGFyZ2V0IHx8IGlzRm9jdXNhYmxlKHRhcmdldCwgY29uZmlnLnRhYmJhYmxlT3B0aW9ucykgJiYgIWlzVGFiYmFibGUodGFyZ2V0LCBjb25maWcudGFiYmFibGVPcHRpb25zKSAmJiAhY29udGFpbmVyR3JvdXAubmV4dFRhYmJhYmxlTm9kZSh0YXJnZXQpKSkge1xuICAgICAgICAgIC8vIGFuIGV4Y2VwdGlvbiBjYXNlIHdoZXJlIHRoZSB0YXJnZXQgaXMgdGhlIGNvbnRhaW5lciBpdHNlbGYsIG9yXG4gICAgICAgICAgLy8gIGEgbm9uLXRhYmJhYmxlIG5vZGUgdGhhdCB3YXMgZ2l2ZW4gZm9jdXMgKGkuZS4gdGFiaW5kZXggaXMgbmVnYXRpdmVcbiAgICAgICAgICAvLyAgYW5kIHVzZXIgY2xpY2tlZCBvbiBpdCBvciBub2RlIHdhcyBwcm9ncmFtbWF0aWNhbGx5IGdpdmVuIGZvY3VzKVxuICAgICAgICAgIC8vICBhbmQgaXMgbm90IGZvbGxvd2VkIGJ5IGFueSBvdGhlciB0YWJiYWJsZSBub2RlLCBpbiB3aGljaFxuICAgICAgICAgIC8vICBjYXNlLCB3ZSBzaG91bGQgaGFuZGxlIHRhYiBhcyBpZiBmb2N1cyB3ZXJlIG9uIHRoZSBjb250YWluZXInc1xuICAgICAgICAgIC8vICBsYXN0IHRhYmJhYmxlIG5vZGUsIGFuZCBnbyB0byB0aGUgZmlyc3QgdGFiYmFibGUgbm9kZSBvZiB0aGUgRklSU1QgZ3JvdXBcbiAgICAgICAgICBsYXN0T2ZHcm91cEluZGV4ID0gY29udGFpbmVySW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RPZkdyb3VwSW5kZXggPj0gMCkge1xuICAgICAgICAgIC8vIFlFUzogdGhlbiB0YWIgc2hvdWxkIGdvIHRvIHRoZSBmaXJzdCB0YWJiYWJsZSBub2RlIGluIHRoZSBuZXh0XG4gICAgICAgICAgLy8gIGdyb3VwIChhbmQgd3JhcCBhcm91bmQgdG8gdGhlIGZpcnN0IHRhYmJhYmxlIG5vZGUgb2YgdGhlIEZJUlNUXG4gICAgICAgICAgLy8gIGdyb3VwIGlmIGl0J3MgdGhlIGxhc3QgdGFiYmFibGUgbm9kZSBvZiB0aGUgTEFTVCBncm91cClcbiAgICAgICAgICB2YXIgX2Rlc3RpbmF0aW9uR3JvdXBJbmRleCA9IGxhc3RPZkdyb3VwSW5kZXggPT09IHN0YXRlLnRhYmJhYmxlR3JvdXBzLmxlbmd0aCAtIDEgPyAwIDogbGFzdE9mR3JvdXBJbmRleCArIDE7XG4gICAgICAgICAgdmFyIF9kZXN0aW5hdGlvbkdyb3VwID0gc3RhdGUudGFiYmFibGVHcm91cHNbX2Rlc3RpbmF0aW9uR3JvdXBJbmRleF07XG4gICAgICAgICAgZGVzdGluYXRpb25Ob2RlID0gZ2V0VGFiSW5kZXgodGFyZ2V0KSA+PSAwID8gX2Rlc3RpbmF0aW9uR3JvdXAuZmlyc3RUYWJiYWJsZU5vZGUgOiBfZGVzdGluYXRpb25Hcm91cC5maXJzdERvbVRhYmJhYmxlTm9kZTtcbiAgICAgICAgfSBlbHNlIGlmICghaXNUYWJFdmVudChldmVudCkpIHtcbiAgICAgICAgICAvLyB1c2VyIG11c3QgaGF2ZSBjdXN0b21pemVkIHRoZSBuYXYga2V5cyBzbyB3ZSBoYXZlIHRvIG1vdmUgZm9jdXMgbWFudWFsbHkgX3dpdGhpbl9cbiAgICAgICAgICAvLyAgdGhlIGFjdGl2ZSBncm91cDogZG8gdGhpcyBiYXNlZCBvbiB0aGUgb3JkZXIgZGV0ZXJtaW5lZCBieSB0YWJiYWJsZSgpXG4gICAgICAgICAgZGVzdGluYXRpb25Ob2RlID0gY29udGFpbmVyR3JvdXAubmV4dFRhYmJhYmxlTm9kZSh0YXJnZXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG5vIGdyb3VwcyBhdmFpbGFibGVcbiAgICAgIC8vIE5PVEU6IHRoZSBmYWxsYmFja0ZvY3VzIG9wdGlvbiBkb2VzIG5vdCBzdXBwb3J0IHJldHVybmluZyBmYWxzZSB0byBvcHQtb3V0XG4gICAgICBkZXN0aW5hdGlvbk5vZGUgPSBnZXROb2RlRm9yT3B0aW9uKCdmYWxsYmFja0ZvY3VzJyk7XG4gICAgfVxuICAgIHJldHVybiBkZXN0aW5hdGlvbk5vZGU7XG4gIH07XG5cbiAgLy8gVGhpcyBuZWVkcyB0byBiZSBkb25lIG9uIG1vdXNlZG93biBhbmQgdG91Y2hzdGFydCBpbnN0ZWFkIG9mIGNsaWNrXG4gIC8vIHNvIHRoYXQgaXQgcHJlY2VkZXMgdGhlIGZvY3VzIGV2ZW50LlxuICB2YXIgY2hlY2tQb2ludGVyRG93biA9IGZ1bmN0aW9uIGNoZWNrUG9pbnRlckRvd24oZSkge1xuICAgIHZhciB0YXJnZXQgPSBnZXRBY3R1YWxUYXJnZXQoZSk7XG4gICAgaWYgKGZpbmRDb250YWluZXJJbmRleCh0YXJnZXQsIGUpID49IDApIHtcbiAgICAgIC8vIGFsbG93IHRoZSBjbGljayBzaW5jZSBpdCBvY3VycmVkIGluc2lkZSB0aGUgdHJhcFxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodmFsdWVPckhhbmRsZXIoY29uZmlnLmNsaWNrT3V0c2lkZURlYWN0aXZhdGVzLCBlKSkge1xuICAgICAgLy8gaW1tZWRpYXRlbHkgZGVhY3RpdmF0ZSB0aGUgdHJhcFxuICAgICAgdHJhcC5kZWFjdGl2YXRlKHtcbiAgICAgICAgLy8gTk9URTogYnkgc2V0dGluZyBgcmV0dXJuRm9jdXM6IGZhbHNlYCwgZGVhY3RpdmF0ZSgpIHdpbGwgZG8gbm90aGluZyxcbiAgICAgICAgLy8gIHdoaWNoIHdpbGwgcmVzdWx0IGluIHRoZSBvdXRzaWRlIGNsaWNrIHNldHRpbmcgZm9jdXMgdG8gdGhlIG5vZGVcbiAgICAgICAgLy8gIHRoYXQgd2FzIGNsaWNrZWQgKGFuZCBpZiBub3QgZm9jdXNhYmxlLCB0byBcIm5vdGhpbmdcIik7IGJ5IHNldHRpbmdcbiAgICAgICAgLy8gIGByZXR1cm5Gb2N1czogdHJ1ZWAsIHdlJ2xsIGF0dGVtcHQgdG8gcmUtZm9jdXMgdGhlIG5vZGUgb3JpZ2luYWxseS1mb2N1c2VkXG4gICAgICAgIC8vICBvbiBhY3RpdmF0aW9uIChvciB0aGUgY29uZmlndXJlZCBgc2V0UmV0dXJuRm9jdXNgIG5vZGUpLCB3aGV0aGVyIHRoZVxuICAgICAgICAvLyAgb3V0c2lkZSBjbGljayB3YXMgb24gYSBmb2N1c2FibGUgbm9kZSBvciBub3RcbiAgICAgICAgcmV0dXJuRm9jdXM6IGNvbmZpZy5yZXR1cm5Gb2N1c09uRGVhY3RpdmF0ZVxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVGhpcyBpcyBuZWVkZWQgZm9yIG1vYmlsZSBkZXZpY2VzLlxuICAgIC8vIChJZiB3ZSdsbCBvbmx5IGxldCBgY2xpY2tgIGV2ZW50cyB0aHJvdWdoLFxuICAgIC8vIHRoZW4gb24gbW9iaWxlIHRoZXkgd2lsbCBiZSBibG9ja2VkIGFueXdheXMgaWYgYHRvdWNoc3RhcnRgIGlzIGJsb2NrZWQuKVxuICAgIGlmICh2YWx1ZU9ySGFuZGxlcihjb25maWcuYWxsb3dPdXRzaWRlQ2xpY2ssIGUpKSB7XG4gICAgICAvLyBhbGxvdyB0aGUgY2xpY2sgb3V0c2lkZSB0aGUgdHJhcCB0byB0YWtlIHBsYWNlXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gb3RoZXJ3aXNlLCBwcmV2ZW50IHRoZSBjbGlja1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgfTtcblxuICAvLyBJbiBjYXNlIGZvY3VzIGVzY2FwZXMgdGhlIHRyYXAgZm9yIHNvbWUgc3RyYW5nZSByZWFzb24sIHB1bGwgaXQgYmFjayBpbi5cbiAgLy8gTk9URTogdGhlIGZvY3VzSW4gZXZlbnQgaXMgTk9UIGNhbmNlbGFibGUsIHNvIGlmIGZvY3VzIGVzY2FwZXMsIGl0IG1heSBjYXVzZSB1bmV4cGVjdGVkXG4gIC8vICBzY3JvbGxpbmcgaWYgdGhlIG5vZGUgdGhhdCBnb3QgZm9jdXNlZCB3YXMgb3V0IG9mIHZpZXc7IHRoZXJlJ3Mgbm90aGluZyB3ZSBjYW4gZG8gdG9cbiAgLy8gIHByZXZlbnQgdGhhdCBmcm9tIGhhcHBlbmluZyBieSB0aGUgdGltZSB3ZSBkaXNjb3ZlciB0aGF0IGZvY3VzIGVzY2FwZWRcbiAgdmFyIGNoZWNrRm9jdXNJbiA9IGZ1bmN0aW9uIGNoZWNrRm9jdXNJbihldmVudCkge1xuICAgIHZhciB0YXJnZXQgPSBnZXRBY3R1YWxUYXJnZXQoZXZlbnQpO1xuICAgIHZhciB0YXJnZXRDb250YWluZWQgPSBmaW5kQ29udGFpbmVySW5kZXgodGFyZ2V0LCBldmVudCkgPj0gMDtcblxuICAgIC8vIEluIEZpcmVmb3ggd2hlbiB5b3UgVGFiIG91dCBvZiBhbiBpZnJhbWUgdGhlIERvY3VtZW50IGlzIGJyaWVmbHkgZm9jdXNlZC5cbiAgICBpZiAodGFyZ2V0Q29udGFpbmVkIHx8IHRhcmdldCBpbnN0YW5jZW9mIERvY3VtZW50KSB7XG4gICAgICBpZiAodGFyZ2V0Q29udGFpbmVkKSB7XG4gICAgICAgIHN0YXRlLm1vc3RSZWNlbnRseUZvY3VzZWROb2RlID0gdGFyZ2V0O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlc2NhcGVkISBwdWxsIGl0IGJhY2sgaW4gdG8gd2hlcmUgaXQganVzdCBsZWZ0XG4gICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblxuICAgICAgLy8gZm9jdXMgd2lsbCBlc2NhcGUgaWYgdGhlIE1SVSBub2RlIGhhZCBhIHBvc2l0aXZlIHRhYiBpbmRleCBhbmQgdXNlciB0cmllZCB0byBuYXYgZm9yd2FyZDtcbiAgICAgIC8vICBpdCB3aWxsIGFsc28gZXNjYXBlIGlmIHRoZSBNUlUgbm9kZSBoYWQgYSAwIHRhYiBpbmRleCBhbmQgdXNlciB0cmllZCB0byBuYXYgYmFja3dhcmRcbiAgICAgIC8vICB0b3dhcmQgYSBub2RlIHdpdGggYSBwb3NpdGl2ZSB0YWIgaW5kZXhcbiAgICAgIHZhciBuZXh0Tm9kZTsgLy8gbmV4dCBub2RlIHRvIGZvY3VzLCBpZiB3ZSBmaW5kIG9uZVxuICAgICAgdmFyIG5hdkFjcm9zc0NvbnRhaW5lcnMgPSB0cnVlO1xuICAgICAgaWYgKHN0YXRlLm1vc3RSZWNlbnRseUZvY3VzZWROb2RlKSB7XG4gICAgICAgIGlmIChnZXRUYWJJbmRleChzdGF0ZS5tb3N0UmVjZW50bHlGb2N1c2VkTm9kZSkgPiAwKSB7XG4gICAgICAgICAgLy8gTVJVIGNvbnRhaW5lciBpbmRleCBtdXN0IGJlID49MCBvdGhlcndpc2Ugd2Ugd291bGRuJ3QgaGF2ZSBpdCBhcyBhbiBNUlUgbm9kZS4uLlxuICAgICAgICAgIHZhciBtcnVDb250YWluZXJJZHggPSBmaW5kQ29udGFpbmVySW5kZXgoc3RhdGUubW9zdFJlY2VudGx5Rm9jdXNlZE5vZGUpO1xuICAgICAgICAgIC8vIHRoZXJlIE1BWSBub3QgYmUgYW55IHRhYmJhYmxlIG5vZGVzIGluIHRoZSBjb250YWluZXIgaWYgdGhlcmUgYXJlIGF0IGxlYXN0IDIgY29udGFpbmVyc1xuICAgICAgICAgIC8vICBhbmQgdGhlIE1SVSBub2RlIGlzIGZvY3VzYWJsZSBidXQgbm90IHRhYmJhYmxlIChmb2N1cy10cmFwIHJlcXVpcmVzIGF0IGxlYXN0IDEgY29udGFpbmVyXG4gICAgICAgICAgLy8gIHdpdGggYXQgbGVhc3Qgb25lIHRhYmJhYmxlIG5vZGUgaW4gb3JkZXIgdG8gZnVuY3Rpb24sIHNvIHRoaXMgY291bGQgYmUgdGhlIG90aGVyIGNvbnRhaW5lclxuICAgICAgICAgIC8vICB3aXRoIG5vdGhpbmcgdGFiYmFibGUgaW4gaXQpXG4gICAgICAgICAgdmFyIHRhYmJhYmxlTm9kZXMgPSBzdGF0ZS5jb250YWluZXJHcm91cHNbbXJ1Q29udGFpbmVySWR4XS50YWJiYWJsZU5vZGVzO1xuICAgICAgICAgIGlmICh0YWJiYWJsZU5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIE1SVSB0YWIgaW5kZXggTUFZIG5vdCBiZSBmb3VuZCBpZiB0aGUgTVJVIG5vZGUgaXMgZm9jdXNhYmxlIGJ1dCBub3QgdGFiYmFibGVcbiAgICAgICAgICAgIHZhciBtcnVUYWJJZHggPSB0YWJiYWJsZU5vZGVzLmZpbmRJbmRleChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICByZXR1cm4gbm9kZSA9PT0gc3RhdGUubW9zdFJlY2VudGx5Rm9jdXNlZE5vZGU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChtcnVUYWJJZHggPj0gMCkge1xuICAgICAgICAgICAgICBpZiAoY29uZmlnLmlzS2V5Rm9yd2FyZChzdGF0ZS5yZWNlbnROYXZFdmVudCkpIHtcbiAgICAgICAgICAgICAgICBpZiAobXJ1VGFiSWR4ICsgMSA8IHRhYmJhYmxlTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IHRhYmJhYmxlTm9kZXNbbXJ1VGFiSWR4ICsgMV07XG4gICAgICAgICAgICAgICAgICBuYXZBY3Jvc3NDb250YWluZXJzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGVsc2UsIGRvbid0IHdyYXAgd2l0aGluIHRoZSBjb250YWluZXIgYXMgZm9jdXMgc2hvdWxkIG1vdmUgdG8gbmV4dC9wcmV2aW91c1xuICAgICAgICAgICAgICAgIC8vICBjb250YWluZXJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAobXJ1VGFiSWR4IC0gMSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICBuZXh0Tm9kZSA9IHRhYmJhYmxlTm9kZXNbbXJ1VGFiSWR4IC0gMV07XG4gICAgICAgICAgICAgICAgICBuYXZBY3Jvc3NDb250YWluZXJzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGVsc2UsIGRvbid0IHdyYXAgd2l0aGluIHRoZSBjb250YWluZXIgYXMgZm9jdXMgc2hvdWxkIG1vdmUgdG8gbmV4dC9wcmV2aW91c1xuICAgICAgICAgICAgICAgIC8vICBjb250YWluZXJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBlbHNlLCBkb24ndCBmaW5kIGluIGNvbnRhaW5lciBvcmRlciB3aXRob3V0IGNvbnNpZGVyaW5nIGRpcmVjdGlvbiB0b29cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gZWxzZSwgbm8gdGFiYmFibGUgbm9kZXMgaW4gdGhhdCBjb250YWluZXIgKHdoaWNoIG1lYW5zIHdlIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgb3RoZXJcbiAgICAgICAgICAvLyAgY29udGFpbmVyIHdpdGggYXQgbGVhc3Qgb25lIHRhYmJhYmxlIG5vZGUgaW4gaXQsIG90aGVyd2lzZSBmb2N1cy10cmFwIHdvdWxkJ3ZlIHRocm93blxuICAgICAgICAgIC8vICBhbiBlcnJvciB0aGUgbGFzdCB0aW1lIHVwZGF0ZVRhYmJhYmxlTm9kZXMoKSB3YXMgcnVuKTogZmluZCBuZXh0IG5vZGUgYW1vbmcgYWxsIGtub3duXG4gICAgICAgICAgLy8gIGNvbnRhaW5lcnNcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBjaGVjayB0byBzZWUgaWYgdGhlcmUncyBhdCBsZWFzdCBvbmUgdGFiYmFibGUgbm9kZSB3aXRoIGEgcG9zaXRpdmUgdGFiIGluZGV4IGluc2lkZVxuICAgICAgICAgIC8vICB0aGUgdHJhcCBiZWNhdXNlIGZvY3VzIHNlZW1zIHRvIGVzY2FwZSB3aGVuIG5hdmlnYXRpbmcgYmFja3dhcmQgZnJvbSBhIHRhYmJhYmxlIG5vZGVcbiAgICAgICAgICAvLyAgd2l0aCB0YWJpbmRleD0wIHdoZW4gdGhpcyBpcyB0aGUgY2FzZSAoaW5zdGVhZCBvZiB3cmFwcGluZyB0byB0aGUgdGFiYmFibGUgbm9kZSB3aXRoXG4gICAgICAgICAgLy8gIHRoZSBncmVhdGVzdCBwb3NpdGl2ZSB0YWIgaW5kZXggbGlrZSBpdCBzaG91bGQpXG4gICAgICAgICAgaWYgKCFzdGF0ZS5jb250YWluZXJHcm91cHMuc29tZShmdW5jdGlvbiAoZykge1xuICAgICAgICAgICAgcmV0dXJuIGcudGFiYmFibGVOb2Rlcy5zb21lKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgICAgICAgIHJldHVybiBnZXRUYWJJbmRleChuKSA+IDA7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgLy8gbm8gY29udGFpbmVycyB3aXRoIHRhYmJhYmxlIG5vZGVzIHdpdGggcG9zaXRpdmUgdGFiIGluZGV4ZXMgd2hpY2ggbWVhbnMgdGhlIGZvY3VzXG4gICAgICAgICAgICAvLyAgZXNjYXBlZCBmb3Igc29tZSBvdGhlciByZWFzb24gYW5kIHdlIHNob3VsZCBqdXN0IGV4ZWN1dGUgdGhlIGZhbGxiYWNrIHRvIHRoZVxuICAgICAgICAgICAgLy8gIE1SVSBub2RlIG9yIGluaXRpYWwgZm9jdXMgbm9kZSwgaWYgYW55XG4gICAgICAgICAgICBuYXZBY3Jvc3NDb250YWluZXJzID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBubyBNUlUgbm9kZSBtZWFucyB3ZSdyZSBsaWtlbHkgaW4gc29tZSBpbml0aWFsIGNvbmRpdGlvbiB3aGVuIHRoZSB0cmFwIGhhcyBqdXN0XG4gICAgICAgIC8vICBiZWVuIGFjdGl2YXRlZCBhbmQgaW5pdGlhbCBmb2N1cyBoYXNuJ3QgYmVlbiBnaXZlbiB5ZXQsIGluIHdoaWNoIGNhc2Ugd2Ugc2hvdWxkXG4gICAgICAgIC8vICBmYWxsIHRocm91Z2ggdG8gdHJ5aW5nIHRvIGZvY3VzIHRoZSBpbml0aWFsIGZvY3VzIG5vZGUsIHdoaWNoIGlzIHdoYXQgc2hvdWxkXG4gICAgICAgIC8vICBoYXBwZW4gYmVsb3cgYXQgdGhpcyBwb2ludCBpbiB0aGUgbG9naWNcbiAgICAgICAgbmF2QWNyb3NzQ29udGFpbmVycyA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKG5hdkFjcm9zc0NvbnRhaW5lcnMpIHtcbiAgICAgICAgbmV4dE5vZGUgPSBmaW5kTmV4dE5hdk5vZGUoe1xuICAgICAgICAgIC8vIG1vdmUgRlJPTSB0aGUgTVJVIG5vZGUsIG5vdCBldmVudC1yZWxhdGVkIG5vZGUgKHdoaWNoIHdpbGwgYmUgdGhlIG5vZGUgdGhhdCBpc1xuICAgICAgICAgIC8vICBvdXRzaWRlIHRoZSB0cmFwIGNhdXNpbmcgdGhlIGZvY3VzIGVzY2FwZSB3ZSdyZSB0cnlpbmcgdG8gZml4KVxuICAgICAgICAgIHRhcmdldDogc3RhdGUubW9zdFJlY2VudGx5Rm9jdXNlZE5vZGUsXG4gICAgICAgICAgaXNCYWNrd2FyZDogY29uZmlnLmlzS2V5QmFja3dhcmQoc3RhdGUucmVjZW50TmF2RXZlbnQpXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKG5leHROb2RlKSB7XG4gICAgICAgIF90cnlGb2N1cyhuZXh0Tm9kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdHJ5Rm9jdXMoc3RhdGUubW9zdFJlY2VudGx5Rm9jdXNlZE5vZGUgfHwgZ2V0SW5pdGlhbEZvY3VzTm9kZSgpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc3RhdGUucmVjZW50TmF2RXZlbnQgPSB1bmRlZmluZWQ7IC8vIGNsZWFyXG4gIH07XG5cbiAgLy8gSGlqYWNrIGtleSBuYXYgZXZlbnRzIG9uIHRoZSBmaXJzdCBhbmQgbGFzdCBmb2N1c2FibGUgbm9kZXMgb2YgdGhlIHRyYXAsXG4gIC8vIGluIG9yZGVyIHRvIHByZXZlbnQgZm9jdXMgZnJvbSBlc2NhcGluZy4gSWYgaXQgZXNjYXBlcyBmb3IgZXZlbiBhXG4gIC8vIG1vbWVudCBpdCBjYW4gZW5kIHVwIHNjcm9sbGluZyB0aGUgcGFnZSBhbmQgY2F1c2luZyBjb25mdXNpb24gc28gd2VcbiAgLy8ga2luZCBvZiBuZWVkIHRvIGNhcHR1cmUgdGhlIGFjdGlvbiBhdCB0aGUga2V5ZG93biBwaGFzZS5cbiAgdmFyIGNoZWNrS2V5TmF2ID0gZnVuY3Rpb24gY2hlY2tLZXlOYXYoZXZlbnQpIHtcbiAgICB2YXIgaXNCYWNrd2FyZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgc3RhdGUucmVjZW50TmF2RXZlbnQgPSBldmVudDtcbiAgICB2YXIgZGVzdGluYXRpb25Ob2RlID0gZmluZE5leHROYXZOb2RlKHtcbiAgICAgIGV2ZW50OiBldmVudCxcbiAgICAgIGlzQmFja3dhcmQ6IGlzQmFja3dhcmRcbiAgICB9KTtcbiAgICBpZiAoZGVzdGluYXRpb25Ob2RlKSB7XG4gICAgICBpZiAoaXNUYWJFdmVudChldmVudCkpIHtcbiAgICAgICAgLy8gc2luY2UgdGFiIG5hdGl2ZWx5IG1vdmVzIGZvY3VzLCB3ZSB3b3VsZG4ndCBoYXZlIGEgZGVzdGluYXRpb24gbm9kZSB1bmxlc3Mgd2VcbiAgICAgICAgLy8gIHdlcmUgb24gdGhlIGVkZ2Ugb2YgYSBjb250YWluZXIgYW5kIGhhZCB0byBtb3ZlIHRvIHRoZSBuZXh0L3ByZXZpb3VzIGVkZ2UsIGluXG4gICAgICAgIC8vICB3aGljaCBjYXNlIHdlIHdhbnQgdG8gcHJldmVudCBkZWZhdWx0IHRvIGtlZXAgdGhlIGJyb3dzZXIgZnJvbSBtb3ZpbmcgZm9jdXNcbiAgICAgICAgLy8gIHRvIHdoZXJlIGl0IG5vcm1hbGx5IHdvdWxkXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgICBfdHJ5Rm9jdXMoZGVzdGluYXRpb25Ob2RlKTtcbiAgICB9XG4gICAgLy8gZWxzZSwgbGV0IHRoZSBicm93c2VyIHRha2UgY2FyZSBvZiBbc2hpZnQrXXRhYiBhbmQgbW92ZSB0aGUgZm9jdXNcbiAgfTtcbiAgdmFyIGNoZWNrVGFiS2V5ID0gZnVuY3Rpb24gY2hlY2tUYWJLZXkoZXZlbnQpIHtcbiAgICBpZiAoY29uZmlnLmlzS2V5Rm9yd2FyZChldmVudCkgfHwgY29uZmlnLmlzS2V5QmFja3dhcmQoZXZlbnQpKSB7XG4gICAgICBjaGVja0tleU5hdihldmVudCwgY29uZmlnLmlzS2V5QmFja3dhcmQoZXZlbnQpKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gd2UgdXNlIGEgZGlmZmVyZW50IGV2ZW50IHBoYXNlIGZvciB0aGUgRXNjYXBlIGtleSB0byBhbGxvdyBjYW5jZWxpbmcgdGhlIGV2ZW50IGFuZCBjaGVja2luZyBmb3IgdGhpcyBpbiBlc2NhcGVEZWFjdGl2YXRlc1xuICB2YXIgY2hlY2tFc2NhcGVLZXkgPSBmdW5jdGlvbiBjaGVja0VzY2FwZUtleShldmVudCkge1xuICAgIGlmIChpc0VzY2FwZUV2ZW50KGV2ZW50KSAmJiB2YWx1ZU9ySGFuZGxlcihjb25maWcuZXNjYXBlRGVhY3RpdmF0ZXMsIGV2ZW50KSAhPT0gZmFsc2UpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0cmFwLmRlYWN0aXZhdGUoKTtcbiAgICB9XG4gIH07XG4gIHZhciBjaGVja0NsaWNrID0gZnVuY3Rpb24gY2hlY2tDbGljayhlKSB7XG4gICAgdmFyIHRhcmdldCA9IGdldEFjdHVhbFRhcmdldChlKTtcbiAgICBpZiAoZmluZENvbnRhaW5lckluZGV4KHRhcmdldCwgZSkgPj0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodmFsdWVPckhhbmRsZXIoY29uZmlnLmNsaWNrT3V0c2lkZURlYWN0aXZhdGVzLCBlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodmFsdWVPckhhbmRsZXIoY29uZmlnLmFsbG93T3V0c2lkZUNsaWNrLCBlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgfTtcblxuICAvL1xuICAvLyBFVkVOVCBMSVNURU5FUlNcbiAgLy9cblxuICB2YXIgYWRkTGlzdGVuZXJzID0gZnVuY3Rpb24gYWRkTGlzdGVuZXJzKCkge1xuICAgIGlmICghc3RhdGUuYWN0aXZlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVGhlcmUgY2FuIGJlIG9ubHkgb25lIGxpc3RlbmluZyBmb2N1cyB0cmFwIGF0IGEgdGltZVxuICAgIGFjdGl2ZUZvY3VzVHJhcHMuYWN0aXZhdGVUcmFwKHRyYXBTdGFjaywgdHJhcCk7XG5cbiAgICAvLyBEZWxheSBlbnN1cmVzIHRoYXQgdGhlIGZvY3VzZWQgZWxlbWVudCBkb2Vzbid0IGNhcHR1cmUgdGhlIGV2ZW50XG4gICAgLy8gdGhhdCBjYXVzZWQgdGhlIGZvY3VzIHRyYXAgYWN0aXZhdGlvbi5cbiAgICBzdGF0ZS5kZWxheUluaXRpYWxGb2N1c1RpbWVyID0gY29uZmlnLmRlbGF5SW5pdGlhbEZvY3VzID8gZGVsYXkoZnVuY3Rpb24gKCkge1xuICAgICAgX3RyeUZvY3VzKGdldEluaXRpYWxGb2N1c05vZGUoKSk7XG4gICAgfSkgOiBfdHJ5Rm9jdXMoZ2V0SW5pdGlhbEZvY3VzTm9kZSgpKTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIGNoZWNrRm9jdXNJbiwgdHJ1ZSk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIGNoZWNrUG9pbnRlckRvd24sIHtcbiAgICAgIGNhcHR1cmU6IHRydWUsXG4gICAgICBwYXNzaXZlOiBmYWxzZVxuICAgIH0pO1xuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgY2hlY2tQb2ludGVyRG93biwge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgfSk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgY2hlY2tDbGljaywge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgfSk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBjaGVja1RhYktleSwge1xuICAgICAgY2FwdHVyZTogdHJ1ZSxcbiAgICAgIHBhc3NpdmU6IGZhbHNlXG4gICAgfSk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBjaGVja0VzY2FwZUtleSk7XG4gICAgcmV0dXJuIHRyYXA7XG4gIH07XG4gIHZhciByZW1vdmVMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKCFzdGF0ZS5hY3RpdmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzaW4nLCBjaGVja0ZvY3VzSW4sIHRydWUpO1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBjaGVja1BvaW50ZXJEb3duLCB0cnVlKTtcbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGNoZWNrUG9pbnRlckRvd24sIHRydWUpO1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGNoZWNrQ2xpY2ssIHRydWUpO1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgY2hlY2tUYWJLZXksIHRydWUpO1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgY2hlY2tFc2NhcGVLZXkpO1xuICAgIHJldHVybiB0cmFwO1xuICB9O1xuXG4gIC8vXG4gIC8vIE1VVEFUSU9OIE9CU0VSVkVSXG4gIC8vXG5cbiAgdmFyIGNoZWNrRG9tUmVtb3ZhbCA9IGZ1bmN0aW9uIGNoZWNrRG9tUmVtb3ZhbChtdXRhdGlvbnMpIHtcbiAgICB2YXIgaXNGb2N1c2VkTm9kZVJlbW92ZWQgPSBtdXRhdGlvbnMuc29tZShmdW5jdGlvbiAobXV0YXRpb24pIHtcbiAgICAgIHZhciByZW1vdmVkTm9kZXMgPSBBcnJheS5mcm9tKG11dGF0aW9uLnJlbW92ZWROb2Rlcyk7XG4gICAgICByZXR1cm4gcmVtb3ZlZE5vZGVzLnNvbWUoZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUgPT09IHN0YXRlLm1vc3RSZWNlbnRseUZvY3VzZWROb2RlO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBJZiB0aGUgY3VycmVudGx5IGZvY3VzZWQgaXMgcmVtb3ZlZCB0aGVuIGJyb3dzZXJzIHdpbGwgbW92ZSBmb2N1cyB0byB0aGVcbiAgICAvLyA8Ym9keT4gZWxlbWVudC4gSWYgdGhpcyBoYXBwZW5zLCB0cnkgdG8gbW92ZSBmb2N1cyBiYWNrIGludG8gdGhlIHRyYXAuXG4gICAgaWYgKGlzRm9jdXNlZE5vZGVSZW1vdmVkKSB7XG4gICAgICBfdHJ5Rm9jdXMoZ2V0SW5pdGlhbEZvY3VzTm9kZSgpKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gVXNlIE11dGF0aW9uT2JzZXJ2ZXIgLSBpZiBzdXBwb3J0ZWQgLSB0byBkZXRlY3QgaWYgZm9jdXNlZCBub2RlIGlzIHJlbW92ZWRcbiAgLy8gZnJvbSB0aGUgRE9NLlxuICB2YXIgbXV0YXRpb25PYnNlcnZlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICdNdXRhdGlvbk9ic2VydmVyJyBpbiB3aW5kb3cgPyBuZXcgTXV0YXRpb25PYnNlcnZlcihjaGVja0RvbVJlbW92YWwpIDogdW5kZWZpbmVkO1xuICB2YXIgdXBkYXRlT2JzZXJ2ZWROb2RlcyA9IGZ1bmN0aW9uIHVwZGF0ZU9ic2VydmVkTm9kZXMoKSB7XG4gICAgaWYgKCFtdXRhdGlvbk9ic2VydmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG11dGF0aW9uT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIGlmIChzdGF0ZS5hY3RpdmUgJiYgIXN0YXRlLnBhdXNlZCkge1xuICAgICAgc3RhdGUuY29udGFpbmVycy5tYXAoZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgICAgICBtdXRhdGlvbk9ic2VydmVyLm9ic2VydmUoY29udGFpbmVyLCB7XG4gICAgICAgICAgc3VidHJlZTogdHJ1ZSxcbiAgICAgICAgICBjaGlsZExpc3Q6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG5cbiAgLy9cbiAgLy8gVFJBUCBERUZJTklUSU9OXG4gIC8vXG5cbiAgdHJhcCA9IHtcbiAgICBnZXQgYWN0aXZlKCkge1xuICAgICAgcmV0dXJuIHN0YXRlLmFjdGl2ZTtcbiAgICB9LFxuICAgIGdldCBwYXVzZWQoKSB7XG4gICAgICByZXR1cm4gc3RhdGUucGF1c2VkO1xuICAgIH0sXG4gICAgYWN0aXZhdGU6IGZ1bmN0aW9uIGFjdGl2YXRlKGFjdGl2YXRlT3B0aW9ucykge1xuICAgICAgaWYgKHN0YXRlLmFjdGl2ZSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHZhciBvbkFjdGl2YXRlID0gZ2V0T3B0aW9uKGFjdGl2YXRlT3B0aW9ucywgJ29uQWN0aXZhdGUnKTtcbiAgICAgIHZhciBvblBvc3RBY3RpdmF0ZSA9IGdldE9wdGlvbihhY3RpdmF0ZU9wdGlvbnMsICdvblBvc3RBY3RpdmF0ZScpO1xuICAgICAgdmFyIGNoZWNrQ2FuRm9jdXNUcmFwID0gZ2V0T3B0aW9uKGFjdGl2YXRlT3B0aW9ucywgJ2NoZWNrQ2FuRm9jdXNUcmFwJyk7XG4gICAgICBpZiAoIWNoZWNrQ2FuRm9jdXNUcmFwKSB7XG4gICAgICAgIHVwZGF0ZVRhYmJhYmxlTm9kZXMoKTtcbiAgICAgIH1cbiAgICAgIHN0YXRlLmFjdGl2ZSA9IHRydWU7XG4gICAgICBzdGF0ZS5wYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0YXRlLm5vZGVGb2N1c2VkQmVmb3JlQWN0aXZhdGlvbiA9IF9nZXRBY3RpdmVFbGVtZW50KGRvYyk7XG4gICAgICBvbkFjdGl2YXRlID09PSBudWxsIHx8IG9uQWN0aXZhdGUgPT09IHZvaWQgMCB8fCBvbkFjdGl2YXRlKCk7XG4gICAgICB2YXIgZmluaXNoQWN0aXZhdGlvbiA9IGZ1bmN0aW9uIGZpbmlzaEFjdGl2YXRpb24oKSB7XG4gICAgICAgIGlmIChjaGVja0NhbkZvY3VzVHJhcCkge1xuICAgICAgICAgIHVwZGF0ZVRhYmJhYmxlTm9kZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRMaXN0ZW5lcnMoKTtcbiAgICAgICAgdXBkYXRlT2JzZXJ2ZWROb2RlcygpO1xuICAgICAgICBvblBvc3RBY3RpdmF0ZSA9PT0gbnVsbCB8fCBvblBvc3RBY3RpdmF0ZSA9PT0gdm9pZCAwIHx8IG9uUG9zdEFjdGl2YXRlKCk7XG4gICAgICB9O1xuICAgICAgaWYgKGNoZWNrQ2FuRm9jdXNUcmFwKSB7XG4gICAgICAgIGNoZWNrQ2FuRm9jdXNUcmFwKHN0YXRlLmNvbnRhaW5lcnMuY29uY2F0KCkpLnRoZW4oZmluaXNoQWN0aXZhdGlvbiwgZmluaXNoQWN0aXZhdGlvbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgZmluaXNoQWN0aXZhdGlvbigpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBkZWFjdGl2YXRlOiBmdW5jdGlvbiBkZWFjdGl2YXRlKGRlYWN0aXZhdGVPcHRpb25zKSB7XG4gICAgICBpZiAoIXN0YXRlLmFjdGl2ZSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHZhciBvcHRpb25zID0gX29iamVjdFNwcmVhZDIoe1xuICAgICAgICBvbkRlYWN0aXZhdGU6IGNvbmZpZy5vbkRlYWN0aXZhdGUsXG4gICAgICAgIG9uUG9zdERlYWN0aXZhdGU6IGNvbmZpZy5vblBvc3REZWFjdGl2YXRlLFxuICAgICAgICBjaGVja0NhblJldHVybkZvY3VzOiBjb25maWcuY2hlY2tDYW5SZXR1cm5Gb2N1c1xuICAgICAgfSwgZGVhY3RpdmF0ZU9wdGlvbnMpO1xuICAgICAgY2xlYXJUaW1lb3V0KHN0YXRlLmRlbGF5SW5pdGlhbEZvY3VzVGltZXIpOyAvLyBub29wIGlmIHVuZGVmaW5lZFxuICAgICAgc3RhdGUuZGVsYXlJbml0aWFsRm9jdXNUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgIHJlbW92ZUxpc3RlbmVycygpO1xuICAgICAgc3RhdGUuYWN0aXZlID0gZmFsc2U7XG4gICAgICBzdGF0ZS5wYXVzZWQgPSBmYWxzZTtcbiAgICAgIHVwZGF0ZU9ic2VydmVkTm9kZXMoKTtcbiAgICAgIGFjdGl2ZUZvY3VzVHJhcHMuZGVhY3RpdmF0ZVRyYXAodHJhcFN0YWNrLCB0cmFwKTtcbiAgICAgIHZhciBvbkRlYWN0aXZhdGUgPSBnZXRPcHRpb24ob3B0aW9ucywgJ29uRGVhY3RpdmF0ZScpO1xuICAgICAgdmFyIG9uUG9zdERlYWN0aXZhdGUgPSBnZXRPcHRpb24ob3B0aW9ucywgJ29uUG9zdERlYWN0aXZhdGUnKTtcbiAgICAgIHZhciBjaGVja0NhblJldHVybkZvY3VzID0gZ2V0T3B0aW9uKG9wdGlvbnMsICdjaGVja0NhblJldHVybkZvY3VzJyk7XG4gICAgICB2YXIgcmV0dXJuRm9jdXMgPSBnZXRPcHRpb24ob3B0aW9ucywgJ3JldHVybkZvY3VzJywgJ3JldHVybkZvY3VzT25EZWFjdGl2YXRlJyk7XG4gICAgICBvbkRlYWN0aXZhdGUgPT09IG51bGwgfHwgb25EZWFjdGl2YXRlID09PSB2b2lkIDAgfHwgb25EZWFjdGl2YXRlKCk7XG4gICAgICB2YXIgZmluaXNoRGVhY3RpdmF0aW9uID0gZnVuY3Rpb24gZmluaXNoRGVhY3RpdmF0aW9uKCkge1xuICAgICAgICBkZWxheShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHJldHVybkZvY3VzKSB7XG4gICAgICAgICAgICBfdHJ5Rm9jdXMoZ2V0UmV0dXJuRm9jdXNOb2RlKHN0YXRlLm5vZGVGb2N1c2VkQmVmb3JlQWN0aXZhdGlvbikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvblBvc3REZWFjdGl2YXRlID09PSBudWxsIHx8IG9uUG9zdERlYWN0aXZhdGUgPT09IHZvaWQgMCB8fCBvblBvc3REZWFjdGl2YXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIGlmIChyZXR1cm5Gb2N1cyAmJiBjaGVja0NhblJldHVybkZvY3VzKSB7XG4gICAgICAgIGNoZWNrQ2FuUmV0dXJuRm9jdXMoZ2V0UmV0dXJuRm9jdXNOb2RlKHN0YXRlLm5vZGVGb2N1c2VkQmVmb3JlQWN0aXZhdGlvbikpLnRoZW4oZmluaXNoRGVhY3RpdmF0aW9uLCBmaW5pc2hEZWFjdGl2YXRpb24pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIGZpbmlzaERlYWN0aXZhdGlvbigpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBwYXVzZTogZnVuY3Rpb24gcGF1c2UocGF1c2VPcHRpb25zKSB7XG4gICAgICBpZiAoIXN0YXRlLmFjdGl2ZSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHN0YXRlLm1hbnVhbGx5UGF1c2VkID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzLl9zZXRQYXVzZWRTdGF0ZSh0cnVlLCBwYXVzZU9wdGlvbnMpO1xuICAgIH0sXG4gICAgdW5wYXVzZTogZnVuY3Rpb24gdW5wYXVzZSh1bnBhdXNlT3B0aW9ucykge1xuICAgICAgaWYgKCFzdGF0ZS5hY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICBzdGF0ZS5tYW51YWxseVBhdXNlZCA9IGZhbHNlO1xuICAgICAgaWYgKHRyYXBTdGFja1t0cmFwU3RhY2subGVuZ3RoIC0gMV0gIT09IHRoaXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fc2V0UGF1c2VkU3RhdGUoZmFsc2UsIHVucGF1c2VPcHRpb25zKTtcbiAgICB9LFxuICAgIHVwZGF0ZUNvbnRhaW5lckVsZW1lbnRzOiBmdW5jdGlvbiB1cGRhdGVDb250YWluZXJFbGVtZW50cyhjb250YWluZXJFbGVtZW50cykge1xuICAgICAgdmFyIGVsZW1lbnRzQXNBcnJheSA9IFtdLmNvbmNhdChjb250YWluZXJFbGVtZW50cykuZmlsdGVyKEJvb2xlYW4pO1xuICAgICAgc3RhdGUuY29udGFpbmVycyA9IGVsZW1lbnRzQXNBcnJheS5tYXAoZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJyA/IGRvYy5xdWVyeVNlbGVjdG9yKGVsZW1lbnQpIDogZWxlbWVudDtcbiAgICAgIH0pO1xuICAgICAgaWYgKHN0YXRlLmFjdGl2ZSkge1xuICAgICAgICB1cGRhdGVUYWJiYWJsZU5vZGVzKCk7XG4gICAgICB9XG4gICAgICB1cGRhdGVPYnNlcnZlZE5vZGVzKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRyYXAsIHtcbiAgICBfaXNNYW51YWxseVBhdXNlZDoge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xuICAgICAgICByZXR1cm4gc3RhdGUubWFudWFsbHlQYXVzZWQ7XG4gICAgICB9XG4gICAgfSxcbiAgICBfc2V0UGF1c2VkU3RhdGU6IHtcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShwYXVzZWQsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHN0YXRlLnBhdXNlZCA9PT0gcGF1c2VkKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUucGF1c2VkID0gcGF1c2VkO1xuICAgICAgICBpZiAocGF1c2VkKSB7XG4gICAgICAgICAgdmFyIG9uUGF1c2UgPSBnZXRPcHRpb24ob3B0aW9ucywgJ29uUGF1c2UnKTtcbiAgICAgICAgICB2YXIgb25Qb3N0UGF1c2UgPSBnZXRPcHRpb24ob3B0aW9ucywgJ29uUG9zdFBhdXNlJyk7XG4gICAgICAgICAgb25QYXVzZSA9PT0gbnVsbCB8fCBvblBhdXNlID09PSB2b2lkIDAgfHwgb25QYXVzZSgpO1xuICAgICAgICAgIHJlbW92ZUxpc3RlbmVycygpO1xuICAgICAgICAgIHVwZGF0ZU9ic2VydmVkTm9kZXMoKTtcbiAgICAgICAgICBvblBvc3RQYXVzZSA9PT0gbnVsbCB8fCBvblBvc3RQYXVzZSA9PT0gdm9pZCAwIHx8IG9uUG9zdFBhdXNlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG9uVW5wYXVzZSA9IGdldE9wdGlvbihvcHRpb25zLCAnb25VbnBhdXNlJyk7XG4gICAgICAgICAgdmFyIG9uUG9zdFVucGF1c2UgPSBnZXRPcHRpb24ob3B0aW9ucywgJ29uUG9zdFVucGF1c2UnKTtcbiAgICAgICAgICBvblVucGF1c2UgPT09IG51bGwgfHwgb25VbnBhdXNlID09PSB2b2lkIDAgfHwgb25VbnBhdXNlKCk7XG4gICAgICAgICAgdXBkYXRlVGFiYmFibGVOb2RlcygpO1xuICAgICAgICAgIGFkZExpc3RlbmVycygpO1xuICAgICAgICAgIHVwZGF0ZU9ic2VydmVkTm9kZXMoKTtcbiAgICAgICAgICBvblBvc3RVbnBhdXNlID09PSBudWxsIHx8IG9uUG9zdFVucGF1c2UgPT09IHZvaWQgMCB8fCBvblBvc3RVbnBhdXNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICAvLyBpbml0aWFsaXplIGNvbnRhaW5lciBlbGVtZW50c1xuICB0cmFwLnVwZGF0ZUNvbnRhaW5lckVsZW1lbnRzKGVsZW1lbnRzKTtcbiAgcmV0dXJuIHRyYXA7XG59O1xuXG5leHBvcnQgeyBjcmVhdGVGb2N1c1RyYXAgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvY3VzLXRyYXAuZXNtLmpzLm1hcFxuIiwiLyoqIVxuICogU29ydGFibGUgMS4xNS42XG4gKiBAYXV0aG9yXHRSdWJhWGEgICA8dHJhc2hAcnViYXhhLm9yZz5cbiAqIEBhdXRob3JcdG93ZW5tICAgIDxvd2VuMjMzNTVAZ21haWwuY29tPlxuICogQGxpY2Vuc2UgTUlUXG4gKi9cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkge1xuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgaWYgKGVudW1lcmFibGVPbmx5KSB7XG4gICAgICBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XG4gIH1cbiAgcmV0dXJuIGtleXM7XG59XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkMih0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTtcbiAgICBpZiAoaSAlIDIpIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59XG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5mdW5jdGlvbiBfZXh0ZW5kcygpIHtcbiAgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG4gIHJldHVybiBfZXh0ZW5kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG4gIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7XG4gIHZhciBrZXksIGk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7XG4gICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07XG4gICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gIHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpO1xufVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xufVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTtcbiAgcmV0dXJuIGFycjI7XG59XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuXG52YXIgdmVyc2lvbiA9IFwiMS4xNS42XCI7XG5cbmZ1bmN0aW9uIHVzZXJBZ2VudChwYXR0ZXJuKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cubmF2aWdhdG9yKSB7XG4gICAgcmV0dXJuICEhIC8qQF9fUFVSRV9fKi9uYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKHBhdHRlcm4pO1xuICB9XG59XG52YXIgSUUxMU9yTGVzcyA9IHVzZXJBZ2VudCgvKD86VHJpZGVudC4qcnZbIDpdPzExXFwufG1zaWV8aWVtb2JpbGV8V2luZG93cyBQaG9uZSkvaSk7XG52YXIgRWRnZSA9IHVzZXJBZ2VudCgvRWRnZS9pKTtcbnZhciBGaXJlRm94ID0gdXNlckFnZW50KC9maXJlZm94L2kpO1xudmFyIFNhZmFyaSA9IHVzZXJBZ2VudCgvc2FmYXJpL2kpICYmICF1c2VyQWdlbnQoL2Nocm9tZS9pKSAmJiAhdXNlckFnZW50KC9hbmRyb2lkL2kpO1xudmFyIElPUyA9IHVzZXJBZ2VudCgvaVAoYWR8b2R8aG9uZSkvaSk7XG52YXIgQ2hyb21lRm9yQW5kcm9pZCA9IHVzZXJBZ2VudCgvY2hyb21lL2kpICYmIHVzZXJBZ2VudCgvYW5kcm9pZC9pKTtcblxudmFyIGNhcHR1cmVNb2RlID0ge1xuICBjYXB0dXJlOiBmYWxzZSxcbiAgcGFzc2l2ZTogZmFsc2Vcbn07XG5mdW5jdGlvbiBvbihlbCwgZXZlbnQsIGZuKSB7XG4gIGVsLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGZuLCAhSUUxMU9yTGVzcyAmJiBjYXB0dXJlTW9kZSk7XG59XG5mdW5jdGlvbiBvZmYoZWwsIGV2ZW50LCBmbikge1xuICBlbC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBmbiwgIUlFMTFPckxlc3MgJiYgY2FwdHVyZU1vZGUpO1xufVxuZnVuY3Rpb24gbWF0Y2hlcyggLyoqSFRNTEVsZW1lbnQqL2VsLCAvKipTdHJpbmcqL3NlbGVjdG9yKSB7XG4gIGlmICghc2VsZWN0b3IpIHJldHVybjtcbiAgc2VsZWN0b3JbMF0gPT09ICc+JyAmJiAoc2VsZWN0b3IgPSBzZWxlY3Rvci5zdWJzdHJpbmcoMSkpO1xuICBpZiAoZWwpIHtcbiAgICB0cnkge1xuICAgICAgaWYgKGVsLm1hdGNoZXMpIHtcbiAgICAgICAgcmV0dXJuIGVsLm1hdGNoZXMoc2VsZWN0b3IpO1xuICAgICAgfSBlbHNlIGlmIChlbC5tc01hdGNoZXNTZWxlY3Rvcikge1xuICAgICAgICByZXR1cm4gZWwubXNNYXRjaGVzU2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgICAgfSBlbHNlIGlmIChlbC53ZWJraXRNYXRjaGVzU2VsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIGVsLndlYmtpdE1hdGNoZXNTZWxlY3RvcihzZWxlY3Rvcik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoXykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBnZXRQYXJlbnRPckhvc3QoZWwpIHtcbiAgcmV0dXJuIGVsLmhvc3QgJiYgZWwgIT09IGRvY3VtZW50ICYmIGVsLmhvc3Qubm9kZVR5cGUgPyBlbC5ob3N0IDogZWwucGFyZW50Tm9kZTtcbn1cbmZ1bmN0aW9uIGNsb3Nlc3QoIC8qKkhUTUxFbGVtZW50Ki9lbCwgLyoqU3RyaW5nKi9zZWxlY3RvciwgLyoqSFRNTEVsZW1lbnQqL2N0eCwgaW5jbHVkZUNUWCkge1xuICBpZiAoZWwpIHtcbiAgICBjdHggPSBjdHggfHwgZG9jdW1lbnQ7XG4gICAgZG8ge1xuICAgICAgaWYgKHNlbGVjdG9yICE9IG51bGwgJiYgKHNlbGVjdG9yWzBdID09PSAnPicgPyBlbC5wYXJlbnROb2RlID09PSBjdHggJiYgbWF0Y2hlcyhlbCwgc2VsZWN0b3IpIDogbWF0Y2hlcyhlbCwgc2VsZWN0b3IpKSB8fCBpbmNsdWRlQ1RYICYmIGVsID09PSBjdHgpIHtcbiAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgfVxuICAgICAgaWYgKGVsID09PSBjdHgpIGJyZWFrO1xuICAgICAgLyoganNoaW50IGJvc3M6dHJ1ZSAqL1xuICAgIH0gd2hpbGUgKGVsID0gZ2V0UGFyZW50T3JIb3N0KGVsKSk7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG52YXIgUl9TUEFDRSA9IC9cXHMrL2c7XG5mdW5jdGlvbiB0b2dnbGVDbGFzcyhlbCwgbmFtZSwgc3RhdGUpIHtcbiAgaWYgKGVsICYmIG5hbWUpIHtcbiAgICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgICBlbC5jbGFzc0xpc3Rbc3RhdGUgPyAnYWRkJyA6ICdyZW1vdmUnXShuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNsYXNzTmFtZSA9ICgnICcgKyBlbC5jbGFzc05hbWUgKyAnICcpLnJlcGxhY2UoUl9TUEFDRSwgJyAnKS5yZXBsYWNlKCcgJyArIG5hbWUgKyAnICcsICcgJyk7XG4gICAgICBlbC5jbGFzc05hbWUgPSAoY2xhc3NOYW1lICsgKHN0YXRlID8gJyAnICsgbmFtZSA6ICcnKSkucmVwbGFjZShSX1NQQUNFLCAnICcpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY3NzKGVsLCBwcm9wLCB2YWwpIHtcbiAgdmFyIHN0eWxlID0gZWwgJiYgZWwuc3R5bGU7XG4gIGlmIChzdHlsZSkge1xuICAgIGlmICh2YWwgPT09IHZvaWQgMCkge1xuICAgICAgaWYgKGRvY3VtZW50LmRlZmF1bHRWaWV3ICYmIGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUpIHtcbiAgICAgICAgdmFsID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZShlbCwgJycpO1xuICAgICAgfSBlbHNlIGlmIChlbC5jdXJyZW50U3R5bGUpIHtcbiAgICAgICAgdmFsID0gZWwuY3VycmVudFN0eWxlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByb3AgPT09IHZvaWQgMCA/IHZhbCA6IHZhbFtwcm9wXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCEocHJvcCBpbiBzdHlsZSkgJiYgcHJvcC5pbmRleE9mKCd3ZWJraXQnKSA9PT0gLTEpIHtcbiAgICAgICAgcHJvcCA9ICctd2Via2l0LScgKyBwcm9wO1xuICAgICAgfVxuICAgICAgc3R5bGVbcHJvcF0gPSB2YWwgKyAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgPyAnJyA6ICdweCcpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWF0cml4KGVsLCBzZWxmT25seSkge1xuICB2YXIgYXBwbGllZFRyYW5zZm9ybXMgPSAnJztcbiAgaWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcbiAgICBhcHBsaWVkVHJhbnNmb3JtcyA9IGVsO1xuICB9IGVsc2Uge1xuICAgIGRvIHtcbiAgICAgIHZhciB0cmFuc2Zvcm0gPSBjc3MoZWwsICd0cmFuc2Zvcm0nKTtcbiAgICAgIGlmICh0cmFuc2Zvcm0gJiYgdHJhbnNmb3JtICE9PSAnbm9uZScpIHtcbiAgICAgICAgYXBwbGllZFRyYW5zZm9ybXMgPSB0cmFuc2Zvcm0gKyAnICcgKyBhcHBsaWVkVHJhbnNmb3JtcztcbiAgICAgIH1cbiAgICAgIC8qIGpzaGludCBib3NzOnRydWUgKi9cbiAgICB9IHdoaWxlICghc2VsZk9ubHkgJiYgKGVsID0gZWwucGFyZW50Tm9kZSkpO1xuICB9XG4gIHZhciBtYXRyaXhGbiA9IHdpbmRvdy5ET01NYXRyaXggfHwgd2luZG93LldlYktpdENTU01hdHJpeCB8fCB3aW5kb3cuQ1NTTWF0cml4IHx8IHdpbmRvdy5NU0NTU01hdHJpeDtcbiAgLypqc2hpbnQgLVcwNTYgKi9cbiAgcmV0dXJuIG1hdHJpeEZuICYmIG5ldyBtYXRyaXhGbihhcHBsaWVkVHJhbnNmb3Jtcyk7XG59XG5mdW5jdGlvbiBmaW5kKGN0eCwgdGFnTmFtZSwgaXRlcmF0b3IpIHtcbiAgaWYgKGN0eCkge1xuICAgIHZhciBsaXN0ID0gY3R4LmdldEVsZW1lbnRzQnlUYWdOYW1lKHRhZ05hbWUpLFxuICAgICAgaSA9IDAsXG4gICAgICBuID0gbGlzdC5sZW5ndGg7XG4gICAgaWYgKGl0ZXJhdG9yKSB7XG4gICAgICBmb3IgKDsgaSA8IG47IGkrKykge1xuICAgICAgICBpdGVyYXRvcihsaXN0W2ldLCBpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxpc3Q7XG4gIH1cbiAgcmV0dXJuIFtdO1xufVxuZnVuY3Rpb24gZ2V0V2luZG93U2Nyb2xsaW5nRWxlbWVudCgpIHtcbiAgdmFyIHNjcm9sbGluZ0VsZW1lbnQgPSBkb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50O1xuICBpZiAoc2Nyb2xsaW5nRWxlbWVudCkge1xuICAgIHJldHVybiBzY3JvbGxpbmdFbGVtZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIH1cbn1cblxuLyoqXHJcbiAqIFJldHVybnMgdGhlIFwiYm91bmRpbmcgY2xpZW50IHJlY3RcIiBvZiBnaXZlbiBlbGVtZW50XHJcbiAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSBlbCAgICAgICAgICAgICAgICAgICAgICAgVGhlIGVsZW1lbnQgd2hvc2UgYm91bmRpbmdDbGllbnRSZWN0IGlzIHdhbnRlZFxyXG4gKiBAcGFyYW0gIHtbQm9vbGVhbl19IHJlbGF0aXZlVG9Db250YWluaW5nQmxvY2sgIFdoZXRoZXIgdGhlIHJlY3Qgc2hvdWxkIGJlIHJlbGF0aXZlIHRvIHRoZSBjb250YWluaW5nIGJsb2NrIG9mIChpbmNsdWRpbmcpIHRoZSBjb250YWluZXJcclxuICogQHBhcmFtICB7W0Jvb2xlYW5dfSByZWxhdGl2ZVRvTm9uU3RhdGljUGFyZW50ICBXaGV0aGVyIHRoZSByZWN0IHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgcmVsYXRpdmUgcGFyZW50IG9mIChpbmNsdWRpbmcpIHRoZSBjb250YWllbnJcclxuICogQHBhcmFtICB7W0Jvb2xlYW5dfSB1bmRvU2NhbGUgICAgICAgICAgICAgICAgICBXaGV0aGVyIHRoZSBjb250YWluZXIncyBzY2FsZSgpIHNob3VsZCBiZSB1bmRvbmVcclxuICogQHBhcmFtICB7W0hUTUxFbGVtZW50XX0gY29udGFpbmVyICAgICAgICAgICAgICBUaGUgcGFyZW50IHRoZSBlbGVtZW50IHdpbGwgYmUgcGxhY2VkIGluXHJcbiAqIEByZXR1cm4ge09iamVjdH0gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIGJvdW5kaW5nQ2xpZW50UmVjdCBvZiBlbCwgd2l0aCBzcGVjaWZpZWQgYWRqdXN0bWVudHNcclxuICovXG5mdW5jdGlvbiBnZXRSZWN0KGVsLCByZWxhdGl2ZVRvQ29udGFpbmluZ0Jsb2NrLCByZWxhdGl2ZVRvTm9uU3RhdGljUGFyZW50LCB1bmRvU2NhbGUsIGNvbnRhaW5lcikge1xuICBpZiAoIWVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCAmJiBlbCAhPT0gd2luZG93KSByZXR1cm47XG4gIHZhciBlbFJlY3QsIHRvcCwgbGVmdCwgYm90dG9tLCByaWdodCwgaGVpZ2h0LCB3aWR0aDtcbiAgaWYgKGVsICE9PSB3aW5kb3cgJiYgZWwucGFyZW50Tm9kZSAmJiBlbCAhPT0gZ2V0V2luZG93U2Nyb2xsaW5nRWxlbWVudCgpKSB7XG4gICAgZWxSZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdG9wID0gZWxSZWN0LnRvcDtcbiAgICBsZWZ0ID0gZWxSZWN0LmxlZnQ7XG4gICAgYm90dG9tID0gZWxSZWN0LmJvdHRvbTtcbiAgICByaWdodCA9IGVsUmVjdC5yaWdodDtcbiAgICBoZWlnaHQgPSBlbFJlY3QuaGVpZ2h0O1xuICAgIHdpZHRoID0gZWxSZWN0LndpZHRoO1xuICB9IGVsc2Uge1xuICAgIHRvcCA9IDA7XG4gICAgbGVmdCA9IDA7XG4gICAgYm90dG9tID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgIHJpZ2h0ID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgIHdpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gIH1cbiAgaWYgKChyZWxhdGl2ZVRvQ29udGFpbmluZ0Jsb2NrIHx8IHJlbGF0aXZlVG9Ob25TdGF0aWNQYXJlbnQpICYmIGVsICE9PSB3aW5kb3cpIHtcbiAgICAvLyBBZGp1c3QgZm9yIHRyYW5zbGF0ZSgpXG4gICAgY29udGFpbmVyID0gY29udGFpbmVyIHx8IGVsLnBhcmVudE5vZGU7XG5cbiAgICAvLyBzb2x2ZXMgIzExMjMgKHNlZTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM3OTUzODA2LzYwODgzMTIpXG4gICAgLy8gTm90IG5lZWRlZCBvbiA8PSBJRTExXG4gICAgaWYgKCFJRTExT3JMZXNzKSB7XG4gICAgICBkbyB7XG4gICAgICAgIGlmIChjb250YWluZXIgJiYgY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCAmJiAoY3NzKGNvbnRhaW5lciwgJ3RyYW5zZm9ybScpICE9PSAnbm9uZScgfHwgcmVsYXRpdmVUb05vblN0YXRpY1BhcmVudCAmJiBjc3MoY29udGFpbmVyLCAncG9zaXRpb24nKSAhPT0gJ3N0YXRpYycpKSB7XG4gICAgICAgICAgdmFyIGNvbnRhaW5lclJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgICAvLyBTZXQgcmVsYXRpdmUgdG8gZWRnZXMgb2YgcGFkZGluZyBib3ggb2YgY29udGFpbmVyXG4gICAgICAgICAgdG9wIC09IGNvbnRhaW5lclJlY3QudG9wICsgcGFyc2VJbnQoY3NzKGNvbnRhaW5lciwgJ2JvcmRlci10b3Atd2lkdGgnKSk7XG4gICAgICAgICAgbGVmdCAtPSBjb250YWluZXJSZWN0LmxlZnQgKyBwYXJzZUludChjc3MoY29udGFpbmVyLCAnYm9yZGVyLWxlZnQtd2lkdGgnKSk7XG4gICAgICAgICAgYm90dG9tID0gdG9wICsgZWxSZWN0LmhlaWdodDtcbiAgICAgICAgICByaWdodCA9IGxlZnQgKyBlbFJlY3Qud2lkdGg7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLyoganNoaW50IGJvc3M6dHJ1ZSAqL1xuICAgICAgfSB3aGlsZSAoY29udGFpbmVyID0gY29udGFpbmVyLnBhcmVudE5vZGUpO1xuICAgIH1cbiAgfVxuICBpZiAodW5kb1NjYWxlICYmIGVsICE9PSB3aW5kb3cpIHtcbiAgICAvLyBBZGp1c3QgZm9yIHNjYWxlKClcbiAgICB2YXIgZWxNYXRyaXggPSBtYXRyaXgoY29udGFpbmVyIHx8IGVsKSxcbiAgICAgIHNjYWxlWCA9IGVsTWF0cml4ICYmIGVsTWF0cml4LmEsXG4gICAgICBzY2FsZVkgPSBlbE1hdHJpeCAmJiBlbE1hdHJpeC5kO1xuICAgIGlmIChlbE1hdHJpeCkge1xuICAgICAgdG9wIC89IHNjYWxlWTtcbiAgICAgIGxlZnQgLz0gc2NhbGVYO1xuICAgICAgd2lkdGggLz0gc2NhbGVYO1xuICAgICAgaGVpZ2h0IC89IHNjYWxlWTtcbiAgICAgIGJvdHRvbSA9IHRvcCArIGhlaWdodDtcbiAgICAgIHJpZ2h0ID0gbGVmdCArIHdpZHRoO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHRvcDogdG9wLFxuICAgIGxlZnQ6IGxlZnQsXG4gICAgYm90dG9tOiBib3R0b20sXG4gICAgcmlnaHQ6IHJpZ2h0LFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodFxuICB9O1xufVxuXG4vKipcclxuICogQ2hlY2tzIGlmIGEgc2lkZSBvZiBhbiBlbGVtZW50IGlzIHNjcm9sbGVkIHBhc3QgYSBzaWRlIG9mIGl0cyBwYXJlbnRzXHJcbiAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSAgZWwgICAgICAgICAgIFRoZSBlbGVtZW50IHdobydzIHNpZGUgYmVpbmcgc2Nyb2xsZWQgb3V0IG9mIHZpZXcgaXMgaW4gcXVlc3Rpb25cclxuICogQHBhcmFtICB7U3RyaW5nfSAgICAgICBlbFNpZGUgICAgICAgU2lkZSBvZiB0aGUgZWxlbWVudCBpbiBxdWVzdGlvbiAoJ3RvcCcsICdsZWZ0JywgJ3JpZ2h0JywgJ2JvdHRvbScpXHJcbiAqIEBwYXJhbSAge1N0cmluZ30gICAgICAgcGFyZW50U2lkZSAgIFNpZGUgb2YgdGhlIHBhcmVudCBpbiBxdWVzdGlvbiAoJ3RvcCcsICdsZWZ0JywgJ3JpZ2h0JywgJ2JvdHRvbScpXHJcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSAgICAgICAgICAgICAgIFRoZSBwYXJlbnQgc2Nyb2xsIGVsZW1lbnQgdGhhdCB0aGUgZWwncyBzaWRlIGlzIHNjcm9sbGVkIHBhc3QsIG9yIG51bGwgaWYgdGhlcmUgaXMgbm8gc3VjaCBlbGVtZW50XHJcbiAqL1xuZnVuY3Rpb24gaXNTY3JvbGxlZFBhc3QoZWwsIGVsU2lkZSwgcGFyZW50U2lkZSkge1xuICB2YXIgcGFyZW50ID0gZ2V0UGFyZW50QXV0b1Njcm9sbEVsZW1lbnQoZWwsIHRydWUpLFxuICAgIGVsU2lkZVZhbCA9IGdldFJlY3QoZWwpW2VsU2lkZV07XG5cbiAgLyoganNoaW50IGJvc3M6dHJ1ZSAqL1xuICB3aGlsZSAocGFyZW50KSB7XG4gICAgdmFyIHBhcmVudFNpZGVWYWwgPSBnZXRSZWN0KHBhcmVudClbcGFyZW50U2lkZV0sXG4gICAgICB2aXNpYmxlID0gdm9pZCAwO1xuICAgIGlmIChwYXJlbnRTaWRlID09PSAndG9wJyB8fCBwYXJlbnRTaWRlID09PSAnbGVmdCcpIHtcbiAgICAgIHZpc2libGUgPSBlbFNpZGVWYWwgPj0gcGFyZW50U2lkZVZhbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmlzaWJsZSA9IGVsU2lkZVZhbCA8PSBwYXJlbnRTaWRlVmFsO1xuICAgIH1cbiAgICBpZiAoIXZpc2libGUpIHJldHVybiBwYXJlbnQ7XG4gICAgaWYgKHBhcmVudCA9PT0gZ2V0V2luZG93U2Nyb2xsaW5nRWxlbWVudCgpKSBicmVhaztcbiAgICBwYXJlbnQgPSBnZXRQYXJlbnRBdXRvU2Nyb2xsRWxlbWVudChwYXJlbnQsIGZhbHNlKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxyXG4gKiBHZXRzIG50aCBjaGlsZCBvZiBlbCwgaWdub3JpbmcgaGlkZGVuIGNoaWxkcmVuLCBzb3J0YWJsZSdzIGVsZW1lbnRzIChkb2VzIG5vdCBpZ25vcmUgY2xvbmUgaWYgaXQncyB2aXNpYmxlKVxyXG4gKiBhbmQgbm9uLWRyYWdnYWJsZSBlbGVtZW50c1xyXG4gKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gZWwgICAgICAgVGhlIHBhcmVudCBlbGVtZW50XHJcbiAqIEBwYXJhbSAge051bWJlcn0gY2hpbGROdW0gICAgICBUaGUgaW5kZXggb2YgdGhlIGNoaWxkXHJcbiAqIEBwYXJhbSAge09iamVjdH0gb3B0aW9ucyAgICAgICBQYXJlbnQgU29ydGFibGUncyBvcHRpb25zXHJcbiAqIEByZXR1cm4ge0hUTUxFbGVtZW50fSAgICAgICAgICBUaGUgY2hpbGQgYXQgaW5kZXggY2hpbGROdW0sIG9yIG51bGwgaWYgbm90IGZvdW5kXHJcbiAqL1xuZnVuY3Rpb24gZ2V0Q2hpbGQoZWwsIGNoaWxkTnVtLCBvcHRpb25zLCBpbmNsdWRlRHJhZ0VsKSB7XG4gIHZhciBjdXJyZW50Q2hpbGQgPSAwLFxuICAgIGkgPSAwLFxuICAgIGNoaWxkcmVuID0gZWwuY2hpbGRyZW47XG4gIHdoaWxlIChpIDwgY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgaWYgKGNoaWxkcmVuW2ldLnN0eWxlLmRpc3BsYXkgIT09ICdub25lJyAmJiBjaGlsZHJlbltpXSAhPT0gU29ydGFibGUuZ2hvc3QgJiYgKGluY2x1ZGVEcmFnRWwgfHwgY2hpbGRyZW5baV0gIT09IFNvcnRhYmxlLmRyYWdnZWQpICYmIGNsb3Nlc3QoY2hpbGRyZW5baV0sIG9wdGlvbnMuZHJhZ2dhYmxlLCBlbCwgZmFsc2UpKSB7XG4gICAgICBpZiAoY3VycmVudENoaWxkID09PSBjaGlsZE51bSkge1xuICAgICAgICByZXR1cm4gY2hpbGRyZW5baV07XG4gICAgICB9XG4gICAgICBjdXJyZW50Q2hpbGQrKztcbiAgICB9XG4gICAgaSsrO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcclxuICogR2V0cyB0aGUgbGFzdCBjaGlsZCBpbiB0aGUgZWwsIGlnbm9yaW5nIGdob3N0RWwgb3IgaW52aXNpYmxlIGVsZW1lbnRzIChjbG9uZXMpXHJcbiAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSBlbCAgICAgICBQYXJlbnQgZWxlbWVudFxyXG4gKiBAcGFyYW0gIHtzZWxlY3Rvcn0gc2VsZWN0b3IgICAgQW55IG90aGVyIGVsZW1lbnRzIHRoYXQgc2hvdWxkIGJlIGlnbm9yZWRcclxuICogQHJldHVybiB7SFRNTEVsZW1lbnR9ICAgICAgICAgIFRoZSBsYXN0IGNoaWxkLCBpZ25vcmluZyBnaG9zdEVsXHJcbiAqL1xuZnVuY3Rpb24gbGFzdENoaWxkKGVsLCBzZWxlY3Rvcikge1xuICB2YXIgbGFzdCA9IGVsLmxhc3RFbGVtZW50Q2hpbGQ7XG4gIHdoaWxlIChsYXN0ICYmIChsYXN0ID09PSBTb3J0YWJsZS5naG9zdCB8fCBjc3MobGFzdCwgJ2Rpc3BsYXknKSA9PT0gJ25vbmUnIHx8IHNlbGVjdG9yICYmICFtYXRjaGVzKGxhc3QsIHNlbGVjdG9yKSkpIHtcbiAgICBsYXN0ID0gbGFzdC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuICB9XG4gIHJldHVybiBsYXN0IHx8IG51bGw7XG59XG5cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBpbmRleCBvZiBhbiBlbGVtZW50IHdpdGhpbiBpdHMgcGFyZW50IGZvciBhIHNlbGVjdGVkIHNldCBvZlxyXG4gKiBlbGVtZW50c1xyXG4gKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gZWxcclxuICogQHBhcmFtICB7c2VsZWN0b3J9IHNlbGVjdG9yXHJcbiAqIEByZXR1cm4ge251bWJlcn1cclxuICovXG5mdW5jdGlvbiBpbmRleChlbCwgc2VsZWN0b3IpIHtcbiAgdmFyIGluZGV4ID0gMDtcbiAgaWYgKCFlbCB8fCAhZWwucGFyZW50Tm9kZSkge1xuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qIGpzaGludCBib3NzOnRydWUgKi9cbiAgd2hpbGUgKGVsID0gZWwucHJldmlvdXNFbGVtZW50U2libGluZykge1xuICAgIGlmIChlbC5ub2RlTmFtZS50b1VwcGVyQ2FzZSgpICE9PSAnVEVNUExBVEUnICYmIGVsICE9PSBTb3J0YWJsZS5jbG9uZSAmJiAoIXNlbGVjdG9yIHx8IG1hdGNoZXMoZWwsIHNlbGVjdG9yKSkpIHtcbiAgICAgIGluZGV4Kys7XG4gICAgfVxuICB9XG4gIHJldHVybiBpbmRleDtcbn1cblxuLyoqXHJcbiAqIFJldHVybnMgdGhlIHNjcm9sbCBvZmZzZXQgb2YgdGhlIGdpdmVuIGVsZW1lbnQsIGFkZGVkIHdpdGggYWxsIHRoZSBzY3JvbGwgb2Zmc2V0cyBvZiBwYXJlbnQgZWxlbWVudHMuXHJcbiAqIFRoZSB2YWx1ZSBpcyByZXR1cm5lZCBpbiByZWFsIHBpeGVscy5cclxuICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGVsXHJcbiAqIEByZXR1cm4ge0FycmF5fSAgICAgICAgICAgICBPZmZzZXRzIGluIHRoZSBmb3JtYXQgb2YgW2xlZnQsIHRvcF1cclxuICovXG5mdW5jdGlvbiBnZXRSZWxhdGl2ZVNjcm9sbE9mZnNldChlbCkge1xuICB2YXIgb2Zmc2V0TGVmdCA9IDAsXG4gICAgb2Zmc2V0VG9wID0gMCxcbiAgICB3aW5TY3JvbGxlciA9IGdldFdpbmRvd1Njcm9sbGluZ0VsZW1lbnQoKTtcbiAgaWYgKGVsKSB7XG4gICAgZG8ge1xuICAgICAgdmFyIGVsTWF0cml4ID0gbWF0cml4KGVsKSxcbiAgICAgICAgc2NhbGVYID0gZWxNYXRyaXguYSxcbiAgICAgICAgc2NhbGVZID0gZWxNYXRyaXguZDtcbiAgICAgIG9mZnNldExlZnQgKz0gZWwuc2Nyb2xsTGVmdCAqIHNjYWxlWDtcbiAgICAgIG9mZnNldFRvcCArPSBlbC5zY3JvbGxUb3AgKiBzY2FsZVk7XG4gICAgfSB3aGlsZSAoZWwgIT09IHdpblNjcm9sbGVyICYmIChlbCA9IGVsLnBhcmVudE5vZGUpKTtcbiAgfVxuICByZXR1cm4gW29mZnNldExlZnQsIG9mZnNldFRvcF07XG59XG5cbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgb2JqZWN0IHdpdGhpbiB0aGUgZ2l2ZW4gYXJyYXlcclxuICogQHBhcmFtICB7QXJyYXl9IGFyciAgIEFycmF5IHRoYXQgbWF5IG9yIG1heSBub3QgaG9sZCB0aGUgb2JqZWN0XHJcbiAqIEBwYXJhbSAge09iamVjdH0gb2JqICBBbiBvYmplY3QgdGhhdCBoYXMgYSBrZXktdmFsdWUgcGFpciB1bmlxdWUgdG8gYW5kIGlkZW50aWNhbCB0byBhIGtleS12YWx1ZSBwYWlyIGluIHRoZSBvYmplY3QgeW91IHdhbnQgdG8gZmluZFxyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgVGhlIGluZGV4IG9mIHRoZSBvYmplY3QgaW4gdGhlIGFycmF5LCBvciAtMVxyXG4gKi9cbmZ1bmN0aW9uIGluZGV4T2ZPYmplY3QoYXJyLCBvYmopIHtcbiAgZm9yICh2YXIgaSBpbiBhcnIpIHtcbiAgICBpZiAoIWFyci5oYXNPd25Qcm9wZXJ0eShpKSkgY29udGludWU7XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpICYmIG9ialtrZXldID09PSBhcnJbaV1ba2V5XSkgcmV0dXJuIE51bWJlcihpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuZnVuY3Rpb24gZ2V0UGFyZW50QXV0b1Njcm9sbEVsZW1lbnQoZWwsIGluY2x1ZGVTZWxmKSB7XG4gIC8vIHNraXAgdG8gd2luZG93XG4gIGlmICghZWwgfHwgIWVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCkgcmV0dXJuIGdldFdpbmRvd1Njcm9sbGluZ0VsZW1lbnQoKTtcbiAgdmFyIGVsZW0gPSBlbDtcbiAgdmFyIGdvdFNlbGYgPSBmYWxzZTtcbiAgZG8ge1xuICAgIC8vIHdlIGRvbid0IG5lZWQgdG8gZ2V0IGVsZW0gY3NzIGlmIGl0IGlzbid0IGV2ZW4gb3ZlcmZsb3dpbmcgaW4gdGhlIGZpcnN0IHBsYWNlIChwZXJmb3JtYW5jZSlcbiAgICBpZiAoZWxlbS5jbGllbnRXaWR0aCA8IGVsZW0uc2Nyb2xsV2lkdGggfHwgZWxlbS5jbGllbnRIZWlnaHQgPCBlbGVtLnNjcm9sbEhlaWdodCkge1xuICAgICAgdmFyIGVsZW1DU1MgPSBjc3MoZWxlbSk7XG4gICAgICBpZiAoZWxlbS5jbGllbnRXaWR0aCA8IGVsZW0uc2Nyb2xsV2lkdGggJiYgKGVsZW1DU1Mub3ZlcmZsb3dYID09ICdhdXRvJyB8fCBlbGVtQ1NTLm92ZXJmbG93WCA9PSAnc2Nyb2xsJykgfHwgZWxlbS5jbGllbnRIZWlnaHQgPCBlbGVtLnNjcm9sbEhlaWdodCAmJiAoZWxlbUNTUy5vdmVyZmxvd1kgPT0gJ2F1dG8nIHx8IGVsZW1DU1Mub3ZlcmZsb3dZID09ICdzY3JvbGwnKSkge1xuICAgICAgICBpZiAoIWVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0IHx8IGVsZW0gPT09IGRvY3VtZW50LmJvZHkpIHJldHVybiBnZXRXaW5kb3dTY3JvbGxpbmdFbGVtZW50KCk7XG4gICAgICAgIGlmIChnb3RTZWxmIHx8IGluY2x1ZGVTZWxmKSByZXR1cm4gZWxlbTtcbiAgICAgICAgZ290U2VsZiA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIC8qIGpzaGludCBib3NzOnRydWUgKi9cbiAgfSB3aGlsZSAoZWxlbSA9IGVsZW0ucGFyZW50Tm9kZSk7XG4gIHJldHVybiBnZXRXaW5kb3dTY3JvbGxpbmdFbGVtZW50KCk7XG59XG5mdW5jdGlvbiBleHRlbmQoZHN0LCBzcmMpIHtcbiAgaWYgKGRzdCAmJiBzcmMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgICBpZiAoc3JjLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgZHN0W2tleV0gPSBzcmNba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRzdDtcbn1cbmZ1bmN0aW9uIGlzUmVjdEVxdWFsKHJlY3QxLCByZWN0Mikge1xuICByZXR1cm4gTWF0aC5yb3VuZChyZWN0MS50b3ApID09PSBNYXRoLnJvdW5kKHJlY3QyLnRvcCkgJiYgTWF0aC5yb3VuZChyZWN0MS5sZWZ0KSA9PT0gTWF0aC5yb3VuZChyZWN0Mi5sZWZ0KSAmJiBNYXRoLnJvdW5kKHJlY3QxLmhlaWdodCkgPT09IE1hdGgucm91bmQocmVjdDIuaGVpZ2h0KSAmJiBNYXRoLnJvdW5kKHJlY3QxLndpZHRoKSA9PT0gTWF0aC5yb3VuZChyZWN0Mi53aWR0aCk7XG59XG52YXIgX3Rocm90dGxlVGltZW91dDtcbmZ1bmN0aW9uIHRocm90dGxlKGNhbGxiYWNrLCBtcykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghX3Rocm90dGxlVGltZW91dCkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgIF90aGlzID0gdGhpcztcbiAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBjYWxsYmFjay5jYWxsKF90aGlzLCBhcmdzWzBdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGxiYWNrLmFwcGx5KF90aGlzLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIF90aHJvdHRsZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3Rocm90dGxlVGltZW91dCA9IHZvaWQgMDtcbiAgICAgIH0sIG1zKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBjYW5jZWxUaHJvdHRsZSgpIHtcbiAgY2xlYXJUaW1lb3V0KF90aHJvdHRsZVRpbWVvdXQpO1xuICBfdGhyb3R0bGVUaW1lb3V0ID0gdm9pZCAwO1xufVxuZnVuY3Rpb24gc2Nyb2xsQnkoZWwsIHgsIHkpIHtcbiAgZWwuc2Nyb2xsTGVmdCArPSB4O1xuICBlbC5zY3JvbGxUb3AgKz0geTtcbn1cbmZ1bmN0aW9uIGNsb25lKGVsKSB7XG4gIHZhciBQb2x5bWVyID0gd2luZG93LlBvbHltZXI7XG4gIHZhciAkID0gd2luZG93LmpRdWVyeSB8fCB3aW5kb3cuWmVwdG87XG4gIGlmIChQb2x5bWVyICYmIFBvbHltZXIuZG9tKSB7XG4gICAgcmV0dXJuIFBvbHltZXIuZG9tKGVsKS5jbG9uZU5vZGUodHJ1ZSk7XG4gIH0gZWxzZSBpZiAoJCkge1xuICAgIHJldHVybiAkKGVsKS5jbG9uZSh0cnVlKVswXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZWwuY2xvbmVOb2RlKHRydWUpO1xuICB9XG59XG5mdW5jdGlvbiBzZXRSZWN0KGVsLCByZWN0KSB7XG4gIGNzcyhlbCwgJ3Bvc2l0aW9uJywgJ2Fic29sdXRlJyk7XG4gIGNzcyhlbCwgJ3RvcCcsIHJlY3QudG9wKTtcbiAgY3NzKGVsLCAnbGVmdCcsIHJlY3QubGVmdCk7XG4gIGNzcyhlbCwgJ3dpZHRoJywgcmVjdC53aWR0aCk7XG4gIGNzcyhlbCwgJ2hlaWdodCcsIHJlY3QuaGVpZ2h0KTtcbn1cbmZ1bmN0aW9uIHVuc2V0UmVjdChlbCkge1xuICBjc3MoZWwsICdwb3NpdGlvbicsICcnKTtcbiAgY3NzKGVsLCAndG9wJywgJycpO1xuICBjc3MoZWwsICdsZWZ0JywgJycpO1xuICBjc3MoZWwsICd3aWR0aCcsICcnKTtcbiAgY3NzKGVsLCAnaGVpZ2h0JywgJycpO1xufVxuZnVuY3Rpb24gZ2V0Q2hpbGRDb250YWluaW5nUmVjdEZyb21FbGVtZW50KGNvbnRhaW5lciwgb3B0aW9ucywgZ2hvc3RFbCkge1xuICB2YXIgcmVjdCA9IHt9O1xuICBBcnJheS5mcm9tKGNvbnRhaW5lci5jaGlsZHJlbikuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICB2YXIgX3JlY3QkbGVmdCwgX3JlY3QkdG9wLCBfcmVjdCRyaWdodCwgX3JlY3QkYm90dG9tO1xuICAgIGlmICghY2xvc2VzdChjaGlsZCwgb3B0aW9ucy5kcmFnZ2FibGUsIGNvbnRhaW5lciwgZmFsc2UpIHx8IGNoaWxkLmFuaW1hdGVkIHx8IGNoaWxkID09PSBnaG9zdEVsKSByZXR1cm47XG4gICAgdmFyIGNoaWxkUmVjdCA9IGdldFJlY3QoY2hpbGQpO1xuICAgIHJlY3QubGVmdCA9IE1hdGgubWluKChfcmVjdCRsZWZ0ID0gcmVjdC5sZWZ0KSAhPT0gbnVsbCAmJiBfcmVjdCRsZWZ0ICE9PSB2b2lkIDAgPyBfcmVjdCRsZWZ0IDogSW5maW5pdHksIGNoaWxkUmVjdC5sZWZ0KTtcbiAgICByZWN0LnRvcCA9IE1hdGgubWluKChfcmVjdCR0b3AgPSByZWN0LnRvcCkgIT09IG51bGwgJiYgX3JlY3QkdG9wICE9PSB2b2lkIDAgPyBfcmVjdCR0b3AgOiBJbmZpbml0eSwgY2hpbGRSZWN0LnRvcCk7XG4gICAgcmVjdC5yaWdodCA9IE1hdGgubWF4KChfcmVjdCRyaWdodCA9IHJlY3QucmlnaHQpICE9PSBudWxsICYmIF9yZWN0JHJpZ2h0ICE9PSB2b2lkIDAgPyBfcmVjdCRyaWdodCA6IC1JbmZpbml0eSwgY2hpbGRSZWN0LnJpZ2h0KTtcbiAgICByZWN0LmJvdHRvbSA9IE1hdGgubWF4KChfcmVjdCRib3R0b20gPSByZWN0LmJvdHRvbSkgIT09IG51bGwgJiYgX3JlY3QkYm90dG9tICE9PSB2b2lkIDAgPyBfcmVjdCRib3R0b20gOiAtSW5maW5pdHksIGNoaWxkUmVjdC5ib3R0b20pO1xuICB9KTtcbiAgcmVjdC53aWR0aCA9IHJlY3QucmlnaHQgLSByZWN0LmxlZnQ7XG4gIHJlY3QuaGVpZ2h0ID0gcmVjdC5ib3R0b20gLSByZWN0LnRvcDtcbiAgcmVjdC54ID0gcmVjdC5sZWZ0O1xuICByZWN0LnkgPSByZWN0LnRvcDtcbiAgcmV0dXJuIHJlY3Q7XG59XG52YXIgZXhwYW5kbyA9ICdTb3J0YWJsZScgKyBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcblxuZnVuY3Rpb24gQW5pbWF0aW9uU3RhdGVNYW5hZ2VyKCkge1xuICB2YXIgYW5pbWF0aW9uU3RhdGVzID0gW10sXG4gICAgYW5pbWF0aW9uQ2FsbGJhY2tJZDtcbiAgcmV0dXJuIHtcbiAgICBjYXB0dXJlQW5pbWF0aW9uU3RhdGU6IGZ1bmN0aW9uIGNhcHR1cmVBbmltYXRpb25TdGF0ZSgpIHtcbiAgICAgIGFuaW1hdGlvblN0YXRlcyA9IFtdO1xuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuYW5pbWF0aW9uKSByZXR1cm47XG4gICAgICB2YXIgY2hpbGRyZW4gPSBbXS5zbGljZS5jYWxsKHRoaXMuZWwuY2hpbGRyZW4pO1xuICAgICAgY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgaWYgKGNzcyhjaGlsZCwgJ2Rpc3BsYXknKSA9PT0gJ25vbmUnIHx8IGNoaWxkID09PSBTb3J0YWJsZS5naG9zdCkgcmV0dXJuO1xuICAgICAgICBhbmltYXRpb25TdGF0ZXMucHVzaCh7XG4gICAgICAgICAgdGFyZ2V0OiBjaGlsZCxcbiAgICAgICAgICByZWN0OiBnZXRSZWN0KGNoaWxkKVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGZyb21SZWN0ID0gX29iamVjdFNwcmVhZDIoe30sIGFuaW1hdGlvblN0YXRlc1thbmltYXRpb25TdGF0ZXMubGVuZ3RoIC0gMV0ucmVjdCk7XG5cbiAgICAgICAgLy8gSWYgYW5pbWF0aW5nOiBjb21wZW5zYXRlIGZvciBjdXJyZW50IGFuaW1hdGlvblxuICAgICAgICBpZiAoY2hpbGQudGhpc0FuaW1hdGlvbkR1cmF0aW9uKSB7XG4gICAgICAgICAgdmFyIGNoaWxkTWF0cml4ID0gbWF0cml4KGNoaWxkLCB0cnVlKTtcbiAgICAgICAgICBpZiAoY2hpbGRNYXRyaXgpIHtcbiAgICAgICAgICAgIGZyb21SZWN0LnRvcCAtPSBjaGlsZE1hdHJpeC5mO1xuICAgICAgICAgICAgZnJvbVJlY3QubGVmdCAtPSBjaGlsZE1hdHJpeC5lO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjaGlsZC5mcm9tUmVjdCA9IGZyb21SZWN0O1xuICAgICAgfSk7XG4gICAgfSxcbiAgICBhZGRBbmltYXRpb25TdGF0ZTogZnVuY3Rpb24gYWRkQW5pbWF0aW9uU3RhdGUoc3RhdGUpIHtcbiAgICAgIGFuaW1hdGlvblN0YXRlcy5wdXNoKHN0YXRlKTtcbiAgICB9LFxuICAgIHJlbW92ZUFuaW1hdGlvblN0YXRlOiBmdW5jdGlvbiByZW1vdmVBbmltYXRpb25TdGF0ZSh0YXJnZXQpIHtcbiAgICAgIGFuaW1hdGlvblN0YXRlcy5zcGxpY2UoaW5kZXhPZk9iamVjdChhbmltYXRpb25TdGF0ZXMsIHtcbiAgICAgICAgdGFyZ2V0OiB0YXJnZXRcbiAgICAgIH0pLCAxKTtcbiAgICB9LFxuICAgIGFuaW1hdGVBbGw6IGZ1bmN0aW9uIGFuaW1hdGVBbGwoY2FsbGJhY2spIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy5hbmltYXRpb24pIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KGFuaW1hdGlvbkNhbGxiYWNrSWQpO1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSBjYWxsYmFjaygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgYW5pbWF0aW5nID0gZmFsc2UsXG4gICAgICAgIGFuaW1hdGlvblRpbWUgPSAwO1xuICAgICAgYW5pbWF0aW9uU3RhdGVzLmZvckVhY2goZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIHZhciB0aW1lID0gMCxcbiAgICAgICAgICB0YXJnZXQgPSBzdGF0ZS50YXJnZXQsXG4gICAgICAgICAgZnJvbVJlY3QgPSB0YXJnZXQuZnJvbVJlY3QsXG4gICAgICAgICAgdG9SZWN0ID0gZ2V0UmVjdCh0YXJnZXQpLFxuICAgICAgICAgIHByZXZGcm9tUmVjdCA9IHRhcmdldC5wcmV2RnJvbVJlY3QsXG4gICAgICAgICAgcHJldlRvUmVjdCA9IHRhcmdldC5wcmV2VG9SZWN0LFxuICAgICAgICAgIGFuaW1hdGluZ1JlY3QgPSBzdGF0ZS5yZWN0LFxuICAgICAgICAgIHRhcmdldE1hdHJpeCA9IG1hdHJpeCh0YXJnZXQsIHRydWUpO1xuICAgICAgICBpZiAodGFyZ2V0TWF0cml4KSB7XG4gICAgICAgICAgLy8gQ29tcGVuc2F0ZSBmb3IgY3VycmVudCBhbmltYXRpb25cbiAgICAgICAgICB0b1JlY3QudG9wIC09IHRhcmdldE1hdHJpeC5mO1xuICAgICAgICAgIHRvUmVjdC5sZWZ0IC09IHRhcmdldE1hdHJpeC5lO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldC50b1JlY3QgPSB0b1JlY3Q7XG4gICAgICAgIGlmICh0YXJnZXQudGhpc0FuaW1hdGlvbkR1cmF0aW9uKSB7XG4gICAgICAgICAgLy8gQ291bGQgYWxzbyBjaGVjayBpZiBhbmltYXRpbmdSZWN0IGlzIGJldHdlZW4gZnJvbVJlY3QgYW5kIHRvUmVjdFxuICAgICAgICAgIGlmIChpc1JlY3RFcXVhbChwcmV2RnJvbVJlY3QsIHRvUmVjdCkgJiYgIWlzUmVjdEVxdWFsKGZyb21SZWN0LCB0b1JlY3QpICYmXG4gICAgICAgICAgLy8gTWFrZSBzdXJlIGFuaW1hdGluZ1JlY3QgaXMgb24gbGluZSBiZXR3ZWVuIHRvUmVjdCAmIGZyb21SZWN0XG4gICAgICAgICAgKGFuaW1hdGluZ1JlY3QudG9wIC0gdG9SZWN0LnRvcCkgLyAoYW5pbWF0aW5nUmVjdC5sZWZ0IC0gdG9SZWN0LmxlZnQpID09PSAoZnJvbVJlY3QudG9wIC0gdG9SZWN0LnRvcCkgLyAoZnJvbVJlY3QubGVmdCAtIHRvUmVjdC5sZWZ0KSkge1xuICAgICAgICAgICAgLy8gSWYgcmV0dXJuaW5nIHRvIHNhbWUgcGxhY2UgYXMgc3RhcnRlZCBmcm9tIGFuaW1hdGlvbiBhbmQgb24gc2FtZSBheGlzXG4gICAgICAgICAgICB0aW1lID0gY2FsY3VsYXRlUmVhbFRpbWUoYW5pbWF0aW5nUmVjdCwgcHJldkZyb21SZWN0LCBwcmV2VG9SZWN0LCBfdGhpcy5vcHRpb25zKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiBmcm9tUmVjdCAhPSB0b1JlY3Q6IGFuaW1hdGVcbiAgICAgICAgaWYgKCFpc1JlY3RFcXVhbCh0b1JlY3QsIGZyb21SZWN0KSkge1xuICAgICAgICAgIHRhcmdldC5wcmV2RnJvbVJlY3QgPSBmcm9tUmVjdDtcbiAgICAgICAgICB0YXJnZXQucHJldlRvUmVjdCA9IHRvUmVjdDtcbiAgICAgICAgICBpZiAoIXRpbWUpIHtcbiAgICAgICAgICAgIHRpbWUgPSBfdGhpcy5vcHRpb25zLmFuaW1hdGlvbjtcbiAgICAgICAgICB9XG4gICAgICAgICAgX3RoaXMuYW5pbWF0ZSh0YXJnZXQsIGFuaW1hdGluZ1JlY3QsIHRvUmVjdCwgdGltZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRpbWUpIHtcbiAgICAgICAgICBhbmltYXRpbmcgPSB0cnVlO1xuICAgICAgICAgIGFuaW1hdGlvblRpbWUgPSBNYXRoLm1heChhbmltYXRpb25UaW1lLCB0aW1lKTtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGFyZ2V0LmFuaW1hdGlvblJlc2V0VGltZXIpO1xuICAgICAgICAgIHRhcmdldC5hbmltYXRpb25SZXNldFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0YXJnZXQuYW5pbWF0aW9uVGltZSA9IDA7XG4gICAgICAgICAgICB0YXJnZXQucHJldkZyb21SZWN0ID0gbnVsbDtcbiAgICAgICAgICAgIHRhcmdldC5mcm9tUmVjdCA9IG51bGw7XG4gICAgICAgICAgICB0YXJnZXQucHJldlRvUmVjdCA9IG51bGw7XG4gICAgICAgICAgICB0YXJnZXQudGhpc0FuaW1hdGlvbkR1cmF0aW9uID0gbnVsbDtcbiAgICAgICAgICB9LCB0aW1lKTtcbiAgICAgICAgICB0YXJnZXQudGhpc0FuaW1hdGlvbkR1cmF0aW9uID0gdGltZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjbGVhclRpbWVvdXQoYW5pbWF0aW9uQ2FsbGJhY2tJZCk7XG4gICAgICBpZiAoIWFuaW1hdGluZykge1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSBjYWxsYmFjaygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYW5pbWF0aW9uQ2FsbGJhY2tJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIGNhbGxiYWNrKCk7XG4gICAgICAgIH0sIGFuaW1hdGlvblRpbWUpO1xuICAgICAgfVxuICAgICAgYW5pbWF0aW9uU3RhdGVzID0gW107XG4gICAgfSxcbiAgICBhbmltYXRlOiBmdW5jdGlvbiBhbmltYXRlKHRhcmdldCwgY3VycmVudFJlY3QsIHRvUmVjdCwgZHVyYXRpb24pIHtcbiAgICAgIGlmIChkdXJhdGlvbikge1xuICAgICAgICBjc3ModGFyZ2V0LCAndHJhbnNpdGlvbicsICcnKTtcbiAgICAgICAgY3NzKHRhcmdldCwgJ3RyYW5zZm9ybScsICcnKTtcbiAgICAgICAgdmFyIGVsTWF0cml4ID0gbWF0cml4KHRoaXMuZWwpLFxuICAgICAgICAgIHNjYWxlWCA9IGVsTWF0cml4ICYmIGVsTWF0cml4LmEsXG4gICAgICAgICAgc2NhbGVZID0gZWxNYXRyaXggJiYgZWxNYXRyaXguZCxcbiAgICAgICAgICB0cmFuc2xhdGVYID0gKGN1cnJlbnRSZWN0LmxlZnQgLSB0b1JlY3QubGVmdCkgLyAoc2NhbGVYIHx8IDEpLFxuICAgICAgICAgIHRyYW5zbGF0ZVkgPSAoY3VycmVudFJlY3QudG9wIC0gdG9SZWN0LnRvcCkgLyAoc2NhbGVZIHx8IDEpO1xuICAgICAgICB0YXJnZXQuYW5pbWF0aW5nWCA9ICEhdHJhbnNsYXRlWDtcbiAgICAgICAgdGFyZ2V0LmFuaW1hdGluZ1kgPSAhIXRyYW5zbGF0ZVk7XG4gICAgICAgIGNzcyh0YXJnZXQsICd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlM2QoJyArIHRyYW5zbGF0ZVggKyAncHgsJyArIHRyYW5zbGF0ZVkgKyAncHgsMCknKTtcbiAgICAgICAgdGhpcy5mb3JSZXBhaW50RHVtbXkgPSByZXBhaW50KHRhcmdldCk7IC8vIHJlcGFpbnRcblxuICAgICAgICBjc3ModGFyZ2V0LCAndHJhbnNpdGlvbicsICd0cmFuc2Zvcm0gJyArIGR1cmF0aW9uICsgJ21zJyArICh0aGlzLm9wdGlvbnMuZWFzaW5nID8gJyAnICsgdGhpcy5vcHRpb25zLmVhc2luZyA6ICcnKSk7XG4gICAgICAgIGNzcyh0YXJnZXQsICd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlM2QoMCwwLDApJyk7XG4gICAgICAgIHR5cGVvZiB0YXJnZXQuYW5pbWF0ZWQgPT09ICdudW1iZXInICYmIGNsZWFyVGltZW91dCh0YXJnZXQuYW5pbWF0ZWQpO1xuICAgICAgICB0YXJnZXQuYW5pbWF0ZWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjc3ModGFyZ2V0LCAndHJhbnNpdGlvbicsICcnKTtcbiAgICAgICAgICBjc3ModGFyZ2V0LCAndHJhbnNmb3JtJywgJycpO1xuICAgICAgICAgIHRhcmdldC5hbmltYXRlZCA9IGZhbHNlO1xuICAgICAgICAgIHRhcmdldC5hbmltYXRpbmdYID0gZmFsc2U7XG4gICAgICAgICAgdGFyZ2V0LmFuaW1hdGluZ1kgPSBmYWxzZTtcbiAgICAgICAgfSwgZHVyYXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIHJlcGFpbnQodGFyZ2V0KSB7XG4gIHJldHVybiB0YXJnZXQub2Zmc2V0V2lkdGg7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVSZWFsVGltZShhbmltYXRpbmdSZWN0LCBmcm9tUmVjdCwgdG9SZWN0LCBvcHRpb25zKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coZnJvbVJlY3QudG9wIC0gYW5pbWF0aW5nUmVjdC50b3AsIDIpICsgTWF0aC5wb3coZnJvbVJlY3QubGVmdCAtIGFuaW1hdGluZ1JlY3QubGVmdCwgMikpIC8gTWF0aC5zcXJ0KE1hdGgucG93KGZyb21SZWN0LnRvcCAtIHRvUmVjdC50b3AsIDIpICsgTWF0aC5wb3coZnJvbVJlY3QubGVmdCAtIHRvUmVjdC5sZWZ0LCAyKSkgKiBvcHRpb25zLmFuaW1hdGlvbjtcbn1cblxudmFyIHBsdWdpbnMgPSBbXTtcbnZhciBkZWZhdWx0cyA9IHtcbiAgaW5pdGlhbGl6ZUJ5RGVmYXVsdDogdHJ1ZVxufTtcbnZhciBQbHVnaW5NYW5hZ2VyID0ge1xuICBtb3VudDogZnVuY3Rpb24gbW91bnQocGx1Z2luKSB7XG4gICAgLy8gU2V0IGRlZmF1bHQgc3RhdGljIHByb3BlcnRpZXNcbiAgICBmb3IgKHZhciBvcHRpb24gaW4gZGVmYXVsdHMpIHtcbiAgICAgIGlmIChkZWZhdWx0cy5oYXNPd25Qcm9wZXJ0eShvcHRpb24pICYmICEob3B0aW9uIGluIHBsdWdpbikpIHtcbiAgICAgICAgcGx1Z2luW29wdGlvbl0gPSBkZWZhdWx0c1tvcHRpb25dO1xuICAgICAgfVxuICAgIH1cbiAgICBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICAgIGlmIChwLnBsdWdpbk5hbWUgPT09IHBsdWdpbi5wbHVnaW5OYW1lKSB7XG4gICAgICAgIHRocm93IFwiU29ydGFibGU6IENhbm5vdCBtb3VudCBwbHVnaW4gXCIuY29uY2F0KHBsdWdpbi5wbHVnaW5OYW1lLCBcIiBtb3JlIHRoYW4gb25jZVwiKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBwbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgfSxcbiAgcGx1Z2luRXZlbnQ6IGZ1bmN0aW9uIHBsdWdpbkV2ZW50KGV2ZW50TmFtZSwgc29ydGFibGUsIGV2dCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdGhpcy5ldmVudENhbmNlbGVkID0gZmFsc2U7XG4gICAgZXZ0LmNhbmNlbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIF90aGlzLmV2ZW50Q2FuY2VsZWQgPSB0cnVlO1xuICAgIH07XG4gICAgdmFyIGV2ZW50TmFtZUdsb2JhbCA9IGV2ZW50TmFtZSArICdHbG9iYWwnO1xuICAgIHBsdWdpbnMuZm9yRWFjaChmdW5jdGlvbiAocGx1Z2luKSB7XG4gICAgICBpZiAoIXNvcnRhYmxlW3BsdWdpbi5wbHVnaW5OYW1lXSkgcmV0dXJuO1xuICAgICAgLy8gRmlyZSBnbG9iYWwgZXZlbnRzIGlmIGl0IGV4aXN0cyBpbiB0aGlzIHNvcnRhYmxlXG4gICAgICBpZiAoc29ydGFibGVbcGx1Z2luLnBsdWdpbk5hbWVdW2V2ZW50TmFtZUdsb2JhbF0pIHtcbiAgICAgICAgc29ydGFibGVbcGx1Z2luLnBsdWdpbk5hbWVdW2V2ZW50TmFtZUdsb2JhbF0oX29iamVjdFNwcmVhZDIoe1xuICAgICAgICAgIHNvcnRhYmxlOiBzb3J0YWJsZVxuICAgICAgICB9LCBldnQpKTtcbiAgICAgIH1cblxuICAgICAgLy8gT25seSBmaXJlIHBsdWdpbiBldmVudCBpZiBwbHVnaW4gaXMgZW5hYmxlZCBpbiB0aGlzIHNvcnRhYmxlLFxuICAgICAgLy8gYW5kIHBsdWdpbiBoYXMgZXZlbnQgZGVmaW5lZFxuICAgICAgaWYgKHNvcnRhYmxlLm9wdGlvbnNbcGx1Z2luLnBsdWdpbk5hbWVdICYmIHNvcnRhYmxlW3BsdWdpbi5wbHVnaW5OYW1lXVtldmVudE5hbWVdKSB7XG4gICAgICAgIHNvcnRhYmxlW3BsdWdpbi5wbHVnaW5OYW1lXVtldmVudE5hbWVdKF9vYmplY3RTcHJlYWQyKHtcbiAgICAgICAgICBzb3J0YWJsZTogc29ydGFibGVcbiAgICAgICAgfSwgZXZ0KSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIGluaXRpYWxpemVQbHVnaW5zOiBmdW5jdGlvbiBpbml0aWFsaXplUGx1Z2lucyhzb3J0YWJsZSwgZWwsIGRlZmF1bHRzLCBvcHRpb25zKSB7XG4gICAgcGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICAgIHZhciBwbHVnaW5OYW1lID0gcGx1Z2luLnBsdWdpbk5hbWU7XG4gICAgICBpZiAoIXNvcnRhYmxlLm9wdGlvbnNbcGx1Z2luTmFtZV0gJiYgIXBsdWdpbi5pbml0aWFsaXplQnlEZWZhdWx0KSByZXR1cm47XG4gICAgICB2YXIgaW5pdGlhbGl6ZWQgPSBuZXcgcGx1Z2luKHNvcnRhYmxlLCBlbCwgc29ydGFibGUub3B0aW9ucyk7XG4gICAgICBpbml0aWFsaXplZC5zb3J0YWJsZSA9IHNvcnRhYmxlO1xuICAgICAgaW5pdGlhbGl6ZWQub3B0aW9ucyA9IHNvcnRhYmxlLm9wdGlvbnM7XG4gICAgICBzb3J0YWJsZVtwbHVnaW5OYW1lXSA9IGluaXRpYWxpemVkO1xuXG4gICAgICAvLyBBZGQgZGVmYXVsdCBvcHRpb25zIGZyb20gcGx1Z2luXG4gICAgICBfZXh0ZW5kcyhkZWZhdWx0cywgaW5pdGlhbGl6ZWQuZGVmYXVsdHMpO1xuICAgIH0pO1xuICAgIGZvciAodmFyIG9wdGlvbiBpbiBzb3J0YWJsZS5vcHRpb25zKSB7XG4gICAgICBpZiAoIXNvcnRhYmxlLm9wdGlvbnMuaGFzT3duUHJvcGVydHkob3B0aW9uKSkgY29udGludWU7XG4gICAgICB2YXIgbW9kaWZpZWQgPSB0aGlzLm1vZGlmeU9wdGlvbihzb3J0YWJsZSwgb3B0aW9uLCBzb3J0YWJsZS5vcHRpb25zW29wdGlvbl0pO1xuICAgICAgaWYgKHR5cGVvZiBtb2RpZmllZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgc29ydGFibGUub3B0aW9uc1tvcHRpb25dID0gbW9kaWZpZWQ7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBnZXRFdmVudFByb3BlcnRpZXM6IGZ1bmN0aW9uIGdldEV2ZW50UHJvcGVydGllcyhuYW1lLCBzb3J0YWJsZSkge1xuICAgIHZhciBldmVudFByb3BlcnRpZXMgPSB7fTtcbiAgICBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgaWYgKHR5cGVvZiBwbHVnaW4uZXZlbnRQcm9wZXJ0aWVzICE9PSAnZnVuY3Rpb24nKSByZXR1cm47XG4gICAgICBfZXh0ZW5kcyhldmVudFByb3BlcnRpZXMsIHBsdWdpbi5ldmVudFByb3BlcnRpZXMuY2FsbChzb3J0YWJsZVtwbHVnaW4ucGx1Z2luTmFtZV0sIG5hbWUpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZXZlbnRQcm9wZXJ0aWVzO1xuICB9LFxuICBtb2RpZnlPcHRpb246IGZ1bmN0aW9uIG1vZGlmeU9wdGlvbihzb3J0YWJsZSwgbmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgbW9kaWZpZWRWYWx1ZTtcbiAgICBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24gKHBsdWdpbikge1xuICAgICAgLy8gUGx1Z2luIG11c3QgZXhpc3Qgb24gdGhlIFNvcnRhYmxlXG4gICAgICBpZiAoIXNvcnRhYmxlW3BsdWdpbi5wbHVnaW5OYW1lXSkgcmV0dXJuO1xuXG4gICAgICAvLyBJZiBzdGF0aWMgb3B0aW9uIGxpc3RlbmVyIGV4aXN0cyBmb3IgdGhpcyBvcHRpb24sIGNhbGwgaW4gdGhlIGNvbnRleHQgb2YgdGhlIFNvcnRhYmxlJ3MgaW5zdGFuY2Ugb2YgdGhpcyBwbHVnaW5cbiAgICAgIGlmIChwbHVnaW4ub3B0aW9uTGlzdGVuZXJzICYmIHR5cGVvZiBwbHVnaW4ub3B0aW9uTGlzdGVuZXJzW25hbWVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG1vZGlmaWVkVmFsdWUgPSBwbHVnaW4ub3B0aW9uTGlzdGVuZXJzW25hbWVdLmNhbGwoc29ydGFibGVbcGx1Z2luLnBsdWdpbk5hbWVdLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG1vZGlmaWVkVmFsdWU7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQoX3JlZikge1xuICB2YXIgc29ydGFibGUgPSBfcmVmLnNvcnRhYmxlLFxuICAgIHJvb3RFbCA9IF9yZWYucm9vdEVsLFxuICAgIG5hbWUgPSBfcmVmLm5hbWUsXG4gICAgdGFyZ2V0RWwgPSBfcmVmLnRhcmdldEVsLFxuICAgIGNsb25lRWwgPSBfcmVmLmNsb25lRWwsXG4gICAgdG9FbCA9IF9yZWYudG9FbCxcbiAgICBmcm9tRWwgPSBfcmVmLmZyb21FbCxcbiAgICBvbGRJbmRleCA9IF9yZWYub2xkSW5kZXgsXG4gICAgbmV3SW5kZXggPSBfcmVmLm5ld0luZGV4LFxuICAgIG9sZERyYWdnYWJsZUluZGV4ID0gX3JlZi5vbGREcmFnZ2FibGVJbmRleCxcbiAgICBuZXdEcmFnZ2FibGVJbmRleCA9IF9yZWYubmV3RHJhZ2dhYmxlSW5kZXgsXG4gICAgb3JpZ2luYWxFdmVudCA9IF9yZWYub3JpZ2luYWxFdmVudCxcbiAgICBwdXRTb3J0YWJsZSA9IF9yZWYucHV0U29ydGFibGUsXG4gICAgZXh0cmFFdmVudFByb3BlcnRpZXMgPSBfcmVmLmV4dHJhRXZlbnRQcm9wZXJ0aWVzO1xuICBzb3J0YWJsZSA9IHNvcnRhYmxlIHx8IHJvb3RFbCAmJiByb290RWxbZXhwYW5kb107XG4gIGlmICghc29ydGFibGUpIHJldHVybjtcbiAgdmFyIGV2dCxcbiAgICBvcHRpb25zID0gc29ydGFibGUub3B0aW9ucyxcbiAgICBvbk5hbWUgPSAnb24nICsgbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc3Vic3RyKDEpO1xuICAvLyBTdXBwb3J0IGZvciBuZXcgQ3VzdG9tRXZlbnQgZmVhdHVyZVxuICBpZiAod2luZG93LkN1c3RvbUV2ZW50ICYmICFJRTExT3JMZXNzICYmICFFZGdlKSB7XG4gICAgZXZ0ID0gbmV3IEN1c3RvbUV2ZW50KG5hbWUsIHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgZXZ0LmluaXRFdmVudChuYW1lLCB0cnVlLCB0cnVlKTtcbiAgfVxuICBldnQudG8gPSB0b0VsIHx8IHJvb3RFbDtcbiAgZXZ0LmZyb20gPSBmcm9tRWwgfHwgcm9vdEVsO1xuICBldnQuaXRlbSA9IHRhcmdldEVsIHx8IHJvb3RFbDtcbiAgZXZ0LmNsb25lID0gY2xvbmVFbDtcbiAgZXZ0Lm9sZEluZGV4ID0gb2xkSW5kZXg7XG4gIGV2dC5uZXdJbmRleCA9IG5ld0luZGV4O1xuICBldnQub2xkRHJhZ2dhYmxlSW5kZXggPSBvbGREcmFnZ2FibGVJbmRleDtcbiAgZXZ0Lm5ld0RyYWdnYWJsZUluZGV4ID0gbmV3RHJhZ2dhYmxlSW5kZXg7XG4gIGV2dC5vcmlnaW5hbEV2ZW50ID0gb3JpZ2luYWxFdmVudDtcbiAgZXZ0LnB1bGxNb2RlID0gcHV0U29ydGFibGUgPyBwdXRTb3J0YWJsZS5sYXN0UHV0TW9kZSA6IHVuZGVmaW5lZDtcbiAgdmFyIGFsbEV2ZW50UHJvcGVydGllcyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBleHRyYUV2ZW50UHJvcGVydGllcyksIFBsdWdpbk1hbmFnZXIuZ2V0RXZlbnRQcm9wZXJ0aWVzKG5hbWUsIHNvcnRhYmxlKSk7XG4gIGZvciAodmFyIG9wdGlvbiBpbiBhbGxFdmVudFByb3BlcnRpZXMpIHtcbiAgICBldnRbb3B0aW9uXSA9IGFsbEV2ZW50UHJvcGVydGllc1tvcHRpb25dO1xuICB9XG4gIGlmIChyb290RWwpIHtcbiAgICByb290RWwuZGlzcGF0Y2hFdmVudChldnQpO1xuICB9XG4gIGlmIChvcHRpb25zW29uTmFtZV0pIHtcbiAgICBvcHRpb25zW29uTmFtZV0uY2FsbChzb3J0YWJsZSwgZXZ0KTtcbiAgfVxufVxuXG52YXIgX2V4Y2x1ZGVkID0gW1wiZXZ0XCJdO1xudmFyIHBsdWdpbkV2ZW50ID0gZnVuY3Rpb24gcGx1Z2luRXZlbnQoZXZlbnROYW1lLCBzb3J0YWJsZSkge1xuICB2YXIgX3JlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge30sXG4gICAgb3JpZ2luYWxFdmVudCA9IF9yZWYuZXZ0LFxuICAgIGRhdGEgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZiwgX2V4Y2x1ZGVkKTtcbiAgUGx1Z2luTWFuYWdlci5wbHVnaW5FdmVudC5iaW5kKFNvcnRhYmxlKShldmVudE5hbWUsIHNvcnRhYmxlLCBfb2JqZWN0U3ByZWFkMih7XG4gICAgZHJhZ0VsOiBkcmFnRWwsXG4gICAgcGFyZW50RWw6IHBhcmVudEVsLFxuICAgIGdob3N0RWw6IGdob3N0RWwsXG4gICAgcm9vdEVsOiByb290RWwsXG4gICAgbmV4dEVsOiBuZXh0RWwsXG4gICAgbGFzdERvd25FbDogbGFzdERvd25FbCxcbiAgICBjbG9uZUVsOiBjbG9uZUVsLFxuICAgIGNsb25lSGlkZGVuOiBjbG9uZUhpZGRlbixcbiAgICBkcmFnU3RhcnRlZDogbW92ZWQsXG4gICAgcHV0U29ydGFibGU6IHB1dFNvcnRhYmxlLFxuICAgIGFjdGl2ZVNvcnRhYmxlOiBTb3J0YWJsZS5hY3RpdmUsXG4gICAgb3JpZ2luYWxFdmVudDogb3JpZ2luYWxFdmVudCxcbiAgICBvbGRJbmRleDogb2xkSW5kZXgsXG4gICAgb2xkRHJhZ2dhYmxlSW5kZXg6IG9sZERyYWdnYWJsZUluZGV4LFxuICAgIG5ld0luZGV4OiBuZXdJbmRleCxcbiAgICBuZXdEcmFnZ2FibGVJbmRleDogbmV3RHJhZ2dhYmxlSW5kZXgsXG4gICAgaGlkZUdob3N0Rm9yVGFyZ2V0OiBfaGlkZUdob3N0Rm9yVGFyZ2V0LFxuICAgIHVuaGlkZUdob3N0Rm9yVGFyZ2V0OiBfdW5oaWRlR2hvc3RGb3JUYXJnZXQsXG4gICAgY2xvbmVOb3dIaWRkZW46IGZ1bmN0aW9uIGNsb25lTm93SGlkZGVuKCkge1xuICAgICAgY2xvbmVIaWRkZW4gPSB0cnVlO1xuICAgIH0sXG4gICAgY2xvbmVOb3dTaG93bjogZnVuY3Rpb24gY2xvbmVOb3dTaG93bigpIHtcbiAgICAgIGNsb25lSGlkZGVuID0gZmFsc2U7XG4gICAgfSxcbiAgICBkaXNwYXRjaFNvcnRhYmxlRXZlbnQ6IGZ1bmN0aW9uIGRpc3BhdGNoU29ydGFibGVFdmVudChuYW1lKSB7XG4gICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgIHNvcnRhYmxlOiBzb3J0YWJsZSxcbiAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgb3JpZ2luYWxFdmVudDogb3JpZ2luYWxFdmVudFxuICAgICAgfSk7XG4gICAgfVxuICB9LCBkYXRhKSk7XG59O1xuZnVuY3Rpb24gX2Rpc3BhdGNoRXZlbnQoaW5mbykge1xuICBkaXNwYXRjaEV2ZW50KF9vYmplY3RTcHJlYWQyKHtcbiAgICBwdXRTb3J0YWJsZTogcHV0U29ydGFibGUsXG4gICAgY2xvbmVFbDogY2xvbmVFbCxcbiAgICB0YXJnZXRFbDogZHJhZ0VsLFxuICAgIHJvb3RFbDogcm9vdEVsLFxuICAgIG9sZEluZGV4OiBvbGRJbmRleCxcbiAgICBvbGREcmFnZ2FibGVJbmRleDogb2xkRHJhZ2dhYmxlSW5kZXgsXG4gICAgbmV3SW5kZXg6IG5ld0luZGV4LFxuICAgIG5ld0RyYWdnYWJsZUluZGV4OiBuZXdEcmFnZ2FibGVJbmRleFxuICB9LCBpbmZvKSk7XG59XG52YXIgZHJhZ0VsLFxuICBwYXJlbnRFbCxcbiAgZ2hvc3RFbCxcbiAgcm9vdEVsLFxuICBuZXh0RWwsXG4gIGxhc3REb3duRWwsXG4gIGNsb25lRWwsXG4gIGNsb25lSGlkZGVuLFxuICBvbGRJbmRleCxcbiAgbmV3SW5kZXgsXG4gIG9sZERyYWdnYWJsZUluZGV4LFxuICBuZXdEcmFnZ2FibGVJbmRleCxcbiAgYWN0aXZlR3JvdXAsXG4gIHB1dFNvcnRhYmxlLFxuICBhd2FpdGluZ0RyYWdTdGFydGVkID0gZmFsc2UsXG4gIGlnbm9yZU5leHRDbGljayA9IGZhbHNlLFxuICBzb3J0YWJsZXMgPSBbXSxcbiAgdGFwRXZ0LFxuICB0b3VjaEV2dCxcbiAgbGFzdER4LFxuICBsYXN0RHksXG4gIHRhcERpc3RhbmNlTGVmdCxcbiAgdGFwRGlzdGFuY2VUb3AsXG4gIG1vdmVkLFxuICBsYXN0VGFyZ2V0LFxuICBsYXN0RGlyZWN0aW9uLFxuICBwYXN0Rmlyc3RJbnZlcnRUaHJlc2ggPSBmYWxzZSxcbiAgaXNDaXJjdW1zdGFudGlhbEludmVydCA9IGZhbHNlLFxuICB0YXJnZXRNb3ZlRGlzdGFuY2UsXG4gIC8vIEZvciBwb3NpdGlvbmluZyBnaG9zdCBhYnNvbHV0ZWx5XG4gIGdob3N0UmVsYXRpdmVQYXJlbnQsXG4gIGdob3N0UmVsYXRpdmVQYXJlbnRJbml0aWFsU2Nyb2xsID0gW10sXG4gIC8vIChsZWZ0LCB0b3ApXG5cbiAgX3NpbGVudCA9IGZhbHNlLFxuICBzYXZlZElucHV0Q2hlY2tlZCA9IFtdO1xuXG4vKiogQGNvbnN0ICovXG52YXIgZG9jdW1lbnRFeGlzdHMgPSB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnLFxuICBQb3NpdGlvbkdob3N0QWJzb2x1dGVseSA9IElPUyxcbiAgQ1NTRmxvYXRQcm9wZXJ0eSA9IEVkZ2UgfHwgSUUxMU9yTGVzcyA/ICdjc3NGbG9hdCcgOiAnZmxvYXQnLFxuICAvLyBUaGlzIHdpbGwgbm90IHBhc3MgZm9yIElFOSwgYmVjYXVzZSBJRTkgRG5EIG9ubHkgd29ya3Mgb24gYW5jaG9yc1xuICBzdXBwb3J0RHJhZ2dhYmxlID0gZG9jdW1lbnRFeGlzdHMgJiYgIUNocm9tZUZvckFuZHJvaWQgJiYgIUlPUyAmJiAnZHJhZ2dhYmxlJyBpbiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgc3VwcG9ydENzc1BvaW50ZXJFdmVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFkb2N1bWVudEV4aXN0cykgcmV0dXJuO1xuICAgIC8vIGZhbHNlIHdoZW4gPD0gSUUxMVxuICAgIGlmIChJRTExT3JMZXNzKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3gnKTtcbiAgICBlbC5zdHlsZS5jc3NUZXh0ID0gJ3BvaW50ZXItZXZlbnRzOmF1dG8nO1xuICAgIHJldHVybiBlbC5zdHlsZS5wb2ludGVyRXZlbnRzID09PSAnYXV0byc7XG4gIH0oKSxcbiAgX2RldGVjdERpcmVjdGlvbiA9IGZ1bmN0aW9uIF9kZXRlY3REaXJlY3Rpb24oZWwsIG9wdGlvbnMpIHtcbiAgICB2YXIgZWxDU1MgPSBjc3MoZWwpLFxuICAgICAgZWxXaWR0aCA9IHBhcnNlSW50KGVsQ1NTLndpZHRoKSAtIHBhcnNlSW50KGVsQ1NTLnBhZGRpbmdMZWZ0KSAtIHBhcnNlSW50KGVsQ1NTLnBhZGRpbmdSaWdodCkgLSBwYXJzZUludChlbENTUy5ib3JkZXJMZWZ0V2lkdGgpIC0gcGFyc2VJbnQoZWxDU1MuYm9yZGVyUmlnaHRXaWR0aCksXG4gICAgICBjaGlsZDEgPSBnZXRDaGlsZChlbCwgMCwgb3B0aW9ucyksXG4gICAgICBjaGlsZDIgPSBnZXRDaGlsZChlbCwgMSwgb3B0aW9ucyksXG4gICAgICBmaXJzdENoaWxkQ1NTID0gY2hpbGQxICYmIGNzcyhjaGlsZDEpLFxuICAgICAgc2Vjb25kQ2hpbGRDU1MgPSBjaGlsZDIgJiYgY3NzKGNoaWxkMiksXG4gICAgICBmaXJzdENoaWxkV2lkdGggPSBmaXJzdENoaWxkQ1NTICYmIHBhcnNlSW50KGZpcnN0Q2hpbGRDU1MubWFyZ2luTGVmdCkgKyBwYXJzZUludChmaXJzdENoaWxkQ1NTLm1hcmdpblJpZ2h0KSArIGdldFJlY3QoY2hpbGQxKS53aWR0aCxcbiAgICAgIHNlY29uZENoaWxkV2lkdGggPSBzZWNvbmRDaGlsZENTUyAmJiBwYXJzZUludChzZWNvbmRDaGlsZENTUy5tYXJnaW5MZWZ0KSArIHBhcnNlSW50KHNlY29uZENoaWxkQ1NTLm1hcmdpblJpZ2h0KSArIGdldFJlY3QoY2hpbGQyKS53aWR0aDtcbiAgICBpZiAoZWxDU1MuZGlzcGxheSA9PT0gJ2ZsZXgnKSB7XG4gICAgICByZXR1cm4gZWxDU1MuZmxleERpcmVjdGlvbiA9PT0gJ2NvbHVtbicgfHwgZWxDU1MuZmxleERpcmVjdGlvbiA9PT0gJ2NvbHVtbi1yZXZlcnNlJyA/ICd2ZXJ0aWNhbCcgOiAnaG9yaXpvbnRhbCc7XG4gICAgfVxuICAgIGlmIChlbENTUy5kaXNwbGF5ID09PSAnZ3JpZCcpIHtcbiAgICAgIHJldHVybiBlbENTUy5ncmlkVGVtcGxhdGVDb2x1bW5zLnNwbGl0KCcgJykubGVuZ3RoIDw9IDEgPyAndmVydGljYWwnIDogJ2hvcml6b250YWwnO1xuICAgIH1cbiAgICBpZiAoY2hpbGQxICYmIGZpcnN0Q2hpbGRDU1NbXCJmbG9hdFwiXSAmJiBmaXJzdENoaWxkQ1NTW1wiZmxvYXRcIl0gIT09ICdub25lJykge1xuICAgICAgdmFyIHRvdWNoaW5nU2lkZUNoaWxkMiA9IGZpcnN0Q2hpbGRDU1NbXCJmbG9hdFwiXSA9PT0gJ2xlZnQnID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgICAgIHJldHVybiBjaGlsZDIgJiYgKHNlY29uZENoaWxkQ1NTLmNsZWFyID09PSAnYm90aCcgfHwgc2Vjb25kQ2hpbGRDU1MuY2xlYXIgPT09IHRvdWNoaW5nU2lkZUNoaWxkMikgPyAndmVydGljYWwnIDogJ2hvcml6b250YWwnO1xuICAgIH1cbiAgICByZXR1cm4gY2hpbGQxICYmIChmaXJzdENoaWxkQ1NTLmRpc3BsYXkgPT09ICdibG9jaycgfHwgZmlyc3RDaGlsZENTUy5kaXNwbGF5ID09PSAnZmxleCcgfHwgZmlyc3RDaGlsZENTUy5kaXNwbGF5ID09PSAndGFibGUnIHx8IGZpcnN0Q2hpbGRDU1MuZGlzcGxheSA9PT0gJ2dyaWQnIHx8IGZpcnN0Q2hpbGRXaWR0aCA+PSBlbFdpZHRoICYmIGVsQ1NTW0NTU0Zsb2F0UHJvcGVydHldID09PSAnbm9uZScgfHwgY2hpbGQyICYmIGVsQ1NTW0NTU0Zsb2F0UHJvcGVydHldID09PSAnbm9uZScgJiYgZmlyc3RDaGlsZFdpZHRoICsgc2Vjb25kQ2hpbGRXaWR0aCA+IGVsV2lkdGgpID8gJ3ZlcnRpY2FsJyA6ICdob3Jpem9udGFsJztcbiAgfSxcbiAgX2RyYWdFbEluUm93Q29sdW1uID0gZnVuY3Rpb24gX2RyYWdFbEluUm93Q29sdW1uKGRyYWdSZWN0LCB0YXJnZXRSZWN0LCB2ZXJ0aWNhbCkge1xuICAgIHZhciBkcmFnRWxTMU9wcCA9IHZlcnRpY2FsID8gZHJhZ1JlY3QubGVmdCA6IGRyYWdSZWN0LnRvcCxcbiAgICAgIGRyYWdFbFMyT3BwID0gdmVydGljYWwgPyBkcmFnUmVjdC5yaWdodCA6IGRyYWdSZWN0LmJvdHRvbSxcbiAgICAgIGRyYWdFbE9wcExlbmd0aCA9IHZlcnRpY2FsID8gZHJhZ1JlY3Qud2lkdGggOiBkcmFnUmVjdC5oZWlnaHQsXG4gICAgICB0YXJnZXRTMU9wcCA9IHZlcnRpY2FsID8gdGFyZ2V0UmVjdC5sZWZ0IDogdGFyZ2V0UmVjdC50b3AsXG4gICAgICB0YXJnZXRTMk9wcCA9IHZlcnRpY2FsID8gdGFyZ2V0UmVjdC5yaWdodCA6IHRhcmdldFJlY3QuYm90dG9tLFxuICAgICAgdGFyZ2V0T3BwTGVuZ3RoID0gdmVydGljYWwgPyB0YXJnZXRSZWN0LndpZHRoIDogdGFyZ2V0UmVjdC5oZWlnaHQ7XG4gICAgcmV0dXJuIGRyYWdFbFMxT3BwID09PSB0YXJnZXRTMU9wcCB8fCBkcmFnRWxTMk9wcCA9PT0gdGFyZ2V0UzJPcHAgfHwgZHJhZ0VsUzFPcHAgKyBkcmFnRWxPcHBMZW5ndGggLyAyID09PSB0YXJnZXRTMU9wcCArIHRhcmdldE9wcExlbmd0aCAvIDI7XG4gIH0sXG4gIC8qKlxyXG4gICAqIERldGVjdHMgZmlyc3QgbmVhcmVzdCBlbXB0eSBzb3J0YWJsZSB0byBYIGFuZCBZIHBvc2l0aW9uIHVzaW5nIGVtcHR5SW5zZXJ0VGhyZXNob2xkLlxyXG4gICAqIEBwYXJhbSAge051bWJlcn0geCAgICAgIFggcG9zaXRpb25cclxuICAgKiBAcGFyYW0gIHtOdW1iZXJ9IHkgICAgICBZIHBvc2l0aW9uXHJcbiAgICogQHJldHVybiB7SFRNTEVsZW1lbnR9ICAgRWxlbWVudCBvZiB0aGUgZmlyc3QgZm91bmQgbmVhcmVzdCBTb3J0YWJsZVxyXG4gICAqL1xuICBfZGV0ZWN0TmVhcmVzdEVtcHR5U29ydGFibGUgPSBmdW5jdGlvbiBfZGV0ZWN0TmVhcmVzdEVtcHR5U29ydGFibGUoeCwgeSkge1xuICAgIHZhciByZXQ7XG4gICAgc29ydGFibGVzLnNvbWUoZnVuY3Rpb24gKHNvcnRhYmxlKSB7XG4gICAgICB2YXIgdGhyZXNob2xkID0gc29ydGFibGVbZXhwYW5kb10ub3B0aW9ucy5lbXB0eUluc2VydFRocmVzaG9sZDtcbiAgICAgIGlmICghdGhyZXNob2xkIHx8IGxhc3RDaGlsZChzb3J0YWJsZSkpIHJldHVybjtcbiAgICAgIHZhciByZWN0ID0gZ2V0UmVjdChzb3J0YWJsZSksXG4gICAgICAgIGluc2lkZUhvcml6b250YWxseSA9IHggPj0gcmVjdC5sZWZ0IC0gdGhyZXNob2xkICYmIHggPD0gcmVjdC5yaWdodCArIHRocmVzaG9sZCxcbiAgICAgICAgaW5zaWRlVmVydGljYWxseSA9IHkgPj0gcmVjdC50b3AgLSB0aHJlc2hvbGQgJiYgeSA8PSByZWN0LmJvdHRvbSArIHRocmVzaG9sZDtcbiAgICAgIGlmIChpbnNpZGVIb3Jpem9udGFsbHkgJiYgaW5zaWRlVmVydGljYWxseSkge1xuICAgICAgICByZXR1cm4gcmV0ID0gc29ydGFibGU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJldDtcbiAgfSxcbiAgX3ByZXBhcmVHcm91cCA9IGZ1bmN0aW9uIF9wcmVwYXJlR3JvdXAob3B0aW9ucykge1xuICAgIGZ1bmN0aW9uIHRvRm4odmFsdWUsIHB1bGwpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAodG8sIGZyb20sIGRyYWdFbCwgZXZ0KSB7XG4gICAgICAgIHZhciBzYW1lR3JvdXAgPSB0by5vcHRpb25zLmdyb3VwLm5hbWUgJiYgZnJvbS5vcHRpb25zLmdyb3VwLm5hbWUgJiYgdG8ub3B0aW9ucy5ncm91cC5uYW1lID09PSBmcm9tLm9wdGlvbnMuZ3JvdXAubmFtZTtcbiAgICAgICAgaWYgKHZhbHVlID09IG51bGwgJiYgKHB1bGwgfHwgc2FtZUdyb3VwKSkge1xuICAgICAgICAgIC8vIERlZmF1bHQgcHVsbCB2YWx1ZVxuICAgICAgICAgIC8vIERlZmF1bHQgcHVsbCBhbmQgcHV0IHZhbHVlIGlmIHNhbWUgZ3JvdXBcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSA9PSBudWxsIHx8IHZhbHVlID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChwdWxsICYmIHZhbHVlID09PSAnY2xvbmUnKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiB0b0ZuKHZhbHVlKHRvLCBmcm9tLCBkcmFnRWwsIGV2dCksIHB1bGwpKHRvLCBmcm9tLCBkcmFnRWwsIGV2dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG90aGVyR3JvdXAgPSAocHVsbCA/IHRvIDogZnJvbSkub3B0aW9ucy5ncm91cC5uYW1lO1xuICAgICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSB8fCB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlID09PSBvdGhlckdyb3VwIHx8IHZhbHVlLmpvaW4gJiYgdmFsdWUuaW5kZXhPZihvdGhlckdyb3VwKSA+IC0xO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICB2YXIgZ3JvdXAgPSB7fTtcbiAgICB2YXIgb3JpZ2luYWxHcm91cCA9IG9wdGlvbnMuZ3JvdXA7XG4gICAgaWYgKCFvcmlnaW5hbEdyb3VwIHx8IF90eXBlb2Yob3JpZ2luYWxHcm91cCkgIT0gJ29iamVjdCcpIHtcbiAgICAgIG9yaWdpbmFsR3JvdXAgPSB7XG4gICAgICAgIG5hbWU6IG9yaWdpbmFsR3JvdXBcbiAgICAgIH07XG4gICAgfVxuICAgIGdyb3VwLm5hbWUgPSBvcmlnaW5hbEdyb3VwLm5hbWU7XG4gICAgZ3JvdXAuY2hlY2tQdWxsID0gdG9GbihvcmlnaW5hbEdyb3VwLnB1bGwsIHRydWUpO1xuICAgIGdyb3VwLmNoZWNrUHV0ID0gdG9GbihvcmlnaW5hbEdyb3VwLnB1dCk7XG4gICAgZ3JvdXAucmV2ZXJ0Q2xvbmUgPSBvcmlnaW5hbEdyb3VwLnJldmVydENsb25lO1xuICAgIG9wdGlvbnMuZ3JvdXAgPSBncm91cDtcbiAgfSxcbiAgX2hpZGVHaG9zdEZvclRhcmdldCA9IGZ1bmN0aW9uIF9oaWRlR2hvc3RGb3JUYXJnZXQoKSB7XG4gICAgaWYgKCFzdXBwb3J0Q3NzUG9pbnRlckV2ZW50cyAmJiBnaG9zdEVsKSB7XG4gICAgICBjc3MoZ2hvc3RFbCwgJ2Rpc3BsYXknLCAnbm9uZScpO1xuICAgIH1cbiAgfSxcbiAgX3VuaGlkZUdob3N0Rm9yVGFyZ2V0ID0gZnVuY3Rpb24gX3VuaGlkZUdob3N0Rm9yVGFyZ2V0KCkge1xuICAgIGlmICghc3VwcG9ydENzc1BvaW50ZXJFdmVudHMgJiYgZ2hvc3RFbCkge1xuICAgICAgY3NzKGdob3N0RWwsICdkaXNwbGF5JywgJycpO1xuICAgIH1cbiAgfTtcblxuLy8gIzExODQgZml4IC0gUHJldmVudCBjbGljayBldmVudCBvbiBmYWxsYmFjayBpZiBkcmFnZ2VkIGJ1dCBpdGVtIG5vdCBjaGFuZ2VkIHBvc2l0aW9uXG5pZiAoZG9jdW1lbnRFeGlzdHMgJiYgIUNocm9tZUZvckFuZHJvaWQpIHtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgaWYgKGlnbm9yZU5leHRDbGljaykge1xuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBldnQuc3RvcFByb3BhZ2F0aW9uICYmIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIGV2dC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gJiYgZXZ0LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgaWdub3JlTmV4dENsaWNrID0gZmFsc2U7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9LCB0cnVlKTtcbn1cbnZhciBuZWFyZXN0RW1wdHlJbnNlcnREZXRlY3RFdmVudCA9IGZ1bmN0aW9uIG5lYXJlc3RFbXB0eUluc2VydERldGVjdEV2ZW50KGV2dCkge1xuICBpZiAoZHJhZ0VsKSB7XG4gICAgZXZ0ID0gZXZ0LnRvdWNoZXMgPyBldnQudG91Y2hlc1swXSA6IGV2dDtcbiAgICB2YXIgbmVhcmVzdCA9IF9kZXRlY3ROZWFyZXN0RW1wdHlTb3J0YWJsZShldnQuY2xpZW50WCwgZXZ0LmNsaWVudFkpO1xuICAgIGlmIChuZWFyZXN0KSB7XG4gICAgICAvLyBDcmVhdGUgaW1pdGF0aW9uIGV2ZW50XG4gICAgICB2YXIgZXZlbnQgPSB7fTtcbiAgICAgIGZvciAodmFyIGkgaW4gZXZ0KSB7XG4gICAgICAgIGlmIChldnQuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICBldmVudFtpXSA9IGV2dFtpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZXZlbnQudGFyZ2V0ID0gZXZlbnQucm9vdEVsID0gbmVhcmVzdDtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0ID0gdm9pZCAwO1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uID0gdm9pZCAwO1xuICAgICAgbmVhcmVzdFtleHBhbmRvXS5fb25EcmFnT3ZlcihldmVudCk7XG4gICAgfVxuICB9XG59O1xudmFyIF9jaGVja091dHNpZGVUYXJnZXRFbCA9IGZ1bmN0aW9uIF9jaGVja091dHNpZGVUYXJnZXRFbChldnQpIHtcbiAgaWYgKGRyYWdFbCkge1xuICAgIGRyYWdFbC5wYXJlbnROb2RlW2V4cGFuZG9dLl9pc091dHNpZGVUaGlzRWwoZXZ0LnRhcmdldCk7XG4gIH1cbn07XG5cbi8qKlxyXG4gKiBAY2xhc3MgIFNvcnRhYmxlXHJcbiAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSAgZWxcclxuICogQHBhcmFtICB7T2JqZWN0fSAgICAgICBbb3B0aW9uc11cclxuICovXG5mdW5jdGlvbiBTb3J0YWJsZShlbCwgb3B0aW9ucykge1xuICBpZiAoIShlbCAmJiBlbC5ub2RlVHlwZSAmJiBlbC5ub2RlVHlwZSA9PT0gMSkpIHtcbiAgICB0aHJvdyBcIlNvcnRhYmxlOiBgZWxgIG11c3QgYmUgYW4gSFRNTEVsZW1lbnQsIG5vdCBcIi5jb25jYXQoe30udG9TdHJpbmcuY2FsbChlbCkpO1xuICB9XG4gIHRoaXMuZWwgPSBlbDsgLy8gcm9vdCBlbGVtZW50XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgb3B0aW9ucyk7XG5cbiAgLy8gRXhwb3J0IGluc3RhbmNlXG4gIGVsW2V4cGFuZG9dID0gdGhpcztcbiAgdmFyIGRlZmF1bHRzID0ge1xuICAgIGdyb3VwOiBudWxsLFxuICAgIHNvcnQ6IHRydWUsXG4gICAgZGlzYWJsZWQ6IGZhbHNlLFxuICAgIHN0b3JlOiBudWxsLFxuICAgIGhhbmRsZTogbnVsbCxcbiAgICBkcmFnZ2FibGU6IC9eW3VvXWwkL2kudGVzdChlbC5ub2RlTmFtZSkgPyAnPmxpJyA6ICc+KicsXG4gICAgc3dhcFRocmVzaG9sZDogMSxcbiAgICAvLyBwZXJjZW50YWdlOyAwIDw9IHggPD0gMVxuICAgIGludmVydFN3YXA6IGZhbHNlLFxuICAgIC8vIGludmVydCBhbHdheXNcbiAgICBpbnZlcnRlZFN3YXBUaHJlc2hvbGQ6IG51bGwsXG4gICAgLy8gd2lsbCBiZSBzZXQgdG8gc2FtZSBhcyBzd2FwVGhyZXNob2xkIGlmIGRlZmF1bHRcbiAgICByZW1vdmVDbG9uZU9uSGlkZTogdHJ1ZSxcbiAgICBkaXJlY3Rpb246IGZ1bmN0aW9uIGRpcmVjdGlvbigpIHtcbiAgICAgIHJldHVybiBfZGV0ZWN0RGlyZWN0aW9uKGVsLCB0aGlzLm9wdGlvbnMpO1xuICAgIH0sXG4gICAgZ2hvc3RDbGFzczogJ3NvcnRhYmxlLWdob3N0JyxcbiAgICBjaG9zZW5DbGFzczogJ3NvcnRhYmxlLWNob3NlbicsXG4gICAgZHJhZ0NsYXNzOiAnc29ydGFibGUtZHJhZycsXG4gICAgaWdub3JlOiAnYSwgaW1nJyxcbiAgICBmaWx0ZXI6IG51bGwsXG4gICAgcHJldmVudE9uRmlsdGVyOiB0cnVlLFxuICAgIGFuaW1hdGlvbjogMCxcbiAgICBlYXNpbmc6IG51bGwsXG4gICAgc2V0RGF0YTogZnVuY3Rpb24gc2V0RGF0YShkYXRhVHJhbnNmZXIsIGRyYWdFbCkge1xuICAgICAgZGF0YVRyYW5zZmVyLnNldERhdGEoJ1RleHQnLCBkcmFnRWwudGV4dENvbnRlbnQpO1xuICAgIH0sXG4gICAgZHJvcEJ1YmJsZTogZmFsc2UsXG4gICAgZHJhZ292ZXJCdWJibGU6IGZhbHNlLFxuICAgIGRhdGFJZEF0dHI6ICdkYXRhLWlkJyxcbiAgICBkZWxheTogMCxcbiAgICBkZWxheU9uVG91Y2hPbmx5OiBmYWxzZSxcbiAgICB0b3VjaFN0YXJ0VGhyZXNob2xkOiAoTnVtYmVyLnBhcnNlSW50ID8gTnVtYmVyIDogd2luZG93KS5wYXJzZUludCh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbywgMTApIHx8IDEsXG4gICAgZm9yY2VGYWxsYmFjazogZmFsc2UsXG4gICAgZmFsbGJhY2tDbGFzczogJ3NvcnRhYmxlLWZhbGxiYWNrJyxcbiAgICBmYWxsYmFja09uQm9keTogZmFsc2UsXG4gICAgZmFsbGJhY2tUb2xlcmFuY2U6IDAsXG4gICAgZmFsbGJhY2tPZmZzZXQ6IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfSxcbiAgICAvLyBEaXNhYmxlZCBvbiBTYWZhcmk6ICMxNTcxOyBFbmFibGVkIG9uIFNhZmFyaSBJT1M6ICMyMjQ0XG4gICAgc3VwcG9ydFBvaW50ZXI6IFNvcnRhYmxlLnN1cHBvcnRQb2ludGVyICE9PSBmYWxzZSAmJiAnUG9pbnRlckV2ZW50JyBpbiB3aW5kb3cgJiYgKCFTYWZhcmkgfHwgSU9TKSxcbiAgICBlbXB0eUluc2VydFRocmVzaG9sZDogNVxuICB9O1xuICBQbHVnaW5NYW5hZ2VyLmluaXRpYWxpemVQbHVnaW5zKHRoaXMsIGVsLCBkZWZhdWx0cyk7XG5cbiAgLy8gU2V0IGRlZmF1bHQgb3B0aW9uc1xuICBmb3IgKHZhciBuYW1lIGluIGRlZmF1bHRzKSB7XG4gICAgIShuYW1lIGluIG9wdGlvbnMpICYmIChvcHRpb25zW25hbWVdID0gZGVmYXVsdHNbbmFtZV0pO1xuICB9XG4gIF9wcmVwYXJlR3JvdXAob3B0aW9ucyk7XG5cbiAgLy8gQmluZCBhbGwgcHJpdmF0ZSBtZXRob2RzXG4gIGZvciAodmFyIGZuIGluIHRoaXMpIHtcbiAgICBpZiAoZm4uY2hhckF0KDApID09PSAnXycgJiYgdHlwZW9mIHRoaXNbZm5dID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2ZuXSA9IHRoaXNbZm5dLmJpbmQodGhpcyk7XG4gICAgfVxuICB9XG5cbiAgLy8gU2V0dXAgZHJhZyBtb2RlXG4gIHRoaXMubmF0aXZlRHJhZ2dhYmxlID0gb3B0aW9ucy5mb3JjZUZhbGxiYWNrID8gZmFsc2UgOiBzdXBwb3J0RHJhZ2dhYmxlO1xuICBpZiAodGhpcy5uYXRpdmVEcmFnZ2FibGUpIHtcbiAgICAvLyBUb3VjaCBzdGFydCB0aHJlc2hvbGQgY2Fubm90IGJlIGdyZWF0ZXIgdGhhbiB0aGUgbmF0aXZlIGRyYWdzdGFydCB0aHJlc2hvbGRcbiAgICB0aGlzLm9wdGlvbnMudG91Y2hTdGFydFRocmVzaG9sZCA9IDE7XG4gIH1cblxuICAvLyBCaW5kIGV2ZW50c1xuICBpZiAob3B0aW9ucy5zdXBwb3J0UG9pbnRlcikge1xuICAgIG9uKGVsLCAncG9pbnRlcmRvd24nLCB0aGlzLl9vblRhcFN0YXJ0KTtcbiAgfSBlbHNlIHtcbiAgICBvbihlbCwgJ21vdXNlZG93bicsIHRoaXMuX29uVGFwU3RhcnQpO1xuICAgIG9uKGVsLCAndG91Y2hzdGFydCcsIHRoaXMuX29uVGFwU3RhcnQpO1xuICB9XG4gIGlmICh0aGlzLm5hdGl2ZURyYWdnYWJsZSkge1xuICAgIG9uKGVsLCAnZHJhZ292ZXInLCB0aGlzKTtcbiAgICBvbihlbCwgJ2RyYWdlbnRlcicsIHRoaXMpO1xuICB9XG4gIHNvcnRhYmxlcy5wdXNoKHRoaXMuZWwpO1xuXG4gIC8vIFJlc3RvcmUgc29ydGluZ1xuICBvcHRpb25zLnN0b3JlICYmIG9wdGlvbnMuc3RvcmUuZ2V0ICYmIHRoaXMuc29ydChvcHRpb25zLnN0b3JlLmdldCh0aGlzKSB8fCBbXSk7XG5cbiAgLy8gQWRkIGFuaW1hdGlvbiBzdGF0ZSBtYW5hZ2VyXG4gIF9leHRlbmRzKHRoaXMsIEFuaW1hdGlvblN0YXRlTWFuYWdlcigpKTtcbn1cblNvcnRhYmxlLnByb3RvdHlwZSA9IC8qKiBAbGVuZHMgU29ydGFibGUucHJvdG90eXBlICove1xuICBjb25zdHJ1Y3RvcjogU29ydGFibGUsXG4gIF9pc091dHNpZGVUaGlzRWw6IGZ1bmN0aW9uIF9pc091dHNpZGVUaGlzRWwodGFyZ2V0KSB7XG4gICAgaWYgKCF0aGlzLmVsLmNvbnRhaW5zKHRhcmdldCkgJiYgdGFyZ2V0ICE9PSB0aGlzLmVsKSB7XG4gICAgICBsYXN0VGFyZ2V0ID0gbnVsbDtcbiAgICB9XG4gIH0sXG4gIF9nZXREaXJlY3Rpb246IGZ1bmN0aW9uIF9nZXREaXJlY3Rpb24oZXZ0LCB0YXJnZXQpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaXMub3B0aW9ucy5kaXJlY3Rpb24gPT09ICdmdW5jdGlvbicgPyB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uLmNhbGwodGhpcywgZXZ0LCB0YXJnZXQsIGRyYWdFbCkgOiB0aGlzLm9wdGlvbnMuZGlyZWN0aW9uO1xuICB9LFxuICBfb25UYXBTdGFydDogZnVuY3Rpb24gX29uVGFwU3RhcnQoIC8qKiBFdmVudHxUb3VjaEV2ZW50ICovZXZ0KSB7XG4gICAgaWYgKCFldnQuY2FuY2VsYWJsZSkgcmV0dXJuO1xuICAgIHZhciBfdGhpcyA9IHRoaXMsXG4gICAgICBlbCA9IHRoaXMuZWwsXG4gICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgcHJldmVudE9uRmlsdGVyID0gb3B0aW9ucy5wcmV2ZW50T25GaWx0ZXIsXG4gICAgICB0eXBlID0gZXZ0LnR5cGUsXG4gICAgICB0b3VjaCA9IGV2dC50b3VjaGVzICYmIGV2dC50b3VjaGVzWzBdIHx8IGV2dC5wb2ludGVyVHlwZSAmJiBldnQucG9pbnRlclR5cGUgPT09ICd0b3VjaCcgJiYgZXZ0LFxuICAgICAgdGFyZ2V0ID0gKHRvdWNoIHx8IGV2dCkudGFyZ2V0LFxuICAgICAgb3JpZ2luYWxUYXJnZXQgPSBldnQudGFyZ2V0LnNoYWRvd1Jvb3QgJiYgKGV2dC5wYXRoICYmIGV2dC5wYXRoWzBdIHx8IGV2dC5jb21wb3NlZFBhdGggJiYgZXZ0LmNvbXBvc2VkUGF0aCgpWzBdKSB8fCB0YXJnZXQsXG4gICAgICBmaWx0ZXIgPSBvcHRpb25zLmZpbHRlcjtcbiAgICBfc2F2ZUlucHV0Q2hlY2tlZFN0YXRlKGVsKTtcblxuICAgIC8vIERvbid0IHRyaWdnZXIgc3RhcnQgZXZlbnQgd2hlbiBhbiBlbGVtZW50IGlzIGJlZW4gZHJhZ2dlZCwgb3RoZXJ3aXNlIHRoZSBldnQub2xkaW5kZXggYWx3YXlzIHdyb25nIHdoZW4gc2V0IG9wdGlvbi5ncm91cC5cbiAgICBpZiAoZHJhZ0VsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICgvbW91c2Vkb3dufHBvaW50ZXJkb3duLy50ZXN0KHR5cGUpICYmIGV2dC5idXR0b24gIT09IDAgfHwgb3B0aW9ucy5kaXNhYmxlZCkge1xuICAgICAgcmV0dXJuOyAvLyBvbmx5IGxlZnQgYnV0dG9uIGFuZCBlbmFibGVkXG4gICAgfVxuXG4gICAgLy8gY2FuY2VsIGRuZCBpZiBvcmlnaW5hbCB0YXJnZXQgaXMgY29udGVudCBlZGl0YWJsZVxuICAgIGlmIChvcmlnaW5hbFRhcmdldC5pc0NvbnRlbnRFZGl0YWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFNhZmFyaSBpZ25vcmVzIGZ1cnRoZXIgZXZlbnQgaGFuZGxpbmcgYWZ0ZXIgbW91c2Vkb3duXG4gICAgaWYgKCF0aGlzLm5hdGl2ZURyYWdnYWJsZSAmJiBTYWZhcmkgJiYgdGFyZ2V0ICYmIHRhcmdldC50YWdOYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdTRUxFQ1QnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRhcmdldCA9IGNsb3Nlc3QodGFyZ2V0LCBvcHRpb25zLmRyYWdnYWJsZSwgZWwsIGZhbHNlKTtcbiAgICBpZiAodGFyZ2V0ICYmIHRhcmdldC5hbmltYXRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobGFzdERvd25FbCA9PT0gdGFyZ2V0KSB7XG4gICAgICAvLyBJZ25vcmluZyBkdXBsaWNhdGUgYGRvd25gXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gR2V0IHRoZSBpbmRleCBvZiB0aGUgZHJhZ2dlZCBlbGVtZW50IHdpdGhpbiBpdHMgcGFyZW50XG4gICAgb2xkSW5kZXggPSBpbmRleCh0YXJnZXQpO1xuICAgIG9sZERyYWdnYWJsZUluZGV4ID0gaW5kZXgodGFyZ2V0LCBvcHRpb25zLmRyYWdnYWJsZSk7XG5cbiAgICAvLyBDaGVjayBmaWx0ZXJcbiAgICBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGZpbHRlci5jYWxsKHRoaXMsIGV2dCwgdGFyZ2V0LCB0aGlzKSkge1xuICAgICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgc29ydGFibGU6IF90aGlzLFxuICAgICAgICAgIHJvb3RFbDogb3JpZ2luYWxUYXJnZXQsXG4gICAgICAgICAgbmFtZTogJ2ZpbHRlcicsXG4gICAgICAgICAgdGFyZ2V0RWw6IHRhcmdldCxcbiAgICAgICAgICB0b0VsOiBlbCxcbiAgICAgICAgICBmcm9tRWw6IGVsXG4gICAgICAgIH0pO1xuICAgICAgICBwbHVnaW5FdmVudCgnZmlsdGVyJywgX3RoaXMsIHtcbiAgICAgICAgICBldnQ6IGV2dFxuICAgICAgICB9KTtcbiAgICAgICAgcHJldmVudE9uRmlsdGVyICYmIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXR1cm47IC8vIGNhbmNlbCBkbmRcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGZpbHRlcikge1xuICAgICAgZmlsdGVyID0gZmlsdGVyLnNwbGl0KCcsJykuc29tZShmdW5jdGlvbiAoY3JpdGVyaWEpIHtcbiAgICAgICAgY3JpdGVyaWEgPSBjbG9zZXN0KG9yaWdpbmFsVGFyZ2V0LCBjcml0ZXJpYS50cmltKCksIGVsLCBmYWxzZSk7XG4gICAgICAgIGlmIChjcml0ZXJpYSkge1xuICAgICAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICAgIHNvcnRhYmxlOiBfdGhpcyxcbiAgICAgICAgICAgIHJvb3RFbDogY3JpdGVyaWEsXG4gICAgICAgICAgICBuYW1lOiAnZmlsdGVyJyxcbiAgICAgICAgICAgIHRhcmdldEVsOiB0YXJnZXQsXG4gICAgICAgICAgICBmcm9tRWw6IGVsLFxuICAgICAgICAgICAgdG9FbDogZWxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBwbHVnaW5FdmVudCgnZmlsdGVyJywgX3RoaXMsIHtcbiAgICAgICAgICAgIGV2dDogZXZ0XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKGZpbHRlcikge1xuICAgICAgICBwcmV2ZW50T25GaWx0ZXIgJiYgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybjsgLy8gY2FuY2VsIGRuZFxuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5oYW5kbGUgJiYgIWNsb3Nlc3Qob3JpZ2luYWxUYXJnZXQsIG9wdGlvbnMuaGFuZGxlLCBlbCwgZmFsc2UpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gUHJlcGFyZSBgZHJhZ3N0YXJ0YFxuICAgIHRoaXMuX3ByZXBhcmVEcmFnU3RhcnQoZXZ0LCB0b3VjaCwgdGFyZ2V0KTtcbiAgfSxcbiAgX3ByZXBhcmVEcmFnU3RhcnQ6IGZ1bmN0aW9uIF9wcmVwYXJlRHJhZ1N0YXJ0KCAvKiogRXZlbnQgKi9ldnQsIC8qKiBUb3VjaCAqL3RvdWNoLCAvKiogSFRNTEVsZW1lbnQgKi90YXJnZXQpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzLFxuICAgICAgZWwgPSBfdGhpcy5lbCxcbiAgICAgIG9wdGlvbnMgPSBfdGhpcy5vcHRpb25zLFxuICAgICAgb3duZXJEb2N1bWVudCA9IGVsLm93bmVyRG9jdW1lbnQsXG4gICAgICBkcmFnU3RhcnRGbjtcbiAgICBpZiAodGFyZ2V0ICYmICFkcmFnRWwgJiYgdGFyZ2V0LnBhcmVudE5vZGUgPT09IGVsKSB7XG4gICAgICB2YXIgZHJhZ1JlY3QgPSBnZXRSZWN0KHRhcmdldCk7XG4gICAgICByb290RWwgPSBlbDtcbiAgICAgIGRyYWdFbCA9IHRhcmdldDtcbiAgICAgIHBhcmVudEVsID0gZHJhZ0VsLnBhcmVudE5vZGU7XG4gICAgICBuZXh0RWwgPSBkcmFnRWwubmV4dFNpYmxpbmc7XG4gICAgICBsYXN0RG93bkVsID0gdGFyZ2V0O1xuICAgICAgYWN0aXZlR3JvdXAgPSBvcHRpb25zLmdyb3VwO1xuICAgICAgU29ydGFibGUuZHJhZ2dlZCA9IGRyYWdFbDtcbiAgICAgIHRhcEV2dCA9IHtcbiAgICAgICAgdGFyZ2V0OiBkcmFnRWwsXG4gICAgICAgIGNsaWVudFg6ICh0b3VjaCB8fCBldnQpLmNsaWVudFgsXG4gICAgICAgIGNsaWVudFk6ICh0b3VjaCB8fCBldnQpLmNsaWVudFlcbiAgICAgIH07XG4gICAgICB0YXBEaXN0YW5jZUxlZnQgPSB0YXBFdnQuY2xpZW50WCAtIGRyYWdSZWN0LmxlZnQ7XG4gICAgICB0YXBEaXN0YW5jZVRvcCA9IHRhcEV2dC5jbGllbnRZIC0gZHJhZ1JlY3QudG9wO1xuICAgICAgdGhpcy5fbGFzdFggPSAodG91Y2ggfHwgZXZ0KS5jbGllbnRYO1xuICAgICAgdGhpcy5fbGFzdFkgPSAodG91Y2ggfHwgZXZ0KS5jbGllbnRZO1xuICAgICAgZHJhZ0VsLnN0eWxlWyd3aWxsLWNoYW5nZSddID0gJ2FsbCc7XG4gICAgICBkcmFnU3RhcnRGbiA9IGZ1bmN0aW9uIGRyYWdTdGFydEZuKCkge1xuICAgICAgICBwbHVnaW5FdmVudCgnZGVsYXlFbmRlZCcsIF90aGlzLCB7XG4gICAgICAgICAgZXZ0OiBldnRcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChTb3J0YWJsZS5ldmVudENhbmNlbGVkKSB7XG4gICAgICAgICAgX3RoaXMuX29uRHJvcCgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBEZWxheWVkIGRyYWcgaGFzIGJlZW4gdHJpZ2dlcmVkXG4gICAgICAgIC8vIHdlIGNhbiByZS1lbmFibGUgdGhlIGV2ZW50czogdG91Y2htb3ZlL21vdXNlbW92ZVxuICAgICAgICBfdGhpcy5fZGlzYWJsZURlbGF5ZWREcmFnRXZlbnRzKCk7XG4gICAgICAgIGlmICghRmlyZUZveCAmJiBfdGhpcy5uYXRpdmVEcmFnZ2FibGUpIHtcbiAgICAgICAgICBkcmFnRWwuZHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJpbmQgdGhlIGV2ZW50czogZHJhZ3N0YXJ0L2RyYWdlbmRcbiAgICAgICAgX3RoaXMuX3RyaWdnZXJEcmFnU3RhcnQoZXZ0LCB0b3VjaCk7XG5cbiAgICAgICAgLy8gRHJhZyBzdGFydCBldmVudFxuICAgICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgc29ydGFibGU6IF90aGlzLFxuICAgICAgICAgIG5hbWU6ICdjaG9vc2UnLFxuICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBDaG9zZW4gaXRlbVxuICAgICAgICB0b2dnbGVDbGFzcyhkcmFnRWwsIG9wdGlvbnMuY2hvc2VuQ2xhc3MsIHRydWUpO1xuICAgICAgfTtcblxuICAgICAgLy8gRGlzYWJsZSBcImRyYWdnYWJsZVwiXG4gICAgICBvcHRpb25zLmlnbm9yZS5zcGxpdCgnLCcpLmZvckVhY2goZnVuY3Rpb24gKGNyaXRlcmlhKSB7XG4gICAgICAgIGZpbmQoZHJhZ0VsLCBjcml0ZXJpYS50cmltKCksIF9kaXNhYmxlRHJhZ2dhYmxlKTtcbiAgICAgIH0pO1xuICAgICAgb24ob3duZXJEb2N1bWVudCwgJ2RyYWdvdmVyJywgbmVhcmVzdEVtcHR5SW5zZXJ0RGV0ZWN0RXZlbnQpO1xuICAgICAgb24ob3duZXJEb2N1bWVudCwgJ21vdXNlbW92ZScsIG5lYXJlc3RFbXB0eUluc2VydERldGVjdEV2ZW50KTtcbiAgICAgIG9uKG93bmVyRG9jdW1lbnQsICd0b3VjaG1vdmUnLCBuZWFyZXN0RW1wdHlJbnNlcnREZXRlY3RFdmVudCk7XG4gICAgICBpZiAob3B0aW9ucy5zdXBwb3J0UG9pbnRlcikge1xuICAgICAgICBvbihvd25lckRvY3VtZW50LCAncG9pbnRlcnVwJywgX3RoaXMuX29uRHJvcCk7XG4gICAgICAgIC8vIE5hdGl2ZSBEJkQgdHJpZ2dlcnMgcG9pbnRlcmNhbmNlbFxuICAgICAgICAhdGhpcy5uYXRpdmVEcmFnZ2FibGUgJiYgb24ob3duZXJEb2N1bWVudCwgJ3BvaW50ZXJjYW5jZWwnLCBfdGhpcy5fb25Ecm9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9uKG93bmVyRG9jdW1lbnQsICdtb3VzZXVwJywgX3RoaXMuX29uRHJvcCk7XG4gICAgICAgIG9uKG93bmVyRG9jdW1lbnQsICd0b3VjaGVuZCcsIF90aGlzLl9vbkRyb3ApO1xuICAgICAgICBvbihvd25lckRvY3VtZW50LCAndG91Y2hjYW5jZWwnLCBfdGhpcy5fb25Ecm9wKTtcbiAgICAgIH1cblxuICAgICAgLy8gTWFrZSBkcmFnRWwgZHJhZ2dhYmxlIChtdXN0IGJlIGJlZm9yZSBkZWxheSBmb3IgRmlyZUZveClcbiAgICAgIGlmIChGaXJlRm94ICYmIHRoaXMubmF0aXZlRHJhZ2dhYmxlKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy50b3VjaFN0YXJ0VGhyZXNob2xkID0gNDtcbiAgICAgICAgZHJhZ0VsLmRyYWdnYWJsZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBwbHVnaW5FdmVudCgnZGVsYXlTdGFydCcsIHRoaXMsIHtcbiAgICAgICAgZXZ0OiBldnRcbiAgICAgIH0pO1xuXG4gICAgICAvLyBEZWxheSBpcyBpbXBvc3NpYmxlIGZvciBuYXRpdmUgRG5EIGluIEVkZ2Ugb3IgSUVcbiAgICAgIGlmIChvcHRpb25zLmRlbGF5ICYmICghb3B0aW9ucy5kZWxheU9uVG91Y2hPbmx5IHx8IHRvdWNoKSAmJiAoIXRoaXMubmF0aXZlRHJhZ2dhYmxlIHx8ICEoRWRnZSB8fCBJRTExT3JMZXNzKSkpIHtcbiAgICAgICAgaWYgKFNvcnRhYmxlLmV2ZW50Q2FuY2VsZWQpIHtcbiAgICAgICAgICB0aGlzLl9vbkRyb3AoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgdGhlIHVzZXIgbW92ZXMgdGhlIHBvaW50ZXIgb3IgbGV0IGdvIHRoZSBjbGljayBvciB0b3VjaFxuICAgICAgICAvLyBiZWZvcmUgdGhlIGRlbGF5IGhhcyBiZWVuIHJlYWNoZWQ6XG4gICAgICAgIC8vIGRpc2FibGUgdGhlIGRlbGF5ZWQgZHJhZ1xuICAgICAgICBpZiAob3B0aW9ucy5zdXBwb3J0UG9pbnRlcikge1xuICAgICAgICAgIG9uKG93bmVyRG9jdW1lbnQsICdwb2ludGVydXAnLCBfdGhpcy5fZGlzYWJsZURlbGF5ZWREcmFnKTtcbiAgICAgICAgICBvbihvd25lckRvY3VtZW50LCAncG9pbnRlcmNhbmNlbCcsIF90aGlzLl9kaXNhYmxlRGVsYXllZERyYWcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9uKG93bmVyRG9jdW1lbnQsICdtb3VzZXVwJywgX3RoaXMuX2Rpc2FibGVEZWxheWVkRHJhZyk7XG4gICAgICAgICAgb24ob3duZXJEb2N1bWVudCwgJ3RvdWNoZW5kJywgX3RoaXMuX2Rpc2FibGVEZWxheWVkRHJhZyk7XG4gICAgICAgICAgb24ob3duZXJEb2N1bWVudCwgJ3RvdWNoY2FuY2VsJywgX3RoaXMuX2Rpc2FibGVEZWxheWVkRHJhZyk7XG4gICAgICAgIH1cbiAgICAgICAgb24ob3duZXJEb2N1bWVudCwgJ21vdXNlbW92ZScsIF90aGlzLl9kZWxheWVkRHJhZ1RvdWNoTW92ZUhhbmRsZXIpO1xuICAgICAgICBvbihvd25lckRvY3VtZW50LCAndG91Y2htb3ZlJywgX3RoaXMuX2RlbGF5ZWREcmFnVG91Y2hNb3ZlSGFuZGxlcik7XG4gICAgICAgIG9wdGlvbnMuc3VwcG9ydFBvaW50ZXIgJiYgb24ob3duZXJEb2N1bWVudCwgJ3BvaW50ZXJtb3ZlJywgX3RoaXMuX2RlbGF5ZWREcmFnVG91Y2hNb3ZlSGFuZGxlcik7XG4gICAgICAgIF90aGlzLl9kcmFnU3RhcnRUaW1lciA9IHNldFRpbWVvdXQoZHJhZ1N0YXJ0Rm4sIG9wdGlvbnMuZGVsYXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZHJhZ1N0YXJ0Rm4oKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIF9kZWxheWVkRHJhZ1RvdWNoTW92ZUhhbmRsZXI6IGZ1bmN0aW9uIF9kZWxheWVkRHJhZ1RvdWNoTW92ZUhhbmRsZXIoIC8qKiBUb3VjaEV2ZW50fFBvaW50ZXJFdmVudCAqKi9lKSB7XG4gICAgdmFyIHRvdWNoID0gZS50b3VjaGVzID8gZS50b3VjaGVzWzBdIDogZTtcbiAgICBpZiAoTWF0aC5tYXgoTWF0aC5hYnModG91Y2guY2xpZW50WCAtIHRoaXMuX2xhc3RYKSwgTWF0aC5hYnModG91Y2guY2xpZW50WSAtIHRoaXMuX2xhc3RZKSkgPj0gTWF0aC5mbG9vcih0aGlzLm9wdGlvbnMudG91Y2hTdGFydFRocmVzaG9sZCAvICh0aGlzLm5hdGl2ZURyYWdnYWJsZSAmJiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSkpIHtcbiAgICAgIHRoaXMuX2Rpc2FibGVEZWxheWVkRHJhZygpO1xuICAgIH1cbiAgfSxcbiAgX2Rpc2FibGVEZWxheWVkRHJhZzogZnVuY3Rpb24gX2Rpc2FibGVEZWxheWVkRHJhZygpIHtcbiAgICBkcmFnRWwgJiYgX2Rpc2FibGVEcmFnZ2FibGUoZHJhZ0VsKTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fZHJhZ1N0YXJ0VGltZXIpO1xuICAgIHRoaXMuX2Rpc2FibGVEZWxheWVkRHJhZ0V2ZW50cygpO1xuICB9LFxuICBfZGlzYWJsZURlbGF5ZWREcmFnRXZlbnRzOiBmdW5jdGlvbiBfZGlzYWJsZURlbGF5ZWREcmFnRXZlbnRzKCkge1xuICAgIHZhciBvd25lckRvY3VtZW50ID0gdGhpcy5lbC5vd25lckRvY3VtZW50O1xuICAgIG9mZihvd25lckRvY3VtZW50LCAnbW91c2V1cCcsIHRoaXMuX2Rpc2FibGVEZWxheWVkRHJhZyk7XG4gICAgb2ZmKG93bmVyRG9jdW1lbnQsICd0b3VjaGVuZCcsIHRoaXMuX2Rpc2FibGVEZWxheWVkRHJhZyk7XG4gICAgb2ZmKG93bmVyRG9jdW1lbnQsICd0b3VjaGNhbmNlbCcsIHRoaXMuX2Rpc2FibGVEZWxheWVkRHJhZyk7XG4gICAgb2ZmKG93bmVyRG9jdW1lbnQsICdwb2ludGVydXAnLCB0aGlzLl9kaXNhYmxlRGVsYXllZERyYWcpO1xuICAgIG9mZihvd25lckRvY3VtZW50LCAncG9pbnRlcmNhbmNlbCcsIHRoaXMuX2Rpc2FibGVEZWxheWVkRHJhZyk7XG4gICAgb2ZmKG93bmVyRG9jdW1lbnQsICdtb3VzZW1vdmUnLCB0aGlzLl9kZWxheWVkRHJhZ1RvdWNoTW92ZUhhbmRsZXIpO1xuICAgIG9mZihvd25lckRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fZGVsYXllZERyYWdUb3VjaE1vdmVIYW5kbGVyKTtcbiAgICBvZmYob3duZXJEb2N1bWVudCwgJ3BvaW50ZXJtb3ZlJywgdGhpcy5fZGVsYXllZERyYWdUb3VjaE1vdmVIYW5kbGVyKTtcbiAgfSxcbiAgX3RyaWdnZXJEcmFnU3RhcnQ6IGZ1bmN0aW9uIF90cmlnZ2VyRHJhZ1N0YXJ0KCAvKiogRXZlbnQgKi9ldnQsIC8qKiBUb3VjaCAqL3RvdWNoKSB7XG4gICAgdG91Y2ggPSB0b3VjaCB8fCBldnQucG9pbnRlclR5cGUgPT0gJ3RvdWNoJyAmJiBldnQ7XG4gICAgaWYgKCF0aGlzLm5hdGl2ZURyYWdnYWJsZSB8fCB0b3VjaCkge1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdXBwb3J0UG9pbnRlcikge1xuICAgICAgICBvbihkb2N1bWVudCwgJ3BvaW50ZXJtb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUpO1xuICAgICAgfSBlbHNlIGlmICh0b3VjaCkge1xuICAgICAgICBvbihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9uKGRvY3VtZW50LCAnbW91c2Vtb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvbihkcmFnRWwsICdkcmFnZW5kJywgdGhpcyk7XG4gICAgICBvbihyb290RWwsICdkcmFnc3RhcnQnLCB0aGlzLl9vbkRyYWdTdGFydCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBpZiAoZG9jdW1lbnQuc2VsZWN0aW9uKSB7XG4gICAgICAgIF9uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZG9jdW1lbnQuc2VsZWN0aW9uLmVtcHR5KCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luZG93LmdldFNlbGVjdGlvbigpLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge31cbiAgfSxcbiAgX2RyYWdTdGFydGVkOiBmdW5jdGlvbiBfZHJhZ1N0YXJ0ZWQoZmFsbGJhY2ssIGV2dCkge1xuICAgIGF3YWl0aW5nRHJhZ1N0YXJ0ZWQgPSBmYWxzZTtcbiAgICBpZiAocm9vdEVsICYmIGRyYWdFbCkge1xuICAgICAgcGx1Z2luRXZlbnQoJ2RyYWdTdGFydGVkJywgdGhpcywge1xuICAgICAgICBldnQ6IGV2dFxuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy5uYXRpdmVEcmFnZ2FibGUpIHtcbiAgICAgICAgb24oZG9jdW1lbnQsICdkcmFnb3ZlcicsIF9jaGVja091dHNpZGVUYXJnZXRFbCk7XG4gICAgICB9XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICAgICAgLy8gQXBwbHkgZWZmZWN0XG4gICAgICAhZmFsbGJhY2sgJiYgdG9nZ2xlQ2xhc3MoZHJhZ0VsLCBvcHRpb25zLmRyYWdDbGFzcywgZmFsc2UpO1xuICAgICAgdG9nZ2xlQ2xhc3MoZHJhZ0VsLCBvcHRpb25zLmdob3N0Q2xhc3MsIHRydWUpO1xuICAgICAgU29ydGFibGUuYWN0aXZlID0gdGhpcztcbiAgICAgIGZhbGxiYWNrICYmIHRoaXMuX2FwcGVuZEdob3N0KCk7XG5cbiAgICAgIC8vIERyYWcgc3RhcnQgZXZlbnRcbiAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgc29ydGFibGU6IHRoaXMsXG4gICAgICAgIG5hbWU6ICdzdGFydCcsXG4gICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dFxuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX251bGxpbmcoKTtcbiAgICB9XG4gIH0sXG4gIF9lbXVsYXRlRHJhZ092ZXI6IGZ1bmN0aW9uIF9lbXVsYXRlRHJhZ092ZXIoKSB7XG4gICAgaWYgKHRvdWNoRXZ0KSB7XG4gICAgICB0aGlzLl9sYXN0WCA9IHRvdWNoRXZ0LmNsaWVudFg7XG4gICAgICB0aGlzLl9sYXN0WSA9IHRvdWNoRXZ0LmNsaWVudFk7XG4gICAgICBfaGlkZUdob3N0Rm9yVGFyZ2V0KCk7XG4gICAgICB2YXIgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh0b3VjaEV2dC5jbGllbnRYLCB0b3VjaEV2dC5jbGllbnRZKTtcbiAgICAgIHZhciBwYXJlbnQgPSB0YXJnZXQ7XG4gICAgICB3aGlsZSAodGFyZ2V0ICYmIHRhcmdldC5zaGFkb3dSb290KSB7XG4gICAgICAgIHRhcmdldCA9IHRhcmdldC5zaGFkb3dSb290LmVsZW1lbnRGcm9tUG9pbnQodG91Y2hFdnQuY2xpZW50WCwgdG91Y2hFdnQuY2xpZW50WSk7XG4gICAgICAgIGlmICh0YXJnZXQgPT09IHBhcmVudCkgYnJlYWs7XG4gICAgICAgIHBhcmVudCA9IHRhcmdldDtcbiAgICAgIH1cbiAgICAgIGRyYWdFbC5wYXJlbnROb2RlW2V4cGFuZG9dLl9pc091dHNpZGVUaGlzRWwodGFyZ2V0KTtcbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIGlmIChwYXJlbnRbZXhwYW5kb10pIHtcbiAgICAgICAgICAgIHZhciBpbnNlcnRlZCA9IHZvaWQgMDtcbiAgICAgICAgICAgIGluc2VydGVkID0gcGFyZW50W2V4cGFuZG9dLl9vbkRyYWdPdmVyKHtcbiAgICAgICAgICAgICAgY2xpZW50WDogdG91Y2hFdnQuY2xpZW50WCxcbiAgICAgICAgICAgICAgY2xpZW50WTogdG91Y2hFdnQuY2xpZW50WSxcbiAgICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICAgICAgICAgIHJvb3RFbDogcGFyZW50XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChpbnNlcnRlZCAmJiAhdGhpcy5vcHRpb25zLmRyYWdvdmVyQnViYmxlKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0YXJnZXQgPSBwYXJlbnQ7IC8vIHN0b3JlIGxhc3QgZWxlbWVudFxuICAgICAgICB9XG4gICAgICAgIC8qIGpzaGludCBib3NzOnRydWUgKi8gd2hpbGUgKHBhcmVudCA9IGdldFBhcmVudE9ySG9zdChwYXJlbnQpKTtcbiAgICAgIH1cbiAgICAgIF91bmhpZGVHaG9zdEZvclRhcmdldCgpO1xuICAgIH1cbiAgfSxcbiAgX29uVG91Y2hNb3ZlOiBmdW5jdGlvbiBfb25Ub3VjaE1vdmUoIC8qKlRvdWNoRXZlbnQqL2V2dCkge1xuICAgIGlmICh0YXBFdnQpIHtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBmYWxsYmFja1RvbGVyYW5jZSA9IG9wdGlvbnMuZmFsbGJhY2tUb2xlcmFuY2UsXG4gICAgICAgIGZhbGxiYWNrT2Zmc2V0ID0gb3B0aW9ucy5mYWxsYmFja09mZnNldCxcbiAgICAgICAgdG91Y2ggPSBldnQudG91Y2hlcyA/IGV2dC50b3VjaGVzWzBdIDogZXZ0LFxuICAgICAgICBnaG9zdE1hdHJpeCA9IGdob3N0RWwgJiYgbWF0cml4KGdob3N0RWwsIHRydWUpLFxuICAgICAgICBzY2FsZVggPSBnaG9zdEVsICYmIGdob3N0TWF0cml4ICYmIGdob3N0TWF0cml4LmEsXG4gICAgICAgIHNjYWxlWSA9IGdob3N0RWwgJiYgZ2hvc3RNYXRyaXggJiYgZ2hvc3RNYXRyaXguZCxcbiAgICAgICAgcmVsYXRpdmVTY3JvbGxPZmZzZXQgPSBQb3NpdGlvbkdob3N0QWJzb2x1dGVseSAmJiBnaG9zdFJlbGF0aXZlUGFyZW50ICYmIGdldFJlbGF0aXZlU2Nyb2xsT2Zmc2V0KGdob3N0UmVsYXRpdmVQYXJlbnQpLFxuICAgICAgICBkeCA9ICh0b3VjaC5jbGllbnRYIC0gdGFwRXZ0LmNsaWVudFggKyBmYWxsYmFja09mZnNldC54KSAvIChzY2FsZVggfHwgMSkgKyAocmVsYXRpdmVTY3JvbGxPZmZzZXQgPyByZWxhdGl2ZVNjcm9sbE9mZnNldFswXSAtIGdob3N0UmVsYXRpdmVQYXJlbnRJbml0aWFsU2Nyb2xsWzBdIDogMCkgLyAoc2NhbGVYIHx8IDEpLFxuICAgICAgICBkeSA9ICh0b3VjaC5jbGllbnRZIC0gdGFwRXZ0LmNsaWVudFkgKyBmYWxsYmFja09mZnNldC55KSAvIChzY2FsZVkgfHwgMSkgKyAocmVsYXRpdmVTY3JvbGxPZmZzZXQgPyByZWxhdGl2ZVNjcm9sbE9mZnNldFsxXSAtIGdob3N0UmVsYXRpdmVQYXJlbnRJbml0aWFsU2Nyb2xsWzFdIDogMCkgLyAoc2NhbGVZIHx8IDEpO1xuXG4gICAgICAvLyBvbmx5IHNldCB0aGUgc3RhdHVzIHRvIGRyYWdnaW5nLCB3aGVuIHdlIGFyZSBhY3R1YWxseSBkcmFnZ2luZ1xuICAgICAgaWYgKCFTb3J0YWJsZS5hY3RpdmUgJiYgIWF3YWl0aW5nRHJhZ1N0YXJ0ZWQpIHtcbiAgICAgICAgaWYgKGZhbGxiYWNrVG9sZXJhbmNlICYmIE1hdGgubWF4KE1hdGguYWJzKHRvdWNoLmNsaWVudFggLSB0aGlzLl9sYXN0WCksIE1hdGguYWJzKHRvdWNoLmNsaWVudFkgLSB0aGlzLl9sYXN0WSkpIDwgZmFsbGJhY2tUb2xlcmFuY2UpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fb25EcmFnU3RhcnQoZXZ0LCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChnaG9zdEVsKSB7XG4gICAgICAgIGlmIChnaG9zdE1hdHJpeCkge1xuICAgICAgICAgIGdob3N0TWF0cml4LmUgKz0gZHggLSAobGFzdER4IHx8IDApO1xuICAgICAgICAgIGdob3N0TWF0cml4LmYgKz0gZHkgLSAobGFzdER5IHx8IDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdob3N0TWF0cml4ID0ge1xuICAgICAgICAgICAgYTogMSxcbiAgICAgICAgICAgIGI6IDAsXG4gICAgICAgICAgICBjOiAwLFxuICAgICAgICAgICAgZDogMSxcbiAgICAgICAgICAgIGU6IGR4LFxuICAgICAgICAgICAgZjogZHlcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHZhciBjc3NNYXRyaXggPSBcIm1hdHJpeChcIi5jb25jYXQoZ2hvc3RNYXRyaXguYSwgXCIsXCIpLmNvbmNhdChnaG9zdE1hdHJpeC5iLCBcIixcIikuY29uY2F0KGdob3N0TWF0cml4LmMsIFwiLFwiKS5jb25jYXQoZ2hvc3RNYXRyaXguZCwgXCIsXCIpLmNvbmNhdChnaG9zdE1hdHJpeC5lLCBcIixcIikuY29uY2F0KGdob3N0TWF0cml4LmYsIFwiKVwiKTtcbiAgICAgICAgY3NzKGdob3N0RWwsICd3ZWJraXRUcmFuc2Zvcm0nLCBjc3NNYXRyaXgpO1xuICAgICAgICBjc3MoZ2hvc3RFbCwgJ21velRyYW5zZm9ybScsIGNzc01hdHJpeCk7XG4gICAgICAgIGNzcyhnaG9zdEVsLCAnbXNUcmFuc2Zvcm0nLCBjc3NNYXRyaXgpO1xuICAgICAgICBjc3MoZ2hvc3RFbCwgJ3RyYW5zZm9ybScsIGNzc01hdHJpeCk7XG4gICAgICAgIGxhc3REeCA9IGR4O1xuICAgICAgICBsYXN0RHkgPSBkeTtcbiAgICAgICAgdG91Y2hFdnQgPSB0b3VjaDtcbiAgICAgIH1cbiAgICAgIGV2dC5jYW5jZWxhYmxlICYmIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfSxcbiAgX2FwcGVuZEdob3N0OiBmdW5jdGlvbiBfYXBwZW5kR2hvc3QoKSB7XG4gICAgLy8gQnVnIGlmIHVzaW5nIHNjYWxlKCk6IGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzI2MzcwNThcbiAgICAvLyBOb3QgYmVpbmcgYWRqdXN0ZWQgZm9yXG4gICAgaWYgKCFnaG9zdEVsKSB7XG4gICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5vcHRpb25zLmZhbGxiYWNrT25Cb2R5ID8gZG9jdW1lbnQuYm9keSA6IHJvb3RFbCxcbiAgICAgICAgcmVjdCA9IGdldFJlY3QoZHJhZ0VsLCB0cnVlLCBQb3NpdGlvbkdob3N0QWJzb2x1dGVseSwgdHJ1ZSwgY29udGFpbmVyKSxcbiAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICAgICAgLy8gUG9zaXRpb24gYWJzb2x1dGVseVxuICAgICAgaWYgKFBvc2l0aW9uR2hvc3RBYnNvbHV0ZWx5KSB7XG4gICAgICAgIC8vIEdldCByZWxhdGl2ZWx5IHBvc2l0aW9uZWQgcGFyZW50XG4gICAgICAgIGdob3N0UmVsYXRpdmVQYXJlbnQgPSBjb250YWluZXI7XG4gICAgICAgIHdoaWxlIChjc3MoZ2hvc3RSZWxhdGl2ZVBhcmVudCwgJ3Bvc2l0aW9uJykgPT09ICdzdGF0aWMnICYmIGNzcyhnaG9zdFJlbGF0aXZlUGFyZW50LCAndHJhbnNmb3JtJykgPT09ICdub25lJyAmJiBnaG9zdFJlbGF0aXZlUGFyZW50ICE9PSBkb2N1bWVudCkge1xuICAgICAgICAgIGdob3N0UmVsYXRpdmVQYXJlbnQgPSBnaG9zdFJlbGF0aXZlUGFyZW50LnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdob3N0UmVsYXRpdmVQYXJlbnQgIT09IGRvY3VtZW50LmJvZHkgJiYgZ2hvc3RSZWxhdGl2ZVBhcmVudCAhPT0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICAgICAgaWYgKGdob3N0UmVsYXRpdmVQYXJlbnQgPT09IGRvY3VtZW50KSBnaG9zdFJlbGF0aXZlUGFyZW50ID0gZ2V0V2luZG93U2Nyb2xsaW5nRWxlbWVudCgpO1xuICAgICAgICAgIHJlY3QudG9wICs9IGdob3N0UmVsYXRpdmVQYXJlbnQuc2Nyb2xsVG9wO1xuICAgICAgICAgIHJlY3QubGVmdCArPSBnaG9zdFJlbGF0aXZlUGFyZW50LnNjcm9sbExlZnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2hvc3RSZWxhdGl2ZVBhcmVudCA9IGdldFdpbmRvd1Njcm9sbGluZ0VsZW1lbnQoKTtcbiAgICAgICAgfVxuICAgICAgICBnaG9zdFJlbGF0aXZlUGFyZW50SW5pdGlhbFNjcm9sbCA9IGdldFJlbGF0aXZlU2Nyb2xsT2Zmc2V0KGdob3N0UmVsYXRpdmVQYXJlbnQpO1xuICAgICAgfVxuICAgICAgZ2hvc3RFbCA9IGRyYWdFbC5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICB0b2dnbGVDbGFzcyhnaG9zdEVsLCBvcHRpb25zLmdob3N0Q2xhc3MsIGZhbHNlKTtcbiAgICAgIHRvZ2dsZUNsYXNzKGdob3N0RWwsIG9wdGlvbnMuZmFsbGJhY2tDbGFzcywgdHJ1ZSk7XG4gICAgICB0b2dnbGVDbGFzcyhnaG9zdEVsLCBvcHRpb25zLmRyYWdDbGFzcywgdHJ1ZSk7XG4gICAgICBjc3MoZ2hvc3RFbCwgJ3RyYW5zaXRpb24nLCAnJyk7XG4gICAgICBjc3MoZ2hvc3RFbCwgJ3RyYW5zZm9ybScsICcnKTtcbiAgICAgIGNzcyhnaG9zdEVsLCAnYm94LXNpemluZycsICdib3JkZXItYm94Jyk7XG4gICAgICBjc3MoZ2hvc3RFbCwgJ21hcmdpbicsIDApO1xuICAgICAgY3NzKGdob3N0RWwsICd0b3AnLCByZWN0LnRvcCk7XG4gICAgICBjc3MoZ2hvc3RFbCwgJ2xlZnQnLCByZWN0LmxlZnQpO1xuICAgICAgY3NzKGdob3N0RWwsICd3aWR0aCcsIHJlY3Qud2lkdGgpO1xuICAgICAgY3NzKGdob3N0RWwsICdoZWlnaHQnLCByZWN0LmhlaWdodCk7XG4gICAgICBjc3MoZ2hvc3RFbCwgJ29wYWNpdHknLCAnMC44Jyk7XG4gICAgICBjc3MoZ2hvc3RFbCwgJ3Bvc2l0aW9uJywgUG9zaXRpb25HaG9zdEFic29sdXRlbHkgPyAnYWJzb2x1dGUnIDogJ2ZpeGVkJyk7XG4gICAgICBjc3MoZ2hvc3RFbCwgJ3pJbmRleCcsICcxMDAwMDAnKTtcbiAgICAgIGNzcyhnaG9zdEVsLCAncG9pbnRlckV2ZW50cycsICdub25lJyk7XG4gICAgICBTb3J0YWJsZS5naG9zdCA9IGdob3N0RWw7XG4gICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZ2hvc3RFbCk7XG5cbiAgICAgIC8vIFNldCB0cmFuc2Zvcm0tb3JpZ2luXG4gICAgICBjc3MoZ2hvc3RFbCwgJ3RyYW5zZm9ybS1vcmlnaW4nLCB0YXBEaXN0YW5jZUxlZnQgLyBwYXJzZUludChnaG9zdEVsLnN0eWxlLndpZHRoKSAqIDEwMCArICclICcgKyB0YXBEaXN0YW5jZVRvcCAvIHBhcnNlSW50KGdob3N0RWwuc3R5bGUuaGVpZ2h0KSAqIDEwMCArICclJyk7XG4gICAgfVxuICB9LFxuICBfb25EcmFnU3RhcnQ6IGZ1bmN0aW9uIF9vbkRyYWdTdGFydCggLyoqRXZlbnQqL2V2dCwgLyoqYm9vbGVhbiovZmFsbGJhY2spIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHZhciBkYXRhVHJhbnNmZXIgPSBldnQuZGF0YVRyYW5zZmVyO1xuICAgIHZhciBvcHRpb25zID0gX3RoaXMub3B0aW9ucztcbiAgICBwbHVnaW5FdmVudCgnZHJhZ1N0YXJ0JywgdGhpcywge1xuICAgICAgZXZ0OiBldnRcbiAgICB9KTtcbiAgICBpZiAoU29ydGFibGUuZXZlbnRDYW5jZWxlZCkge1xuICAgICAgdGhpcy5fb25Ecm9wKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHBsdWdpbkV2ZW50KCdzZXR1cENsb25lJywgdGhpcyk7XG4gICAgaWYgKCFTb3J0YWJsZS5ldmVudENhbmNlbGVkKSB7XG4gICAgICBjbG9uZUVsID0gY2xvbmUoZHJhZ0VsKTtcbiAgICAgIGNsb25lRWwucmVtb3ZlQXR0cmlidXRlKFwiaWRcIik7XG4gICAgICBjbG9uZUVsLmRyYWdnYWJsZSA9IGZhbHNlO1xuICAgICAgY2xvbmVFbC5zdHlsZVsnd2lsbC1jaGFuZ2UnXSA9ICcnO1xuICAgICAgdGhpcy5faGlkZUNsb25lKCk7XG4gICAgICB0b2dnbGVDbGFzcyhjbG9uZUVsLCB0aGlzLm9wdGlvbnMuY2hvc2VuQ2xhc3MsIGZhbHNlKTtcbiAgICAgIFNvcnRhYmxlLmNsb25lID0gY2xvbmVFbDtcbiAgICB9XG5cbiAgICAvLyAjMTE0MzogSUZyYW1lIHN1cHBvcnQgd29ya2Fyb3VuZFxuICAgIF90aGlzLmNsb25lSWQgPSBfbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgcGx1Z2luRXZlbnQoJ2Nsb25lJywgX3RoaXMpO1xuICAgICAgaWYgKFNvcnRhYmxlLmV2ZW50Q2FuY2VsZWQpIHJldHVybjtcbiAgICAgIGlmICghX3RoaXMub3B0aW9ucy5yZW1vdmVDbG9uZU9uSGlkZSkge1xuICAgICAgICByb290RWwuaW5zZXJ0QmVmb3JlKGNsb25lRWwsIGRyYWdFbCk7XG4gICAgICB9XG4gICAgICBfdGhpcy5faGlkZUNsb25lKCk7XG4gICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgIHNvcnRhYmxlOiBfdGhpcyxcbiAgICAgICAgbmFtZTogJ2Nsb25lJ1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgIWZhbGxiYWNrICYmIHRvZ2dsZUNsYXNzKGRyYWdFbCwgb3B0aW9ucy5kcmFnQ2xhc3MsIHRydWUpO1xuXG4gICAgLy8gU2V0IHByb3BlciBkcm9wIGV2ZW50c1xuICAgIGlmIChmYWxsYmFjaykge1xuICAgICAgaWdub3JlTmV4dENsaWNrID0gdHJ1ZTtcbiAgICAgIF90aGlzLl9sb29wSWQgPSBzZXRJbnRlcnZhbChfdGhpcy5fZW11bGF0ZURyYWdPdmVyLCA1MCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFVuZG8gd2hhdCB3YXMgc2V0IGluIF9wcmVwYXJlRHJhZ1N0YXJ0IGJlZm9yZSBkcmFnIHN0YXJ0ZWRcbiAgICAgIG9mZihkb2N1bWVudCwgJ21vdXNldXAnLCBfdGhpcy5fb25Ecm9wKTtcbiAgICAgIG9mZihkb2N1bWVudCwgJ3RvdWNoZW5kJywgX3RoaXMuX29uRHJvcCk7XG4gICAgICBvZmYoZG9jdW1lbnQsICd0b3VjaGNhbmNlbCcsIF90aGlzLl9vbkRyb3ApO1xuICAgICAgaWYgKGRhdGFUcmFuc2Zlcikge1xuICAgICAgICBkYXRhVHJhbnNmZXIuZWZmZWN0QWxsb3dlZCA9ICdtb3ZlJztcbiAgICAgICAgb3B0aW9ucy5zZXREYXRhICYmIG9wdGlvbnMuc2V0RGF0YS5jYWxsKF90aGlzLCBkYXRhVHJhbnNmZXIsIGRyYWdFbCk7XG4gICAgICB9XG4gICAgICBvbihkb2N1bWVudCwgJ2Ryb3AnLCBfdGhpcyk7XG5cbiAgICAgIC8vICMxMjc2IGZpeDpcbiAgICAgIGNzcyhkcmFnRWwsICd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlWigwKScpO1xuICAgIH1cbiAgICBhd2FpdGluZ0RyYWdTdGFydGVkID0gdHJ1ZTtcbiAgICBfdGhpcy5fZHJhZ1N0YXJ0SWQgPSBfbmV4dFRpY2soX3RoaXMuX2RyYWdTdGFydGVkLmJpbmQoX3RoaXMsIGZhbGxiYWNrLCBldnQpKTtcbiAgICBvbihkb2N1bWVudCwgJ3NlbGVjdHN0YXJ0JywgX3RoaXMpO1xuICAgIG1vdmVkID0gdHJ1ZTtcbiAgICB3aW5kb3cuZ2V0U2VsZWN0aW9uKCkucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgaWYgKFNhZmFyaSkge1xuICAgICAgY3NzKGRvY3VtZW50LmJvZHksICd1c2VyLXNlbGVjdCcsICdub25lJyk7XG4gICAgfVxuICB9LFxuICAvLyBSZXR1cm5zIHRydWUgLSBpZiBubyBmdXJ0aGVyIGFjdGlvbiBpcyBuZWVkZWQgKGVpdGhlciBpbnNlcnRlZCBvciBhbm90aGVyIGNvbmRpdGlvbilcbiAgX29uRHJhZ092ZXI6IGZ1bmN0aW9uIF9vbkRyYWdPdmVyKCAvKipFdmVudCovZXZ0KSB7XG4gICAgdmFyIGVsID0gdGhpcy5lbCxcbiAgICAgIHRhcmdldCA9IGV2dC50YXJnZXQsXG4gICAgICBkcmFnUmVjdCxcbiAgICAgIHRhcmdldFJlY3QsXG4gICAgICByZXZlcnQsXG4gICAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgZ3JvdXAgPSBvcHRpb25zLmdyb3VwLFxuICAgICAgYWN0aXZlU29ydGFibGUgPSBTb3J0YWJsZS5hY3RpdmUsXG4gICAgICBpc093bmVyID0gYWN0aXZlR3JvdXAgPT09IGdyb3VwLFxuICAgICAgY2FuU29ydCA9IG9wdGlvbnMuc29ydCxcbiAgICAgIGZyb21Tb3J0YWJsZSA9IHB1dFNvcnRhYmxlIHx8IGFjdGl2ZVNvcnRhYmxlLFxuICAgICAgdmVydGljYWwsXG4gICAgICBfdGhpcyA9IHRoaXMsXG4gICAgICBjb21wbGV0ZWRGaXJlZCA9IGZhbHNlO1xuICAgIGlmIChfc2lsZW50KSByZXR1cm47XG4gICAgZnVuY3Rpb24gZHJhZ092ZXJFdmVudChuYW1lLCBleHRyYSkge1xuICAgICAgcGx1Z2luRXZlbnQobmFtZSwgX3RoaXMsIF9vYmplY3RTcHJlYWQyKHtcbiAgICAgICAgZXZ0OiBldnQsXG4gICAgICAgIGlzT3duZXI6IGlzT3duZXIsXG4gICAgICAgIGF4aXM6IHZlcnRpY2FsID8gJ3ZlcnRpY2FsJyA6ICdob3Jpem9udGFsJyxcbiAgICAgICAgcmV2ZXJ0OiByZXZlcnQsXG4gICAgICAgIGRyYWdSZWN0OiBkcmFnUmVjdCxcbiAgICAgICAgdGFyZ2V0UmVjdDogdGFyZ2V0UmVjdCxcbiAgICAgICAgY2FuU29ydDogY2FuU29ydCxcbiAgICAgICAgZnJvbVNvcnRhYmxlOiBmcm9tU29ydGFibGUsXG4gICAgICAgIHRhcmdldDogdGFyZ2V0LFxuICAgICAgICBjb21wbGV0ZWQ6IGNvbXBsZXRlZCxcbiAgICAgICAgb25Nb3ZlOiBmdW5jdGlvbiBvbk1vdmUodGFyZ2V0LCBhZnRlcikge1xuICAgICAgICAgIHJldHVybiBfb25Nb3ZlKHJvb3RFbCwgZWwsIGRyYWdFbCwgZHJhZ1JlY3QsIHRhcmdldCwgZ2V0UmVjdCh0YXJnZXQpLCBldnQsIGFmdGVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2hhbmdlZDogY2hhbmdlZFxuICAgICAgfSwgZXh0cmEpKTtcbiAgICB9XG5cbiAgICAvLyBDYXB0dXJlIGFuaW1hdGlvbiBzdGF0ZVxuICAgIGZ1bmN0aW9uIGNhcHR1cmUoKSB7XG4gICAgICBkcmFnT3ZlckV2ZW50KCdkcmFnT3ZlckFuaW1hdGlvbkNhcHR1cmUnKTtcbiAgICAgIF90aGlzLmNhcHR1cmVBbmltYXRpb25TdGF0ZSgpO1xuICAgICAgaWYgKF90aGlzICE9PSBmcm9tU29ydGFibGUpIHtcbiAgICAgICAgZnJvbVNvcnRhYmxlLmNhcHR1cmVBbmltYXRpb25TdGF0ZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBpbnZvY2F0aW9uIHdoZW4gZHJhZ0VsIGlzIGluc2VydGVkIChvciBjb21wbGV0ZWQpXG4gICAgZnVuY3Rpb24gY29tcGxldGVkKGluc2VydGlvbikge1xuICAgICAgZHJhZ092ZXJFdmVudCgnZHJhZ092ZXJDb21wbGV0ZWQnLCB7XG4gICAgICAgIGluc2VydGlvbjogaW5zZXJ0aW9uXG4gICAgICB9KTtcbiAgICAgIGlmIChpbnNlcnRpb24pIHtcbiAgICAgICAgLy8gQ2xvbmVzIG11c3QgYmUgaGlkZGVuIGJlZm9yZSBmb2xkaW5nIGFuaW1hdGlvbiB0byBjYXB0dXJlIGRyYWdSZWN0QWJzb2x1dGUgcHJvcGVybHlcbiAgICAgICAgaWYgKGlzT3duZXIpIHtcbiAgICAgICAgICBhY3RpdmVTb3J0YWJsZS5faGlkZUNsb25lKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWN0aXZlU29ydGFibGUuX3Nob3dDbG9uZShfdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF90aGlzICE9PSBmcm9tU29ydGFibGUpIHtcbiAgICAgICAgICAvLyBTZXQgZ2hvc3QgY2xhc3MgdG8gbmV3IHNvcnRhYmxlJ3MgZ2hvc3QgY2xhc3NcbiAgICAgICAgICB0b2dnbGVDbGFzcyhkcmFnRWwsIHB1dFNvcnRhYmxlID8gcHV0U29ydGFibGUub3B0aW9ucy5naG9zdENsYXNzIDogYWN0aXZlU29ydGFibGUub3B0aW9ucy5naG9zdENsYXNzLCBmYWxzZSk7XG4gICAgICAgICAgdG9nZ2xlQ2xhc3MoZHJhZ0VsLCBvcHRpb25zLmdob3N0Q2xhc3MsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwdXRTb3J0YWJsZSAhPT0gX3RoaXMgJiYgX3RoaXMgIT09IFNvcnRhYmxlLmFjdGl2ZSkge1xuICAgICAgICAgIHB1dFNvcnRhYmxlID0gX3RoaXM7XG4gICAgICAgIH0gZWxzZSBpZiAoX3RoaXMgPT09IFNvcnRhYmxlLmFjdGl2ZSAmJiBwdXRTb3J0YWJsZSkge1xuICAgICAgICAgIHB1dFNvcnRhYmxlID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEFuaW1hdGlvblxuICAgICAgICBpZiAoZnJvbVNvcnRhYmxlID09PSBfdGhpcykge1xuICAgICAgICAgIF90aGlzLl9pZ25vcmVXaGlsZUFuaW1hdGluZyA9IHRhcmdldDtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5hbmltYXRlQWxsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBkcmFnT3ZlckV2ZW50KCdkcmFnT3ZlckFuaW1hdGlvbkNvbXBsZXRlJyk7XG4gICAgICAgICAgX3RoaXMuX2lnbm9yZVdoaWxlQW5pbWF0aW5nID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChfdGhpcyAhPT0gZnJvbVNvcnRhYmxlKSB7XG4gICAgICAgICAgZnJvbVNvcnRhYmxlLmFuaW1hdGVBbGwoKTtcbiAgICAgICAgICBmcm9tU29ydGFibGUuX2lnbm9yZVdoaWxlQW5pbWF0aW5nID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBOdWxsIGxhc3RUYXJnZXQgaWYgaXQgaXMgbm90IGluc2lkZSBhIHByZXZpb3VzbHkgc3dhcHBlZCBlbGVtZW50XG4gICAgICBpZiAodGFyZ2V0ID09PSBkcmFnRWwgJiYgIWRyYWdFbC5hbmltYXRlZCB8fCB0YXJnZXQgPT09IGVsICYmICF0YXJnZXQuYW5pbWF0ZWQpIHtcbiAgICAgICAgbGFzdFRhcmdldCA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIG5vIGJ1YmJsaW5nIGFuZCBub3QgZmFsbGJhY2tcbiAgICAgIGlmICghb3B0aW9ucy5kcmFnb3ZlckJ1YmJsZSAmJiAhZXZ0LnJvb3RFbCAmJiB0YXJnZXQgIT09IGRvY3VtZW50KSB7XG4gICAgICAgIGRyYWdFbC5wYXJlbnROb2RlW2V4cGFuZG9dLl9pc091dHNpZGVUaGlzRWwoZXZ0LnRhcmdldCk7XG5cbiAgICAgICAgLy8gRG8gbm90IGRldGVjdCBmb3IgZW1wdHkgaW5zZXJ0IGlmIGFscmVhZHkgaW5zZXJ0ZWRcbiAgICAgICAgIWluc2VydGlvbiAmJiBuZWFyZXN0RW1wdHlJbnNlcnREZXRlY3RFdmVudChldnQpO1xuICAgICAgfVxuICAgICAgIW9wdGlvbnMuZHJhZ292ZXJCdWJibGUgJiYgZXZ0LnN0b3BQcm9wYWdhdGlvbiAmJiBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICByZXR1cm4gY29tcGxldGVkRmlyZWQgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIENhbGwgd2hlbiBkcmFnRWwgaGFzIGJlZW4gaW5zZXJ0ZWRcbiAgICBmdW5jdGlvbiBjaGFuZ2VkKCkge1xuICAgICAgbmV3SW5kZXggPSBpbmRleChkcmFnRWwpO1xuICAgICAgbmV3RHJhZ2dhYmxlSW5kZXggPSBpbmRleChkcmFnRWwsIG9wdGlvbnMuZHJhZ2dhYmxlKTtcbiAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgc29ydGFibGU6IF90aGlzLFxuICAgICAgICBuYW1lOiAnY2hhbmdlJyxcbiAgICAgICAgdG9FbDogZWwsXG4gICAgICAgIG5ld0luZGV4OiBuZXdJbmRleCxcbiAgICAgICAgbmV3RHJhZ2dhYmxlSW5kZXg6IG5ld0RyYWdnYWJsZUluZGV4LFxuICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnRcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoZXZ0LnByZXZlbnREZWZhdWx0ICE9PSB2b2lkIDApIHtcbiAgICAgIGV2dC5jYW5jZWxhYmxlICYmIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICB0YXJnZXQgPSBjbG9zZXN0KHRhcmdldCwgb3B0aW9ucy5kcmFnZ2FibGUsIGVsLCB0cnVlKTtcbiAgICBkcmFnT3ZlckV2ZW50KCdkcmFnT3ZlcicpO1xuICAgIGlmIChTb3J0YWJsZS5ldmVudENhbmNlbGVkKSByZXR1cm4gY29tcGxldGVkRmlyZWQ7XG4gICAgaWYgKGRyYWdFbC5jb250YWlucyhldnQudGFyZ2V0KSB8fCB0YXJnZXQuYW5pbWF0ZWQgJiYgdGFyZ2V0LmFuaW1hdGluZ1ggJiYgdGFyZ2V0LmFuaW1hdGluZ1kgfHwgX3RoaXMuX2lnbm9yZVdoaWxlQW5pbWF0aW5nID09PSB0YXJnZXQpIHtcbiAgICAgIHJldHVybiBjb21wbGV0ZWQoZmFsc2UpO1xuICAgIH1cbiAgICBpZ25vcmVOZXh0Q2xpY2sgPSBmYWxzZTtcbiAgICBpZiAoYWN0aXZlU29ydGFibGUgJiYgIW9wdGlvbnMuZGlzYWJsZWQgJiYgKGlzT3duZXIgPyBjYW5Tb3J0IHx8IChyZXZlcnQgPSBwYXJlbnRFbCAhPT0gcm9vdEVsKSAvLyBSZXZlcnRpbmcgaXRlbSBpbnRvIHRoZSBvcmlnaW5hbCBsaXN0XG4gICAgOiBwdXRTb3J0YWJsZSA9PT0gdGhpcyB8fCAodGhpcy5sYXN0UHV0TW9kZSA9IGFjdGl2ZUdyb3VwLmNoZWNrUHVsbCh0aGlzLCBhY3RpdmVTb3J0YWJsZSwgZHJhZ0VsLCBldnQpKSAmJiBncm91cC5jaGVja1B1dCh0aGlzLCBhY3RpdmVTb3J0YWJsZSwgZHJhZ0VsLCBldnQpKSkge1xuICAgICAgdmVydGljYWwgPSB0aGlzLl9nZXREaXJlY3Rpb24oZXZ0LCB0YXJnZXQpID09PSAndmVydGljYWwnO1xuICAgICAgZHJhZ1JlY3QgPSBnZXRSZWN0KGRyYWdFbCk7XG4gICAgICBkcmFnT3ZlckV2ZW50KCdkcmFnT3ZlclZhbGlkJyk7XG4gICAgICBpZiAoU29ydGFibGUuZXZlbnRDYW5jZWxlZCkgcmV0dXJuIGNvbXBsZXRlZEZpcmVkO1xuICAgICAgaWYgKHJldmVydCkge1xuICAgICAgICBwYXJlbnRFbCA9IHJvb3RFbDsgLy8gYWN0dWFsaXphdGlvblxuICAgICAgICBjYXB0dXJlKCk7XG4gICAgICAgIHRoaXMuX2hpZGVDbG9uZSgpO1xuICAgICAgICBkcmFnT3ZlckV2ZW50KCdyZXZlcnQnKTtcbiAgICAgICAgaWYgKCFTb3J0YWJsZS5ldmVudENhbmNlbGVkKSB7XG4gICAgICAgICAgaWYgKG5leHRFbCkge1xuICAgICAgICAgICAgcm9vdEVsLmluc2VydEJlZm9yZShkcmFnRWwsIG5leHRFbCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJvb3RFbC5hcHBlbmRDaGlsZChkcmFnRWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tcGxldGVkKHRydWUpO1xuICAgICAgfVxuICAgICAgdmFyIGVsTGFzdENoaWxkID0gbGFzdENoaWxkKGVsLCBvcHRpb25zLmRyYWdnYWJsZSk7XG4gICAgICBpZiAoIWVsTGFzdENoaWxkIHx8IF9naG9zdElzTGFzdChldnQsIHZlcnRpY2FsLCB0aGlzKSAmJiAhZWxMYXN0Q2hpbGQuYW5pbWF0ZWQpIHtcbiAgICAgICAgLy8gSW5zZXJ0IHRvIGVuZCBvZiBsaXN0XG5cbiAgICAgICAgLy8gSWYgYWxyZWFkeSBhdCBlbmQgb2YgbGlzdDogRG8gbm90IGluc2VydFxuICAgICAgICBpZiAoZWxMYXN0Q2hpbGQgPT09IGRyYWdFbCkge1xuICAgICAgICAgIHJldHVybiBjb21wbGV0ZWQoZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgdGhlcmUgaXMgYSBsYXN0IGVsZW1lbnQsIGl0IGlzIHRoZSB0YXJnZXRcbiAgICAgICAgaWYgKGVsTGFzdENoaWxkICYmIGVsID09PSBldnQudGFyZ2V0KSB7XG4gICAgICAgICAgdGFyZ2V0ID0gZWxMYXN0Q2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgIHRhcmdldFJlY3QgPSBnZXRSZWN0KHRhcmdldCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9vbk1vdmUocm9vdEVsLCBlbCwgZHJhZ0VsLCBkcmFnUmVjdCwgdGFyZ2V0LCB0YXJnZXRSZWN0LCBldnQsICEhdGFyZ2V0KSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBjYXB0dXJlKCk7XG4gICAgICAgICAgaWYgKGVsTGFzdENoaWxkICYmIGVsTGFzdENoaWxkLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICAvLyB0aGUgbGFzdCBkcmFnZ2FibGUgZWxlbWVudCBpcyBub3QgdGhlIGxhc3Qgbm9kZVxuICAgICAgICAgICAgZWwuaW5zZXJ0QmVmb3JlKGRyYWdFbCwgZWxMYXN0Q2hpbGQubmV4dFNpYmxpbmcpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbC5hcHBlbmRDaGlsZChkcmFnRWwpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJlbnRFbCA9IGVsOyAvLyBhY3R1YWxpemF0aW9uXG5cbiAgICAgICAgICBjaGFuZ2VkKCk7XG4gICAgICAgICAgcmV0dXJuIGNvbXBsZXRlZCh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChlbExhc3RDaGlsZCAmJiBfZ2hvc3RJc0ZpcnN0KGV2dCwgdmVydGljYWwsIHRoaXMpKSB7XG4gICAgICAgIC8vIEluc2VydCB0byBzdGFydCBvZiBsaXN0XG4gICAgICAgIHZhciBmaXJzdENoaWxkID0gZ2V0Q2hpbGQoZWwsIDAsIG9wdGlvbnMsIHRydWUpO1xuICAgICAgICBpZiAoZmlyc3RDaGlsZCA9PT0gZHJhZ0VsKSB7XG4gICAgICAgICAgcmV0dXJuIGNvbXBsZXRlZChmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0ID0gZmlyc3RDaGlsZDtcbiAgICAgICAgdGFyZ2V0UmVjdCA9IGdldFJlY3QodGFyZ2V0KTtcbiAgICAgICAgaWYgKF9vbk1vdmUocm9vdEVsLCBlbCwgZHJhZ0VsLCBkcmFnUmVjdCwgdGFyZ2V0LCB0YXJnZXRSZWN0LCBldnQsIGZhbHNlKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICBjYXB0dXJlKCk7XG4gICAgICAgICAgZWwuaW5zZXJ0QmVmb3JlKGRyYWdFbCwgZmlyc3RDaGlsZCk7XG4gICAgICAgICAgcGFyZW50RWwgPSBlbDsgLy8gYWN0dWFsaXphdGlvblxuXG4gICAgICAgICAgY2hhbmdlZCgpO1xuICAgICAgICAgIHJldHVybiBjb21wbGV0ZWQodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGFyZ2V0LnBhcmVudE5vZGUgPT09IGVsKSB7XG4gICAgICAgIHRhcmdldFJlY3QgPSBnZXRSZWN0KHRhcmdldCk7XG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSAwLFxuICAgICAgICAgIHRhcmdldEJlZm9yZUZpcnN0U3dhcCxcbiAgICAgICAgICBkaWZmZXJlbnRMZXZlbCA9IGRyYWdFbC5wYXJlbnROb2RlICE9PSBlbCxcbiAgICAgICAgICBkaWZmZXJlbnRSb3dDb2wgPSAhX2RyYWdFbEluUm93Q29sdW1uKGRyYWdFbC5hbmltYXRlZCAmJiBkcmFnRWwudG9SZWN0IHx8IGRyYWdSZWN0LCB0YXJnZXQuYW5pbWF0ZWQgJiYgdGFyZ2V0LnRvUmVjdCB8fCB0YXJnZXRSZWN0LCB2ZXJ0aWNhbCksXG4gICAgICAgICAgc2lkZTEgPSB2ZXJ0aWNhbCA/ICd0b3AnIDogJ2xlZnQnLFxuICAgICAgICAgIHNjcm9sbGVkUGFzdFRvcCA9IGlzU2Nyb2xsZWRQYXN0KHRhcmdldCwgJ3RvcCcsICd0b3AnKSB8fCBpc1Njcm9sbGVkUGFzdChkcmFnRWwsICd0b3AnLCAndG9wJyksXG4gICAgICAgICAgc2Nyb2xsQmVmb3JlID0gc2Nyb2xsZWRQYXN0VG9wID8gc2Nyb2xsZWRQYXN0VG9wLnNjcm9sbFRvcCA6IHZvaWQgMDtcbiAgICAgICAgaWYgKGxhc3RUYXJnZXQgIT09IHRhcmdldCkge1xuICAgICAgICAgIHRhcmdldEJlZm9yZUZpcnN0U3dhcCA9IHRhcmdldFJlY3Rbc2lkZTFdO1xuICAgICAgICAgIHBhc3RGaXJzdEludmVydFRocmVzaCA9IGZhbHNlO1xuICAgICAgICAgIGlzQ2lyY3Vtc3RhbnRpYWxJbnZlcnQgPSAhZGlmZmVyZW50Um93Q29sICYmIG9wdGlvbnMuaW52ZXJ0U3dhcCB8fCBkaWZmZXJlbnRMZXZlbDtcbiAgICAgICAgfVxuICAgICAgICBkaXJlY3Rpb24gPSBfZ2V0U3dhcERpcmVjdGlvbihldnQsIHRhcmdldCwgdGFyZ2V0UmVjdCwgdmVydGljYWwsIGRpZmZlcmVudFJvd0NvbCA/IDEgOiBvcHRpb25zLnN3YXBUaHJlc2hvbGQsIG9wdGlvbnMuaW52ZXJ0ZWRTd2FwVGhyZXNob2xkID09IG51bGwgPyBvcHRpb25zLnN3YXBUaHJlc2hvbGQgOiBvcHRpb25zLmludmVydGVkU3dhcFRocmVzaG9sZCwgaXNDaXJjdW1zdGFudGlhbEludmVydCwgbGFzdFRhcmdldCA9PT0gdGFyZ2V0KTtcbiAgICAgICAgdmFyIHNpYmxpbmc7XG4gICAgICAgIGlmIChkaXJlY3Rpb24gIT09IDApIHtcbiAgICAgICAgICAvLyBDaGVjayBpZiB0YXJnZXQgaXMgYmVzaWRlIGRyYWdFbCBpbiByZXNwZWN0aXZlIGRpcmVjdGlvbiAoaWdub3JpbmcgaGlkZGVuIGVsZW1lbnRzKVxuICAgICAgICAgIHZhciBkcmFnSW5kZXggPSBpbmRleChkcmFnRWwpO1xuICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgIGRyYWdJbmRleCAtPSBkaXJlY3Rpb247XG4gICAgICAgICAgICBzaWJsaW5nID0gcGFyZW50RWwuY2hpbGRyZW5bZHJhZ0luZGV4XTtcbiAgICAgICAgICB9IHdoaWxlIChzaWJsaW5nICYmIChjc3Moc2libGluZywgJ2Rpc3BsYXknKSA9PT0gJ25vbmUnIHx8IHNpYmxpbmcgPT09IGdob3N0RWwpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBkcmFnRWwgaXMgYWxyZWFkeSBiZXNpZGUgdGFyZ2V0OiBEbyBub3QgaW5zZXJ0XG4gICAgICAgIGlmIChkaXJlY3Rpb24gPT09IDAgfHwgc2libGluZyA9PT0gdGFyZ2V0KSB7XG4gICAgICAgICAgcmV0dXJuIGNvbXBsZXRlZChmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgbGFzdERpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICAgICAgdmFyIG5leHRTaWJsaW5nID0gdGFyZ2V0Lm5leHRFbGVtZW50U2libGluZyxcbiAgICAgICAgICBhZnRlciA9IGZhbHNlO1xuICAgICAgICBhZnRlciA9IGRpcmVjdGlvbiA9PT0gMTtcbiAgICAgICAgdmFyIG1vdmVWZWN0b3IgPSBfb25Nb3ZlKHJvb3RFbCwgZWwsIGRyYWdFbCwgZHJhZ1JlY3QsIHRhcmdldCwgdGFyZ2V0UmVjdCwgZXZ0LCBhZnRlcik7XG4gICAgICAgIGlmIChtb3ZlVmVjdG9yICE9PSBmYWxzZSkge1xuICAgICAgICAgIGlmIChtb3ZlVmVjdG9yID09PSAxIHx8IG1vdmVWZWN0b3IgPT09IC0xKSB7XG4gICAgICAgICAgICBhZnRlciA9IG1vdmVWZWN0b3IgPT09IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIF9zaWxlbnQgPSB0cnVlO1xuICAgICAgICAgIHNldFRpbWVvdXQoX3Vuc2lsZW50LCAzMCk7XG4gICAgICAgICAgY2FwdHVyZSgpO1xuICAgICAgICAgIGlmIChhZnRlciAmJiAhbmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgIGVsLmFwcGVuZENoaWxkKGRyYWdFbCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShkcmFnRWwsIGFmdGVyID8gbmV4dFNpYmxpbmcgOiB0YXJnZXQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFVuZG8gY2hyb21lJ3Mgc2Nyb2xsIGFkanVzdG1lbnQgKGhhcyBubyBlZmZlY3Qgb24gb3RoZXIgYnJvd3NlcnMpXG4gICAgICAgICAgaWYgKHNjcm9sbGVkUGFzdFRvcCkge1xuICAgICAgICAgICAgc2Nyb2xsQnkoc2Nyb2xsZWRQYXN0VG9wLCAwLCBzY3JvbGxCZWZvcmUgLSBzY3JvbGxlZFBhc3RUb3Auc2Nyb2xsVG9wKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGFyZW50RWwgPSBkcmFnRWwucGFyZW50Tm9kZTsgLy8gYWN0dWFsaXphdGlvblxuXG4gICAgICAgICAgLy8gbXVzdCBiZSBkb25lIGJlZm9yZSBhbmltYXRpb25cbiAgICAgICAgICBpZiAodGFyZ2V0QmVmb3JlRmlyc3RTd2FwICE9PSB1bmRlZmluZWQgJiYgIWlzQ2lyY3Vtc3RhbnRpYWxJbnZlcnQpIHtcbiAgICAgICAgICAgIHRhcmdldE1vdmVEaXN0YW5jZSA9IE1hdGguYWJzKHRhcmdldEJlZm9yZUZpcnN0U3dhcCAtIGdldFJlY3QodGFyZ2V0KVtzaWRlMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjaGFuZ2VkKCk7XG4gICAgICAgICAgcmV0dXJuIGNvbXBsZXRlZCh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGVsLmNvbnRhaW5zKGRyYWdFbCkpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBsZXRlZChmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcbiAgX2lnbm9yZVdoaWxlQW5pbWF0aW5nOiBudWxsLFxuICBfb2ZmTW92ZUV2ZW50czogZnVuY3Rpb24gX29mZk1vdmVFdmVudHMoKSB7XG4gICAgb2ZmKGRvY3VtZW50LCAnbW91c2Vtb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUpO1xuICAgIG9mZihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlKTtcbiAgICBvZmYoZG9jdW1lbnQsICdwb2ludGVybW92ZScsIHRoaXMuX29uVG91Y2hNb3ZlKTtcbiAgICBvZmYoZG9jdW1lbnQsICdkcmFnb3ZlcicsIG5lYXJlc3RFbXB0eUluc2VydERldGVjdEV2ZW50KTtcbiAgICBvZmYoZG9jdW1lbnQsICdtb3VzZW1vdmUnLCBuZWFyZXN0RW1wdHlJbnNlcnREZXRlY3RFdmVudCk7XG4gICAgb2ZmKGRvY3VtZW50LCAndG91Y2htb3ZlJywgbmVhcmVzdEVtcHR5SW5zZXJ0RGV0ZWN0RXZlbnQpO1xuICB9LFxuICBfb2ZmVXBFdmVudHM6IGZ1bmN0aW9uIF9vZmZVcEV2ZW50cygpIHtcbiAgICB2YXIgb3duZXJEb2N1bWVudCA9IHRoaXMuZWwub3duZXJEb2N1bWVudDtcbiAgICBvZmYob3duZXJEb2N1bWVudCwgJ21vdXNldXAnLCB0aGlzLl9vbkRyb3ApO1xuICAgIG9mZihvd25lckRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLl9vbkRyb3ApO1xuICAgIG9mZihvd25lckRvY3VtZW50LCAncG9pbnRlcnVwJywgdGhpcy5fb25Ecm9wKTtcbiAgICBvZmYob3duZXJEb2N1bWVudCwgJ3BvaW50ZXJjYW5jZWwnLCB0aGlzLl9vbkRyb3ApO1xuICAgIG9mZihvd25lckRvY3VtZW50LCAndG91Y2hjYW5jZWwnLCB0aGlzLl9vbkRyb3ApO1xuICAgIG9mZihkb2N1bWVudCwgJ3NlbGVjdHN0YXJ0JywgdGhpcyk7XG4gIH0sXG4gIF9vbkRyb3A6IGZ1bmN0aW9uIF9vbkRyb3AoIC8qKkV2ZW50Ki9ldnQpIHtcbiAgICB2YXIgZWwgPSB0aGlzLmVsLFxuICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcblxuICAgIC8vIEdldCB0aGUgaW5kZXggb2YgdGhlIGRyYWdnZWQgZWxlbWVudCB3aXRoaW4gaXRzIHBhcmVudFxuICAgIG5ld0luZGV4ID0gaW5kZXgoZHJhZ0VsKTtcbiAgICBuZXdEcmFnZ2FibGVJbmRleCA9IGluZGV4KGRyYWdFbCwgb3B0aW9ucy5kcmFnZ2FibGUpO1xuICAgIHBsdWdpbkV2ZW50KCdkcm9wJywgdGhpcywge1xuICAgICAgZXZ0OiBldnRcbiAgICB9KTtcbiAgICBwYXJlbnRFbCA9IGRyYWdFbCAmJiBkcmFnRWwucGFyZW50Tm9kZTtcblxuICAgIC8vIEdldCBhZ2FpbiBhZnRlciBwbHVnaW4gZXZlbnRcbiAgICBuZXdJbmRleCA9IGluZGV4KGRyYWdFbCk7XG4gICAgbmV3RHJhZ2dhYmxlSW5kZXggPSBpbmRleChkcmFnRWwsIG9wdGlvbnMuZHJhZ2dhYmxlKTtcbiAgICBpZiAoU29ydGFibGUuZXZlbnRDYW5jZWxlZCkge1xuICAgICAgdGhpcy5fbnVsbGluZygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhd2FpdGluZ0RyYWdTdGFydGVkID0gZmFsc2U7XG4gICAgaXNDaXJjdW1zdGFudGlhbEludmVydCA9IGZhbHNlO1xuICAgIHBhc3RGaXJzdEludmVydFRocmVzaCA9IGZhbHNlO1xuICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fbG9vcElkKTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fZHJhZ1N0YXJ0VGltZXIpO1xuICAgIF9jYW5jZWxOZXh0VGljayh0aGlzLmNsb25lSWQpO1xuICAgIF9jYW5jZWxOZXh0VGljayh0aGlzLl9kcmFnU3RhcnRJZCk7XG5cbiAgICAvLyBVbmJpbmQgZXZlbnRzXG4gICAgaWYgKHRoaXMubmF0aXZlRHJhZ2dhYmxlKSB7XG4gICAgICBvZmYoZG9jdW1lbnQsICdkcm9wJywgdGhpcyk7XG4gICAgICBvZmYoZWwsICdkcmFnc3RhcnQnLCB0aGlzLl9vbkRyYWdTdGFydCk7XG4gICAgfVxuICAgIHRoaXMuX29mZk1vdmVFdmVudHMoKTtcbiAgICB0aGlzLl9vZmZVcEV2ZW50cygpO1xuICAgIGlmIChTYWZhcmkpIHtcbiAgICAgIGNzcyhkb2N1bWVudC5ib2R5LCAndXNlci1zZWxlY3QnLCAnJyk7XG4gICAgfVxuICAgIGNzcyhkcmFnRWwsICd0cmFuc2Zvcm0nLCAnJyk7XG4gICAgaWYgKGV2dCkge1xuICAgICAgaWYgKG1vdmVkKSB7XG4gICAgICAgIGV2dC5jYW5jZWxhYmxlICYmIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAhb3B0aW9ucy5kcm9wQnViYmxlICYmIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH1cbiAgICAgIGdob3N0RWwgJiYgZ2hvc3RFbC5wYXJlbnROb2RlICYmIGdob3N0RWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChnaG9zdEVsKTtcbiAgICAgIGlmIChyb290RWwgPT09IHBhcmVudEVsIHx8IHB1dFNvcnRhYmxlICYmIHB1dFNvcnRhYmxlLmxhc3RQdXRNb2RlICE9PSAnY2xvbmUnKSB7XG4gICAgICAgIC8vIFJlbW92ZSBjbG9uZShzKVxuICAgICAgICBjbG9uZUVsICYmIGNsb25lRWwucGFyZW50Tm9kZSAmJiBjbG9uZUVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2xvbmVFbCk7XG4gICAgICB9XG4gICAgICBpZiAoZHJhZ0VsKSB7XG4gICAgICAgIGlmICh0aGlzLm5hdGl2ZURyYWdnYWJsZSkge1xuICAgICAgICAgIG9mZihkcmFnRWwsICdkcmFnZW5kJywgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgX2Rpc2FibGVEcmFnZ2FibGUoZHJhZ0VsKTtcbiAgICAgICAgZHJhZ0VsLnN0eWxlWyd3aWxsLWNoYW5nZSddID0gJyc7XG5cbiAgICAgICAgLy8gUmVtb3ZlIGNsYXNzZXNcbiAgICAgICAgLy8gZ2hvc3RDbGFzcyBpcyBhZGRlZCBpbiBkcmFnU3RhcnRlZFxuICAgICAgICBpZiAobW92ZWQgJiYgIWF3YWl0aW5nRHJhZ1N0YXJ0ZWQpIHtcbiAgICAgICAgICB0b2dnbGVDbGFzcyhkcmFnRWwsIHB1dFNvcnRhYmxlID8gcHV0U29ydGFibGUub3B0aW9ucy5naG9zdENsYXNzIDogdGhpcy5vcHRpb25zLmdob3N0Q2xhc3MsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICB0b2dnbGVDbGFzcyhkcmFnRWwsIHRoaXMub3B0aW9ucy5jaG9zZW5DbGFzcywgZmFsc2UpO1xuXG4gICAgICAgIC8vIERyYWcgc3RvcCBldmVudFxuICAgICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgc29ydGFibGU6IHRoaXMsXG4gICAgICAgICAgbmFtZTogJ3VuY2hvb3NlJyxcbiAgICAgICAgICB0b0VsOiBwYXJlbnRFbCxcbiAgICAgICAgICBuZXdJbmRleDogbnVsbCxcbiAgICAgICAgICBuZXdEcmFnZ2FibGVJbmRleDogbnVsbCxcbiAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnRcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChyb290RWwgIT09IHBhcmVudEVsKSB7XG4gICAgICAgICAgaWYgKG5ld0luZGV4ID49IDApIHtcbiAgICAgICAgICAgIC8vIEFkZCBldmVudFxuICAgICAgICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgICByb290RWw6IHBhcmVudEVsLFxuICAgICAgICAgICAgICBuYW1lOiAnYWRkJyxcbiAgICAgICAgICAgICAgdG9FbDogcGFyZW50RWwsXG4gICAgICAgICAgICAgIGZyb21FbDogcm9vdEVsLFxuICAgICAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnRcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBSZW1vdmUgZXZlbnRcbiAgICAgICAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICAgICAgc29ydGFibGU6IHRoaXMsXG4gICAgICAgICAgICAgIG5hbWU6ICdyZW1vdmUnLFxuICAgICAgICAgICAgICB0b0VsOiBwYXJlbnRFbCxcbiAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgLy8gZHJhZyBmcm9tIG9uZSBsaXN0IGFuZCBkcm9wIGludG8gYW5vdGhlclxuICAgICAgICAgICAgX2Rpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgICByb290RWw6IHBhcmVudEVsLFxuICAgICAgICAgICAgICBuYW1lOiAnc29ydCcsXG4gICAgICAgICAgICAgIHRvRWw6IHBhcmVudEVsLFxuICAgICAgICAgICAgICBmcm9tRWw6IHJvb3RFbCxcbiAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICAgICAgc29ydGFibGU6IHRoaXMsXG4gICAgICAgICAgICAgIG5hbWU6ICdzb3J0JyxcbiAgICAgICAgICAgICAgdG9FbDogcGFyZW50RWwsXG4gICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHB1dFNvcnRhYmxlICYmIHB1dFNvcnRhYmxlLnNhdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAobmV3SW5kZXggIT09IG9sZEluZGV4KSB7XG4gICAgICAgICAgICBpZiAobmV3SW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAvLyBkcmFnICYgZHJvcCB3aXRoaW4gdGhlIHNhbWUgbGlzdFxuICAgICAgICAgICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICAgICAgc29ydGFibGU6IHRoaXMsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3VwZGF0ZScsXG4gICAgICAgICAgICAgICAgdG9FbDogcGFyZW50RWwsXG4gICAgICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBfZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICAgICAgc29ydGFibGU6IHRoaXMsXG4gICAgICAgICAgICAgICAgbmFtZTogJ3NvcnQnLFxuICAgICAgICAgICAgICAgIHRvRWw6IHBhcmVudEVsLFxuICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFNvcnRhYmxlLmFjdGl2ZSkge1xuICAgICAgICAgIC8qIGpzaGludCBlcW51bGw6dHJ1ZSAqL1xuICAgICAgICAgIGlmIChuZXdJbmRleCA9PSBudWxsIHx8IG5ld0luZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgbmV3SW5kZXggPSBvbGRJbmRleDtcbiAgICAgICAgICAgIG5ld0RyYWdnYWJsZUluZGV4ID0gb2xkRHJhZ2dhYmxlSW5kZXg7XG4gICAgICAgICAgfVxuICAgICAgICAgIF9kaXNwYXRjaEV2ZW50KHtcbiAgICAgICAgICAgIHNvcnRhYmxlOiB0aGlzLFxuICAgICAgICAgICAgbmFtZTogJ2VuZCcsXG4gICAgICAgICAgICB0b0VsOiBwYXJlbnRFbCxcbiAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gU2F2ZSBzb3J0aW5nXG4gICAgICAgICAgdGhpcy5zYXZlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fbnVsbGluZygpO1xuICB9LFxuICBfbnVsbGluZzogZnVuY3Rpb24gX251bGxpbmcoKSB7XG4gICAgcGx1Z2luRXZlbnQoJ251bGxpbmcnLCB0aGlzKTtcbiAgICByb290RWwgPSBkcmFnRWwgPSBwYXJlbnRFbCA9IGdob3N0RWwgPSBuZXh0RWwgPSBjbG9uZUVsID0gbGFzdERvd25FbCA9IGNsb25lSGlkZGVuID0gdGFwRXZ0ID0gdG91Y2hFdnQgPSBtb3ZlZCA9IG5ld0luZGV4ID0gbmV3RHJhZ2dhYmxlSW5kZXggPSBvbGRJbmRleCA9IG9sZERyYWdnYWJsZUluZGV4ID0gbGFzdFRhcmdldCA9IGxhc3REaXJlY3Rpb24gPSBwdXRTb3J0YWJsZSA9IGFjdGl2ZUdyb3VwID0gU29ydGFibGUuZHJhZ2dlZCA9IFNvcnRhYmxlLmdob3N0ID0gU29ydGFibGUuY2xvbmUgPSBTb3J0YWJsZS5hY3RpdmUgPSBudWxsO1xuICAgIHNhdmVkSW5wdXRDaGVja2VkLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICBlbC5jaGVja2VkID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBzYXZlZElucHV0Q2hlY2tlZC5sZW5ndGggPSBsYXN0RHggPSBsYXN0RHkgPSAwO1xuICB9LFxuICBoYW5kbGVFdmVudDogZnVuY3Rpb24gaGFuZGxlRXZlbnQoIC8qKkV2ZW50Ki9ldnQpIHtcbiAgICBzd2l0Y2ggKGV2dC50eXBlKSB7XG4gICAgICBjYXNlICdkcm9wJzpcbiAgICAgIGNhc2UgJ2RyYWdlbmQnOlxuICAgICAgICB0aGlzLl9vbkRyb3AoZXZ0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdkcmFnZW50ZXInOlxuICAgICAgY2FzZSAnZHJhZ292ZXInOlxuICAgICAgICBpZiAoZHJhZ0VsKSB7XG4gICAgICAgICAgdGhpcy5fb25EcmFnT3ZlcihldnQpO1xuICAgICAgICAgIF9nbG9iYWxEcmFnT3ZlcihldnQpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc2VsZWN0c3RhcnQnOlxuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9LFxuICAvKipcclxuICAgKiBTZXJpYWxpemVzIHRoZSBpdGVtIGludG8gYW4gYXJyYXkgb2Ygc3RyaW5nLlxyXG4gICAqIEByZXR1cm5zIHtTdHJpbmdbXX1cclxuICAgKi9cbiAgdG9BcnJheTogZnVuY3Rpb24gdG9BcnJheSgpIHtcbiAgICB2YXIgb3JkZXIgPSBbXSxcbiAgICAgIGVsLFxuICAgICAgY2hpbGRyZW4gPSB0aGlzLmVsLmNoaWxkcmVuLFxuICAgICAgaSA9IDAsXG4gICAgICBuID0gY2hpbGRyZW4ubGVuZ3RoLFxuICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBmb3IgKDsgaSA8IG47IGkrKykge1xuICAgICAgZWwgPSBjaGlsZHJlbltpXTtcbiAgICAgIGlmIChjbG9zZXN0KGVsLCBvcHRpb25zLmRyYWdnYWJsZSwgdGhpcy5lbCwgZmFsc2UpKSB7XG4gICAgICAgIG9yZGVyLnB1c2goZWwuZ2V0QXR0cmlidXRlKG9wdGlvbnMuZGF0YUlkQXR0cikgfHwgX2dlbmVyYXRlSWQoZWwpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9yZGVyO1xuICB9LFxuICAvKipcclxuICAgKiBTb3J0cyB0aGUgZWxlbWVudHMgYWNjb3JkaW5nIHRvIHRoZSBhcnJheS5cclxuICAgKiBAcGFyYW0gIHtTdHJpbmdbXX0gIG9yZGVyICBvcmRlciBvZiB0aGUgaXRlbXNcclxuICAgKi9cbiAgc29ydDogZnVuY3Rpb24gc29ydChvcmRlciwgdXNlQW5pbWF0aW9uKSB7XG4gICAgdmFyIGl0ZW1zID0ge30sXG4gICAgICByb290RWwgPSB0aGlzLmVsO1xuICAgIHRoaXMudG9BcnJheSgpLmZvckVhY2goZnVuY3Rpb24gKGlkLCBpKSB7XG4gICAgICB2YXIgZWwgPSByb290RWwuY2hpbGRyZW5baV07XG4gICAgICBpZiAoY2xvc2VzdChlbCwgdGhpcy5vcHRpb25zLmRyYWdnYWJsZSwgcm9vdEVsLCBmYWxzZSkpIHtcbiAgICAgICAgaXRlbXNbaWRdID0gZWw7XG4gICAgICB9XG4gICAgfSwgdGhpcyk7XG4gICAgdXNlQW5pbWF0aW9uICYmIHRoaXMuY2FwdHVyZUFuaW1hdGlvblN0YXRlKCk7XG4gICAgb3JkZXIuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAgIGlmIChpdGVtc1tpZF0pIHtcbiAgICAgICAgcm9vdEVsLnJlbW92ZUNoaWxkKGl0ZW1zW2lkXSk7XG4gICAgICAgIHJvb3RFbC5hcHBlbmRDaGlsZChpdGVtc1tpZF0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHVzZUFuaW1hdGlvbiAmJiB0aGlzLmFuaW1hdGVBbGwoKTtcbiAgfSxcbiAgLyoqXHJcbiAgICogU2F2ZSB0aGUgY3VycmVudCBzb3J0aW5nXHJcbiAgICovXG4gIHNhdmU6IGZ1bmN0aW9uIHNhdmUoKSB7XG4gICAgdmFyIHN0b3JlID0gdGhpcy5vcHRpb25zLnN0b3JlO1xuICAgIHN0b3JlICYmIHN0b3JlLnNldCAmJiBzdG9yZS5zZXQodGhpcyk7XG4gIH0sXG4gIC8qKlxyXG4gICAqIEZvciBlYWNoIGVsZW1lbnQgaW4gdGhlIHNldCwgZ2V0IHRoZSBmaXJzdCBlbGVtZW50IHRoYXQgbWF0Y2hlcyB0aGUgc2VsZWN0b3IgYnkgdGVzdGluZyB0aGUgZWxlbWVudCBpdHNlbGYgYW5kIHRyYXZlcnNpbmcgdXAgdGhyb3VnaCBpdHMgYW5jZXN0b3JzIGluIHRoZSBET00gdHJlZS5cclxuICAgKiBAcGFyYW0gICB7SFRNTEVsZW1lbnR9ICBlbFxyXG4gICAqIEBwYXJhbSAgIHtTdHJpbmd9ICAgICAgIFtzZWxlY3Rvcl0gIGRlZmF1bHQ6IGBvcHRpb25zLmRyYWdnYWJsZWBcclxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR8bnVsbH1cclxuICAgKi9cbiAgY2xvc2VzdDogZnVuY3Rpb24gY2xvc2VzdCQxKGVsLCBzZWxlY3Rvcikge1xuICAgIHJldHVybiBjbG9zZXN0KGVsLCBzZWxlY3RvciB8fCB0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlLCB0aGlzLmVsLCBmYWxzZSk7XG4gIH0sXG4gIC8qKlxyXG4gICAqIFNldC9nZXQgb3B0aW9uXHJcbiAgICogQHBhcmFtICAge3N0cmluZ30gbmFtZVxyXG4gICAqIEBwYXJhbSAgIHsqfSAgICAgIFt2YWx1ZV1cclxuICAgKiBAcmV0dXJucyB7Kn1cclxuICAgKi9cbiAgb3B0aW9uOiBmdW5jdGlvbiBvcHRpb24obmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIG9wdGlvbnNbbmFtZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBtb2RpZmllZFZhbHVlID0gUGx1Z2luTWFuYWdlci5tb2RpZnlPcHRpb24odGhpcywgbmFtZSwgdmFsdWUpO1xuICAgICAgaWYgKHR5cGVvZiBtb2RpZmllZFZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBvcHRpb25zW25hbWVdID0gbW9kaWZpZWRWYWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdGlvbnNbbmFtZV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChuYW1lID09PSAnZ3JvdXAnKSB7XG4gICAgICAgIF9wcmVwYXJlR3JvdXAob3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICAvKipcclxuICAgKiBEZXN0cm95XHJcbiAgICovXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgcGx1Z2luRXZlbnQoJ2Rlc3Ryb3knLCB0aGlzKTtcbiAgICB2YXIgZWwgPSB0aGlzLmVsO1xuICAgIGVsW2V4cGFuZG9dID0gbnVsbDtcbiAgICBvZmYoZWwsICdtb3VzZWRvd24nLCB0aGlzLl9vblRhcFN0YXJ0KTtcbiAgICBvZmYoZWwsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25UYXBTdGFydCk7XG4gICAgb2ZmKGVsLCAncG9pbnRlcmRvd24nLCB0aGlzLl9vblRhcFN0YXJ0KTtcbiAgICBpZiAodGhpcy5uYXRpdmVEcmFnZ2FibGUpIHtcbiAgICAgIG9mZihlbCwgJ2RyYWdvdmVyJywgdGhpcyk7XG4gICAgICBvZmYoZWwsICdkcmFnZW50ZXInLCB0aGlzKTtcbiAgICB9XG4gICAgLy8gUmVtb3ZlIGRyYWdnYWJsZSBhdHRyaWJ1dGVzXG4gICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChlbC5xdWVyeVNlbGVjdG9yQWxsKCdbZHJhZ2dhYmxlXScpLCBmdW5jdGlvbiAoZWwpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnZHJhZ2dhYmxlJyk7XG4gICAgfSk7XG4gICAgdGhpcy5fb25Ecm9wKCk7XG4gICAgdGhpcy5fZGlzYWJsZURlbGF5ZWREcmFnRXZlbnRzKCk7XG4gICAgc29ydGFibGVzLnNwbGljZShzb3J0YWJsZXMuaW5kZXhPZih0aGlzLmVsKSwgMSk7XG4gICAgdGhpcy5lbCA9IGVsID0gbnVsbDtcbiAgfSxcbiAgX2hpZGVDbG9uZTogZnVuY3Rpb24gX2hpZGVDbG9uZSgpIHtcbiAgICBpZiAoIWNsb25lSGlkZGVuKSB7XG4gICAgICBwbHVnaW5FdmVudCgnaGlkZUNsb25lJywgdGhpcyk7XG4gICAgICBpZiAoU29ydGFibGUuZXZlbnRDYW5jZWxlZCkgcmV0dXJuO1xuICAgICAgY3NzKGNsb25lRWwsICdkaXNwbGF5JywgJ25vbmUnKTtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMucmVtb3ZlQ2xvbmVPbkhpZGUgJiYgY2xvbmVFbC5wYXJlbnROb2RlKSB7XG4gICAgICAgIGNsb25lRWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjbG9uZUVsKTtcbiAgICAgIH1cbiAgICAgIGNsb25lSGlkZGVuID0gdHJ1ZTtcbiAgICB9XG4gIH0sXG4gIF9zaG93Q2xvbmU6IGZ1bmN0aW9uIF9zaG93Q2xvbmUocHV0U29ydGFibGUpIHtcbiAgICBpZiAocHV0U29ydGFibGUubGFzdFB1dE1vZGUgIT09ICdjbG9uZScpIHtcbiAgICAgIHRoaXMuX2hpZGVDbG9uZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY2xvbmVIaWRkZW4pIHtcbiAgICAgIHBsdWdpbkV2ZW50KCdzaG93Q2xvbmUnLCB0aGlzKTtcbiAgICAgIGlmIChTb3J0YWJsZS5ldmVudENhbmNlbGVkKSByZXR1cm47XG5cbiAgICAgIC8vIHNob3cgY2xvbmUgYXQgZHJhZ0VsIG9yIG9yaWdpbmFsIHBvc2l0aW9uXG4gICAgICBpZiAoZHJhZ0VsLnBhcmVudE5vZGUgPT0gcm9vdEVsICYmICF0aGlzLm9wdGlvbnMuZ3JvdXAucmV2ZXJ0Q2xvbmUpIHtcbiAgICAgICAgcm9vdEVsLmluc2VydEJlZm9yZShjbG9uZUVsLCBkcmFnRWwpO1xuICAgICAgfSBlbHNlIGlmIChuZXh0RWwpIHtcbiAgICAgICAgcm9vdEVsLmluc2VydEJlZm9yZShjbG9uZUVsLCBuZXh0RWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdEVsLmFwcGVuZENoaWxkKGNsb25lRWwpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMub3B0aW9ucy5ncm91cC5yZXZlcnRDbG9uZSkge1xuICAgICAgICB0aGlzLmFuaW1hdGUoZHJhZ0VsLCBjbG9uZUVsKTtcbiAgICAgIH1cbiAgICAgIGNzcyhjbG9uZUVsLCAnZGlzcGxheScsICcnKTtcbiAgICAgIGNsb25lSGlkZGVuID0gZmFsc2U7XG4gICAgfVxuICB9XG59O1xuZnVuY3Rpb24gX2dsb2JhbERyYWdPdmVyKCAvKipFdmVudCovZXZ0KSB7XG4gIGlmIChldnQuZGF0YVRyYW5zZmVyKSB7XG4gICAgZXZ0LmRhdGFUcmFuc2Zlci5kcm9wRWZmZWN0ID0gJ21vdmUnO1xuICB9XG4gIGV2dC5jYW5jZWxhYmxlICYmIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xufVxuZnVuY3Rpb24gX29uTW92ZShmcm9tRWwsIHRvRWwsIGRyYWdFbCwgZHJhZ1JlY3QsIHRhcmdldEVsLCB0YXJnZXRSZWN0LCBvcmlnaW5hbEV2ZW50LCB3aWxsSW5zZXJ0QWZ0ZXIpIHtcbiAgdmFyIGV2dCxcbiAgICBzb3J0YWJsZSA9IGZyb21FbFtleHBhbmRvXSxcbiAgICBvbk1vdmVGbiA9IHNvcnRhYmxlLm9wdGlvbnMub25Nb3ZlLFxuICAgIHJldFZhbDtcbiAgLy8gU3VwcG9ydCBmb3IgbmV3IEN1c3RvbUV2ZW50IGZlYXR1cmVcbiAgaWYgKHdpbmRvdy5DdXN0b21FdmVudCAmJiAhSUUxMU9yTGVzcyAmJiAhRWRnZSkge1xuICAgIGV2dCA9IG5ldyBDdXN0b21FdmVudCgnbW92ZScsIHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgZXZ0LmluaXRFdmVudCgnbW92ZScsIHRydWUsIHRydWUpO1xuICB9XG4gIGV2dC50byA9IHRvRWw7XG4gIGV2dC5mcm9tID0gZnJvbUVsO1xuICBldnQuZHJhZ2dlZCA9IGRyYWdFbDtcbiAgZXZ0LmRyYWdnZWRSZWN0ID0gZHJhZ1JlY3Q7XG4gIGV2dC5yZWxhdGVkID0gdGFyZ2V0RWwgfHwgdG9FbDtcbiAgZXZ0LnJlbGF0ZWRSZWN0ID0gdGFyZ2V0UmVjdCB8fCBnZXRSZWN0KHRvRWwpO1xuICBldnQud2lsbEluc2VydEFmdGVyID0gd2lsbEluc2VydEFmdGVyO1xuICBldnQub3JpZ2luYWxFdmVudCA9IG9yaWdpbmFsRXZlbnQ7XG4gIGZyb21FbC5kaXNwYXRjaEV2ZW50KGV2dCk7XG4gIGlmIChvbk1vdmVGbikge1xuICAgIHJldFZhbCA9IG9uTW92ZUZuLmNhbGwoc29ydGFibGUsIGV2dCwgb3JpZ2luYWxFdmVudCk7XG4gIH1cbiAgcmV0dXJuIHJldFZhbDtcbn1cbmZ1bmN0aW9uIF9kaXNhYmxlRHJhZ2dhYmxlKGVsKSB7XG4gIGVsLmRyYWdnYWJsZSA9IGZhbHNlO1xufVxuZnVuY3Rpb24gX3Vuc2lsZW50KCkge1xuICBfc2lsZW50ID0gZmFsc2U7XG59XG5mdW5jdGlvbiBfZ2hvc3RJc0ZpcnN0KGV2dCwgdmVydGljYWwsIHNvcnRhYmxlKSB7XG4gIHZhciBmaXJzdEVsUmVjdCA9IGdldFJlY3QoZ2V0Q2hpbGQoc29ydGFibGUuZWwsIDAsIHNvcnRhYmxlLm9wdGlvbnMsIHRydWUpKTtcbiAgdmFyIGNoaWxkQ29udGFpbmluZ1JlY3QgPSBnZXRDaGlsZENvbnRhaW5pbmdSZWN0RnJvbUVsZW1lbnQoc29ydGFibGUuZWwsIHNvcnRhYmxlLm9wdGlvbnMsIGdob3N0RWwpO1xuICB2YXIgc3BhY2VyID0gMTA7XG4gIHJldHVybiB2ZXJ0aWNhbCA/IGV2dC5jbGllbnRYIDwgY2hpbGRDb250YWluaW5nUmVjdC5sZWZ0IC0gc3BhY2VyIHx8IGV2dC5jbGllbnRZIDwgZmlyc3RFbFJlY3QudG9wICYmIGV2dC5jbGllbnRYIDwgZmlyc3RFbFJlY3QucmlnaHQgOiBldnQuY2xpZW50WSA8IGNoaWxkQ29udGFpbmluZ1JlY3QudG9wIC0gc3BhY2VyIHx8IGV2dC5jbGllbnRZIDwgZmlyc3RFbFJlY3QuYm90dG9tICYmIGV2dC5jbGllbnRYIDwgZmlyc3RFbFJlY3QubGVmdDtcbn1cbmZ1bmN0aW9uIF9naG9zdElzTGFzdChldnQsIHZlcnRpY2FsLCBzb3J0YWJsZSkge1xuICB2YXIgbGFzdEVsUmVjdCA9IGdldFJlY3QobGFzdENoaWxkKHNvcnRhYmxlLmVsLCBzb3J0YWJsZS5vcHRpb25zLmRyYWdnYWJsZSkpO1xuICB2YXIgY2hpbGRDb250YWluaW5nUmVjdCA9IGdldENoaWxkQ29udGFpbmluZ1JlY3RGcm9tRWxlbWVudChzb3J0YWJsZS5lbCwgc29ydGFibGUub3B0aW9ucywgZ2hvc3RFbCk7XG4gIHZhciBzcGFjZXIgPSAxMDtcbiAgcmV0dXJuIHZlcnRpY2FsID8gZXZ0LmNsaWVudFggPiBjaGlsZENvbnRhaW5pbmdSZWN0LnJpZ2h0ICsgc3BhY2VyIHx8IGV2dC5jbGllbnRZID4gbGFzdEVsUmVjdC5ib3R0b20gJiYgZXZ0LmNsaWVudFggPiBsYXN0RWxSZWN0LmxlZnQgOiBldnQuY2xpZW50WSA+IGNoaWxkQ29udGFpbmluZ1JlY3QuYm90dG9tICsgc3BhY2VyIHx8IGV2dC5jbGllbnRYID4gbGFzdEVsUmVjdC5yaWdodCAmJiBldnQuY2xpZW50WSA+IGxhc3RFbFJlY3QudG9wO1xufVxuZnVuY3Rpb24gX2dldFN3YXBEaXJlY3Rpb24oZXZ0LCB0YXJnZXQsIHRhcmdldFJlY3QsIHZlcnRpY2FsLCBzd2FwVGhyZXNob2xkLCBpbnZlcnRlZFN3YXBUaHJlc2hvbGQsIGludmVydFN3YXAsIGlzTGFzdFRhcmdldCkge1xuICB2YXIgbW91c2VPbkF4aXMgPSB2ZXJ0aWNhbCA/IGV2dC5jbGllbnRZIDogZXZ0LmNsaWVudFgsXG4gICAgdGFyZ2V0TGVuZ3RoID0gdmVydGljYWwgPyB0YXJnZXRSZWN0LmhlaWdodCA6IHRhcmdldFJlY3Qud2lkdGgsXG4gICAgdGFyZ2V0UzEgPSB2ZXJ0aWNhbCA/IHRhcmdldFJlY3QudG9wIDogdGFyZ2V0UmVjdC5sZWZ0LFxuICAgIHRhcmdldFMyID0gdmVydGljYWwgPyB0YXJnZXRSZWN0LmJvdHRvbSA6IHRhcmdldFJlY3QucmlnaHQsXG4gICAgaW52ZXJ0ID0gZmFsc2U7XG4gIGlmICghaW52ZXJ0U3dhcCkge1xuICAgIC8vIE5ldmVyIGludmVydCBvciBjcmVhdGUgZHJhZ0VsIHNoYWRvdyB3aGVuIHRhcmdldCBtb3ZlbWVuZXQgY2F1c2VzIG1vdXNlIHRvIG1vdmUgcGFzdCB0aGUgZW5kIG9mIHJlZ3VsYXIgc3dhcFRocmVzaG9sZFxuICAgIGlmIChpc0xhc3RUYXJnZXQgJiYgdGFyZ2V0TW92ZURpc3RhbmNlIDwgdGFyZ2V0TGVuZ3RoICogc3dhcFRocmVzaG9sZCkge1xuICAgICAgLy8gbXVsdGlwbGllZCBvbmx5IGJ5IHN3YXBUaHJlc2hvbGQgYmVjYXVzZSBtb3VzZSB3aWxsIGFscmVhZHkgYmUgaW5zaWRlIHRhcmdldCBieSAoMSAtIHRocmVzaG9sZCkgKiB0YXJnZXRMZW5ndGggLyAyXG4gICAgICAvLyBjaGVjayBpZiBwYXN0IGZpcnN0IGludmVydCB0aHJlc2hvbGQgb24gc2lkZSBvcHBvc2l0ZSBvZiBsYXN0RGlyZWN0aW9uXG4gICAgICBpZiAoIXBhc3RGaXJzdEludmVydFRocmVzaCAmJiAobGFzdERpcmVjdGlvbiA9PT0gMSA/IG1vdXNlT25BeGlzID4gdGFyZ2V0UzEgKyB0YXJnZXRMZW5ndGggKiBpbnZlcnRlZFN3YXBUaHJlc2hvbGQgLyAyIDogbW91c2VPbkF4aXMgPCB0YXJnZXRTMiAtIHRhcmdldExlbmd0aCAqIGludmVydGVkU3dhcFRocmVzaG9sZCAvIDIpKSB7XG4gICAgICAgIC8vIHBhc3QgZmlyc3QgaW52ZXJ0IHRocmVzaG9sZCwgZG8gbm90IHJlc3RyaWN0IGludmVydGVkIHRocmVzaG9sZCB0byBkcmFnRWwgc2hhZG93XG4gICAgICAgIHBhc3RGaXJzdEludmVydFRocmVzaCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoIXBhc3RGaXJzdEludmVydFRocmVzaCkge1xuICAgICAgICAvLyBkcmFnRWwgc2hhZG93ICh0YXJnZXQgbW92ZSBkaXN0YW5jZSBzaGFkb3cpXG4gICAgICAgIGlmIChsYXN0RGlyZWN0aW9uID09PSAxID8gbW91c2VPbkF4aXMgPCB0YXJnZXRTMSArIHRhcmdldE1vdmVEaXN0YW5jZSAvLyBvdmVyIGRyYWdFbCBzaGFkb3dcbiAgICAgICAgOiBtb3VzZU9uQXhpcyA+IHRhcmdldFMyIC0gdGFyZ2V0TW92ZURpc3RhbmNlKSB7XG4gICAgICAgICAgcmV0dXJuIC1sYXN0RGlyZWN0aW9uO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnZlcnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZWd1bGFyXG4gICAgICBpZiAobW91c2VPbkF4aXMgPiB0YXJnZXRTMSArIHRhcmdldExlbmd0aCAqICgxIC0gc3dhcFRocmVzaG9sZCkgLyAyICYmIG1vdXNlT25BeGlzIDwgdGFyZ2V0UzIgLSB0YXJnZXRMZW5ndGggKiAoMSAtIHN3YXBUaHJlc2hvbGQpIC8gMikge1xuICAgICAgICByZXR1cm4gX2dldEluc2VydERpcmVjdGlvbih0YXJnZXQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpbnZlcnQgPSBpbnZlcnQgfHwgaW52ZXJ0U3dhcDtcbiAgaWYgKGludmVydCkge1xuICAgIC8vIEludmVydCBvZiByZWd1bGFyXG4gICAgaWYgKG1vdXNlT25BeGlzIDwgdGFyZ2V0UzEgKyB0YXJnZXRMZW5ndGggKiBpbnZlcnRlZFN3YXBUaHJlc2hvbGQgLyAyIHx8IG1vdXNlT25BeGlzID4gdGFyZ2V0UzIgLSB0YXJnZXRMZW5ndGggKiBpbnZlcnRlZFN3YXBUaHJlc2hvbGQgLyAyKSB7XG4gICAgICByZXR1cm4gbW91c2VPbkF4aXMgPiB0YXJnZXRTMSArIHRhcmdldExlbmd0aCAvIDIgPyAxIDogLTE7XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufVxuXG4vKipcclxuICogR2V0cyB0aGUgZGlyZWN0aW9uIGRyYWdFbCBtdXN0IGJlIHN3YXBwZWQgcmVsYXRpdmUgdG8gdGFyZ2V0IGluIG9yZGVyIHRvIG1ha2UgaXRcclxuICogc2VlbSB0aGF0IGRyYWdFbCBoYXMgYmVlbiBcImluc2VydGVkXCIgaW50byB0aGF0IGVsZW1lbnQncyBwb3NpdGlvblxyXG4gKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gdGFyZ2V0ICAgICAgIFRoZSB0YXJnZXQgd2hvc2UgcG9zaXRpb24gZHJhZ0VsIGlzIGJlaW5nIGluc2VydGVkIGF0XHJcbiAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICAgICAgICAgICAgRGlyZWN0aW9uIGRyYWdFbCBtdXN0IGJlIHN3YXBwZWRcclxuICovXG5mdW5jdGlvbiBfZ2V0SW5zZXJ0RGlyZWN0aW9uKHRhcmdldCkge1xuICBpZiAoaW5kZXgoZHJhZ0VsKSA8IGluZGV4KHRhcmdldCkpIHtcbiAgICByZXR1cm4gMTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbn1cblxuLyoqXHJcbiAqIEdlbmVyYXRlIGlkXHJcbiAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gZWxcclxuICogQHJldHVybnMge1N0cmluZ31cclxuICogQHByaXZhdGVcclxuICovXG5mdW5jdGlvbiBfZ2VuZXJhdGVJZChlbCkge1xuICB2YXIgc3RyID0gZWwudGFnTmFtZSArIGVsLmNsYXNzTmFtZSArIGVsLnNyYyArIGVsLmhyZWYgKyBlbC50ZXh0Q29udGVudCxcbiAgICBpID0gc3RyLmxlbmd0aCxcbiAgICBzdW0gPSAwO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgc3VtICs9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICB9XG4gIHJldHVybiBzdW0udG9TdHJpbmcoMzYpO1xufVxuZnVuY3Rpb24gX3NhdmVJbnB1dENoZWNrZWRTdGF0ZShyb290KSB7XG4gIHNhdmVkSW5wdXRDaGVja2VkLmxlbmd0aCA9IDA7XG4gIHZhciBpbnB1dHMgPSByb290LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdpbnB1dCcpO1xuICB2YXIgaWR4ID0gaW5wdXRzLmxlbmd0aDtcbiAgd2hpbGUgKGlkeC0tKSB7XG4gICAgdmFyIGVsID0gaW5wdXRzW2lkeF07XG4gICAgZWwuY2hlY2tlZCAmJiBzYXZlZElucHV0Q2hlY2tlZC5wdXNoKGVsKTtcbiAgfVxufVxuZnVuY3Rpb24gX25leHRUaWNrKGZuKSB7XG4gIHJldHVybiBzZXRUaW1lb3V0KGZuLCAwKTtcbn1cbmZ1bmN0aW9uIF9jYW5jZWxOZXh0VGljayhpZCkge1xuICByZXR1cm4gY2xlYXJUaW1lb3V0KGlkKTtcbn1cblxuLy8gRml4ZWQgIzk3MzpcbmlmIChkb2N1bWVudEV4aXN0cykge1xuICBvbihkb2N1bWVudCwgJ3RvdWNobW92ZScsIGZ1bmN0aW9uIChldnQpIHtcbiAgICBpZiAoKFNvcnRhYmxlLmFjdGl2ZSB8fCBhd2FpdGluZ0RyYWdTdGFydGVkKSAmJiBldnQuY2FuY2VsYWJsZSkge1xuICAgICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gRXhwb3J0IHV0aWxzXG5Tb3J0YWJsZS51dGlscyA9IHtcbiAgb246IG9uLFxuICBvZmY6IG9mZixcbiAgY3NzOiBjc3MsXG4gIGZpbmQ6IGZpbmQsXG4gIGlzOiBmdW5jdGlvbiBpcyhlbCwgc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gISFjbG9zZXN0KGVsLCBzZWxlY3RvciwgZWwsIGZhbHNlKTtcbiAgfSxcbiAgZXh0ZW5kOiBleHRlbmQsXG4gIHRocm90dGxlOiB0aHJvdHRsZSxcbiAgY2xvc2VzdDogY2xvc2VzdCxcbiAgdG9nZ2xlQ2xhc3M6IHRvZ2dsZUNsYXNzLFxuICBjbG9uZTogY2xvbmUsXG4gIGluZGV4OiBpbmRleCxcbiAgbmV4dFRpY2s6IF9uZXh0VGljayxcbiAgY2FuY2VsTmV4dFRpY2s6IF9jYW5jZWxOZXh0VGljayxcbiAgZGV0ZWN0RGlyZWN0aW9uOiBfZGV0ZWN0RGlyZWN0aW9uLFxuICBnZXRDaGlsZDogZ2V0Q2hpbGQsXG4gIGV4cGFuZG86IGV4cGFuZG9cbn07XG5cbi8qKlxyXG4gKiBHZXQgdGhlIFNvcnRhYmxlIGluc3RhbmNlIG9mIGFuIGVsZW1lbnRcclxuICogQHBhcmFtICB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnRcclxuICogQHJldHVybiB7U29ydGFibGV8dW5kZWZpbmVkfSAgICAgICAgIFRoZSBpbnN0YW5jZSBvZiBTb3J0YWJsZVxyXG4gKi9cblNvcnRhYmxlLmdldCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50W2V4cGFuZG9dO1xufTtcblxuLyoqXHJcbiAqIE1vdW50IGEgcGx1Z2luIHRvIFNvcnRhYmxlXHJcbiAqIEBwYXJhbSAgey4uLlNvcnRhYmxlUGx1Z2lufFNvcnRhYmxlUGx1Z2luW119IHBsdWdpbnMgICAgICAgUGx1Z2lucyBiZWluZyBtb3VudGVkXHJcbiAqL1xuU29ydGFibGUubW91bnQgPSBmdW5jdGlvbiAoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBwbHVnaW5zID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHBsdWdpbnNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cbiAgaWYgKHBsdWdpbnNbMF0uY29uc3RydWN0b3IgPT09IEFycmF5KSBwbHVnaW5zID0gcGx1Z2luc1swXTtcbiAgcGx1Z2lucy5mb3JFYWNoKGZ1bmN0aW9uIChwbHVnaW4pIHtcbiAgICBpZiAoIXBsdWdpbi5wcm90b3R5cGUgfHwgIXBsdWdpbi5wcm90b3R5cGUuY29uc3RydWN0b3IpIHtcbiAgICAgIHRocm93IFwiU29ydGFibGU6IE1vdW50ZWQgcGx1Z2luIG11c3QgYmUgYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiwgbm90IFwiLmNvbmNhdCh7fS50b1N0cmluZy5jYWxsKHBsdWdpbikpO1xuICAgIH1cbiAgICBpZiAocGx1Z2luLnV0aWxzKSBTb3J0YWJsZS51dGlscyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBTb3J0YWJsZS51dGlscyksIHBsdWdpbi51dGlscyk7XG4gICAgUGx1Z2luTWFuYWdlci5tb3VudChwbHVnaW4pO1xuICB9KTtcbn07XG5cbi8qKlxyXG4gKiBDcmVhdGUgc29ydGFibGUgaW5zdGFuY2VcclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gIGVsXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSAgICAgIFtvcHRpb25zXVxyXG4gKi9cblNvcnRhYmxlLmNyZWF0ZSA9IGZ1bmN0aW9uIChlbCwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IFNvcnRhYmxlKGVsLCBvcHRpb25zKTtcbn07XG5cbi8vIEV4cG9ydFxuU29ydGFibGUudmVyc2lvbiA9IHZlcnNpb247XG5cbnZhciBhdXRvU2Nyb2xscyA9IFtdLFxuICBzY3JvbGxFbCxcbiAgc2Nyb2xsUm9vdEVsLFxuICBzY3JvbGxpbmcgPSBmYWxzZSxcbiAgbGFzdEF1dG9TY3JvbGxYLFxuICBsYXN0QXV0b1Njcm9sbFksXG4gIHRvdWNoRXZ0JDEsXG4gIHBvaW50ZXJFbGVtQ2hhbmdlZEludGVydmFsO1xuZnVuY3Rpb24gQXV0b1Njcm9sbFBsdWdpbigpIHtcbiAgZnVuY3Rpb24gQXV0b1Njcm9sbCgpIHtcbiAgICB0aGlzLmRlZmF1bHRzID0ge1xuICAgICAgc2Nyb2xsOiB0cnVlLFxuICAgICAgZm9yY2VBdXRvU2Nyb2xsRmFsbGJhY2s6IGZhbHNlLFxuICAgICAgc2Nyb2xsU2Vuc2l0aXZpdHk6IDMwLFxuICAgICAgc2Nyb2xsU3BlZWQ6IDEwLFxuICAgICAgYnViYmxlU2Nyb2xsOiB0cnVlXG4gICAgfTtcblxuICAgIC8vIEJpbmQgYWxsIHByaXZhdGUgbWV0aG9kc1xuICAgIGZvciAodmFyIGZuIGluIHRoaXMpIHtcbiAgICAgIGlmIChmbi5jaGFyQXQoMCkgPT09ICdfJyAmJiB0eXBlb2YgdGhpc1tmbl0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpc1tmbl0gPSB0aGlzW2ZuXS5iaW5kKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBBdXRvU2Nyb2xsLnByb3RvdHlwZSA9IHtcbiAgICBkcmFnU3RhcnRlZDogZnVuY3Rpb24gZHJhZ1N0YXJ0ZWQoX3JlZikge1xuICAgICAgdmFyIG9yaWdpbmFsRXZlbnQgPSBfcmVmLm9yaWdpbmFsRXZlbnQ7XG4gICAgICBpZiAodGhpcy5zb3J0YWJsZS5uYXRpdmVEcmFnZ2FibGUpIHtcbiAgICAgICAgb24oZG9jdW1lbnQsICdkcmFnb3ZlcicsIHRoaXMuX2hhbmRsZUF1dG9TY3JvbGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdXBwb3J0UG9pbnRlcikge1xuICAgICAgICAgIG9uKGRvY3VtZW50LCAncG9pbnRlcm1vdmUnLCB0aGlzLl9oYW5kbGVGYWxsYmFja0F1dG9TY3JvbGwpO1xuICAgICAgICB9IGVsc2UgaWYgKG9yaWdpbmFsRXZlbnQudG91Y2hlcykge1xuICAgICAgICAgIG9uKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5faGFuZGxlRmFsbGJhY2tBdXRvU2Nyb2xsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvbihkb2N1bWVudCwgJ21vdXNlbW92ZScsIHRoaXMuX2hhbmRsZUZhbGxiYWNrQXV0b1Njcm9sbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGRyYWdPdmVyQ29tcGxldGVkOiBmdW5jdGlvbiBkcmFnT3ZlckNvbXBsZXRlZChfcmVmMikge1xuICAgICAgdmFyIG9yaWdpbmFsRXZlbnQgPSBfcmVmMi5vcmlnaW5hbEV2ZW50O1xuICAgICAgLy8gRm9yIHdoZW4gYnViYmxpbmcgaXMgY2FuY2VsZWQgYW5kIHVzaW5nIGZhbGxiYWNrIChmYWxsYmFjayAndG91Y2htb3ZlJyBhbHdheXMgcmVhY2hlZClcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLmRyYWdPdmVyQnViYmxlICYmICFvcmlnaW5hbEV2ZW50LnJvb3RFbCkge1xuICAgICAgICB0aGlzLl9oYW5kbGVBdXRvU2Nyb2xsKG9yaWdpbmFsRXZlbnQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZHJvcDogZnVuY3Rpb24gZHJvcCgpIHtcbiAgICAgIGlmICh0aGlzLnNvcnRhYmxlLm5hdGl2ZURyYWdnYWJsZSkge1xuICAgICAgICBvZmYoZG9jdW1lbnQsICdkcmFnb3ZlcicsIHRoaXMuX2hhbmRsZUF1dG9TY3JvbGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2ZmKGRvY3VtZW50LCAncG9pbnRlcm1vdmUnLCB0aGlzLl9oYW5kbGVGYWxsYmFja0F1dG9TY3JvbGwpO1xuICAgICAgICBvZmYoZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9oYW5kbGVGYWxsYmFja0F1dG9TY3JvbGwpO1xuICAgICAgICBvZmYoZG9jdW1lbnQsICdtb3VzZW1vdmUnLCB0aGlzLl9oYW5kbGVGYWxsYmFja0F1dG9TY3JvbGwpO1xuICAgICAgfVxuICAgICAgY2xlYXJQb2ludGVyRWxlbUNoYW5nZWRJbnRlcnZhbCgpO1xuICAgICAgY2xlYXJBdXRvU2Nyb2xscygpO1xuICAgICAgY2FuY2VsVGhyb3R0bGUoKTtcbiAgICB9LFxuICAgIG51bGxpbmc6IGZ1bmN0aW9uIG51bGxpbmcoKSB7XG4gICAgICB0b3VjaEV2dCQxID0gc2Nyb2xsUm9vdEVsID0gc2Nyb2xsRWwgPSBzY3JvbGxpbmcgPSBwb2ludGVyRWxlbUNoYW5nZWRJbnRlcnZhbCA9IGxhc3RBdXRvU2Nyb2xsWCA9IGxhc3RBdXRvU2Nyb2xsWSA9IG51bGw7XG4gICAgICBhdXRvU2Nyb2xscy5sZW5ndGggPSAwO1xuICAgIH0sXG4gICAgX2hhbmRsZUZhbGxiYWNrQXV0b1Njcm9sbDogZnVuY3Rpb24gX2hhbmRsZUZhbGxiYWNrQXV0b1Njcm9sbChldnQpIHtcbiAgICAgIHRoaXMuX2hhbmRsZUF1dG9TY3JvbGwoZXZ0LCB0cnVlKTtcbiAgICB9LFxuICAgIF9oYW5kbGVBdXRvU2Nyb2xsOiBmdW5jdGlvbiBfaGFuZGxlQXV0b1Njcm9sbChldnQsIGZhbGxiYWNrKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdmFyIHggPSAoZXZ0LnRvdWNoZXMgPyBldnQudG91Y2hlc1swXSA6IGV2dCkuY2xpZW50WCxcbiAgICAgICAgeSA9IChldnQudG91Y2hlcyA/IGV2dC50b3VjaGVzWzBdIDogZXZ0KS5jbGllbnRZLFxuICAgICAgICBlbGVtID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludCh4LCB5KTtcbiAgICAgIHRvdWNoRXZ0JDEgPSBldnQ7XG5cbiAgICAgIC8vIElFIGRvZXMgbm90IHNlZW0gdG8gaGF2ZSBuYXRpdmUgYXV0b3Njcm9sbCxcbiAgICAgIC8vIEVkZ2UncyBhdXRvc2Nyb2xsIHNlZW1zIHRvbyBjb25kaXRpb25hbCxcbiAgICAgIC8vIE1BQ09TIFNhZmFyaSBkb2VzIG5vdCBoYXZlIGF1dG9zY3JvbGwsXG4gICAgICAvLyBGaXJlZm94IGFuZCBDaHJvbWUgYXJlIGdvb2RcbiAgICAgIGlmIChmYWxsYmFjayB8fCB0aGlzLm9wdGlvbnMuZm9yY2VBdXRvU2Nyb2xsRmFsbGJhY2sgfHwgRWRnZSB8fCBJRTExT3JMZXNzIHx8IFNhZmFyaSkge1xuICAgICAgICBhdXRvU2Nyb2xsKGV2dCwgdGhpcy5vcHRpb25zLCBlbGVtLCBmYWxsYmFjayk7XG5cbiAgICAgICAgLy8gTGlzdGVuZXIgZm9yIHBvaW50ZXIgZWxlbWVudCBjaGFuZ2VcbiAgICAgICAgdmFyIG9nRWxlbVNjcm9sbGVyID0gZ2V0UGFyZW50QXV0b1Njcm9sbEVsZW1lbnQoZWxlbSwgdHJ1ZSk7XG4gICAgICAgIGlmIChzY3JvbGxpbmcgJiYgKCFwb2ludGVyRWxlbUNoYW5nZWRJbnRlcnZhbCB8fCB4ICE9PSBsYXN0QXV0b1Njcm9sbFggfHwgeSAhPT0gbGFzdEF1dG9TY3JvbGxZKSkge1xuICAgICAgICAgIHBvaW50ZXJFbGVtQ2hhbmdlZEludGVydmFsICYmIGNsZWFyUG9pbnRlckVsZW1DaGFuZ2VkSW50ZXJ2YWwoKTtcbiAgICAgICAgICAvLyBEZXRlY3QgZm9yIHBvaW50ZXIgZWxlbSBjaGFuZ2UsIGVtdWxhdGluZyBuYXRpdmUgRG5EIGJlaGF2aW91clxuICAgICAgICAgIHBvaW50ZXJFbGVtQ2hhbmdlZEludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG5ld0VsZW0gPSBnZXRQYXJlbnRBdXRvU2Nyb2xsRWxlbWVudChkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KHgsIHkpLCB0cnVlKTtcbiAgICAgICAgICAgIGlmIChuZXdFbGVtICE9PSBvZ0VsZW1TY3JvbGxlcikge1xuICAgICAgICAgICAgICBvZ0VsZW1TY3JvbGxlciA9IG5ld0VsZW07XG4gICAgICAgICAgICAgIGNsZWFyQXV0b1Njcm9sbHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF1dG9TY3JvbGwoZXZ0LCBfdGhpcy5vcHRpb25zLCBuZXdFbGVtLCBmYWxsYmFjayk7XG4gICAgICAgICAgfSwgMTApO1xuICAgICAgICAgIGxhc3RBdXRvU2Nyb2xsWCA9IHg7XG4gICAgICAgICAgbGFzdEF1dG9TY3JvbGxZID0geTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaWYgRG5EIGlzIGVuYWJsZWQgKGFuZCBicm93c2VyIGhhcyBnb29kIGF1dG9zY3JvbGxpbmcpLCBmaXJzdCBhdXRvc2Nyb2xsIHdpbGwgYWxyZWFkeSBzY3JvbGwsIHNvIGdldCBwYXJlbnQgYXV0b3Njcm9sbCBvZiBmaXJzdCBhdXRvc2Nyb2xsXG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmJ1YmJsZVNjcm9sbCB8fCBnZXRQYXJlbnRBdXRvU2Nyb2xsRWxlbWVudChlbGVtLCB0cnVlKSA9PT0gZ2V0V2luZG93U2Nyb2xsaW5nRWxlbWVudCgpKSB7XG4gICAgICAgICAgY2xlYXJBdXRvU2Nyb2xscygpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBhdXRvU2Nyb2xsKGV2dCwgdGhpcy5vcHRpb25zLCBnZXRQYXJlbnRBdXRvU2Nyb2xsRWxlbWVudChlbGVtLCBmYWxzZSksIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiBfZXh0ZW5kcyhBdXRvU2Nyb2xsLCB7XG4gICAgcGx1Z2luTmFtZTogJ3Njcm9sbCcsXG4gICAgaW5pdGlhbGl6ZUJ5RGVmYXVsdDogdHJ1ZVxuICB9KTtcbn1cbmZ1bmN0aW9uIGNsZWFyQXV0b1Njcm9sbHMoKSB7XG4gIGF1dG9TY3JvbGxzLmZvckVhY2goZnVuY3Rpb24gKGF1dG9TY3JvbGwpIHtcbiAgICBjbGVhckludGVydmFsKGF1dG9TY3JvbGwucGlkKTtcbiAgfSk7XG4gIGF1dG9TY3JvbGxzID0gW107XG59XG5mdW5jdGlvbiBjbGVhclBvaW50ZXJFbGVtQ2hhbmdlZEludGVydmFsKCkge1xuICBjbGVhckludGVydmFsKHBvaW50ZXJFbGVtQ2hhbmdlZEludGVydmFsKTtcbn1cbnZhciBhdXRvU2Nyb2xsID0gdGhyb3R0bGUoZnVuY3Rpb24gKGV2dCwgb3B0aW9ucywgcm9vdEVsLCBpc0ZhbGxiYWNrKSB7XG4gIC8vIEJ1ZzogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NTA1NTIxXG4gIGlmICghb3B0aW9ucy5zY3JvbGwpIHJldHVybjtcbiAgdmFyIHggPSAoZXZ0LnRvdWNoZXMgPyBldnQudG91Y2hlc1swXSA6IGV2dCkuY2xpZW50WCxcbiAgICB5ID0gKGV2dC50b3VjaGVzID8gZXZ0LnRvdWNoZXNbMF0gOiBldnQpLmNsaWVudFksXG4gICAgc2VucyA9IG9wdGlvbnMuc2Nyb2xsU2Vuc2l0aXZpdHksXG4gICAgc3BlZWQgPSBvcHRpb25zLnNjcm9sbFNwZWVkLFxuICAgIHdpblNjcm9sbGVyID0gZ2V0V2luZG93U2Nyb2xsaW5nRWxlbWVudCgpO1xuICB2YXIgc2Nyb2xsVGhpc0luc3RhbmNlID0gZmFsc2UsXG4gICAgc2Nyb2xsQ3VzdG9tRm47XG5cbiAgLy8gTmV3IHNjcm9sbCByb290LCBzZXQgc2Nyb2xsRWxcbiAgaWYgKHNjcm9sbFJvb3RFbCAhPT0gcm9vdEVsKSB7XG4gICAgc2Nyb2xsUm9vdEVsID0gcm9vdEVsO1xuICAgIGNsZWFyQXV0b1Njcm9sbHMoKTtcbiAgICBzY3JvbGxFbCA9IG9wdGlvbnMuc2Nyb2xsO1xuICAgIHNjcm9sbEN1c3RvbUZuID0gb3B0aW9ucy5zY3JvbGxGbjtcbiAgICBpZiAoc2Nyb2xsRWwgPT09IHRydWUpIHtcbiAgICAgIHNjcm9sbEVsID0gZ2V0UGFyZW50QXV0b1Njcm9sbEVsZW1lbnQocm9vdEVsLCB0cnVlKTtcbiAgICB9XG4gIH1cbiAgdmFyIGxheWVyc091dCA9IDA7XG4gIHZhciBjdXJyZW50UGFyZW50ID0gc2Nyb2xsRWw7XG4gIGRvIHtcbiAgICB2YXIgZWwgPSBjdXJyZW50UGFyZW50LFxuICAgICAgcmVjdCA9IGdldFJlY3QoZWwpLFxuICAgICAgdG9wID0gcmVjdC50b3AsXG4gICAgICBib3R0b20gPSByZWN0LmJvdHRvbSxcbiAgICAgIGxlZnQgPSByZWN0LmxlZnQsXG4gICAgICByaWdodCA9IHJlY3QucmlnaHQsXG4gICAgICB3aWR0aCA9IHJlY3Qud2lkdGgsXG4gICAgICBoZWlnaHQgPSByZWN0LmhlaWdodCxcbiAgICAgIGNhblNjcm9sbFggPSB2b2lkIDAsXG4gICAgICBjYW5TY3JvbGxZID0gdm9pZCAwLFxuICAgICAgc2Nyb2xsV2lkdGggPSBlbC5zY3JvbGxXaWR0aCxcbiAgICAgIHNjcm9sbEhlaWdodCA9IGVsLnNjcm9sbEhlaWdodCxcbiAgICAgIGVsQ1NTID0gY3NzKGVsKSxcbiAgICAgIHNjcm9sbFBvc1ggPSBlbC5zY3JvbGxMZWZ0LFxuICAgICAgc2Nyb2xsUG9zWSA9IGVsLnNjcm9sbFRvcDtcbiAgICBpZiAoZWwgPT09IHdpblNjcm9sbGVyKSB7XG4gICAgICBjYW5TY3JvbGxYID0gd2lkdGggPCBzY3JvbGxXaWR0aCAmJiAoZWxDU1Mub3ZlcmZsb3dYID09PSAnYXV0bycgfHwgZWxDU1Mub3ZlcmZsb3dYID09PSAnc2Nyb2xsJyB8fCBlbENTUy5vdmVyZmxvd1ggPT09ICd2aXNpYmxlJyk7XG4gICAgICBjYW5TY3JvbGxZID0gaGVpZ2h0IDwgc2Nyb2xsSGVpZ2h0ICYmIChlbENTUy5vdmVyZmxvd1kgPT09ICdhdXRvJyB8fCBlbENTUy5vdmVyZmxvd1kgPT09ICdzY3JvbGwnIHx8IGVsQ1NTLm92ZXJmbG93WSA9PT0gJ3Zpc2libGUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FuU2Nyb2xsWCA9IHdpZHRoIDwgc2Nyb2xsV2lkdGggJiYgKGVsQ1NTLm92ZXJmbG93WCA9PT0gJ2F1dG8nIHx8IGVsQ1NTLm92ZXJmbG93WCA9PT0gJ3Njcm9sbCcpO1xuICAgICAgY2FuU2Nyb2xsWSA9IGhlaWdodCA8IHNjcm9sbEhlaWdodCAmJiAoZWxDU1Mub3ZlcmZsb3dZID09PSAnYXV0bycgfHwgZWxDU1Mub3ZlcmZsb3dZID09PSAnc2Nyb2xsJyk7XG4gICAgfVxuICAgIHZhciB2eCA9IGNhblNjcm9sbFggJiYgKE1hdGguYWJzKHJpZ2h0IC0geCkgPD0gc2VucyAmJiBzY3JvbGxQb3NYICsgd2lkdGggPCBzY3JvbGxXaWR0aCkgLSAoTWF0aC5hYnMobGVmdCAtIHgpIDw9IHNlbnMgJiYgISFzY3JvbGxQb3NYKTtcbiAgICB2YXIgdnkgPSBjYW5TY3JvbGxZICYmIChNYXRoLmFicyhib3R0b20gLSB5KSA8PSBzZW5zICYmIHNjcm9sbFBvc1kgKyBoZWlnaHQgPCBzY3JvbGxIZWlnaHQpIC0gKE1hdGguYWJzKHRvcCAtIHkpIDw9IHNlbnMgJiYgISFzY3JvbGxQb3NZKTtcbiAgICBpZiAoIWF1dG9TY3JvbGxzW2xheWVyc091dF0pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IGxheWVyc091dDsgaSsrKSB7XG4gICAgICAgIGlmICghYXV0b1Njcm9sbHNbaV0pIHtcbiAgICAgICAgICBhdXRvU2Nyb2xsc1tpXSA9IHt9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhdXRvU2Nyb2xsc1tsYXllcnNPdXRdLnZ4ICE9IHZ4IHx8IGF1dG9TY3JvbGxzW2xheWVyc091dF0udnkgIT0gdnkgfHwgYXV0b1Njcm9sbHNbbGF5ZXJzT3V0XS5lbCAhPT0gZWwpIHtcbiAgICAgIGF1dG9TY3JvbGxzW2xheWVyc091dF0uZWwgPSBlbDtcbiAgICAgIGF1dG9TY3JvbGxzW2xheWVyc091dF0udnggPSB2eDtcbiAgICAgIGF1dG9TY3JvbGxzW2xheWVyc091dF0udnkgPSB2eTtcbiAgICAgIGNsZWFySW50ZXJ2YWwoYXV0b1Njcm9sbHNbbGF5ZXJzT3V0XS5waWQpO1xuICAgICAgaWYgKHZ4ICE9IDAgfHwgdnkgIT0gMCkge1xuICAgICAgICBzY3JvbGxUaGlzSW5zdGFuY2UgPSB0cnVlO1xuICAgICAgICAvKiBqc2hpbnQgbG9vcGZ1bmM6dHJ1ZSAqL1xuICAgICAgICBhdXRvU2Nyb2xsc1tsYXllcnNPdXRdLnBpZCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBlbXVsYXRlIGRyYWcgb3ZlciBkdXJpbmcgYXV0b3Njcm9sbCAoZmFsbGJhY2spLCBlbXVsYXRpbmcgbmF0aXZlIERuRCBiZWhhdmlvdXJcbiAgICAgICAgICBpZiAoaXNGYWxsYmFjayAmJiB0aGlzLmxheWVyID09PSAwKSB7XG4gICAgICAgICAgICBTb3J0YWJsZS5hY3RpdmUuX29uVG91Y2hNb3ZlKHRvdWNoRXZ0JDEpOyAvLyBUbyBtb3ZlIGdob3N0IGlmIGl0IGlzIHBvc2l0aW9uZWQgYWJzb2x1dGVseVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgc2Nyb2xsT2Zmc2V0WSA9IGF1dG9TY3JvbGxzW3RoaXMubGF5ZXJdLnZ5ID8gYXV0b1Njcm9sbHNbdGhpcy5sYXllcl0udnkgKiBzcGVlZCA6IDA7XG4gICAgICAgICAgdmFyIHNjcm9sbE9mZnNldFggPSBhdXRvU2Nyb2xsc1t0aGlzLmxheWVyXS52eCA/IGF1dG9TY3JvbGxzW3RoaXMubGF5ZXJdLnZ4ICogc3BlZWQgOiAwO1xuICAgICAgICAgIGlmICh0eXBlb2Ygc2Nyb2xsQ3VzdG9tRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGlmIChzY3JvbGxDdXN0b21Gbi5jYWxsKFNvcnRhYmxlLmRyYWdnZWQucGFyZW50Tm9kZVtleHBhbmRvXSwgc2Nyb2xsT2Zmc2V0WCwgc2Nyb2xsT2Zmc2V0WSwgZXZ0LCB0b3VjaEV2dCQxLCBhdXRvU2Nyb2xsc1t0aGlzLmxheWVyXS5lbCkgIT09ICdjb250aW51ZScpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBzY3JvbGxCeShhdXRvU2Nyb2xsc1t0aGlzLmxheWVyXS5lbCwgc2Nyb2xsT2Zmc2V0WCwgc2Nyb2xsT2Zmc2V0WSk7XG4gICAgICAgIH0uYmluZCh7XG4gICAgICAgICAgbGF5ZXI6IGxheWVyc091dFxuICAgICAgICB9KSwgMjQpO1xuICAgICAgfVxuICAgIH1cbiAgICBsYXllcnNPdXQrKztcbiAgfSB3aGlsZSAob3B0aW9ucy5idWJibGVTY3JvbGwgJiYgY3VycmVudFBhcmVudCAhPT0gd2luU2Nyb2xsZXIgJiYgKGN1cnJlbnRQYXJlbnQgPSBnZXRQYXJlbnRBdXRvU2Nyb2xsRWxlbWVudChjdXJyZW50UGFyZW50LCBmYWxzZSkpKTtcbiAgc2Nyb2xsaW5nID0gc2Nyb2xsVGhpc0luc3RhbmNlOyAvLyBpbiBjYXNlIGFub3RoZXIgZnVuY3Rpb24gY2F0Y2hlcyBzY3JvbGxpbmcgYXMgZmFsc2UgaW4gYmV0d2VlbiB3aGVuIGl0IGlzIG5vdFxufSwgMzApO1xuXG52YXIgZHJvcCA9IGZ1bmN0aW9uIGRyb3AoX3JlZikge1xuICB2YXIgb3JpZ2luYWxFdmVudCA9IF9yZWYub3JpZ2luYWxFdmVudCxcbiAgICBwdXRTb3J0YWJsZSA9IF9yZWYucHV0U29ydGFibGUsXG4gICAgZHJhZ0VsID0gX3JlZi5kcmFnRWwsXG4gICAgYWN0aXZlU29ydGFibGUgPSBfcmVmLmFjdGl2ZVNvcnRhYmxlLFxuICAgIGRpc3BhdGNoU29ydGFibGVFdmVudCA9IF9yZWYuZGlzcGF0Y2hTb3J0YWJsZUV2ZW50LFxuICAgIGhpZGVHaG9zdEZvclRhcmdldCA9IF9yZWYuaGlkZUdob3N0Rm9yVGFyZ2V0LFxuICAgIHVuaGlkZUdob3N0Rm9yVGFyZ2V0ID0gX3JlZi51bmhpZGVHaG9zdEZvclRhcmdldDtcbiAgaWYgKCFvcmlnaW5hbEV2ZW50KSByZXR1cm47XG4gIHZhciB0b1NvcnRhYmxlID0gcHV0U29ydGFibGUgfHwgYWN0aXZlU29ydGFibGU7XG4gIGhpZGVHaG9zdEZvclRhcmdldCgpO1xuICB2YXIgdG91Y2ggPSBvcmlnaW5hbEV2ZW50LmNoYW5nZWRUb3VjaGVzICYmIG9yaWdpbmFsRXZlbnQuY2hhbmdlZFRvdWNoZXMubGVuZ3RoID8gb3JpZ2luYWxFdmVudC5jaGFuZ2VkVG91Y2hlc1swXSA6IG9yaWdpbmFsRXZlbnQ7XG4gIHZhciB0YXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KHRvdWNoLmNsaWVudFgsIHRvdWNoLmNsaWVudFkpO1xuICB1bmhpZGVHaG9zdEZvclRhcmdldCgpO1xuICBpZiAodG9Tb3J0YWJsZSAmJiAhdG9Tb3J0YWJsZS5lbC5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgZGlzcGF0Y2hTb3J0YWJsZUV2ZW50KCdzcGlsbCcpO1xuICAgIHRoaXMub25TcGlsbCh7XG4gICAgICBkcmFnRWw6IGRyYWdFbCxcbiAgICAgIHB1dFNvcnRhYmxlOiBwdXRTb3J0YWJsZVxuICAgIH0pO1xuICB9XG59O1xuZnVuY3Rpb24gUmV2ZXJ0KCkge31cblJldmVydC5wcm90b3R5cGUgPSB7XG4gIHN0YXJ0SW5kZXg6IG51bGwsXG4gIGRyYWdTdGFydDogZnVuY3Rpb24gZHJhZ1N0YXJ0KF9yZWYyKSB7XG4gICAgdmFyIG9sZERyYWdnYWJsZUluZGV4ID0gX3JlZjIub2xkRHJhZ2dhYmxlSW5kZXg7XG4gICAgdGhpcy5zdGFydEluZGV4ID0gb2xkRHJhZ2dhYmxlSW5kZXg7XG4gIH0sXG4gIG9uU3BpbGw6IGZ1bmN0aW9uIG9uU3BpbGwoX3JlZjMpIHtcbiAgICB2YXIgZHJhZ0VsID0gX3JlZjMuZHJhZ0VsLFxuICAgICAgcHV0U29ydGFibGUgPSBfcmVmMy5wdXRTb3J0YWJsZTtcbiAgICB0aGlzLnNvcnRhYmxlLmNhcHR1cmVBbmltYXRpb25TdGF0ZSgpO1xuICAgIGlmIChwdXRTb3J0YWJsZSkge1xuICAgICAgcHV0U29ydGFibGUuY2FwdHVyZUFuaW1hdGlvblN0YXRlKCk7XG4gICAgfVxuICAgIHZhciBuZXh0U2libGluZyA9IGdldENoaWxkKHRoaXMuc29ydGFibGUuZWwsIHRoaXMuc3RhcnRJbmRleCwgdGhpcy5vcHRpb25zKTtcbiAgICBpZiAobmV4dFNpYmxpbmcpIHtcbiAgICAgIHRoaXMuc29ydGFibGUuZWwuaW5zZXJ0QmVmb3JlKGRyYWdFbCwgbmV4dFNpYmxpbmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNvcnRhYmxlLmVsLmFwcGVuZENoaWxkKGRyYWdFbCk7XG4gICAgfVxuICAgIHRoaXMuc29ydGFibGUuYW5pbWF0ZUFsbCgpO1xuICAgIGlmIChwdXRTb3J0YWJsZSkge1xuICAgICAgcHV0U29ydGFibGUuYW5pbWF0ZUFsbCgpO1xuICAgIH1cbiAgfSxcbiAgZHJvcDogZHJvcFxufTtcbl9leHRlbmRzKFJldmVydCwge1xuICBwbHVnaW5OYW1lOiAncmV2ZXJ0T25TcGlsbCdcbn0pO1xuZnVuY3Rpb24gUmVtb3ZlKCkge31cblJlbW92ZS5wcm90b3R5cGUgPSB7XG4gIG9uU3BpbGw6IGZ1bmN0aW9uIG9uU3BpbGwoX3JlZjQpIHtcbiAgICB2YXIgZHJhZ0VsID0gX3JlZjQuZHJhZ0VsLFxuICAgICAgcHV0U29ydGFibGUgPSBfcmVmNC5wdXRTb3J0YWJsZTtcbiAgICB2YXIgcGFyZW50U29ydGFibGUgPSBwdXRTb3J0YWJsZSB8fCB0aGlzLnNvcnRhYmxlO1xuICAgIHBhcmVudFNvcnRhYmxlLmNhcHR1cmVBbmltYXRpb25TdGF0ZSgpO1xuICAgIGRyYWdFbC5wYXJlbnROb2RlICYmIGRyYWdFbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGRyYWdFbCk7XG4gICAgcGFyZW50U29ydGFibGUuYW5pbWF0ZUFsbCgpO1xuICB9LFxuICBkcm9wOiBkcm9wXG59O1xuX2V4dGVuZHMoUmVtb3ZlLCB7XG4gIHBsdWdpbk5hbWU6ICdyZW1vdmVPblNwaWxsJ1xufSk7XG5cbnZhciBsYXN0U3dhcEVsO1xuZnVuY3Rpb24gU3dhcFBsdWdpbigpIHtcbiAgZnVuY3Rpb24gU3dhcCgpIHtcbiAgICB0aGlzLmRlZmF1bHRzID0ge1xuICAgICAgc3dhcENsYXNzOiAnc29ydGFibGUtc3dhcC1oaWdobGlnaHQnXG4gICAgfTtcbiAgfVxuICBTd2FwLnByb3RvdHlwZSA9IHtcbiAgICBkcmFnU3RhcnQ6IGZ1bmN0aW9uIGRyYWdTdGFydChfcmVmKSB7XG4gICAgICB2YXIgZHJhZ0VsID0gX3JlZi5kcmFnRWw7XG4gICAgICBsYXN0U3dhcEVsID0gZHJhZ0VsO1xuICAgIH0sXG4gICAgZHJhZ092ZXJWYWxpZDogZnVuY3Rpb24gZHJhZ092ZXJWYWxpZChfcmVmMikge1xuICAgICAgdmFyIGNvbXBsZXRlZCA9IF9yZWYyLmNvbXBsZXRlZCxcbiAgICAgICAgdGFyZ2V0ID0gX3JlZjIudGFyZ2V0LFxuICAgICAgICBvbk1vdmUgPSBfcmVmMi5vbk1vdmUsXG4gICAgICAgIGFjdGl2ZVNvcnRhYmxlID0gX3JlZjIuYWN0aXZlU29ydGFibGUsXG4gICAgICAgIGNoYW5nZWQgPSBfcmVmMi5jaGFuZ2VkLFxuICAgICAgICBjYW5jZWwgPSBfcmVmMi5jYW5jZWw7XG4gICAgICBpZiAoIWFjdGl2ZVNvcnRhYmxlLm9wdGlvbnMuc3dhcCkgcmV0dXJuO1xuICAgICAgdmFyIGVsID0gdGhpcy5zb3J0YWJsZS5lbCxcbiAgICAgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgIGlmICh0YXJnZXQgJiYgdGFyZ2V0ICE9PSBlbCkge1xuICAgICAgICB2YXIgcHJldlN3YXBFbCA9IGxhc3RTd2FwRWw7XG4gICAgICAgIGlmIChvbk1vdmUodGFyZ2V0KSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICB0b2dnbGVDbGFzcyh0YXJnZXQsIG9wdGlvbnMuc3dhcENsYXNzLCB0cnVlKTtcbiAgICAgICAgICBsYXN0U3dhcEVsID0gdGFyZ2V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhc3RTd2FwRWwgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2U3dhcEVsICYmIHByZXZTd2FwRWwgIT09IGxhc3RTd2FwRWwpIHtcbiAgICAgICAgICB0b2dnbGVDbGFzcyhwcmV2U3dhcEVsLCBvcHRpb25zLnN3YXBDbGFzcywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjaGFuZ2VkKCk7XG4gICAgICBjb21wbGV0ZWQodHJ1ZSk7XG4gICAgICBjYW5jZWwoKTtcbiAgICB9LFxuICAgIGRyb3A6IGZ1bmN0aW9uIGRyb3AoX3JlZjMpIHtcbiAgICAgIHZhciBhY3RpdmVTb3J0YWJsZSA9IF9yZWYzLmFjdGl2ZVNvcnRhYmxlLFxuICAgICAgICBwdXRTb3J0YWJsZSA9IF9yZWYzLnB1dFNvcnRhYmxlLFxuICAgICAgICBkcmFnRWwgPSBfcmVmMy5kcmFnRWw7XG4gICAgICB2YXIgdG9Tb3J0YWJsZSA9IHB1dFNvcnRhYmxlIHx8IHRoaXMuc29ydGFibGU7XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgIGxhc3RTd2FwRWwgJiYgdG9nZ2xlQ2xhc3MobGFzdFN3YXBFbCwgb3B0aW9ucy5zd2FwQ2xhc3MsIGZhbHNlKTtcbiAgICAgIGlmIChsYXN0U3dhcEVsICYmIChvcHRpb25zLnN3YXAgfHwgcHV0U29ydGFibGUgJiYgcHV0U29ydGFibGUub3B0aW9ucy5zd2FwKSkge1xuICAgICAgICBpZiAoZHJhZ0VsICE9PSBsYXN0U3dhcEVsKSB7XG4gICAgICAgICAgdG9Tb3J0YWJsZS5jYXB0dXJlQW5pbWF0aW9uU3RhdGUoKTtcbiAgICAgICAgICBpZiAodG9Tb3J0YWJsZSAhPT0gYWN0aXZlU29ydGFibGUpIGFjdGl2ZVNvcnRhYmxlLmNhcHR1cmVBbmltYXRpb25TdGF0ZSgpO1xuICAgICAgICAgIHN3YXBOb2RlcyhkcmFnRWwsIGxhc3RTd2FwRWwpO1xuICAgICAgICAgIHRvU29ydGFibGUuYW5pbWF0ZUFsbCgpO1xuICAgICAgICAgIGlmICh0b1NvcnRhYmxlICE9PSBhY3RpdmVTb3J0YWJsZSkgYWN0aXZlU29ydGFibGUuYW5pbWF0ZUFsbCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBudWxsaW5nOiBmdW5jdGlvbiBudWxsaW5nKCkge1xuICAgICAgbGFzdFN3YXBFbCA9IG51bGw7XG4gICAgfVxuICB9O1xuICByZXR1cm4gX2V4dGVuZHMoU3dhcCwge1xuICAgIHBsdWdpbk5hbWU6ICdzd2FwJyxcbiAgICBldmVudFByb3BlcnRpZXM6IGZ1bmN0aW9uIGV2ZW50UHJvcGVydGllcygpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN3YXBJdGVtOiBsYXN0U3dhcEVsXG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBzd2FwTm9kZXMobjEsIG4yKSB7XG4gIHZhciBwMSA9IG4xLnBhcmVudE5vZGUsXG4gICAgcDIgPSBuMi5wYXJlbnROb2RlLFxuICAgIGkxLFxuICAgIGkyO1xuICBpZiAoIXAxIHx8ICFwMiB8fCBwMS5pc0VxdWFsTm9kZShuMikgfHwgcDIuaXNFcXVhbE5vZGUobjEpKSByZXR1cm47XG4gIGkxID0gaW5kZXgobjEpO1xuICBpMiA9IGluZGV4KG4yKTtcbiAgaWYgKHAxLmlzRXF1YWxOb2RlKHAyKSAmJiBpMSA8IGkyKSB7XG4gICAgaTIrKztcbiAgfVxuICBwMS5pbnNlcnRCZWZvcmUobjIsIHAxLmNoaWxkcmVuW2kxXSk7XG4gIHAyLmluc2VydEJlZm9yZShuMSwgcDIuY2hpbGRyZW5baTJdKTtcbn1cblxudmFyIG11bHRpRHJhZ0VsZW1lbnRzID0gW10sXG4gIG11bHRpRHJhZ0Nsb25lcyA9IFtdLFxuICBsYXN0TXVsdGlEcmFnU2VsZWN0LFxuICAvLyBmb3Igc2VsZWN0aW9uIHdpdGggbW9kaWZpZXIga2V5IGRvd24gKFNISUZUKVxuICBtdWx0aURyYWdTb3J0YWJsZSxcbiAgaW5pdGlhbEZvbGRpbmcgPSBmYWxzZSxcbiAgLy8gSW5pdGlhbCBtdWx0aS1kcmFnIGZvbGQgd2hlbiBkcmFnIHN0YXJ0ZWRcbiAgZm9sZGluZyA9IGZhbHNlLFxuICAvLyBGb2xkaW5nIGFueSBvdGhlciB0aW1lXG4gIGRyYWdTdGFydGVkID0gZmFsc2UsXG4gIGRyYWdFbCQxLFxuICBjbG9uZXNGcm9tUmVjdCxcbiAgY2xvbmVzSGlkZGVuO1xuZnVuY3Rpb24gTXVsdGlEcmFnUGx1Z2luKCkge1xuICBmdW5jdGlvbiBNdWx0aURyYWcoc29ydGFibGUpIHtcbiAgICAvLyBCaW5kIGFsbCBwcml2YXRlIG1ldGhvZHNcbiAgICBmb3IgKHZhciBmbiBpbiB0aGlzKSB7XG4gICAgICBpZiAoZm4uY2hhckF0KDApID09PSAnXycgJiYgdHlwZW9mIHRoaXNbZm5dID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXNbZm5dID0gdGhpc1tmbl0uYmluZCh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFzb3J0YWJsZS5vcHRpb25zLmF2b2lkSW1wbGljaXREZXNlbGVjdCkge1xuICAgICAgaWYgKHNvcnRhYmxlLm9wdGlvbnMuc3VwcG9ydFBvaW50ZXIpIHtcbiAgICAgICAgb24oZG9jdW1lbnQsICdwb2ludGVydXAnLCB0aGlzLl9kZXNlbGVjdE11bHRpRHJhZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvbihkb2N1bWVudCwgJ21vdXNldXAnLCB0aGlzLl9kZXNlbGVjdE11bHRpRHJhZyk7XG4gICAgICAgIG9uKGRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLl9kZXNlbGVjdE11bHRpRHJhZyk7XG4gICAgICB9XG4gICAgfVxuICAgIG9uKGRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuX2NoZWNrS2V5RG93bik7XG4gICAgb24oZG9jdW1lbnQsICdrZXl1cCcsIHRoaXMuX2NoZWNrS2V5VXApO1xuICAgIHRoaXMuZGVmYXVsdHMgPSB7XG4gICAgICBzZWxlY3RlZENsYXNzOiAnc29ydGFibGUtc2VsZWN0ZWQnLFxuICAgICAgbXVsdGlEcmFnS2V5OiBudWxsLFxuICAgICAgYXZvaWRJbXBsaWNpdERlc2VsZWN0OiBmYWxzZSxcbiAgICAgIHNldERhdGE6IGZ1bmN0aW9uIHNldERhdGEoZGF0YVRyYW5zZmVyLCBkcmFnRWwpIHtcbiAgICAgICAgdmFyIGRhdGEgPSAnJztcbiAgICAgICAgaWYgKG11bHRpRHJhZ0VsZW1lbnRzLmxlbmd0aCAmJiBtdWx0aURyYWdTb3J0YWJsZSA9PT0gc29ydGFibGUpIHtcbiAgICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtdWx0aURyYWdFbGVtZW50LCBpKSB7XG4gICAgICAgICAgICBkYXRhICs9ICghaSA/ICcnIDogJywgJykgKyBtdWx0aURyYWdFbGVtZW50LnRleHRDb250ZW50O1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGEgPSBkcmFnRWwudGV4dENvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YVRyYW5zZmVyLnNldERhdGEoJ1RleHQnLCBkYXRhKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIE11bHRpRHJhZy5wcm90b3R5cGUgPSB7XG4gICAgbXVsdGlEcmFnS2V5RG93bjogZmFsc2UsXG4gICAgaXNNdWx0aURyYWc6IGZhbHNlLFxuICAgIGRlbGF5U3RhcnRHbG9iYWw6IGZ1bmN0aW9uIGRlbGF5U3RhcnRHbG9iYWwoX3JlZikge1xuICAgICAgdmFyIGRyYWdnZWQgPSBfcmVmLmRyYWdFbDtcbiAgICAgIGRyYWdFbCQxID0gZHJhZ2dlZDtcbiAgICB9LFxuICAgIGRlbGF5RW5kZWQ6IGZ1bmN0aW9uIGRlbGF5RW5kZWQoKSB7XG4gICAgICB0aGlzLmlzTXVsdGlEcmFnID0gfm11bHRpRHJhZ0VsZW1lbnRzLmluZGV4T2YoZHJhZ0VsJDEpO1xuICAgIH0sXG4gICAgc2V0dXBDbG9uZTogZnVuY3Rpb24gc2V0dXBDbG9uZShfcmVmMikge1xuICAgICAgdmFyIHNvcnRhYmxlID0gX3JlZjIuc29ydGFibGUsXG4gICAgICAgIGNhbmNlbCA9IF9yZWYyLmNhbmNlbDtcbiAgICAgIGlmICghdGhpcy5pc011bHRpRHJhZykgcmV0dXJuO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtdWx0aURyYWdFbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBtdWx0aURyYWdDbG9uZXMucHVzaChjbG9uZShtdWx0aURyYWdFbGVtZW50c1tpXSkpO1xuICAgICAgICBtdWx0aURyYWdDbG9uZXNbaV0uc29ydGFibGVJbmRleCA9IG11bHRpRHJhZ0VsZW1lbnRzW2ldLnNvcnRhYmxlSW5kZXg7XG4gICAgICAgIG11bHRpRHJhZ0Nsb25lc1tpXS5kcmFnZ2FibGUgPSBmYWxzZTtcbiAgICAgICAgbXVsdGlEcmFnQ2xvbmVzW2ldLnN0eWxlWyd3aWxsLWNoYW5nZSddID0gJyc7XG4gICAgICAgIHRvZ2dsZUNsYXNzKG11bHRpRHJhZ0Nsb25lc1tpXSwgdGhpcy5vcHRpb25zLnNlbGVjdGVkQ2xhc3MsIGZhbHNlKTtcbiAgICAgICAgbXVsdGlEcmFnRWxlbWVudHNbaV0gPT09IGRyYWdFbCQxICYmIHRvZ2dsZUNsYXNzKG11bHRpRHJhZ0Nsb25lc1tpXSwgdGhpcy5vcHRpb25zLmNob3NlbkNsYXNzLCBmYWxzZSk7XG4gICAgICB9XG4gICAgICBzb3J0YWJsZS5faGlkZUNsb25lKCk7XG4gICAgICBjYW5jZWwoKTtcbiAgICB9LFxuICAgIGNsb25lOiBmdW5jdGlvbiBjbG9uZShfcmVmMykge1xuICAgICAgdmFyIHNvcnRhYmxlID0gX3JlZjMuc29ydGFibGUsXG4gICAgICAgIHJvb3RFbCA9IF9yZWYzLnJvb3RFbCxcbiAgICAgICAgZGlzcGF0Y2hTb3J0YWJsZUV2ZW50ID0gX3JlZjMuZGlzcGF0Y2hTb3J0YWJsZUV2ZW50LFxuICAgICAgICBjYW5jZWwgPSBfcmVmMy5jYW5jZWw7XG4gICAgICBpZiAoIXRoaXMuaXNNdWx0aURyYWcpIHJldHVybjtcbiAgICAgIGlmICghdGhpcy5vcHRpb25zLnJlbW92ZUNsb25lT25IaWRlKSB7XG4gICAgICAgIGlmIChtdWx0aURyYWdFbGVtZW50cy5sZW5ndGggJiYgbXVsdGlEcmFnU29ydGFibGUgPT09IHNvcnRhYmxlKSB7XG4gICAgICAgICAgaW5zZXJ0TXVsdGlEcmFnQ2xvbmVzKHRydWUsIHJvb3RFbCk7XG4gICAgICAgICAgZGlzcGF0Y2hTb3J0YWJsZUV2ZW50KCdjbG9uZScpO1xuICAgICAgICAgIGNhbmNlbCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBzaG93Q2xvbmU6IGZ1bmN0aW9uIHNob3dDbG9uZShfcmVmNCkge1xuICAgICAgdmFyIGNsb25lTm93U2hvd24gPSBfcmVmNC5jbG9uZU5vd1Nob3duLFxuICAgICAgICByb290RWwgPSBfcmVmNC5yb290RWwsXG4gICAgICAgIGNhbmNlbCA9IF9yZWY0LmNhbmNlbDtcbiAgICAgIGlmICghdGhpcy5pc011bHRpRHJhZykgcmV0dXJuO1xuICAgICAgaW5zZXJ0TXVsdGlEcmFnQ2xvbmVzKGZhbHNlLCByb290RWwpO1xuICAgICAgbXVsdGlEcmFnQ2xvbmVzLmZvckVhY2goZnVuY3Rpb24gKGNsb25lKSB7XG4gICAgICAgIGNzcyhjbG9uZSwgJ2Rpc3BsYXknLCAnJyk7XG4gICAgICB9KTtcbiAgICAgIGNsb25lTm93U2hvd24oKTtcbiAgICAgIGNsb25lc0hpZGRlbiA9IGZhbHNlO1xuICAgICAgY2FuY2VsKCk7XG4gICAgfSxcbiAgICBoaWRlQ2xvbmU6IGZ1bmN0aW9uIGhpZGVDbG9uZShfcmVmNSkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIHZhciBzb3J0YWJsZSA9IF9yZWY1LnNvcnRhYmxlLFxuICAgICAgICBjbG9uZU5vd0hpZGRlbiA9IF9yZWY1LmNsb25lTm93SGlkZGVuLFxuICAgICAgICBjYW5jZWwgPSBfcmVmNS5jYW5jZWw7XG4gICAgICBpZiAoIXRoaXMuaXNNdWx0aURyYWcpIHJldHVybjtcbiAgICAgIG11bHRpRHJhZ0Nsb25lcy5mb3JFYWNoKGZ1bmN0aW9uIChjbG9uZSkge1xuICAgICAgICBjc3MoY2xvbmUsICdkaXNwbGF5JywgJ25vbmUnKTtcbiAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMucmVtb3ZlQ2xvbmVPbkhpZGUgJiYgY2xvbmUucGFyZW50Tm9kZSkge1xuICAgICAgICAgIGNsb25lLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2xvbmUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNsb25lTm93SGlkZGVuKCk7XG4gICAgICBjbG9uZXNIaWRkZW4gPSB0cnVlO1xuICAgICAgY2FuY2VsKCk7XG4gICAgfSxcbiAgICBkcmFnU3RhcnRHbG9iYWw6IGZ1bmN0aW9uIGRyYWdTdGFydEdsb2JhbChfcmVmNikge1xuICAgICAgdmFyIHNvcnRhYmxlID0gX3JlZjYuc29ydGFibGU7XG4gICAgICBpZiAoIXRoaXMuaXNNdWx0aURyYWcgJiYgbXVsdGlEcmFnU29ydGFibGUpIHtcbiAgICAgICAgbXVsdGlEcmFnU29ydGFibGUubXVsdGlEcmFnLl9kZXNlbGVjdE11bHRpRHJhZygpO1xuICAgICAgfVxuICAgICAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCkge1xuICAgICAgICBtdWx0aURyYWdFbGVtZW50LnNvcnRhYmxlSW5kZXggPSBpbmRleChtdWx0aURyYWdFbGVtZW50KTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBTb3J0IG11bHRpLWRyYWcgZWxlbWVudHNcbiAgICAgIG11bHRpRHJhZ0VsZW1lbnRzID0gbXVsdGlEcmFnRWxlbWVudHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYS5zb3J0YWJsZUluZGV4IC0gYi5zb3J0YWJsZUluZGV4O1xuICAgICAgfSk7XG4gICAgICBkcmFnU3RhcnRlZCA9IHRydWU7XG4gICAgfSxcbiAgICBkcmFnU3RhcnRlZDogZnVuY3Rpb24gZHJhZ1N0YXJ0ZWQoX3JlZjcpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgdmFyIHNvcnRhYmxlID0gX3JlZjcuc29ydGFibGU7XG4gICAgICBpZiAoIXRoaXMuaXNNdWx0aURyYWcpIHJldHVybjtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuc29ydCkge1xuICAgICAgICAvLyBDYXB0dXJlIHJlY3RzLFxuICAgICAgICAvLyBoaWRlIG11bHRpIGRyYWcgZWxlbWVudHMgKGJ5IHBvc2l0aW9uaW5nIHRoZW0gYWJzb2x1dGUpLFxuICAgICAgICAvLyBzZXQgbXVsdGkgZHJhZyBlbGVtZW50cyByZWN0cyB0byBkcmFnUmVjdCxcbiAgICAgICAgLy8gc2hvdyBtdWx0aSBkcmFnIGVsZW1lbnRzLFxuICAgICAgICAvLyBhbmltYXRlIHRvIHJlY3RzLFxuICAgICAgICAvLyB1bnNldCByZWN0cyAmIHJlbW92ZSBmcm9tIERPTVxuXG4gICAgICAgIHNvcnRhYmxlLmNhcHR1cmVBbmltYXRpb25TdGF0ZSgpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFuaW1hdGlvbikge1xuICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG11bHRpRHJhZ0VsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChtdWx0aURyYWdFbGVtZW50ID09PSBkcmFnRWwkMSkgcmV0dXJuO1xuICAgICAgICAgICAgY3NzKG11bHRpRHJhZ0VsZW1lbnQsICdwb3NpdGlvbicsICdhYnNvbHV0ZScpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBkcmFnUmVjdCA9IGdldFJlY3QoZHJhZ0VsJDEsIGZhbHNlLCB0cnVlLCB0cnVlKTtcbiAgICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtdWx0aURyYWdFbGVtZW50KSB7XG4gICAgICAgICAgICBpZiAobXVsdGlEcmFnRWxlbWVudCA9PT0gZHJhZ0VsJDEpIHJldHVybjtcbiAgICAgICAgICAgIHNldFJlY3QobXVsdGlEcmFnRWxlbWVudCwgZHJhZ1JlY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGZvbGRpbmcgPSB0cnVlO1xuICAgICAgICAgIGluaXRpYWxGb2xkaW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc29ydGFibGUuYW5pbWF0ZUFsbChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvbGRpbmcgPSBmYWxzZTtcbiAgICAgICAgaW5pdGlhbEZvbGRpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKF90aGlzMi5vcHRpb25zLmFuaW1hdGlvbikge1xuICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKG11bHRpRHJhZ0VsZW1lbnQpIHtcbiAgICAgICAgICAgIHVuc2V0UmVjdChtdWx0aURyYWdFbGVtZW50KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlbW92ZSBhbGwgYXV4aWxpYXJ5IG11bHRpZHJhZyBpdGVtcyBmcm9tIGVsLCBpZiBzb3J0aW5nIGVuYWJsZWRcbiAgICAgICAgaWYgKF90aGlzMi5vcHRpb25zLnNvcnQpIHtcbiAgICAgICAgICByZW1vdmVNdWx0aURyYWdFbGVtZW50cygpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGRyYWdPdmVyOiBmdW5jdGlvbiBkcmFnT3ZlcihfcmVmOCkge1xuICAgICAgdmFyIHRhcmdldCA9IF9yZWY4LnRhcmdldCxcbiAgICAgICAgY29tcGxldGVkID0gX3JlZjguY29tcGxldGVkLFxuICAgICAgICBjYW5jZWwgPSBfcmVmOC5jYW5jZWw7XG4gICAgICBpZiAoZm9sZGluZyAmJiB+bXVsdGlEcmFnRWxlbWVudHMuaW5kZXhPZih0YXJnZXQpKSB7XG4gICAgICAgIGNvbXBsZXRlZChmYWxzZSk7XG4gICAgICAgIGNhbmNlbCgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmV2ZXJ0OiBmdW5jdGlvbiByZXZlcnQoX3JlZjkpIHtcbiAgICAgIHZhciBmcm9tU29ydGFibGUgPSBfcmVmOS5mcm9tU29ydGFibGUsXG4gICAgICAgIHJvb3RFbCA9IF9yZWY5LnJvb3RFbCxcbiAgICAgICAgc29ydGFibGUgPSBfcmVmOS5zb3J0YWJsZSxcbiAgICAgICAgZHJhZ1JlY3QgPSBfcmVmOS5kcmFnUmVjdDtcbiAgICAgIGlmIChtdWx0aURyYWdFbGVtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIC8vIFNldHVwIHVuZm9sZCBhbmltYXRpb25cbiAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCkge1xuICAgICAgICAgIHNvcnRhYmxlLmFkZEFuaW1hdGlvblN0YXRlKHtcbiAgICAgICAgICAgIHRhcmdldDogbXVsdGlEcmFnRWxlbWVudCxcbiAgICAgICAgICAgIHJlY3Q6IGZvbGRpbmcgPyBnZXRSZWN0KG11bHRpRHJhZ0VsZW1lbnQpIDogZHJhZ1JlY3RcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB1bnNldFJlY3QobXVsdGlEcmFnRWxlbWVudCk7XG4gICAgICAgICAgbXVsdGlEcmFnRWxlbWVudC5mcm9tUmVjdCA9IGRyYWdSZWN0O1xuICAgICAgICAgIGZyb21Tb3J0YWJsZS5yZW1vdmVBbmltYXRpb25TdGF0ZShtdWx0aURyYWdFbGVtZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGZvbGRpbmcgPSBmYWxzZTtcbiAgICAgICAgaW5zZXJ0TXVsdGlEcmFnRWxlbWVudHMoIXRoaXMub3B0aW9ucy5yZW1vdmVDbG9uZU9uSGlkZSwgcm9vdEVsKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRyYWdPdmVyQ29tcGxldGVkOiBmdW5jdGlvbiBkcmFnT3ZlckNvbXBsZXRlZChfcmVmMTApIHtcbiAgICAgIHZhciBzb3J0YWJsZSA9IF9yZWYxMC5zb3J0YWJsZSxcbiAgICAgICAgaXNPd25lciA9IF9yZWYxMC5pc093bmVyLFxuICAgICAgICBpbnNlcnRpb24gPSBfcmVmMTAuaW5zZXJ0aW9uLFxuICAgICAgICBhY3RpdmVTb3J0YWJsZSA9IF9yZWYxMC5hY3RpdmVTb3J0YWJsZSxcbiAgICAgICAgcGFyZW50RWwgPSBfcmVmMTAucGFyZW50RWwsXG4gICAgICAgIHB1dFNvcnRhYmxlID0gX3JlZjEwLnB1dFNvcnRhYmxlO1xuICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgICBpZiAoaW5zZXJ0aW9uKSB7XG4gICAgICAgIC8vIENsb25lcyBtdXN0IGJlIGhpZGRlbiBiZWZvcmUgZm9sZGluZyBhbmltYXRpb24gdG8gY2FwdHVyZSBkcmFnUmVjdEFic29sdXRlIHByb3Blcmx5XG4gICAgICAgIGlmIChpc093bmVyKSB7XG4gICAgICAgICAgYWN0aXZlU29ydGFibGUuX2hpZGVDbG9uZSgpO1xuICAgICAgICB9XG4gICAgICAgIGluaXRpYWxGb2xkaW5nID0gZmFsc2U7XG4gICAgICAgIC8vIElmIGxlYXZpbmcgc29ydDpmYWxzZSByb290LCBvciBhbHJlYWR5IGZvbGRpbmcgLSBGb2xkIHRvIG5ldyBsb2NhdGlvblxuICAgICAgICBpZiAob3B0aW9ucy5hbmltYXRpb24gJiYgbXVsdGlEcmFnRWxlbWVudHMubGVuZ3RoID4gMSAmJiAoZm9sZGluZyB8fCAhaXNPd25lciAmJiAhYWN0aXZlU29ydGFibGUub3B0aW9ucy5zb3J0ICYmICFwdXRTb3J0YWJsZSkpIHtcbiAgICAgICAgICAvLyBGb2xkOiBTZXQgYWxsIG11bHRpIGRyYWcgZWxlbWVudHMncyByZWN0cyB0byBkcmFnRWwncyByZWN0IHdoZW4gbXVsdGktZHJhZyBlbGVtZW50cyBhcmUgaW52aXNpYmxlXG4gICAgICAgICAgdmFyIGRyYWdSZWN0QWJzb2x1dGUgPSBnZXRSZWN0KGRyYWdFbCQxLCBmYWxzZSwgdHJ1ZSwgdHJ1ZSk7XG4gICAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKG11bHRpRHJhZ0VsZW1lbnQgPT09IGRyYWdFbCQxKSByZXR1cm47XG4gICAgICAgICAgICBzZXRSZWN0KG11bHRpRHJhZ0VsZW1lbnQsIGRyYWdSZWN0QWJzb2x1dGUpO1xuXG4gICAgICAgICAgICAvLyBNb3ZlIGVsZW1lbnQocykgdG8gZW5kIG9mIHBhcmVudEVsIHNvIHRoYXQgaXQgZG9lcyBub3QgaW50ZXJmZXJlIHdpdGggbXVsdGktZHJhZyBjbG9uZXMgaW5zZXJ0aW9uIGlmIHRoZXkgYXJlIGluc2VydGVkXG4gICAgICAgICAgICAvLyB3aGlsZSBmb2xkaW5nLCBhbmQgc28gdGhhdCB3ZSBjYW4gY2FwdHVyZSB0aGVtIGFnYWluIGJlY2F1c2Ugb2xkIHNvcnRhYmxlIHdpbGwgbm8gbG9uZ2VyIGJlIGZyb21Tb3J0YWJsZVxuICAgICAgICAgICAgcGFyZW50RWwuYXBwZW5kQ2hpbGQobXVsdGlEcmFnRWxlbWVudCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZm9sZGluZyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDbG9uZXMgbXVzdCBiZSBzaG93biAoYW5kIGNoZWNrIHRvIHJlbW92ZSBtdWx0aSBkcmFncykgYWZ0ZXIgZm9sZGluZyB3aGVuIGludGVyZmVyaW5nIG11bHRpRHJhZ0VsZW1lbnRzIGFyZSBtb3ZlZCBvdXRcbiAgICAgICAgaWYgKCFpc093bmVyKSB7XG4gICAgICAgICAgLy8gT25seSByZW1vdmUgaWYgbm90IGZvbGRpbmcgKGZvbGRpbmcgd2lsbCByZW1vdmUgdGhlbSBhbnl3YXlzKVxuICAgICAgICAgIGlmICghZm9sZGluZykge1xuICAgICAgICAgICAgcmVtb3ZlTXVsdGlEcmFnRWxlbWVudHMoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG11bHRpRHJhZ0VsZW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHZhciBjbG9uZXNIaWRkZW5CZWZvcmUgPSBjbG9uZXNIaWRkZW47XG4gICAgICAgICAgICBhY3RpdmVTb3J0YWJsZS5fc2hvd0Nsb25lKHNvcnRhYmxlKTtcblxuICAgICAgICAgICAgLy8gVW5mb2xkIGFuaW1hdGlvbiBmb3IgY2xvbmVzIGlmIHNob3dpbmcgZnJvbSBoaWRkZW5cbiAgICAgICAgICAgIGlmIChhY3RpdmVTb3J0YWJsZS5vcHRpb25zLmFuaW1hdGlvbiAmJiAhY2xvbmVzSGlkZGVuICYmIGNsb25lc0hpZGRlbkJlZm9yZSkge1xuICAgICAgICAgICAgICBtdWx0aURyYWdDbG9uZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xvbmUpIHtcbiAgICAgICAgICAgICAgICBhY3RpdmVTb3J0YWJsZS5hZGRBbmltYXRpb25TdGF0ZSh7XG4gICAgICAgICAgICAgICAgICB0YXJnZXQ6IGNsb25lLFxuICAgICAgICAgICAgICAgICAgcmVjdDogY2xvbmVzRnJvbVJlY3RcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjbG9uZS5mcm9tUmVjdCA9IGNsb25lc0Zyb21SZWN0O1xuICAgICAgICAgICAgICAgIGNsb25lLnRoaXNBbmltYXRpb25EdXJhdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhY3RpdmVTb3J0YWJsZS5fc2hvd0Nsb25lKHNvcnRhYmxlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGRyYWdPdmVyQW5pbWF0aW9uQ2FwdHVyZTogZnVuY3Rpb24gZHJhZ092ZXJBbmltYXRpb25DYXB0dXJlKF9yZWYxMSkge1xuICAgICAgdmFyIGRyYWdSZWN0ID0gX3JlZjExLmRyYWdSZWN0LFxuICAgICAgICBpc093bmVyID0gX3JlZjExLmlzT3duZXIsXG4gICAgICAgIGFjdGl2ZVNvcnRhYmxlID0gX3JlZjExLmFjdGl2ZVNvcnRhYmxlO1xuICAgICAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCkge1xuICAgICAgICBtdWx0aURyYWdFbGVtZW50LnRoaXNBbmltYXRpb25EdXJhdGlvbiA9IG51bGw7XG4gICAgICB9KTtcbiAgICAgIGlmIChhY3RpdmVTb3J0YWJsZS5vcHRpb25zLmFuaW1hdGlvbiAmJiAhaXNPd25lciAmJiBhY3RpdmVTb3J0YWJsZS5tdWx0aURyYWcuaXNNdWx0aURyYWcpIHtcbiAgICAgICAgY2xvbmVzRnJvbVJlY3QgPSBfZXh0ZW5kcyh7fSwgZHJhZ1JlY3QpO1xuICAgICAgICB2YXIgZHJhZ01hdHJpeCA9IG1hdHJpeChkcmFnRWwkMSwgdHJ1ZSk7XG4gICAgICAgIGNsb25lc0Zyb21SZWN0LnRvcCAtPSBkcmFnTWF0cml4LmY7XG4gICAgICAgIGNsb25lc0Zyb21SZWN0LmxlZnQgLT0gZHJhZ01hdHJpeC5lO1xuICAgICAgfVxuICAgIH0sXG4gICAgZHJhZ092ZXJBbmltYXRpb25Db21wbGV0ZTogZnVuY3Rpb24gZHJhZ092ZXJBbmltYXRpb25Db21wbGV0ZSgpIHtcbiAgICAgIGlmIChmb2xkaW5nKSB7XG4gICAgICAgIGZvbGRpbmcgPSBmYWxzZTtcbiAgICAgICAgcmVtb3ZlTXVsdGlEcmFnRWxlbWVudHMoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRyb3A6IGZ1bmN0aW9uIGRyb3AoX3JlZjEyKSB7XG4gICAgICB2YXIgZXZ0ID0gX3JlZjEyLm9yaWdpbmFsRXZlbnQsXG4gICAgICAgIHJvb3RFbCA9IF9yZWYxMi5yb290RWwsXG4gICAgICAgIHBhcmVudEVsID0gX3JlZjEyLnBhcmVudEVsLFxuICAgICAgICBzb3J0YWJsZSA9IF9yZWYxMi5zb3J0YWJsZSxcbiAgICAgICAgZGlzcGF0Y2hTb3J0YWJsZUV2ZW50ID0gX3JlZjEyLmRpc3BhdGNoU29ydGFibGVFdmVudCxcbiAgICAgICAgb2xkSW5kZXggPSBfcmVmMTIub2xkSW5kZXgsXG4gICAgICAgIHB1dFNvcnRhYmxlID0gX3JlZjEyLnB1dFNvcnRhYmxlO1xuICAgICAgdmFyIHRvU29ydGFibGUgPSBwdXRTb3J0YWJsZSB8fCB0aGlzLnNvcnRhYmxlO1xuICAgICAgaWYgKCFldnQpIHJldHVybjtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxuICAgICAgICBjaGlsZHJlbiA9IHBhcmVudEVsLmNoaWxkcmVuO1xuXG4gICAgICAvLyBNdWx0aS1kcmFnIHNlbGVjdGlvblxuICAgICAgaWYgKCFkcmFnU3RhcnRlZCkge1xuICAgICAgICBpZiAob3B0aW9ucy5tdWx0aURyYWdLZXkgJiYgIXRoaXMubXVsdGlEcmFnS2V5RG93bikge1xuICAgICAgICAgIHRoaXMuX2Rlc2VsZWN0TXVsdGlEcmFnKCk7XG4gICAgICAgIH1cbiAgICAgICAgdG9nZ2xlQ2xhc3MoZHJhZ0VsJDEsIG9wdGlvbnMuc2VsZWN0ZWRDbGFzcywgIX5tdWx0aURyYWdFbGVtZW50cy5pbmRleE9mKGRyYWdFbCQxKSk7XG4gICAgICAgIGlmICghfm11bHRpRHJhZ0VsZW1lbnRzLmluZGV4T2YoZHJhZ0VsJDEpKSB7XG4gICAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMucHVzaChkcmFnRWwkMSk7XG4gICAgICAgICAgZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICBzb3J0YWJsZTogc29ydGFibGUsXG4gICAgICAgICAgICByb290RWw6IHJvb3RFbCxcbiAgICAgICAgICAgIG5hbWU6ICdzZWxlY3QnLFxuICAgICAgICAgICAgdGFyZ2V0RWw6IGRyYWdFbCQxLFxuICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0XG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICAvLyBNb2RpZmllciBhY3RpdmF0ZWQsIHNlbGVjdCBmcm9tIGxhc3QgdG8gZHJhZ0VsXG4gICAgICAgICAgaWYgKGV2dC5zaGlmdEtleSAmJiBsYXN0TXVsdGlEcmFnU2VsZWN0ICYmIHNvcnRhYmxlLmVsLmNvbnRhaW5zKGxhc3RNdWx0aURyYWdTZWxlY3QpKSB7XG4gICAgICAgICAgICB2YXIgbGFzdEluZGV4ID0gaW5kZXgobGFzdE11bHRpRHJhZ1NlbGVjdCksXG4gICAgICAgICAgICAgIGN1cnJlbnRJbmRleCA9IGluZGV4KGRyYWdFbCQxKTtcbiAgICAgICAgICAgIGlmICh+bGFzdEluZGV4ICYmIH5jdXJyZW50SW5kZXggJiYgbGFzdEluZGV4ICE9PSBjdXJyZW50SW5kZXgpIHtcbiAgICAgICAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBNdXN0IGluY2x1ZGUgbGFzdE11bHRpRHJhZ1NlbGVjdCAoc2VsZWN0IGl0KSwgaW4gY2FzZSBtb2RpZmllZCBzZWxlY3Rpb24gZnJvbSBubyBzZWxlY3Rpb25cbiAgICAgICAgICAgICAgICAvLyAoYnV0IHByZXZpb3VzIHNlbGVjdGlvbiBleGlzdGVkKVxuICAgICAgICAgICAgICAgIHZhciBuLCBpO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50SW5kZXggPiBsYXN0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgIGkgPSBsYXN0SW5kZXg7XG4gICAgICAgICAgICAgICAgICBuID0gY3VycmVudEluZGV4O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBpID0gY3VycmVudEluZGV4O1xuICAgICAgICAgICAgICAgICAgbiA9IGxhc3RJbmRleCArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBmaWx0ZXIgPSBvcHRpb25zLmZpbHRlcjtcbiAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgICAgICAgaWYgKH5tdWx0aURyYWdFbGVtZW50cy5pbmRleE9mKGNoaWxkcmVuW2ldKSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBlbGVtZW50IGlzIGRyYWdnYWJsZVxuICAgICAgICAgICAgICAgICAgaWYgKCFjbG9zZXN0KGNoaWxkcmVuW2ldLCBvcHRpb25zLmRyYWdnYWJsZSwgcGFyZW50RWwsIGZhbHNlKSkgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiBlbGVtZW50IGlzIGZpbHRlcmVkXG4gICAgICAgICAgICAgICAgICB2YXIgZmlsdGVyZWQgPSBmaWx0ZXIgJiYgKHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicgPyBmaWx0ZXIuY2FsbChzb3J0YWJsZSwgZXZ0LCBjaGlsZHJlbltpXSwgc29ydGFibGUpIDogZmlsdGVyLnNwbGl0KCcsJykuc29tZShmdW5jdGlvbiAoY3JpdGVyaWEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNsb3Nlc3QoY2hpbGRyZW5baV0sIGNyaXRlcmlhLnRyaW0oKSwgcGFyZW50RWwsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJlZCkgY29udGludWU7XG4gICAgICAgICAgICAgICAgICB0b2dnbGVDbGFzcyhjaGlsZHJlbltpXSwgb3B0aW9ucy5zZWxlY3RlZENsYXNzLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLnB1c2goY2hpbGRyZW5baV0pO1xuICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hFdmVudCh7XG4gICAgICAgICAgICAgICAgICAgIHNvcnRhYmxlOiBzb3J0YWJsZSxcbiAgICAgICAgICAgICAgICAgICAgcm9vdEVsOiByb290RWwsXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6ICdzZWxlY3QnLFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRFbDogY2hpbGRyZW5baV0sXG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRXZlbnQ6IGV2dFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsYXN0TXVsdGlEcmFnU2VsZWN0ID0gZHJhZ0VsJDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIG11bHRpRHJhZ1NvcnRhYmxlID0gdG9Tb3J0YWJsZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5zcGxpY2UobXVsdGlEcmFnRWxlbWVudHMuaW5kZXhPZihkcmFnRWwkMSksIDEpO1xuICAgICAgICAgIGxhc3RNdWx0aURyYWdTZWxlY3QgPSBudWxsO1xuICAgICAgICAgIGRpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgICAgc29ydGFibGU6IHNvcnRhYmxlLFxuICAgICAgICAgICAgcm9vdEVsOiByb290RWwsXG4gICAgICAgICAgICBuYW1lOiAnZGVzZWxlY3QnLFxuICAgICAgICAgICAgdGFyZ2V0RWw6IGRyYWdFbCQxLFxuICAgICAgICAgICAgb3JpZ2luYWxFdmVudDogZXZ0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gTXVsdGktZHJhZyBkcm9wXG4gICAgICBpZiAoZHJhZ1N0YXJ0ZWQgJiYgdGhpcy5pc011bHRpRHJhZykge1xuICAgICAgICBmb2xkaW5nID0gZmFsc2U7XG4gICAgICAgIC8vIERvIG5vdCBcInVuZm9sZFwiIGFmdGVyIGFyb3VuZCBkcmFnRWwgaWYgcmV2ZXJ0ZWRcbiAgICAgICAgaWYgKChwYXJlbnRFbFtleHBhbmRvXS5vcHRpb25zLnNvcnQgfHwgcGFyZW50RWwgIT09IHJvb3RFbCkgJiYgbXVsdGlEcmFnRWxlbWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHZhciBkcmFnUmVjdCA9IGdldFJlY3QoZHJhZ0VsJDEpLFxuICAgICAgICAgICAgbXVsdGlEcmFnSW5kZXggPSBpbmRleChkcmFnRWwkMSwgJzpub3QoLicgKyB0aGlzLm9wdGlvbnMuc2VsZWN0ZWRDbGFzcyArICcpJyk7XG4gICAgICAgICAgaWYgKCFpbml0aWFsRm9sZGluZyAmJiBvcHRpb25zLmFuaW1hdGlvbikgZHJhZ0VsJDEudGhpc0FuaW1hdGlvbkR1cmF0aW9uID0gbnVsbDtcbiAgICAgICAgICB0b1NvcnRhYmxlLmNhcHR1cmVBbmltYXRpb25TdGF0ZSgpO1xuICAgICAgICAgIGlmICghaW5pdGlhbEZvbGRpbmcpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmFuaW1hdGlvbikge1xuICAgICAgICAgICAgICBkcmFnRWwkMS5mcm9tUmVjdCA9IGRyYWdSZWN0O1xuICAgICAgICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtdWx0aURyYWdFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgbXVsdGlEcmFnRWxlbWVudC50aGlzQW5pbWF0aW9uRHVyYXRpb24gPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChtdWx0aURyYWdFbGVtZW50ICE9PSBkcmFnRWwkMSkge1xuICAgICAgICAgICAgICAgICAgdmFyIHJlY3QgPSBmb2xkaW5nID8gZ2V0UmVjdChtdWx0aURyYWdFbGVtZW50KSA6IGRyYWdSZWN0O1xuICAgICAgICAgICAgICAgICAgbXVsdGlEcmFnRWxlbWVudC5mcm9tUmVjdCA9IHJlY3Q7XG5cbiAgICAgICAgICAgICAgICAgIC8vIFByZXBhcmUgdW5mb2xkIGFuaW1hdGlvblxuICAgICAgICAgICAgICAgICAgdG9Tb3J0YWJsZS5hZGRBbmltYXRpb25TdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogbXVsdGlEcmFnRWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgcmVjdDogcmVjdFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gTXVsdGkgZHJhZyBlbGVtZW50cyBhcmUgbm90IG5lY2Vzc2FyaWx5IHJlbW92ZWQgZnJvbSB0aGUgRE9NIG9uIGRyb3AsIHNvIHRvIHJlaW5zZXJ0XG4gICAgICAgICAgICAvLyBwcm9wZXJseSB0aGV5IG11c3QgYWxsIGJlIHJlbW92ZWRcbiAgICAgICAgICAgIHJlbW92ZU11bHRpRHJhZ0VsZW1lbnRzKCk7XG4gICAgICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtdWx0aURyYWdFbGVtZW50KSB7XG4gICAgICAgICAgICAgIGlmIChjaGlsZHJlblttdWx0aURyYWdJbmRleF0pIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRFbC5pbnNlcnRCZWZvcmUobXVsdGlEcmFnRWxlbWVudCwgY2hpbGRyZW5bbXVsdGlEcmFnSW5kZXhdKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRFbC5hcHBlbmRDaGlsZChtdWx0aURyYWdFbGVtZW50KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBtdWx0aURyYWdJbmRleCsrO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIElmIGluaXRpYWwgZm9sZGluZyBpcyBkb25lLCB0aGUgZWxlbWVudHMgbWF5IGhhdmUgY2hhbmdlZCBwb3NpdGlvbiBiZWNhdXNlIHRoZXkgYXJlIG5vd1xuICAgICAgICAgICAgLy8gdW5mb2xkaW5nIGFyb3VuZCBkcmFnRWwsIGV2ZW4gdGhvdWdoIGRyYWdFbCBtYXkgbm90IGhhdmUgaGlzIGluZGV4IGNoYW5nZWQsIHNvIHVwZGF0ZSBldmVudFxuICAgICAgICAgICAgLy8gbXVzdCBiZSBmaXJlZCBoZXJlIGFzIFNvcnRhYmxlIHdpbGwgbm90LlxuICAgICAgICAgICAgaWYgKG9sZEluZGV4ID09PSBpbmRleChkcmFnRWwkMSkpIHtcbiAgICAgICAgICAgICAgdmFyIHVwZGF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtdWx0aURyYWdFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKG11bHRpRHJhZ0VsZW1lbnQuc29ydGFibGVJbmRleCAhPT0gaW5kZXgobXVsdGlEcmFnRWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgIHVwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgaWYgKHVwZGF0ZSkge1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoU29ydGFibGVFdmVudCgndXBkYXRlJyk7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hTb3J0YWJsZUV2ZW50KCdzb3J0Jyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBNdXN0IGJlIGRvbmUgYWZ0ZXIgY2FwdHVyaW5nIGluZGl2aWR1YWwgcmVjdHMgKHNjcm9sbCBiYXIpXG4gICAgICAgICAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCkge1xuICAgICAgICAgICAgdW5zZXRSZWN0KG11bHRpRHJhZ0VsZW1lbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRvU29ydGFibGUuYW5pbWF0ZUFsbCgpO1xuICAgICAgICB9XG4gICAgICAgIG11bHRpRHJhZ1NvcnRhYmxlID0gdG9Tb3J0YWJsZTtcbiAgICAgIH1cblxuICAgICAgLy8gUmVtb3ZlIGNsb25lcyBpZiBuZWNlc3NhcnlcbiAgICAgIGlmIChyb290RWwgPT09IHBhcmVudEVsIHx8IHB1dFNvcnRhYmxlICYmIHB1dFNvcnRhYmxlLmxhc3RQdXRNb2RlICE9PSAnY2xvbmUnKSB7XG4gICAgICAgIG11bHRpRHJhZ0Nsb25lcy5mb3JFYWNoKGZ1bmN0aW9uIChjbG9uZSkge1xuICAgICAgICAgIGNsb25lLnBhcmVudE5vZGUgJiYgY2xvbmUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjbG9uZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgbnVsbGluZ0dsb2JhbDogZnVuY3Rpb24gbnVsbGluZ0dsb2JhbCgpIHtcbiAgICAgIHRoaXMuaXNNdWx0aURyYWcgPSBkcmFnU3RhcnRlZCA9IGZhbHNlO1xuICAgICAgbXVsdGlEcmFnQ2xvbmVzLmxlbmd0aCA9IDA7XG4gICAgfSxcbiAgICBkZXN0cm95R2xvYmFsOiBmdW5jdGlvbiBkZXN0cm95R2xvYmFsKCkge1xuICAgICAgdGhpcy5fZGVzZWxlY3RNdWx0aURyYWcoKTtcbiAgICAgIG9mZihkb2N1bWVudCwgJ3BvaW50ZXJ1cCcsIHRoaXMuX2Rlc2VsZWN0TXVsdGlEcmFnKTtcbiAgICAgIG9mZihkb2N1bWVudCwgJ21vdXNldXAnLCB0aGlzLl9kZXNlbGVjdE11bHRpRHJhZyk7XG4gICAgICBvZmYoZG9jdW1lbnQsICd0b3VjaGVuZCcsIHRoaXMuX2Rlc2VsZWN0TXVsdGlEcmFnKTtcbiAgICAgIG9mZihkb2N1bWVudCwgJ2tleWRvd24nLCB0aGlzLl9jaGVja0tleURvd24pO1xuICAgICAgb2ZmKGRvY3VtZW50LCAna2V5dXAnLCB0aGlzLl9jaGVja0tleVVwKTtcbiAgICB9LFxuICAgIF9kZXNlbGVjdE11bHRpRHJhZzogZnVuY3Rpb24gX2Rlc2VsZWN0TXVsdGlEcmFnKGV2dCkge1xuICAgICAgaWYgKHR5cGVvZiBkcmFnU3RhcnRlZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkcmFnU3RhcnRlZCkgcmV0dXJuO1xuXG4gICAgICAvLyBPbmx5IGRlc2VsZWN0IGlmIHNlbGVjdGlvbiBpcyBpbiB0aGlzIHNvcnRhYmxlXG4gICAgICBpZiAobXVsdGlEcmFnU29ydGFibGUgIT09IHRoaXMuc29ydGFibGUpIHJldHVybjtcblxuICAgICAgLy8gT25seSBkZXNlbGVjdCBpZiB0YXJnZXQgaXMgbm90IGl0ZW0gaW4gdGhpcyBzb3J0YWJsZVxuICAgICAgaWYgKGV2dCAmJiBjbG9zZXN0KGV2dC50YXJnZXQsIHRoaXMub3B0aW9ucy5kcmFnZ2FibGUsIHRoaXMuc29ydGFibGUuZWwsIGZhbHNlKSkgcmV0dXJuO1xuXG4gICAgICAvLyBPbmx5IGRlc2VsZWN0IGlmIGxlZnQgY2xpY2tcbiAgICAgIGlmIChldnQgJiYgZXZ0LmJ1dHRvbiAhPT0gMCkgcmV0dXJuO1xuICAgICAgd2hpbGUgKG11bHRpRHJhZ0VsZW1lbnRzLmxlbmd0aCkge1xuICAgICAgICB2YXIgZWwgPSBtdWx0aURyYWdFbGVtZW50c1swXTtcbiAgICAgICAgdG9nZ2xlQ2xhc3MoZWwsIHRoaXMub3B0aW9ucy5zZWxlY3RlZENsYXNzLCBmYWxzZSk7XG4gICAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLnNoaWZ0KCk7XG4gICAgICAgIGRpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgIHNvcnRhYmxlOiB0aGlzLnNvcnRhYmxlLFxuICAgICAgICAgIHJvb3RFbDogdGhpcy5zb3J0YWJsZS5lbCxcbiAgICAgICAgICBuYW1lOiAnZGVzZWxlY3QnLFxuICAgICAgICAgIHRhcmdldEVsOiBlbCxcbiAgICAgICAgICBvcmlnaW5hbEV2ZW50OiBldnRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBfY2hlY2tLZXlEb3duOiBmdW5jdGlvbiBfY2hlY2tLZXlEb3duKGV2dCkge1xuICAgICAgaWYgKGV2dC5rZXkgPT09IHRoaXMub3B0aW9ucy5tdWx0aURyYWdLZXkpIHtcbiAgICAgICAgdGhpcy5tdWx0aURyYWdLZXlEb3duID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIF9jaGVja0tleVVwOiBmdW5jdGlvbiBfY2hlY2tLZXlVcChldnQpIHtcbiAgICAgIGlmIChldnQua2V5ID09PSB0aGlzLm9wdGlvbnMubXVsdGlEcmFnS2V5KSB7XG4gICAgICAgIHRoaXMubXVsdGlEcmFnS2V5RG93biA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIF9leHRlbmRzKE11bHRpRHJhZywge1xuICAgIC8vIFN0YXRpYyBtZXRob2RzICYgcHJvcGVydGllc1xuICAgIHBsdWdpbk5hbWU6ICdtdWx0aURyYWcnLFxuICAgIHV0aWxzOiB7XG4gICAgICAvKipcclxuICAgICAgICogU2VsZWN0cyB0aGUgcHJvdmlkZWQgbXVsdGktZHJhZyBpdGVtXHJcbiAgICAgICAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSBlbCAgICBUaGUgZWxlbWVudCB0byBiZSBzZWxlY3RlZFxyXG4gICAgICAgKi9cbiAgICAgIHNlbGVjdDogZnVuY3Rpb24gc2VsZWN0KGVsKSB7XG4gICAgICAgIHZhciBzb3J0YWJsZSA9IGVsLnBhcmVudE5vZGVbZXhwYW5kb107XG4gICAgICAgIGlmICghc29ydGFibGUgfHwgIXNvcnRhYmxlLm9wdGlvbnMubXVsdGlEcmFnIHx8IH5tdWx0aURyYWdFbGVtZW50cy5pbmRleE9mKGVsKSkgcmV0dXJuO1xuICAgICAgICBpZiAobXVsdGlEcmFnU29ydGFibGUgJiYgbXVsdGlEcmFnU29ydGFibGUgIT09IHNvcnRhYmxlKSB7XG4gICAgICAgICAgbXVsdGlEcmFnU29ydGFibGUubXVsdGlEcmFnLl9kZXNlbGVjdE11bHRpRHJhZygpO1xuICAgICAgICAgIG11bHRpRHJhZ1NvcnRhYmxlID0gc29ydGFibGU7XG4gICAgICAgIH1cbiAgICAgICAgdG9nZ2xlQ2xhc3MoZWwsIHNvcnRhYmxlLm9wdGlvbnMuc2VsZWN0ZWRDbGFzcywgdHJ1ZSk7XG4gICAgICAgIG11bHRpRHJhZ0VsZW1lbnRzLnB1c2goZWwpO1xuICAgICAgfSxcbiAgICAgIC8qKlxyXG4gICAgICAgKiBEZXNlbGVjdHMgdGhlIHByb3ZpZGVkIG11bHRpLWRyYWcgaXRlbVxyXG4gICAgICAgKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gZWwgICAgVGhlIGVsZW1lbnQgdG8gYmUgZGVzZWxlY3RlZFxyXG4gICAgICAgKi9cbiAgICAgIGRlc2VsZWN0OiBmdW5jdGlvbiBkZXNlbGVjdChlbCkge1xuICAgICAgICB2YXIgc29ydGFibGUgPSBlbC5wYXJlbnROb2RlW2V4cGFuZG9dLFxuICAgICAgICAgIGluZGV4ID0gbXVsdGlEcmFnRWxlbWVudHMuaW5kZXhPZihlbCk7XG4gICAgICAgIGlmICghc29ydGFibGUgfHwgIXNvcnRhYmxlLm9wdGlvbnMubXVsdGlEcmFnIHx8ICF+aW5kZXgpIHJldHVybjtcbiAgICAgICAgdG9nZ2xlQ2xhc3MoZWwsIHNvcnRhYmxlLm9wdGlvbnMuc2VsZWN0ZWRDbGFzcywgZmFsc2UpO1xuICAgICAgICBtdWx0aURyYWdFbGVtZW50cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZXZlbnRQcm9wZXJ0aWVzOiBmdW5jdGlvbiBldmVudFByb3BlcnRpZXMoKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgIHZhciBvbGRJbmRpY2llcyA9IFtdLFxuICAgICAgICBuZXdJbmRpY2llcyA9IFtdO1xuICAgICAgbXVsdGlEcmFnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobXVsdGlEcmFnRWxlbWVudCkge1xuICAgICAgICBvbGRJbmRpY2llcy5wdXNoKHtcbiAgICAgICAgICBtdWx0aURyYWdFbGVtZW50OiBtdWx0aURyYWdFbGVtZW50LFxuICAgICAgICAgIGluZGV4OiBtdWx0aURyYWdFbGVtZW50LnNvcnRhYmxlSW5kZXhcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gbXVsdGlEcmFnRWxlbWVudHMgd2lsbCBhbHJlYWR5IGJlIHNvcnRlZCBpZiBmb2xkaW5nXG4gICAgICAgIHZhciBuZXdJbmRleDtcbiAgICAgICAgaWYgKGZvbGRpbmcgJiYgbXVsdGlEcmFnRWxlbWVudCAhPT0gZHJhZ0VsJDEpIHtcbiAgICAgICAgICBuZXdJbmRleCA9IC0xO1xuICAgICAgICB9IGVsc2UgaWYgKGZvbGRpbmcpIHtcbiAgICAgICAgICBuZXdJbmRleCA9IGluZGV4KG11bHRpRHJhZ0VsZW1lbnQsICc6bm90KC4nICsgX3RoaXMzLm9wdGlvbnMuc2VsZWN0ZWRDbGFzcyArICcpJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3SW5kZXggPSBpbmRleChtdWx0aURyYWdFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBuZXdJbmRpY2llcy5wdXNoKHtcbiAgICAgICAgICBtdWx0aURyYWdFbGVtZW50OiBtdWx0aURyYWdFbGVtZW50LFxuICAgICAgICAgIGluZGV4OiBuZXdJbmRleFxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaXRlbXM6IF90b0NvbnN1bWFibGVBcnJheShtdWx0aURyYWdFbGVtZW50cyksXG4gICAgICAgIGNsb25lczogW10uY29uY2F0KG11bHRpRHJhZ0Nsb25lcyksXG4gICAgICAgIG9sZEluZGljaWVzOiBvbGRJbmRpY2llcyxcbiAgICAgICAgbmV3SW5kaWNpZXM6IG5ld0luZGljaWVzXG4gICAgICB9O1xuICAgIH0sXG4gICAgb3B0aW9uTGlzdGVuZXJzOiB7XG4gICAgICBtdWx0aURyYWdLZXk6IGZ1bmN0aW9uIG11bHRpRHJhZ0tleShrZXkpIHtcbiAgICAgICAga2V5ID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChrZXkgPT09ICdjdHJsJykge1xuICAgICAgICAgIGtleSA9ICdDb250cm9sJztcbiAgICAgICAgfSBlbHNlIGlmIChrZXkubGVuZ3RoID4gMSkge1xuICAgICAgICAgIGtleSA9IGtleS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGtleS5zdWJzdHIoMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGtleTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gaW5zZXJ0TXVsdGlEcmFnRWxlbWVudHMoY2xvbmVzSW5zZXJ0ZWQsIHJvb3RFbCkge1xuICBtdWx0aURyYWdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtdWx0aURyYWdFbGVtZW50LCBpKSB7XG4gICAgdmFyIHRhcmdldCA9IHJvb3RFbC5jaGlsZHJlblttdWx0aURyYWdFbGVtZW50LnNvcnRhYmxlSW5kZXggKyAoY2xvbmVzSW5zZXJ0ZWQgPyBOdW1iZXIoaSkgOiAwKV07XG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgcm9vdEVsLmluc2VydEJlZm9yZShtdWx0aURyYWdFbGVtZW50LCB0YXJnZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByb290RWwuYXBwZW5kQ2hpbGQobXVsdGlEcmFnRWxlbWVudCk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXHJcbiAqIEluc2VydCBtdWx0aS1kcmFnIGNsb25lc1xyXG4gKiBAcGFyYW0gIHtbQm9vbGVhbl19IGVsZW1lbnRzSW5zZXJ0ZWQgIFdoZXRoZXIgdGhlIG11bHRpLWRyYWcgZWxlbWVudHMgYXJlIGluc2VydGVkXHJcbiAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSByb290RWxcclxuICovXG5mdW5jdGlvbiBpbnNlcnRNdWx0aURyYWdDbG9uZXMoZWxlbWVudHNJbnNlcnRlZCwgcm9vdEVsKSB7XG4gIG11bHRpRHJhZ0Nsb25lcy5mb3JFYWNoKGZ1bmN0aW9uIChjbG9uZSwgaSkge1xuICAgIHZhciB0YXJnZXQgPSByb290RWwuY2hpbGRyZW5bY2xvbmUuc29ydGFibGVJbmRleCArIChlbGVtZW50c0luc2VydGVkID8gTnVtYmVyKGkpIDogMCldO1xuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIHJvb3RFbC5pbnNlcnRCZWZvcmUoY2xvbmUsIHRhcmdldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJvb3RFbC5hcHBlbmRDaGlsZChjbG9uZSk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHJlbW92ZU11bHRpRHJhZ0VsZW1lbnRzKCkge1xuICBtdWx0aURyYWdFbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtdWx0aURyYWdFbGVtZW50KSB7XG4gICAgaWYgKG11bHRpRHJhZ0VsZW1lbnQgPT09IGRyYWdFbCQxKSByZXR1cm47XG4gICAgbXVsdGlEcmFnRWxlbWVudC5wYXJlbnROb2RlICYmIG11bHRpRHJhZ0VsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChtdWx0aURyYWdFbGVtZW50KTtcbiAgfSk7XG59XG5cblNvcnRhYmxlLm1vdW50KG5ldyBBdXRvU2Nyb2xsUGx1Z2luKCkpO1xuU29ydGFibGUubW91bnQoUmVtb3ZlLCBSZXZlcnQpO1xuXG5leHBvcnQgZGVmYXVsdCBTb3J0YWJsZTtcbmV4cG9ydCB7IE11bHRpRHJhZ1BsdWdpbiBhcyBNdWx0aURyYWcsIFNvcnRhYmxlLCBTd2FwUGx1Z2luIGFzIFN3YXAgfTtcbiIsIi8qIVxuKiB0YWJiYWJsZSA2LjIuMFxuKiBAbGljZW5zZSBNSVQsIGh0dHBzOi8vZ2l0aHViLmNvbS9mb2N1cy10cmFwL3RhYmJhYmxlL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiovXG4vLyBOT1RFOiBzZXBhcmF0ZSBgOm5vdCgpYCBzZWxlY3RvcnMgaGFzIGJyb2FkZXIgYnJvd3NlciBzdXBwb3J0IHRoYW4gdGhlIG5ld2VyXG4vLyAgYDpub3QoW2luZXJ0XSwgW2luZXJ0XSAqKWAgKEZlYiAyMDIzKVxuLy8gQ0FSRUZVTDogSlNEb20gZG9lcyBub3Qgc3VwcG9ydCBgOm5vdChbaW5lcnRdICopYCBhcyBhIHNlbGVjdG9yOyB1c2luZyBpdCBjYXVzZXNcbi8vICB0aGUgZW50aXJlIHF1ZXJ5IHRvIGZhaWwsIHJlc3VsdGluZyBpbiBubyBub2RlcyBmb3VuZCwgd2hpY2ggd2lsbCBicmVhayBhIGxvdFxuLy8gIG9mIHRoaW5ncy4uLiBzbyB3ZSBoYXZlIHRvIHJlbHkgb24gSlMgdG8gaWRlbnRpZnkgbm9kZXMgaW5zaWRlIGFuIGluZXJ0IGNvbnRhaW5lclxudmFyIGNhbmRpZGF0ZVNlbGVjdG9ycyA9IFsnaW5wdXQ6bm90KFtpbmVydF0pJywgJ3NlbGVjdDpub3QoW2luZXJ0XSknLCAndGV4dGFyZWE6bm90KFtpbmVydF0pJywgJ2FbaHJlZl06bm90KFtpbmVydF0pJywgJ2J1dHRvbjpub3QoW2luZXJ0XSknLCAnW3RhYmluZGV4XTpub3Qoc2xvdCk6bm90KFtpbmVydF0pJywgJ2F1ZGlvW2NvbnRyb2xzXTpub3QoW2luZXJ0XSknLCAndmlkZW9bY29udHJvbHNdOm5vdChbaW5lcnRdKScsICdbY29udGVudGVkaXRhYmxlXTpub3QoW2NvbnRlbnRlZGl0YWJsZT1cImZhbHNlXCJdKTpub3QoW2luZXJ0XSknLCAnZGV0YWlscz5zdW1tYXJ5OmZpcnN0LW9mLXR5cGU6bm90KFtpbmVydF0pJywgJ2RldGFpbHM6bm90KFtpbmVydF0pJ107XG52YXIgY2FuZGlkYXRlU2VsZWN0b3IgPSAvKiAjX19QVVJFX18gKi9jYW5kaWRhdGVTZWxlY3RvcnMuam9pbignLCcpO1xudmFyIE5vRWxlbWVudCA9IHR5cGVvZiBFbGVtZW50ID09PSAndW5kZWZpbmVkJztcbnZhciBtYXRjaGVzID0gTm9FbGVtZW50ID8gZnVuY3Rpb24gKCkge30gOiBFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzIHx8IEVsZW1lbnQucHJvdG90eXBlLm1zTWF0Y2hlc1NlbGVjdG9yIHx8IEVsZW1lbnQucHJvdG90eXBlLndlYmtpdE1hdGNoZXNTZWxlY3RvcjtcbnZhciBnZXRSb290Tm9kZSA9ICFOb0VsZW1lbnQgJiYgRWxlbWVudC5wcm90b3R5cGUuZ2V0Um9vdE5vZGUgPyBmdW5jdGlvbiAoZWxlbWVudCkge1xuICB2YXIgX2VsZW1lbnQkZ2V0Um9vdE5vZGU7XG4gIHJldHVybiBlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfZWxlbWVudCRnZXRSb290Tm9kZSA9IGVsZW1lbnQuZ2V0Um9vdE5vZGUpID09PSBudWxsIHx8IF9lbGVtZW50JGdldFJvb3ROb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZWxlbWVudCRnZXRSb290Tm9kZS5jYWxsKGVsZW1lbnQpO1xufSA6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gIHJldHVybiBlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVsZW1lbnQub3duZXJEb2N1bWVudDtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBhIG5vZGUgaXMgaW5lcnQgb3IgaW4gYW4gaW5lcnQgYW5jZXN0b3IuXG4gKiBAcGFyYW0ge0VsZW1lbnR9IFtub2RlXVxuICogQHBhcmFtIHtib29sZWFufSBbbG9va1VwXSBJZiB0cnVlIGFuZCBgbm9kZWAgaXMgbm90IGluZXJ0LCBsb29rcyB1cCBhdCBhbmNlc3RvcnMgdG9cbiAqICBzZWUgaWYgYW55IG9mIHRoZW0gYXJlIGluZXJ0LiBJZiBmYWxzZSwgb25seSBgbm9kZWAgaXRzZWxmIGlzIGNvbnNpZGVyZWQuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBpbmVydCBpdHNlbGYgb3IgYnkgd2F5IG9mIGJlaW5nIGluIGFuIGluZXJ0IGFuY2VzdG9yLlxuICogIEZhbHNlIGlmIGBub2RlYCBpcyBmYWxzeS5cbiAqL1xudmFyIGlzSW5lcnQgPSBmdW5jdGlvbiBpc0luZXJ0KG5vZGUsIGxvb2tVcCkge1xuICB2YXIgX25vZGUkZ2V0QXR0cmlidXRlO1xuICBpZiAobG9va1VwID09PSB2b2lkIDApIHtcbiAgICBsb29rVXAgPSB0cnVlO1xuICB9XG4gIC8vIENBUkVGVUw6IEpTRG9tIGRvZXMgbm90IHN1cHBvcnQgaW5lcnQgYXQgYWxsLCBzbyB3ZSBjYW4ndCB1c2UgdGhlIGBIVE1MRWxlbWVudC5pbmVydGBcbiAgLy8gIEpTIEFQSSBwcm9wZXJ0eTsgd2UgaGF2ZSB0byBjaGVjayB0aGUgYXR0cmlidXRlLCB3aGljaCBjYW4gZWl0aGVyIGJlIGVtcHR5IG9yICd0cnVlJztcbiAgLy8gIGlmIGl0J3MgYG51bGxgIChub3Qgc3BlY2lmaWVkKSBvciAnZmFsc2UnLCBpdCdzIGFuIGFjdGl2ZSBlbGVtZW50XG4gIHZhciBpbmVydEF0dCA9IG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9ub2RlJGdldEF0dHJpYnV0ZSA9IG5vZGUuZ2V0QXR0cmlidXRlKSA9PT0gbnVsbCB8fCBfbm9kZSRnZXRBdHRyaWJ1dGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9ub2RlJGdldEF0dHJpYnV0ZS5jYWxsKG5vZGUsICdpbmVydCcpO1xuICB2YXIgaW5lcnQgPSBpbmVydEF0dCA9PT0gJycgfHwgaW5lcnRBdHQgPT09ICd0cnVlJztcblxuICAvLyBOT1RFOiB0aGlzIGNvdWxkIGFsc28gYmUgaGFuZGxlZCB3aXRoIGBub2RlLm1hdGNoZXMoJ1tpbmVydF0sIDppcyhbaW5lcnRdICopJylgXG4gIC8vICBpZiBpdCB3ZXJlbid0IGZvciBgbWF0Y2hlcygpYCBub3QgYmVpbmcgYSBmdW5jdGlvbiBvbiBzaGFkb3cgcm9vdHM7IHRoZSBmb2xsb3dpbmdcbiAgLy8gIGNvZGUgd29ya3MgZm9yIGFueSBraW5kIG9mIG5vZGVcbiAgLy8gQ0FSRUZVTDogSlNEb20gZG9lcyBub3QgYXBwZWFyIHRvIHN1cHBvcnQgY2VydGFpbiBzZWxlY3RvcnMgbGlrZSBgOm5vdChbaW5lcnRdICopYFxuICAvLyAgc28gaXQgbGlrZWx5IHdvdWxkIG5vdCBzdXBwb3J0IGA6aXMoW2luZXJ0XSAqKWAgZWl0aGVyLi4uXG4gIHZhciByZXN1bHQgPSBpbmVydCB8fCBsb29rVXAgJiYgbm9kZSAmJiBpc0luZXJ0KG5vZGUucGFyZW50Tm9kZSk7IC8vIHJlY3Vyc2l2ZVxuXG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgYSBub2RlJ3MgY29udGVudCBpcyBlZGl0YWJsZS5cbiAqIEBwYXJhbSB7RWxlbWVudH0gW25vZGVdXG4gKiBAcmV0dXJucyBUcnVlIGlmIGl0J3MgY29udGVudC1lZGl0YWJsZTsgZmFsc2UgaWYgaXQncyBub3Qgb3IgYG5vZGVgIGlzIGZhbHN5LlxuICovXG52YXIgaXNDb250ZW50RWRpdGFibGUgPSBmdW5jdGlvbiBpc0NvbnRlbnRFZGl0YWJsZShub2RlKSB7XG4gIHZhciBfbm9kZSRnZXRBdHRyaWJ1dGUyO1xuICAvLyBDQVJFRlVMOiBKU0RvbSBkb2VzIG5vdCBzdXBwb3J0IHRoZSBgSFRNTEVsZW1lbnQuaXNDb250ZW50RWRpdGFibGVgIEFQSSBzbyB3ZSBoYXZlXG4gIC8vICB0byB1c2UgdGhlIGF0dHJpYnV0ZSBkaXJlY3RseSB0byBjaGVjayBmb3IgdGhpcywgd2hpY2ggY2FuIGVpdGhlciBiZSBlbXB0eSBvciAndHJ1ZSc7XG4gIC8vICBpZiBpdCdzIGBudWxsYCAobm90IHNwZWNpZmllZCkgb3IgJ2ZhbHNlJywgaXQncyBhIG5vbi1lZGl0YWJsZSBlbGVtZW50XG4gIHZhciBhdHRWYWx1ZSA9IG5vZGUgPT09IG51bGwgfHwgbm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9ub2RlJGdldEF0dHJpYnV0ZTIgPSBub2RlLmdldEF0dHJpYnV0ZSkgPT09IG51bGwgfHwgX25vZGUkZ2V0QXR0cmlidXRlMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25vZGUkZ2V0QXR0cmlidXRlMi5jYWxsKG5vZGUsICdjb250ZW50ZWRpdGFibGUnKTtcbiAgcmV0dXJuIGF0dFZhbHVlID09PSAnJyB8fCBhdHRWYWx1ZSA9PT0gJ3RydWUnO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsIGNvbnRhaW5lciB0byBjaGVjayBpblxuICogQHBhcmFtIHtib29sZWFufSBpbmNsdWRlQ29udGFpbmVyIGFkZCBjb250YWluZXIgdG8gY2hlY2tcbiAqIEBwYXJhbSB7KG5vZGU6IEVsZW1lbnQpID0+IGJvb2xlYW59IGZpbHRlciBmaWx0ZXIgY2FuZGlkYXRlc1xuICogQHJldHVybnMge0VsZW1lbnRbXX1cbiAqL1xudmFyIGdldENhbmRpZGF0ZXMgPSBmdW5jdGlvbiBnZXRDYW5kaWRhdGVzKGVsLCBpbmNsdWRlQ29udGFpbmVyLCBmaWx0ZXIpIHtcbiAgLy8gZXZlbiBpZiBgaW5jbHVkZUNvbnRhaW5lcj1mYWxzZWAsIHdlIHN0aWxsIGhhdmUgdG8gY2hlY2sgaXQgZm9yIGluZXJ0bmVzcyBiZWNhdXNlXG4gIC8vICBpZiBpdCdzIGluZXJ0LCBhbGwgaXRzIGNoaWxkcmVuIGFyZSBpbmVydFxuICBpZiAoaXNJbmVydChlbCkpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgdmFyIGNhbmRpZGF0ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoZWwucXVlcnlTZWxlY3RvckFsbChjYW5kaWRhdGVTZWxlY3RvcikpO1xuICBpZiAoaW5jbHVkZUNvbnRhaW5lciAmJiBtYXRjaGVzLmNhbGwoZWwsIGNhbmRpZGF0ZVNlbGVjdG9yKSkge1xuICAgIGNhbmRpZGF0ZXMudW5zaGlmdChlbCk7XG4gIH1cbiAgY2FuZGlkYXRlcyA9IGNhbmRpZGF0ZXMuZmlsdGVyKGZpbHRlcik7XG4gIHJldHVybiBjYW5kaWRhdGVzO1xufTtcblxuLyoqXG4gKiBAY2FsbGJhY2sgR2V0U2hhZG93Um9vdFxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IHRvIGNoZWNrIGZvciBzaGFkb3cgcm9vdFxuICogQHJldHVybnMge1NoYWRvd1Jvb3R8Ym9vbGVhbn0gU2hhZG93Um9vdCBpZiBhdmFpbGFibGUgb3IgYm9vbGVhbiBpbmRpY2F0aW5nIGlmIGEgc2hhZG93Um9vdCBpcyBhdHRhY2hlZCBidXQgbm90IGF2YWlsYWJsZS5cbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBTaGFkb3dSb290RmlsdGVyXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHNoYWRvd0hvc3ROb2RlIHRoZSBlbGVtZW50IHdoaWNoIGNvbnRhaW5zIHNoYWRvdyBjb250ZW50XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBhIHNoYWRvdyByb290IGNvdWxkIHBvdGVudGlhbGx5IGNvbnRhaW4gdmFsaWQgY2FuZGlkYXRlcy5cbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHtPYmplY3R9IENhbmRpZGF0ZVNjb3BlXG4gKiBAcHJvcGVydHkge0VsZW1lbnR9IHNjb3BlUGFyZW50IGNvbnRhaW5zIGlubmVyIGNhbmRpZGF0ZXNcbiAqIEBwcm9wZXJ0eSB7RWxlbWVudFtdfSBjYW5kaWRhdGVzIGxpc3Qgb2YgY2FuZGlkYXRlcyBmb3VuZCBpbiB0aGUgc2NvcGUgcGFyZW50XG4gKi9cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBJdGVyYXRpdmVPcHRpb25zXG4gKiBAcHJvcGVydHkge0dldFNoYWRvd1Jvb3R8Ym9vbGVhbn0gZ2V0U2hhZG93Um9vdCB0cnVlIGlmIHNoYWRvdyBzdXBwb3J0IGlzIGVuYWJsZWQ7IGZhbHN5IGlmIG5vdDtcbiAqICBpZiBhIGZ1bmN0aW9uLCBpbXBsaWVzIHNoYWRvdyBzdXBwb3J0IGlzIGVuYWJsZWQgYW5kIGVpdGhlciByZXR1cm5zIHRoZSBzaGFkb3cgcm9vdCBvZiBhbiBlbGVtZW50XG4gKiAgb3IgYSBib29sZWFuIHN0YXRpbmcgaWYgaXQgaGFzIGFuIHVuZGlzY2xvc2VkIHNoYWRvdyByb290XG4gKiBAcHJvcGVydHkgeyhub2RlOiBFbGVtZW50KSA9PiBib29sZWFufSBmaWx0ZXIgZmlsdGVyIGNhbmRpZGF0ZXNcbiAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gZmxhdHRlbiBpZiB0cnVlIHRoZW4gcmVzdWx0IHdpbGwgZmxhdHRlbiBhbnkgQ2FuZGlkYXRlU2NvcGUgaW50byB0aGUgcmV0dXJuZWQgbGlzdFxuICogQHByb3BlcnR5IHtTaGFkb3dSb290RmlsdGVyfSBzaGFkb3dSb290RmlsdGVyIGZpbHRlciBzaGFkb3cgcm9vdHM7XG4gKi9cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnRbXX0gZWxlbWVudHMgbGlzdCBvZiBlbGVtZW50IGNvbnRhaW5lcnMgdG8gbWF0Y2ggY2FuZGlkYXRlcyBmcm9tXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGluY2x1ZGVDb250YWluZXIgYWRkIGNvbnRhaW5lciBsaXN0IHRvIGNoZWNrXG4gKiBAcGFyYW0ge0l0ZXJhdGl2ZU9wdGlvbnN9IG9wdGlvbnNcbiAqIEByZXR1cm5zIHtBcnJheS48RWxlbWVudHxDYW5kaWRhdGVTY29wZT59XG4gKi9cbnZhciBnZXRDYW5kaWRhdGVzSXRlcmF0aXZlbHkgPSBmdW5jdGlvbiBnZXRDYW5kaWRhdGVzSXRlcmF0aXZlbHkoZWxlbWVudHMsIGluY2x1ZGVDb250YWluZXIsIG9wdGlvbnMpIHtcbiAgdmFyIGNhbmRpZGF0ZXMgPSBbXTtcbiAgdmFyIGVsZW1lbnRzVG9DaGVjayA9IEFycmF5LmZyb20oZWxlbWVudHMpO1xuICB3aGlsZSAoZWxlbWVudHNUb0NoZWNrLmxlbmd0aCkge1xuICAgIHZhciBlbGVtZW50ID0gZWxlbWVudHNUb0NoZWNrLnNoaWZ0KCk7XG4gICAgaWYgKGlzSW5lcnQoZWxlbWVudCwgZmFsc2UpKSB7XG4gICAgICAvLyBubyBuZWVkIHRvIGxvb2sgdXAgc2luY2Ugd2UncmUgZHJpbGxpbmcgZG93blxuICAgICAgLy8gYW55dGhpbmcgaW5zaWRlIHRoaXMgY29udGFpbmVyIHdpbGwgYWxzbyBiZSBpbmVydFxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChlbGVtZW50LnRhZ05hbWUgPT09ICdTTE9UJykge1xuICAgICAgLy8gYWRkIHNoYWRvdyBkb20gc2xvdCBzY29wZSAoc2xvdCBpdHNlbGYgY2Fubm90IGJlIGZvY3VzYWJsZSlcbiAgICAgIHZhciBhc3NpZ25lZCA9IGVsZW1lbnQuYXNzaWduZWRFbGVtZW50cygpO1xuICAgICAgdmFyIGNvbnRlbnQgPSBhc3NpZ25lZC5sZW5ndGggPyBhc3NpZ25lZCA6IGVsZW1lbnQuY2hpbGRyZW47XG4gICAgICB2YXIgbmVzdGVkQ2FuZGlkYXRlcyA9IGdldENhbmRpZGF0ZXNJdGVyYXRpdmVseShjb250ZW50LCB0cnVlLCBvcHRpb25zKTtcbiAgICAgIGlmIChvcHRpb25zLmZsYXR0ZW4pIHtcbiAgICAgICAgY2FuZGlkYXRlcy5wdXNoLmFwcGx5KGNhbmRpZGF0ZXMsIG5lc3RlZENhbmRpZGF0ZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FuZGlkYXRlcy5wdXNoKHtcbiAgICAgICAgICBzY29wZVBhcmVudDogZWxlbWVudCxcbiAgICAgICAgICBjYW5kaWRhdGVzOiBuZXN0ZWRDYW5kaWRhdGVzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjaGVjayBjYW5kaWRhdGUgZWxlbWVudFxuICAgICAgdmFyIHZhbGlkQ2FuZGlkYXRlID0gbWF0Y2hlcy5jYWxsKGVsZW1lbnQsIGNhbmRpZGF0ZVNlbGVjdG9yKTtcbiAgICAgIGlmICh2YWxpZENhbmRpZGF0ZSAmJiBvcHRpb25zLmZpbHRlcihlbGVtZW50KSAmJiAoaW5jbHVkZUNvbnRhaW5lciB8fCAhZWxlbWVudHMuaW5jbHVkZXMoZWxlbWVudCkpKSB7XG4gICAgICAgIGNhbmRpZGF0ZXMucHVzaChlbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgLy8gaXRlcmF0ZSBvdmVyIHNoYWRvdyBjb250ZW50IGlmIHBvc3NpYmxlXG4gICAgICB2YXIgc2hhZG93Um9vdCA9IGVsZW1lbnQuc2hhZG93Um9vdCB8fFxuICAgICAgLy8gY2hlY2sgZm9yIGFuIHVuZGlzY2xvc2VkIHNoYWRvd1xuICAgICAgdHlwZW9mIG9wdGlvbnMuZ2V0U2hhZG93Um9vdCA9PT0gJ2Z1bmN0aW9uJyAmJiBvcHRpb25zLmdldFNoYWRvd1Jvb3QoZWxlbWVudCk7XG5cbiAgICAgIC8vIG5vIGluZXJ0IGxvb2sgdXAgYmVjYXVzZSB3ZSdyZSBhbHJlYWR5IGRyaWxsaW5nIGRvd24gYW5kIGNoZWNraW5nIGZvciBpbmVydG5lc3NcbiAgICAgIC8vICBvbiB0aGUgd2F5IGRvd24sIHNvIGFsbCBjb250YWluZXJzIHRvIHRoaXMgcm9vdCBub2RlIHNob3VsZCBoYXZlIGFscmVhZHkgYmVlblxuICAgICAgLy8gIHZldHRlZCBhcyBub24taW5lcnRcbiAgICAgIHZhciB2YWxpZFNoYWRvd1Jvb3QgPSAhaXNJbmVydChzaGFkb3dSb290LCBmYWxzZSkgJiYgKCFvcHRpb25zLnNoYWRvd1Jvb3RGaWx0ZXIgfHwgb3B0aW9ucy5zaGFkb3dSb290RmlsdGVyKGVsZW1lbnQpKTtcbiAgICAgIGlmIChzaGFkb3dSb290ICYmIHZhbGlkU2hhZG93Um9vdCkge1xuICAgICAgICAvLyBhZGQgc2hhZG93IGRvbSBzY29wZSBJSUYgYSBzaGFkb3cgcm9vdCBub2RlIHdhcyBnaXZlbjsgb3RoZXJ3aXNlLCBhbiB1bmRpc2Nsb3NlZFxuICAgICAgICAvLyAgc2hhZG93IGV4aXN0cywgc28gbG9vayBhdCBsaWdodCBkb20gY2hpbGRyZW4gYXMgZmFsbGJhY2sgQlVUIGNyZWF0ZSBhIHNjb3BlIGZvciBhbnlcbiAgICAgICAgLy8gIGNoaWxkIGNhbmRpZGF0ZXMgZm91bmQgYmVjYXVzZSB0aGV5J3JlIGxpa2VseSBzbG90dGVkIGVsZW1lbnRzIChlbGVtZW50cyB0aGF0IGFyZVxuICAgICAgICAvLyAgY2hpbGRyZW4gb2YgdGhlIHdlYiBjb21wb25lbnQgZWxlbWVudCAod2hpY2ggaGFzIHRoZSBzaGFkb3cpLCBpbiB0aGUgbGlnaHQgZG9tLCBidXRcbiAgICAgICAgLy8gIHNsb3R0ZWQgc29tZXdoZXJlIF9pbnNpZGVfIHRoZSB1bmRpc2Nsb3NlZCBzaGFkb3cpIC0tIHRoZSBzY29wZSBpcyBjcmVhdGVkIGJlbG93LFxuICAgICAgICAvLyAgX2FmdGVyXyB3ZSByZXR1cm4gZnJvbSB0aGlzIHJlY3Vyc2l2ZSBjYWxsXG4gICAgICAgIHZhciBfbmVzdGVkQ2FuZGlkYXRlcyA9IGdldENhbmRpZGF0ZXNJdGVyYXRpdmVseShzaGFkb3dSb290ID09PSB0cnVlID8gZWxlbWVudC5jaGlsZHJlbiA6IHNoYWRvd1Jvb3QuY2hpbGRyZW4sIHRydWUsIG9wdGlvbnMpO1xuICAgICAgICBpZiAob3B0aW9ucy5mbGF0dGVuKSB7XG4gICAgICAgICAgY2FuZGlkYXRlcy5wdXNoLmFwcGx5KGNhbmRpZGF0ZXMsIF9uZXN0ZWRDYW5kaWRhdGVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYW5kaWRhdGVzLnB1c2goe1xuICAgICAgICAgICAgc2NvcGVQYXJlbnQ6IGVsZW1lbnQsXG4gICAgICAgICAgICBjYW5kaWRhdGVzOiBfbmVzdGVkQ2FuZGlkYXRlc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB0aGVyZSdzIG5vdCBzaGFkb3cgc28ganVzdCBkaWcgaW50byB0aGUgZWxlbWVudCdzIChsaWdodCBkb20pIGNoaWxkcmVuXG4gICAgICAgIC8vICBfX3dpdGhvdXRfXyBnaXZpbmcgdGhlIGVsZW1lbnQgc3BlY2lhbCBzY29wZSB0cmVhdG1lbnRcbiAgICAgICAgZWxlbWVudHNUb0NoZWNrLnVuc2hpZnQuYXBwbHkoZWxlbWVudHNUb0NoZWNrLCBlbGVtZW50LmNoaWxkcmVuKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNhbmRpZGF0ZXM7XG59O1xuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBub2RlIGhhcyBhbiBleHBsaWNpdGx5IHNwZWNpZmllZCBgdGFiaW5kZXhgIGF0dHJpYnV0ZS5cbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHNvOyBmYWxzZSBpZiBub3QuXG4gKi9cbnZhciBoYXNUYWJJbmRleCA9IGZ1bmN0aW9uIGhhc1RhYkluZGV4KG5vZGUpIHtcbiAgcmV0dXJuICFpc05hTihwYXJzZUludChub2RlLmdldEF0dHJpYnV0ZSgndGFiaW5kZXgnKSwgMTApKTtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lIHRoZSB0YWIgaW5kZXggb2YgYSBnaXZlbiBub2RlLlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gbm9kZVxuICogQHJldHVybnMge251bWJlcn0gVGFiIG9yZGVyIChuZWdhdGl2ZSwgMCwgb3IgcG9zaXRpdmUgbnVtYmVyKS5cbiAqIEB0aHJvd3Mge0Vycm9yfSBJZiBgbm9kZWAgaXMgZmFsc3kuXG4gKi9cbnZhciBnZXRUYWJJbmRleCA9IGZ1bmN0aW9uIGdldFRhYkluZGV4KG5vZGUpIHtcbiAgaWYgKCFub2RlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBub2RlIHByb3ZpZGVkJyk7XG4gIH1cbiAgaWYgKG5vZGUudGFiSW5kZXggPCAwKSB7XG4gICAgLy8gaW4gQ2hyb21lLCA8ZGV0YWlscy8+LCA8YXVkaW8gY29udHJvbHMvPiBhbmQgPHZpZGVvIGNvbnRyb2xzLz4gZWxlbWVudHMgZ2V0IGEgZGVmYXVsdFxuICAgIC8vIGB0YWJJbmRleGAgb2YgLTEgd2hlbiB0aGUgJ3RhYmluZGV4JyBhdHRyaWJ1dGUgaXNuJ3Qgc3BlY2lmaWVkIGluIHRoZSBET00sXG4gICAgLy8geWV0IHRoZXkgYXJlIHN0aWxsIHBhcnQgb2YgdGhlIHJlZ3VsYXIgdGFiIG9yZGVyOyBpbiBGRiwgdGhleSBnZXQgYSBkZWZhdWx0XG4gICAgLy8gYHRhYkluZGV4YCBvZiAwOyBzaW5jZSBDaHJvbWUgc3RpbGwgcHV0cyB0aG9zZSBlbGVtZW50cyBpbiB0aGUgcmVndWxhciB0YWJcbiAgICAvLyBvcmRlciwgY29uc2lkZXIgdGhlaXIgdGFiIGluZGV4IHRvIGJlIDAuXG4gICAgLy8gQWxzbyBicm93c2VycyBkbyBub3QgcmV0dXJuIGB0YWJJbmRleGAgY29ycmVjdGx5IGZvciBjb250ZW50RWRpdGFibGUgbm9kZXM7XG4gICAgLy8gc28gaWYgdGhleSBkb24ndCBoYXZlIGEgdGFiaW5kZXggYXR0cmlidXRlIHNwZWNpZmljYWxseSBzZXQsIGFzc3VtZSBpdCdzIDAuXG4gICAgaWYgKCgvXihBVURJT3xWSURFT3xERVRBSUxTKSQvLnRlc3Qobm9kZS50YWdOYW1lKSB8fCBpc0NvbnRlbnRFZGl0YWJsZShub2RlKSkgJiYgIWhhc1RhYkluZGV4KG5vZGUpKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vZGUudGFiSW5kZXg7XG59O1xuXG4vKipcbiAqIERldGVybWluZSB0aGUgdGFiIGluZGV4IG9mIGEgZ2l2ZW4gbm9kZSBfX2ZvciBzb3J0IG9yZGVyIHB1cnBvc2VzX18uXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtpc1Njb3BlXSBUcnVlIGZvciBhIGN1c3RvbSBlbGVtZW50IHdpdGggc2hhZG93IHJvb3Qgb3Igc2xvdCB0aGF0LCBieSBkZWZhdWx0LFxuICogIGhhcyB0YWJJbmRleCAtMSwgYnV0IG5lZWRzIHRvIGJlIHNvcnRlZCBieSBkb2N1bWVudCBvcmRlciBpbiBvcmRlciBmb3IgaXRzIGNvbnRlbnQgdG8gYmVcbiAqICBpbnNlcnRlZCBpbnRvIHRoZSBjb3JyZWN0IHNvcnQgcG9zaXRpb24uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBUYWIgb3JkZXIgKG5lZ2F0aXZlLCAwLCBvciBwb3NpdGl2ZSBudW1iZXIpLlxuICovXG52YXIgZ2V0U29ydE9yZGVyVGFiSW5kZXggPSBmdW5jdGlvbiBnZXRTb3J0T3JkZXJUYWJJbmRleChub2RlLCBpc1Njb3BlKSB7XG4gIHZhciB0YWJJbmRleCA9IGdldFRhYkluZGV4KG5vZGUpO1xuICBpZiAodGFiSW5kZXggPCAwICYmIGlzU2NvcGUgJiYgIWhhc1RhYkluZGV4KG5vZGUpKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIHRhYkluZGV4O1xufTtcbnZhciBzb3J0T3JkZXJlZFRhYmJhYmxlcyA9IGZ1bmN0aW9uIHNvcnRPcmRlcmVkVGFiYmFibGVzKGEsIGIpIHtcbiAgcmV0dXJuIGEudGFiSW5kZXggPT09IGIudGFiSW5kZXggPyBhLmRvY3VtZW50T3JkZXIgLSBiLmRvY3VtZW50T3JkZXIgOiBhLnRhYkluZGV4IC0gYi50YWJJbmRleDtcbn07XG52YXIgaXNJbnB1dCA9IGZ1bmN0aW9uIGlzSW5wdXQobm9kZSkge1xuICByZXR1cm4gbm9kZS50YWdOYW1lID09PSAnSU5QVVQnO1xufTtcbnZhciBpc0hpZGRlbklucHV0ID0gZnVuY3Rpb24gaXNIaWRkZW5JbnB1dChub2RlKSB7XG4gIHJldHVybiBpc0lucHV0KG5vZGUpICYmIG5vZGUudHlwZSA9PT0gJ2hpZGRlbic7XG59O1xudmFyIGlzRGV0YWlsc1dpdGhTdW1tYXJ5ID0gZnVuY3Rpb24gaXNEZXRhaWxzV2l0aFN1bW1hcnkobm9kZSkge1xuICB2YXIgciA9IG5vZGUudGFnTmFtZSA9PT0gJ0RFVEFJTFMnICYmIEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShub2RlLmNoaWxkcmVuKS5zb21lKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIHJldHVybiBjaGlsZC50YWdOYW1lID09PSAnU1VNTUFSWSc7XG4gIH0pO1xuICByZXR1cm4gcjtcbn07XG52YXIgZ2V0Q2hlY2tlZFJhZGlvID0gZnVuY3Rpb24gZ2V0Q2hlY2tlZFJhZGlvKG5vZGVzLCBmb3JtKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAobm9kZXNbaV0uY2hlY2tlZCAmJiBub2Rlc1tpXS5mb3JtID09PSBmb3JtKSB7XG4gICAgICByZXR1cm4gbm9kZXNbaV07XG4gICAgfVxuICB9XG59O1xudmFyIGlzVGFiYmFibGVSYWRpbyA9IGZ1bmN0aW9uIGlzVGFiYmFibGVSYWRpbyhub2RlKSB7XG4gIGlmICghbm9kZS5uYW1lKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIHJhZGlvU2NvcGUgPSBub2RlLmZvcm0gfHwgZ2V0Um9vdE5vZGUobm9kZSk7XG4gIHZhciBxdWVyeVJhZGlvcyA9IGZ1bmN0aW9uIHF1ZXJ5UmFkaW9zKG5hbWUpIHtcbiAgICByZXR1cm4gcmFkaW9TY29wZS5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFt0eXBlPVwicmFkaW9cIl1bbmFtZT1cIicgKyBuYW1lICsgJ1wiXScpO1xuICB9O1xuICB2YXIgcmFkaW9TZXQ7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LkNTUyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5DU1MuZXNjYXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmFkaW9TZXQgPSBxdWVyeVJhZGlvcyh3aW5kb3cuQ1NTLmVzY2FwZShub2RlLm5hbWUpKTtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgcmFkaW9TZXQgPSBxdWVyeVJhZGlvcyhub2RlLm5hbWUpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0xvb2tzIGxpa2UgeW91IGhhdmUgYSByYWRpbyBidXR0b24gd2l0aCBhIG5hbWUgYXR0cmlidXRlIGNvbnRhaW5pbmcgaW52YWxpZCBDU1Mgc2VsZWN0b3IgY2hhcmFjdGVycyBhbmQgbmVlZCB0aGUgQ1NTLmVzY2FwZSBwb2x5ZmlsbDogJXMnLCBlcnIubWVzc2FnZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHZhciBjaGVja2VkID0gZ2V0Q2hlY2tlZFJhZGlvKHJhZGlvU2V0LCBub2RlLmZvcm0pO1xuICByZXR1cm4gIWNoZWNrZWQgfHwgY2hlY2tlZCA9PT0gbm9kZTtcbn07XG52YXIgaXNSYWRpbyA9IGZ1bmN0aW9uIGlzUmFkaW8obm9kZSkge1xuICByZXR1cm4gaXNJbnB1dChub2RlKSAmJiBub2RlLnR5cGUgPT09ICdyYWRpbyc7XG59O1xudmFyIGlzTm9uVGFiYmFibGVSYWRpbyA9IGZ1bmN0aW9uIGlzTm9uVGFiYmFibGVSYWRpbyhub2RlKSB7XG4gIHJldHVybiBpc1JhZGlvKG5vZGUpICYmICFpc1RhYmJhYmxlUmFkaW8obm9kZSk7XG59O1xuXG4vLyBkZXRlcm1pbmVzIGlmIGEgbm9kZSBpcyB1bHRpbWF0ZWx5IGF0dGFjaGVkIHRvIHRoZSB3aW5kb3cncyBkb2N1bWVudFxudmFyIGlzTm9kZUF0dGFjaGVkID0gZnVuY3Rpb24gaXNOb2RlQXR0YWNoZWQobm9kZSkge1xuICB2YXIgX25vZGVSb290O1xuICAvLyBUaGUgcm9vdCBub2RlIGlzIHRoZSBzaGFkb3cgcm9vdCBpZiB0aGUgbm9kZSBpcyBpbiBhIHNoYWRvdyBET007IHNvbWUgZG9jdW1lbnQgb3RoZXJ3aXNlXG4gIC8vICAoYnV0IE5PVCBfdGhlXyBkb2N1bWVudDsgc2VlIHNlY29uZCAnSWYnIGNvbW1lbnQgYmVsb3cgZm9yIG1vcmUpLlxuICAvLyBJZiByb290Tm9kZSBpcyBzaGFkb3cgcm9vdCwgaXQnbGwgaGF2ZSBhIGhvc3QsIHdoaWNoIGlzIHRoZSBlbGVtZW50IHRvIHdoaWNoIHRoZSBzaGFkb3dcbiAgLy8gIGlzIGF0dGFjaGVkLCBhbmQgdGhlIG9uZSB3ZSBuZWVkIHRvIGNoZWNrIGlmIGl0J3MgaW4gdGhlIGRvY3VtZW50IG9yIG5vdCAoYmVjYXVzZSB0aGVcbiAgLy8gIHNoYWRvdywgYW5kIGFsbCBub2RlcyBpdCBjb250YWlucywgaXMgbmV2ZXIgY29uc2lkZXJlZCBpbiB0aGUgZG9jdW1lbnQgc2luY2Ugc2hhZG93c1xuICAvLyAgYmVoYXZlIGxpa2Ugc2VsZi1jb250YWluZWQgRE9NczsgYnV0IGlmIHRoZSBzaGFkb3cncyBIT1NULCB3aGljaCBpcyBwYXJ0IG9mIHRoZSBkb2N1bWVudCxcbiAgLy8gIGlzIGhpZGRlbiwgb3IgaXMgbm90IGluIHRoZSBkb2N1bWVudCBpdHNlbGYgYnV0IGlzIGRldGFjaGVkLCBpdCB3aWxsIGFmZmVjdCB0aGUgc2hhZG93J3NcbiAgLy8gIHZpc2liaWxpdHksIGluY2x1ZGluZyBhbGwgdGhlIG5vZGVzIGl0IGNvbnRhaW5zKS4gVGhlIGhvc3QgY291bGQgYmUgYW55IG5vcm1hbCBub2RlLFxuICAvLyAgb3IgYSBjdXN0b20gZWxlbWVudCAoaS5lLiB3ZWIgY29tcG9uZW50KS4gRWl0aGVyIHdheSwgdGhhdCdzIHRoZSBvbmUgdGhhdCBpcyBjb25zaWRlcmVkXG4gIC8vICBwYXJ0IG9mIHRoZSBkb2N1bWVudCwgbm90IHRoZSBzaGFkb3cgcm9vdCwgbm9yIGFueSBvZiBpdHMgY2hpbGRyZW4gKGkuZS4gdGhlIG5vZGUgYmVpbmdcbiAgLy8gIHRlc3RlZCkuXG4gIC8vIFRvIGZ1cnRoZXIgY29tcGxpY2F0ZSB0aGluZ3MsIHdlIGhhdmUgdG8gbG9vayBhbGwgdGhlIHdheSB1cCB1bnRpbCB3ZSBmaW5kIGEgc2hhZG93IEhPU1RcbiAgLy8gIHRoYXQgaXMgYXR0YWNoZWQgKG9yIGZpbmQgbm9uZSkgYmVjYXVzZSB0aGUgbm9kZSBtaWdodCBiZSBpbiBuZXN0ZWQgc2hhZG93cy4uLlxuICAvLyBJZiByb290Tm9kZSBpcyBub3QgYSBzaGFkb3cgcm9vdCwgaXQgd29uJ3QgaGF2ZSBhIGhvc3QsIGFuZCBzbyByb290Tm9kZSBzaG91bGQgYmUgdGhlXG4gIC8vICBkb2N1bWVudCAocGVyIHRoZSBkb2NzKSBhbmQgd2hpbGUgaXQncyBhIERvY3VtZW50LXR5cGUgb2JqZWN0LCB0aGF0IGRvY3VtZW50IGRvZXMgbm90XG4gIC8vICBhcHBlYXIgdG8gYmUgdGhlIHNhbWUgYXMgdGhlIG5vZGUncyBgb3duZXJEb2N1bWVudGAgZm9yIHNvbWUgcmVhc29uLCBzbyBpdCdzIHNhZmVyXG4gIC8vICB0byBpZ25vcmUgdGhlIHJvb3ROb2RlIGF0IHRoaXMgcG9pbnQsIGFuZCB1c2UgYG5vZGUub3duZXJEb2N1bWVudGAuIE90aGVyd2lzZSxcbiAgLy8gIHVzaW5nIGByb290Tm9kZS5jb250YWlucyhub2RlKWAgd2lsbCBfYWx3YXlzXyBiZSB0cnVlIHdlJ2xsIGdldCBmYWxzZS1wb3NpdGl2ZXMgd2hlblxuICAvLyAgbm9kZSBpcyBhY3R1YWxseSBkZXRhY2hlZC5cbiAgLy8gTk9URTogSWYgYG5vZGVSb290SG9zdGAgb3IgYG5vZGVgIGhhcHBlbnMgdG8gYmUgdGhlIGBkb2N1bWVudGAgaXRzZWxmICh3aGljaCBpcyBwb3NzaWJsZVxuICAvLyAgaWYgYSB0YWJiYWJsZS9mb2N1c2FibGUgbm9kZSB3YXMgcXVpY2tseSBhZGRlZCB0byB0aGUgRE9NLCBmb2N1c2VkLCBhbmQgdGhlbiByZW1vdmVkXG4gIC8vICBmcm9tIHRoZSBET00gYXMgaW4gaHR0cHM6Ly9naXRodWIuY29tL2ZvY3VzLXRyYXAvZm9jdXMtdHJhcC1yZWFjdC9pc3N1ZXMvOTA1KSwgdGhlblxuICAvLyAgYG93bmVyRG9jdW1lbnRgIHdpbGwgYmUgYG51bGxgLCBoZW5jZSB0aGUgb3B0aW9uYWwgY2hhaW5pbmcgb24gaXQuXG4gIHZhciBub2RlUm9vdCA9IG5vZGUgJiYgZ2V0Um9vdE5vZGUobm9kZSk7XG4gIHZhciBub2RlUm9vdEhvc3QgPSAoX25vZGVSb290ID0gbm9kZVJvb3QpID09PSBudWxsIHx8IF9ub2RlUm9vdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25vZGVSb290Lmhvc3Q7XG5cbiAgLy8gaW4gc29tZSBjYXNlcywgYSBkZXRhY2hlZCBub2RlIHdpbGwgcmV0dXJuIGl0c2VsZiBhcyB0aGUgcm9vdCBpbnN0ZWFkIG9mIGEgZG9jdW1lbnQgb3JcbiAgLy8gIHNoYWRvdyByb290IG9iamVjdCwgaW4gd2hpY2ggY2FzZSwgd2Ugc2hvdWxkbid0IHRyeSB0byBsb29rIGZ1cnRoZXIgdXAgdGhlIGhvc3QgY2hhaW5cbiAgdmFyIGF0dGFjaGVkID0gZmFsc2U7XG4gIGlmIChub2RlUm9vdCAmJiBub2RlUm9vdCAhPT0gbm9kZSkge1xuICAgIHZhciBfbm9kZVJvb3RIb3N0LCBfbm9kZVJvb3RIb3N0JG93bmVyRG8sIF9ub2RlJG93bmVyRG9jdW1lbnQ7XG4gICAgYXR0YWNoZWQgPSAhISgoX25vZGVSb290SG9zdCA9IG5vZGVSb290SG9zdCkgIT09IG51bGwgJiYgX25vZGVSb290SG9zdCAhPT0gdm9pZCAwICYmIChfbm9kZVJvb3RIb3N0JG93bmVyRG8gPSBfbm9kZVJvb3RIb3N0Lm93bmVyRG9jdW1lbnQpICE9PSBudWxsICYmIF9ub2RlUm9vdEhvc3Qkb3duZXJEbyAhPT0gdm9pZCAwICYmIF9ub2RlUm9vdEhvc3Qkb3duZXJEby5jb250YWlucyhub2RlUm9vdEhvc3QpIHx8IG5vZGUgIT09IG51bGwgJiYgbm9kZSAhPT0gdm9pZCAwICYmIChfbm9kZSRvd25lckRvY3VtZW50ID0gbm9kZS5vd25lckRvY3VtZW50KSAhPT0gbnVsbCAmJiBfbm9kZSRvd25lckRvY3VtZW50ICE9PSB2b2lkIDAgJiYgX25vZGUkb3duZXJEb2N1bWVudC5jb250YWlucyhub2RlKSk7XG4gICAgd2hpbGUgKCFhdHRhY2hlZCAmJiBub2RlUm9vdEhvc3QpIHtcbiAgICAgIHZhciBfbm9kZVJvb3QyLCBfbm9kZVJvb3RIb3N0MiwgX25vZGVSb290SG9zdDIkb3duZXJEO1xuICAgICAgLy8gc2luY2UgaXQncyBub3QgYXR0YWNoZWQgYW5kIHdlIGhhdmUgYSByb290IGhvc3QsIHRoZSBub2RlIE1VU1QgYmUgaW4gYSBuZXN0ZWQgc2hhZG93IERPTSxcbiAgICAgIC8vICB3aGljaCBtZWFucyB3ZSBuZWVkIHRvIGdldCB0aGUgaG9zdCdzIGhvc3QgYW5kIGNoZWNrIGlmIHRoYXQgcGFyZW50IGhvc3QgaXMgY29udGFpbmVkXG4gICAgICAvLyAgaW4gKGkuZS4gYXR0YWNoZWQgdG8pIHRoZSBkb2N1bWVudFxuICAgICAgbm9kZVJvb3QgPSBnZXRSb290Tm9kZShub2RlUm9vdEhvc3QpO1xuICAgICAgbm9kZVJvb3RIb3N0ID0gKF9ub2RlUm9vdDIgPSBub2RlUm9vdCkgPT09IG51bGwgfHwgX25vZGVSb290MiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25vZGVSb290Mi5ob3N0O1xuICAgICAgYXR0YWNoZWQgPSAhISgoX25vZGVSb290SG9zdDIgPSBub2RlUm9vdEhvc3QpICE9PSBudWxsICYmIF9ub2RlUm9vdEhvc3QyICE9PSB2b2lkIDAgJiYgKF9ub2RlUm9vdEhvc3QyJG93bmVyRCA9IF9ub2RlUm9vdEhvc3QyLm93bmVyRG9jdW1lbnQpICE9PSBudWxsICYmIF9ub2RlUm9vdEhvc3QyJG93bmVyRCAhPT0gdm9pZCAwICYmIF9ub2RlUm9vdEhvc3QyJG93bmVyRC5jb250YWlucyhub2RlUm9vdEhvc3QpKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGF0dGFjaGVkO1xufTtcbnZhciBpc1plcm9BcmVhID0gZnVuY3Rpb24gaXNaZXJvQXJlYShub2RlKSB7XG4gIHZhciBfbm9kZSRnZXRCb3VuZGluZ0NsaWUgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgIHdpZHRoID0gX25vZGUkZ2V0Qm91bmRpbmdDbGllLndpZHRoLFxuICAgIGhlaWdodCA9IF9ub2RlJGdldEJvdW5kaW5nQ2xpZS5oZWlnaHQ7XG4gIHJldHVybiB3aWR0aCA9PT0gMCAmJiBoZWlnaHQgPT09IDA7XG59O1xudmFyIGlzSGlkZGVuID0gZnVuY3Rpb24gaXNIaWRkZW4obm9kZSwgX3JlZikge1xuICB2YXIgZGlzcGxheUNoZWNrID0gX3JlZi5kaXNwbGF5Q2hlY2ssXG4gICAgZ2V0U2hhZG93Um9vdCA9IF9yZWYuZ2V0U2hhZG93Um9vdDtcbiAgLy8gTk9URTogdmlzaWJpbGl0eSB3aWxsIGJlIGB1bmRlZmluZWRgIGlmIG5vZGUgaXMgZGV0YWNoZWQgZnJvbSB0aGUgZG9jdW1lbnRcbiAgLy8gIChzZWUgbm90ZXMgYWJvdXQgdGhpcyBmdXJ0aGVyIGRvd24pLCB3aGljaCBtZWFucyB3ZSB3aWxsIGNvbnNpZGVyIGl0IHZpc2libGVcbiAgLy8gICh0aGlzIGlzIGxlZ2FjeSBiZWhhdmlvciBmcm9tIGEgdmVyeSBsb25nIHdheSBiYWNrKVxuICAvLyBOT1RFOiB3ZSBjaGVjayB0aGlzIHJlZ2FyZGxlc3Mgb2YgYGRpc3BsYXlDaGVjaz1cIm5vbmVcImAgYmVjYXVzZSB0aGlzIGlzIGFcbiAgLy8gIF92aXNpYmlsaXR5XyBjaGVjaywgbm90IGEgX2Rpc3BsYXlfIGNoZWNrXG4gIGlmIChnZXRDb21wdXRlZFN0eWxlKG5vZGUpLnZpc2liaWxpdHkgPT09ICdoaWRkZW4nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIGlzRGlyZWN0U3VtbWFyeSA9IG1hdGNoZXMuY2FsbChub2RlLCAnZGV0YWlscz5zdW1tYXJ5OmZpcnN0LW9mLXR5cGUnKTtcbiAgdmFyIG5vZGVVbmRlckRldGFpbHMgPSBpc0RpcmVjdFN1bW1hcnkgPyBub2RlLnBhcmVudEVsZW1lbnQgOiBub2RlO1xuICBpZiAobWF0Y2hlcy5jYWxsKG5vZGVVbmRlckRldGFpbHMsICdkZXRhaWxzOm5vdChbb3Blbl0pIConKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmICghZGlzcGxheUNoZWNrIHx8IGRpc3BsYXlDaGVjayA9PT0gJ2Z1bGwnIHx8IGRpc3BsYXlDaGVjayA9PT0gJ2xlZ2FjeS1mdWxsJykge1xuICAgIGlmICh0eXBlb2YgZ2V0U2hhZG93Um9vdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gZmlndXJlIG91dCBpZiB3ZSBzaG91bGQgY29uc2lkZXIgdGhlIG5vZGUgdG8gYmUgaW4gYW4gdW5kaXNjbG9zZWQgc2hhZG93IGFuZCB1c2UgdGhlXG4gICAgICAvLyAgJ25vbi16ZXJvLWFyZWEnIGZhbGxiYWNrXG4gICAgICB2YXIgb3JpZ2luYWxOb2RlID0gbm9kZTtcbiAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIHZhciBwYXJlbnRFbGVtZW50ID0gbm9kZS5wYXJlbnRFbGVtZW50O1xuICAgICAgICB2YXIgcm9vdE5vZGUgPSBnZXRSb290Tm9kZShub2RlKTtcbiAgICAgICAgaWYgKHBhcmVudEVsZW1lbnQgJiYgIXBhcmVudEVsZW1lbnQuc2hhZG93Um9vdCAmJiBnZXRTaGFkb3dSb290KHBhcmVudEVsZW1lbnQpID09PSB0cnVlIC8vIGNoZWNrIGlmIHRoZXJlJ3MgYW4gdW5kaXNjbG9zZWQgc2hhZG93XG4gICAgICAgICkge1xuICAgICAgICAgIC8vIG5vZGUgaGFzIGFuIHVuZGlzY2xvc2VkIHNoYWRvdyB3aGljaCBtZWFucyB3ZSBjYW4gb25seSB0cmVhdCBpdCBhcyBhIGJsYWNrIGJveCwgc28gd2VcbiAgICAgICAgICAvLyAgZmFsbCBiYWNrIHRvIGEgbm9uLXplcm8tYXJlYSB0ZXN0XG4gICAgICAgICAgcmV0dXJuIGlzWmVyb0FyZWEobm9kZSk7XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS5hc3NpZ25lZFNsb3QpIHtcbiAgICAgICAgICAvLyBpdGVyYXRlIHVwIHNsb3RcbiAgICAgICAgICBub2RlID0gbm9kZS5hc3NpZ25lZFNsb3Q7XG4gICAgICAgIH0gZWxzZSBpZiAoIXBhcmVudEVsZW1lbnQgJiYgcm9vdE5vZGUgIT09IG5vZGUub3duZXJEb2N1bWVudCkge1xuICAgICAgICAgIC8vIGNyb3NzIHNoYWRvdyBib3VuZGFyeVxuICAgICAgICAgIG5vZGUgPSByb290Tm9kZS5ob3N0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGl0ZXJhdGUgdXAgbm9ybWFsIGRvbVxuICAgICAgICAgIG5vZGUgPSBwYXJlbnRFbGVtZW50O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBub2RlID0gb3JpZ2luYWxOb2RlO1xuICAgIH1cbiAgICAvLyBlbHNlLCBgZ2V0U2hhZG93Um9vdGAgbWlnaHQgYmUgdHJ1ZSwgYnV0IGFsbCB0aGF0IGRvZXMgaXMgZW5hYmxlIHNoYWRvdyBET00gc3VwcG9ydFxuICAgIC8vICAoaS5lLiBpdCBkb2VzIG5vdCBhbHNvIHByZXN1bWUgdGhhdCBhbGwgbm9kZXMgbWlnaHQgaGF2ZSB1bmRpc2Nsb3NlZCBzaGFkb3dzKTsgb3JcbiAgICAvLyAgaXQgbWlnaHQgYmUgYSBmYWxzeSB2YWx1ZSwgd2hpY2ggbWVhbnMgc2hhZG93IERPTSBzdXBwb3J0IGlzIGRpc2FibGVkXG5cbiAgICAvLyBTaW5jZSB3ZSBkaWRuJ3QgZmluZCBpdCBzaXR0aW5nIGluIGFuIHVuZGlzY2xvc2VkIHNoYWRvdyAob3Igc2hhZG93cyBhcmUgZGlzYWJsZWQpXG4gICAgLy8gIG5vdyB3ZSBjYW4ganVzdCB0ZXN0IHRvIHNlZSBpZiBpdCB3b3VsZCBub3JtYWxseSBiZSB2aXNpYmxlIG9yIG5vdCwgcHJvdmlkZWQgaXQnc1xuICAgIC8vICBhdHRhY2hlZCB0byB0aGUgbWFpbiBkb2N1bWVudC5cbiAgICAvLyBOT1RFOiBXZSBtdXN0IGNvbnNpZGVyIGNhc2Ugd2hlcmUgbm9kZSBpcyBpbnNpZGUgYSBzaGFkb3cgRE9NIGFuZCBnaXZlbiBkaXJlY3RseSB0b1xuICAgIC8vICBgaXNUYWJiYWJsZSgpYCBvciBgaXNGb2N1c2FibGUoKWAgLS0gcmVnYXJkbGVzcyBvZiBgZ2V0U2hhZG93Um9vdGAgb3B0aW9uIHNldHRpbmcuXG5cbiAgICBpZiAoaXNOb2RlQXR0YWNoZWQobm9kZSkpIHtcbiAgICAgIC8vIHRoaXMgd29ya3Mgd2hlcmV2ZXIgdGhlIG5vZGUgaXM6IGlmIHRoZXJlJ3MgYXQgbGVhc3Qgb25lIGNsaWVudCByZWN0LCBpdCdzXG4gICAgICAvLyAgc29tZWhvdyBkaXNwbGF5ZWQ7IGl0IGFsc28gY292ZXJzIHRoZSBDU1MgJ2Rpc3BsYXk6IGNvbnRlbnRzJyBjYXNlIHdoZXJlIHRoZVxuICAgICAgLy8gIG5vZGUgaXRzZWxmIGlzIGhpZGRlbiBpbiBwbGFjZSBvZiBpdHMgY29udGVudHM7IGFuZCB0aGVyZSdzIG5vIG5lZWQgdG8gc2VhcmNoXG4gICAgICAvLyAgdXAgdGhlIGhpZXJhcmNoeSBlaXRoZXJcbiAgICAgIHJldHVybiAhbm9kZS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aDtcbiAgICB9XG5cbiAgICAvLyBFbHNlLCB0aGUgbm9kZSBpc24ndCBhdHRhY2hlZCB0byB0aGUgZG9jdW1lbnQsIHdoaWNoIG1lYW5zIHRoZSBgZ2V0Q2xpZW50UmVjdHMoKWBcbiAgICAvLyAgQVBJIHdpbGwgX19hbHdheXNfXyByZXR1cm4gemVybyByZWN0cyAodGhpcyBjYW4gaGFwcGVuLCBmb3IgZXhhbXBsZSwgaWYgUmVhY3RcbiAgICAvLyAgaXMgdXNlZCB0byByZW5kZXIgbm9kZXMgb250byBhIGRldGFjaGVkIHRyZWUsIGFzIGNvbmZpcm1lZCBpbiB0aGlzIHRocmVhZDpcbiAgICAvLyAgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy85MTE3I2lzc3VlY29tbWVudC0yODQyMjg4NzApXG4gICAgLy9cbiAgICAvLyBJdCBhbHNvIG1lYW5zIHRoYXQgZXZlbiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShub2RlKS5kaXNwbGF5IHdpbGwgcmV0dXJuIGB1bmRlZmluZWRgXG4gICAgLy8gIGJlY2F1c2Ugc3R5bGVzIGFyZSBvbmx5IGNvbXB1dGVkIGZvciBub2RlcyB0aGF0IGFyZSBpbiB0aGUgZG9jdW1lbnQuXG4gICAgLy9cbiAgICAvLyBOT1RFOiBUSElTIEhBUyBCRUVOIFRIRSBDQVNFIEZPUiBZRUFSUy4gSXQgaXMgbm90IG5ldywgbm9yIGlzIGl0IGNhdXNlZCBieSB0YWJiYWJsZVxuICAgIC8vICBzb21laG93LiBUaG91Z2ggaXQgd2FzIG5ldmVyIHN0YXRlZCBvZmZpY2lhbGx5LCBhbnlvbmUgd2hvIGhhcyBldmVyIHVzZWQgdGFiYmFibGVcbiAgICAvLyAgQVBJcyBvbiBub2RlcyBpbiBkZXRhY2hlZCBjb250YWluZXJzIGhhcyBhY3R1YWxseSBpbXBsaWNpdGx5IHVzZWQgdGFiYmFibGUgaW4gd2hhdFxuICAgIC8vICB3YXMgbGF0ZXIgKGFzIG9mIHY1LjIuMCBvbiBBcHIgOSwgMjAyMSkgY2FsbGVkIGBkaXNwbGF5Q2hlY2s9XCJub25lXCJgIG1vZGUgLS0gZXNzZW50aWFsbHlcbiAgICAvLyAgY29uc2lkZXJpbmcgX19ldmVyeXRoaW5nX18gdG8gYmUgdmlzaWJsZSBiZWNhdXNlIG9mIHRoZSBpbm5hYmlsaXR5IHRvIGRldGVybWluZSBzdHlsZXMuXG4gICAgLy9cbiAgICAvLyB2Ni4wLjA6IEFzIG9mIHRoaXMgbWFqb3IgcmVsZWFzZSwgdGhlIGRlZmF1bHQgJ2Z1bGwnIG9wdGlvbiBfX25vIGxvbmdlciB0cmVhdHMgZGV0YWNoZWRcbiAgICAvLyAgbm9kZXMgYXMgdmlzaWJsZSB3aXRoIHRoZSAnbm9uZScgZmFsbGJhY2suX19cbiAgICBpZiAoZGlzcGxheUNoZWNrICE9PSAnbGVnYWN5LWZ1bGwnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTsgLy8gaGlkZGVuXG4gICAgfVxuICAgIC8vIGVsc2UsIGZhbGxiYWNrIHRvICdub25lJyBtb2RlIGFuZCBjb25zaWRlciB0aGUgbm9kZSB2aXNpYmxlXG4gIH0gZWxzZSBpZiAoZGlzcGxheUNoZWNrID09PSAnbm9uLXplcm8tYXJlYScpIHtcbiAgICAvLyBOT1RFOiBFdmVuIHRob3VnaCB0aGlzIHRlc3RzIHRoYXQgdGhlIG5vZGUncyBjbGllbnQgcmVjdCBpcyBub24temVybyB0byBkZXRlcm1pbmVcbiAgICAvLyAgd2hldGhlciBpdCdzIGRpc3BsYXllZCwgYW5kIHRoYXQgYSBkZXRhY2hlZCBub2RlIHdpbGwgX19hbHdheXNfXyBoYXZlIGEgemVyby1hcmVhXG4gICAgLy8gIGNsaWVudCByZWN0LCB3ZSBkb24ndCBzcGVjaWFsLWNhc2UgZm9yIHdoZXRoZXIgdGhlIG5vZGUgaXMgYXR0YWNoZWQgb3Igbm90LiBJblxuICAgIC8vICB0aGlzIG1vZGUsIHdlIGRvIHdhbnQgdG8gY29uc2lkZXIgbm9kZXMgdGhhdCBoYXZlIGEgemVybyBhcmVhIHRvIGJlIGhpZGRlbiBhdCBhbGxcbiAgICAvLyAgdGltZXMsIGFuZCB0aGF0IGluY2x1ZGVzIGF0dGFjaGVkIG9yIG5vdC5cbiAgICByZXR1cm4gaXNaZXJvQXJlYShub2RlKTtcbiAgfVxuXG4gIC8vIHZpc2libGUsIGFzIGZhciBhcyB3ZSBjYW4gdGVsbCwgb3IgcGVyIGN1cnJlbnQgYGRpc3BsYXlDaGVjaz1ub25lYCBtb2RlLCB3ZSBhc3N1bWVcbiAgLy8gIGl0J3MgdmlzaWJsZVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vLyBmb3JtIGZpZWxkcyAobmVzdGVkKSBpbnNpZGUgYSBkaXNhYmxlZCBmaWVsZHNldCBhcmUgbm90IGZvY3VzYWJsZS90YWJiYWJsZVxuLy8gIHVubGVzcyB0aGV5IGFyZSBpbiB0aGUgX2ZpcnN0XyA8bGVnZW5kPiBlbGVtZW50IG9mIHRoZSB0b3AtbW9zdCBkaXNhYmxlZFxuLy8gIGZpZWxkc2V0XG52YXIgaXNEaXNhYmxlZEZyb21GaWVsZHNldCA9IGZ1bmN0aW9uIGlzRGlzYWJsZWRGcm9tRmllbGRzZXQobm9kZSkge1xuICBpZiAoL14oSU5QVVR8QlVUVE9OfFNFTEVDVHxURVhUQVJFQSkkLy50ZXN0KG5vZGUudGFnTmFtZSkpIHtcbiAgICB2YXIgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50RWxlbWVudDtcbiAgICAvLyBjaGVjayBpZiBgbm9kZWAgaXMgY29udGFpbmVkIGluIGEgZGlzYWJsZWQgPGZpZWxkc2V0PlxuICAgIHdoaWxlIChwYXJlbnROb2RlKSB7XG4gICAgICBpZiAocGFyZW50Tm9kZS50YWdOYW1lID09PSAnRklFTERTRVQnICYmIHBhcmVudE5vZGUuZGlzYWJsZWQpIHtcbiAgICAgICAgLy8gbG9vayBmb3IgdGhlIGZpcnN0IDxsZWdlbmQ+IGFtb25nIHRoZSBjaGlsZHJlbiBvZiB0aGUgZGlzYWJsZWQgPGZpZWxkc2V0PlxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmVudE5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgY2hpbGQgPSBwYXJlbnROb2RlLmNoaWxkcmVuLml0ZW0oaSk7XG4gICAgICAgICAgLy8gd2hlbiB0aGUgZmlyc3QgPGxlZ2VuZD4gKGluIGRvY3VtZW50IG9yZGVyKSBpcyBmb3VuZFxuICAgICAgICAgIGlmIChjaGlsZC50YWdOYW1lID09PSAnTEVHRU5EJykge1xuICAgICAgICAgICAgLy8gaWYgaXRzIHBhcmVudCA8ZmllbGRzZXQ+IGlzIG5vdCBuZXN0ZWQgaW4gYW5vdGhlciBkaXNhYmxlZCA8ZmllbGRzZXQ+LFxuICAgICAgICAgICAgLy8gcmV0dXJuIHdoZXRoZXIgYG5vZGVgIGlzIGEgZGVzY2VuZGFudCBvZiBpdHMgZmlyc3QgPGxlZ2VuZD5cbiAgICAgICAgICAgIHJldHVybiBtYXRjaGVzLmNhbGwocGFyZW50Tm9kZSwgJ2ZpZWxkc2V0W2Rpc2FibGVkXSAqJykgPyB0cnVlIDogIWNoaWxkLmNvbnRhaW5zKG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB0aGUgZGlzYWJsZWQgPGZpZWxkc2V0PiBjb250YWluaW5nIGBub2RlYCBoYXMgbm8gPGxlZ2VuZD5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBwYXJlbnROb2RlID0gcGFyZW50Tm9kZS5wYXJlbnRFbGVtZW50O1xuICAgIH1cbiAgfVxuXG4gIC8vIGVsc2UsIG5vZGUncyB0YWJiYWJsZS9mb2N1c2FibGUgc3RhdGUgc2hvdWxkIG5vdCBiZSBhZmZlY3RlZCBieSBhIGZpZWxkc2V0J3NcbiAgLy8gIGVuYWJsZWQvZGlzYWJsZWQgc3RhdGVcbiAgcmV0dXJuIGZhbHNlO1xufTtcbnZhciBpc05vZGVNYXRjaGluZ1NlbGVjdG9yRm9jdXNhYmxlID0gZnVuY3Rpb24gaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZShvcHRpb25zLCBub2RlKSB7XG4gIGlmIChub2RlLmRpc2FibGVkIHx8XG4gIC8vIHdlIG11c3QgZG8gYW4gaW5lcnQgbG9vayB1cCB0byBmaWx0ZXIgb3V0IGFueSBlbGVtZW50cyBpbnNpZGUgYW4gaW5lcnQgYW5jZXN0b3JcbiAgLy8gIGJlY2F1c2Ugd2UncmUgbGltaXRlZCBpbiB0aGUgdHlwZSBvZiBzZWxlY3RvcnMgd2UgY2FuIHVzZSBpbiBKU0RvbSAoc2VlIHJlbGF0ZWRcbiAgLy8gIG5vdGUgcmVsYXRlZCB0byBgY2FuZGlkYXRlU2VsZWN0b3JzYClcbiAgaXNJbmVydChub2RlKSB8fCBpc0hpZGRlbklucHV0KG5vZGUpIHx8IGlzSGlkZGVuKG5vZGUsIG9wdGlvbnMpIHx8XG4gIC8vIEZvciBhIGRldGFpbHMgZWxlbWVudCB3aXRoIGEgc3VtbWFyeSwgdGhlIHN1bW1hcnkgZWxlbWVudCBnZXRzIHRoZSBmb2N1c1xuICBpc0RldGFpbHNXaXRoU3VtbWFyeShub2RlKSB8fCBpc0Rpc2FibGVkRnJvbUZpZWxkc2V0KG5vZGUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcbnZhciBpc05vZGVNYXRjaGluZ1NlbGVjdG9yVGFiYmFibGUgPSBmdW5jdGlvbiBpc05vZGVNYXRjaGluZ1NlbGVjdG9yVGFiYmFibGUob3B0aW9ucywgbm9kZSkge1xuICBpZiAoaXNOb25UYWJiYWJsZVJhZGlvKG5vZGUpIHx8IGdldFRhYkluZGV4KG5vZGUpIDwgMCB8fCAhaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZShvcHRpb25zLCBub2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn07XG52YXIgaXNWYWxpZFNoYWRvd1Jvb3RUYWJiYWJsZSA9IGZ1bmN0aW9uIGlzVmFsaWRTaGFkb3dSb290VGFiYmFibGUoc2hhZG93SG9zdE5vZGUpIHtcbiAgdmFyIHRhYkluZGV4ID0gcGFyc2VJbnQoc2hhZG93SG9zdE5vZGUuZ2V0QXR0cmlidXRlKCd0YWJpbmRleCcpLCAxMCk7XG4gIGlmIChpc05hTih0YWJJbmRleCkgfHwgdGFiSW5kZXggPj0gMCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8vIElmIGEgY3VzdG9tIGVsZW1lbnQgaGFzIGFuIGV4cGxpY2l0IG5lZ2F0aXZlIHRhYmluZGV4LFxuICAvLyBicm93c2VycyB3aWxsIG5vdCBhbGxvdyB0YWIgdGFyZ2V0aW5nIHNhaWQgZWxlbWVudCdzIGNoaWxkcmVuLlxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXkuPEVsZW1lbnR8Q2FuZGlkYXRlU2NvcGU+fSBjYW5kaWRhdGVzXG4gKiBAcmV0dXJucyBFbGVtZW50W11cbiAqL1xudmFyIHNvcnRCeU9yZGVyID0gZnVuY3Rpb24gc29ydEJ5T3JkZXIoY2FuZGlkYXRlcykge1xuICB2YXIgcmVndWxhclRhYmJhYmxlcyA9IFtdO1xuICB2YXIgb3JkZXJlZFRhYmJhYmxlcyA9IFtdO1xuICBjYW5kaWRhdGVzLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0sIGkpIHtcbiAgICB2YXIgaXNTY29wZSA9ICEhaXRlbS5zY29wZVBhcmVudDtcbiAgICB2YXIgZWxlbWVudCA9IGlzU2NvcGUgPyBpdGVtLnNjb3BlUGFyZW50IDogaXRlbTtcbiAgICB2YXIgY2FuZGlkYXRlVGFiaW5kZXggPSBnZXRTb3J0T3JkZXJUYWJJbmRleChlbGVtZW50LCBpc1Njb3BlKTtcbiAgICB2YXIgZWxlbWVudHMgPSBpc1Njb3BlID8gc29ydEJ5T3JkZXIoaXRlbS5jYW5kaWRhdGVzKSA6IGVsZW1lbnQ7XG4gICAgaWYgKGNhbmRpZGF0ZVRhYmluZGV4ID09PSAwKSB7XG4gICAgICBpc1Njb3BlID8gcmVndWxhclRhYmJhYmxlcy5wdXNoLmFwcGx5KHJlZ3VsYXJUYWJiYWJsZXMsIGVsZW1lbnRzKSA6IHJlZ3VsYXJUYWJiYWJsZXMucHVzaChlbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3JkZXJlZFRhYmJhYmxlcy5wdXNoKHtcbiAgICAgICAgZG9jdW1lbnRPcmRlcjogaSxcbiAgICAgICAgdGFiSW5kZXg6IGNhbmRpZGF0ZVRhYmluZGV4LFxuICAgICAgICBpdGVtOiBpdGVtLFxuICAgICAgICBpc1Njb3BlOiBpc1Njb3BlLFxuICAgICAgICBjb250ZW50OiBlbGVtZW50c1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG9yZGVyZWRUYWJiYWJsZXMuc29ydChzb3J0T3JkZXJlZFRhYmJhYmxlcykucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHNvcnRhYmxlKSB7XG4gICAgc29ydGFibGUuaXNTY29wZSA/IGFjYy5wdXNoLmFwcGx5KGFjYywgc29ydGFibGUuY29udGVudCkgOiBhY2MucHVzaChzb3J0YWJsZS5jb250ZW50KTtcbiAgICByZXR1cm4gYWNjO1xuICB9LCBbXSkuY29uY2F0KHJlZ3VsYXJUYWJiYWJsZXMpO1xufTtcbnZhciB0YWJiYWJsZSA9IGZ1bmN0aW9uIHRhYmJhYmxlKGNvbnRhaW5lciwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIGNhbmRpZGF0ZXM7XG4gIGlmIChvcHRpb25zLmdldFNoYWRvd1Jvb3QpIHtcbiAgICBjYW5kaWRhdGVzID0gZ2V0Q2FuZGlkYXRlc0l0ZXJhdGl2ZWx5KFtjb250YWluZXJdLCBvcHRpb25zLmluY2x1ZGVDb250YWluZXIsIHtcbiAgICAgIGZpbHRlcjogaXNOb2RlTWF0Y2hpbmdTZWxlY3RvclRhYmJhYmxlLmJpbmQobnVsbCwgb3B0aW9ucyksXG4gICAgICBmbGF0dGVuOiBmYWxzZSxcbiAgICAgIGdldFNoYWRvd1Jvb3Q6IG9wdGlvbnMuZ2V0U2hhZG93Um9vdCxcbiAgICAgIHNoYWRvd1Jvb3RGaWx0ZXI6IGlzVmFsaWRTaGFkb3dSb290VGFiYmFibGVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBjYW5kaWRhdGVzID0gZ2V0Q2FuZGlkYXRlcyhjb250YWluZXIsIG9wdGlvbnMuaW5jbHVkZUNvbnRhaW5lciwgaXNOb2RlTWF0Y2hpbmdTZWxlY3RvclRhYmJhYmxlLmJpbmQobnVsbCwgb3B0aW9ucykpO1xuICB9XG4gIHJldHVybiBzb3J0QnlPcmRlcihjYW5kaWRhdGVzKTtcbn07XG52YXIgZm9jdXNhYmxlID0gZnVuY3Rpb24gZm9jdXNhYmxlKGNvbnRhaW5lciwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIGNhbmRpZGF0ZXM7XG4gIGlmIChvcHRpb25zLmdldFNoYWRvd1Jvb3QpIHtcbiAgICBjYW5kaWRhdGVzID0gZ2V0Q2FuZGlkYXRlc0l0ZXJhdGl2ZWx5KFtjb250YWluZXJdLCBvcHRpb25zLmluY2x1ZGVDb250YWluZXIsIHtcbiAgICAgIGZpbHRlcjogaXNOb2RlTWF0Y2hpbmdTZWxlY3RvckZvY3VzYWJsZS5iaW5kKG51bGwsIG9wdGlvbnMpLFxuICAgICAgZmxhdHRlbjogdHJ1ZSxcbiAgICAgIGdldFNoYWRvd1Jvb3Q6IG9wdGlvbnMuZ2V0U2hhZG93Um9vdFxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGNhbmRpZGF0ZXMgPSBnZXRDYW5kaWRhdGVzKGNvbnRhaW5lciwgb3B0aW9ucy5pbmNsdWRlQ29udGFpbmVyLCBpc05vZGVNYXRjaGluZ1NlbGVjdG9yRm9jdXNhYmxlLmJpbmQobnVsbCwgb3B0aW9ucykpO1xuICB9XG4gIHJldHVybiBjYW5kaWRhdGVzO1xufTtcbnZhciBpc1RhYmJhYmxlID0gZnVuY3Rpb24gaXNUYWJiYWJsZShub2RlLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZiAoIW5vZGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG5vZGUgcHJvdmlkZWQnKTtcbiAgfVxuICBpZiAobWF0Y2hlcy5jYWxsKG5vZGUsIGNhbmRpZGF0ZVNlbGVjdG9yKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JUYWJiYWJsZShvcHRpb25zLCBub2RlKTtcbn07XG52YXIgZm9jdXNhYmxlQ2FuZGlkYXRlU2VsZWN0b3IgPSAvKiAjX19QVVJFX18gKi9jYW5kaWRhdGVTZWxlY3RvcnMuY29uY2F0KCdpZnJhbWUnKS5qb2luKCcsJyk7XG52YXIgaXNGb2N1c2FibGUgPSBmdW5jdGlvbiBpc0ZvY3VzYWJsZShub2RlLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBpZiAoIW5vZGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIG5vZGUgcHJvdmlkZWQnKTtcbiAgfVxuICBpZiAobWF0Y2hlcy5jYWxsKG5vZGUsIGZvY3VzYWJsZUNhbmRpZGF0ZVNlbGVjdG9yKSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzTm9kZU1hdGNoaW5nU2VsZWN0b3JGb2N1c2FibGUob3B0aW9ucywgbm9kZSk7XG59O1xuXG5leHBvcnQgeyBmb2N1c2FibGUsIGdldFRhYkluZGV4LCBpc0ZvY3VzYWJsZSwgaXNUYWJiYWJsZSwgdGFiYmFibGUgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmVzbS5qcy5tYXBcbiIsImltcG9ydCB7IENvbnRyb2xsZXIgfSBmcm9tICdAaG90d2lyZWQvc3RpbXVsdXMnO1xuaW1wb3J0IHsgYnJvd3NlclN1cHBvcnRzV2ViQXV0aG5BdXRvZmlsbCwgYnJvd3NlclN1cHBvcnRzV2ViQXV0aG4sIHN0YXJ0QXV0aGVudGljYXRpb24sIHN0YXJ0UmVnaXN0cmF0aW9uLCBiYXNlNjRVUkxTdHJpbmdUb0J1ZmZlciwgYnVmZmVyVG9CYXNlNjRVUkxTdHJpbmcgfSBmcm9tICdAc2ltcGxld2ViYXV0aG4vYnJvd3Nlcic7XG5cbmNsYXNzIGRlZmF1bHRfMSBleHRlbmRzIENvbnRyb2xsZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmNvbm5lY3QgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RSZXN1bHRVcmw6IHRoaXMucmVxdWVzdFJlc3VsdFVybFZhbHVlLFxuICAgICAgICAgICAgICAgIHJlcXVlc3RPcHRpb25zVXJsOiB0aGlzLnJlcXVlc3RPcHRpb25zVXJsVmFsdWUsXG4gICAgICAgICAgICAgICAgcmVxdWVzdFJlc3VsdEZpZWxkOiAoX2EgPSB0aGlzLnJlcXVlc3RSZXN1bHRGaWVsZFZhbHVlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdW5kZWZpbmVkID8gX2EgOiBudWxsLFxuICAgICAgICAgICAgICAgIGNyZWF0aW9uUmVzdWx0RmllbGQ6IChfYiA9IHRoaXMuY3JlYXRpb25SZXN1bHRGaWVsZFZhbHVlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdW5kZWZpbmVkID8gX2IgOiBudWxsLFxuICAgICAgICAgICAgICAgIHJlcXVlc3RTdWNjZXNzUmVkaXJlY3RVcmk6IChfYyA9IHRoaXMucmVxdWVzdFN1Y2Nlc3NSZWRpcmVjdFVyaVZhbHVlKSAhPT0gbnVsbCAmJiBfYyAhPT0gdW5kZWZpbmVkID8gX2MgOiBudWxsLFxuICAgICAgICAgICAgICAgIGNyZWF0aW9uUmVzdWx0VXJsOiB0aGlzLmNyZWF0aW9uUmVzdWx0VXJsVmFsdWUsXG4gICAgICAgICAgICAgICAgY3JlYXRpb25PcHRpb25zVXJsOiB0aGlzLmNyZWF0aW9uT3B0aW9uc1VybFZhbHVlLFxuICAgICAgICAgICAgICAgIGNyZWF0aW9uU3VjY2Vzc1JlZGlyZWN0VXJpOiAoX2QgPSB0aGlzLmNyZWF0aW9uU3VjY2Vzc1JlZGlyZWN0VXJpVmFsdWUpICE9PSBudWxsICYmIF9kICE9PSB1bmRlZmluZWQgPyBfZCA6IG51bGwsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5fZGlzcGF0Y2hFdmVudCgnd2ViYXV0aG46Y29ubmVjdCcsIHsgb3B0aW9ucyB9KTtcbiAgICAgICAgICAgIGNvbnN0IHN1cHBvcnRBdXRvZmlsbCA9IGF3YWl0IGJyb3dzZXJTdXBwb3J0c1dlYkF1dGhuQXV0b2ZpbGwoKTtcbiAgICAgICAgICAgIGlmIChzdXBwb3J0QXV0b2ZpbGwgJiYgdGhpcy51c2VCcm93c2VyQXV0b2ZpbGxWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9wdGlvbnNSZXNwb25zZUpzb24gPSBhd2FpdCB0aGlzLl9nZXRQdWJsaWNLZXlDcmVkZW50aWFsUmVxdWVzdE9wdGlvbnMoe30pO1xuICAgICAgICAgICAgICAgIGlmICghb3B0aW9uc1Jlc3BvbnNlSnNvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3NTaWduaW4ob3B0aW9uc1Jlc3BvbnNlSnNvbiwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIHNpZ25pbihldmVudCkge1xuICAgICAgICBpZiAoIWJyb3dzZXJTdXBwb3J0c1dlYkF1dGhuKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc3BhdGNoRXZlbnQoJ3dlYmF1dGhuOnVuc3VwcG9ydGVkJywge30pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnNSZXNwb25zZUpzb24gPSBhd2FpdCB0aGlzLl9nZXRQdWJsaWNLZXlDcmVkZW50aWFsUmVxdWVzdE9wdGlvbnMobnVsbCk7XG4gICAgICAgIGlmICghb3B0aW9uc1Jlc3BvbnNlSnNvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Byb2Nlc3NTaWduaW4ob3B0aW9uc1Jlc3BvbnNlSnNvbiwgZmFsc2UpO1xuICAgIH1cbiAgICBhc3luYyBfcHJvY2Vzc1NpZ25pbihvcHRpb25zUmVzcG9uc2VKc29uLCB1c2VCcm93c2VyQXV0b2ZpbGwpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgb3B0aW9uc1Jlc3BvbnNlSnNvbiA9IHRoaXMuX3Byb2Nlc3NFeHRlbnNpb25zSW5wdXQob3B0aW9uc1Jlc3BvbnNlSnNvbik7XG4gICAgICAgICAgICBsZXQgYXV0aGVudGljYXRvclJlc3BvbnNlID0gYXdhaXQgc3RhcnRBdXRoZW50aWNhdGlvbih7IG9wdGlvbnNKU09OOiBvcHRpb25zUmVzcG9uc2VKc29uLCB1c2VCcm93c2VyQXV0b2ZpbGwgfSk7XG4gICAgICAgICAgICBhdXRoZW50aWNhdG9yUmVzcG9uc2UgPSB0aGlzLl9wcm9jZXNzRXh0ZW5zaW9uc091dHB1dChhdXRoZW50aWNhdG9yUmVzcG9uc2UpO1xuICAgICAgICAgICAgdGhpcy5fZGlzcGF0Y2hFdmVudCgnd2ViYXV0aG46YXV0aGVudGljYXRvcjpyZXNwb25zZScsIHsgcmVzcG9uc2U6IGF1dGhlbnRpY2F0b3JSZXNwb25zZSB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlcXVlc3RSZXN1bHRGaWVsZFZhbHVlICYmIHRoaXMuZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxGb3JtRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yKHRoaXMucmVxdWVzdFJlc3VsdEZpZWxkVmFsdWUpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0QXR0cmlidXRlKCd2YWx1ZScsIEpTT04uc3RyaW5naWZ5KGF1dGhlbnRpY2F0b3JSZXNwb25zZSkpO1xuICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudC5zdWJtaXQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhc3NlcnRpb25SZXNwb25zZSA9IGF3YWl0IHRoaXMuX2dldEFzc2VydGlvblJlc3BvbnNlKGF1dGhlbnRpY2F0b3JSZXNwb25zZSk7XG4gICAgICAgICAgICBpZiAoYXNzZXJ0aW9uUmVzcG9uc2UgIT09IGZhbHNlICYmIHRoaXMucmVxdWVzdFN1Y2Nlc3NSZWRpcmVjdFVyaVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2UodGhpcy5yZXF1ZXN0U3VjY2Vzc1JlZGlyZWN0VXJpVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLl9kaXNwYXRjaEV2ZW50KCd3ZWJhdXRobjphc3NlcnRpb246ZmFpbHVyZScsIHsgZXhjZXB0aW9uOiBlLCBhc3NlcnRpb25SZXNwb25zZTogbnVsbCB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBzaWdudXAoZXZlbnQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFicm93c2VyU3VwcG9ydHNXZWJBdXRobigpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzcGF0Y2hFdmVudCgnd2ViYXV0aG46dW5zdXBwb3J0ZWQnLCB7fSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGxldCBvcHRpb25zUmVzcG9uc2VKc29uID0gYXdhaXQgdGhpcy5fZ2V0UHVibGljS2V5Q3JlZGVudGlhbENyZWF0aW9uT3B0aW9ucyhudWxsKTtcbiAgICAgICAgICAgIGlmICghb3B0aW9uc1Jlc3BvbnNlSnNvbikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9wdGlvbnNSZXNwb25zZUpzb24gPSB0aGlzLl9wcm9jZXNzRXh0ZW5zaW9uc0lucHV0KG9wdGlvbnNSZXNwb25zZUpzb24pO1xuICAgICAgICAgICAgbGV0IGF1dGhlbnRpY2F0b3JSZXNwb25zZSA9IGF3YWl0IHN0YXJ0UmVnaXN0cmF0aW9uKHsgb3B0aW9uc0pTT046IG9wdGlvbnNSZXNwb25zZUpzb24gfSk7XG4gICAgICAgICAgICBhdXRoZW50aWNhdG9yUmVzcG9uc2UgPSB0aGlzLl9wcm9jZXNzRXh0ZW5zaW9uc091dHB1dChhdXRoZW50aWNhdG9yUmVzcG9uc2UpO1xuICAgICAgICAgICAgdGhpcy5fZGlzcGF0Y2hFdmVudCgnd2ViYXV0aG46YXV0aGVudGljYXRvcjpyZXNwb25zZScsIHsgcmVzcG9uc2U6IGF1dGhlbnRpY2F0b3JSZXNwb25zZSB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNyZWF0aW9uUmVzdWx0RmllbGRWYWx1ZSAmJiB0aGlzLmVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MRm9ybUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3Rvcih0aGlzLmNyZWF0aW9uUmVzdWx0RmllbGRWYWx1ZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgSlNPTi5zdHJpbmdpZnkoYXV0aGVudGljYXRvclJlc3BvbnNlKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbGVtZW50LnN1Ym1pdCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGF0dGVzdGF0aW9uUmVzcG9uc2VKU09OID0gYXdhaXQgdGhpcy5fZ2V0QXR0ZXN0YXRpb25SZXNwb25zZShhdXRoZW50aWNhdG9yUmVzcG9uc2UpO1xuICAgICAgICAgICAgaWYgKGF0dGVzdGF0aW9uUmVzcG9uc2VKU09OICE9PSBmYWxzZSAmJiB0aGlzLmNyZWF0aW9uU3VjY2Vzc1JlZGlyZWN0VXJpVmFsdWUpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZSh0aGlzLmNyZWF0aW9uU3VjY2Vzc1JlZGlyZWN0VXJpVmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLl9kaXNwYXRjaEV2ZW50KCd3ZWJhdXRobjphdHRlc3RhdGlvbjpmYWlsdXJlJywgeyBleGNlcHRpb246IGUsIGFzc2VydGlvblJlc3BvbnNlOiBudWxsIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9kaXNwYXRjaEV2ZW50KG5hbWUsIHBheWxvYWQpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50LmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KG5hbWUsIHsgZGV0YWlsOiBwYXlsb2FkLCBidWJibGVzOiB0cnVlIH0pKTtcbiAgICB9XG4gICAgX2dldERhdGEoKSB7XG4gICAgICAgIGxldCBkYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQucmVwb3J0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5lbGVtZW50LmNoZWNrVmFsaWRpdHkoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGEgPSBuZXcgRm9ybURhdGEodGhpcy5lbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHJlbW92ZUVtcHR5KG9iaikge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKG9iailcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChbLCB2XSkgPT4gdiAhPT0gbnVsbCAmJiB2ICE9PSAnJylcbiAgICAgICAgICAgICAgICAucmVkdWNlKChhY2MsIFtrLCB2XSkgPT4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgYWNjKSwgeyBba106IHYgPT09IE9iamVjdCh2KSA/IHJlbW92ZUVtcHR5KHYpIDogdiB9KSksIHt9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVtb3ZlRW1wdHkoe1xuICAgICAgICAgICAgdXNlcm5hbWU6IGRhdGEuZ2V0KHRoaXMudXNlcm5hbWVGaWVsZFZhbHVlKSxcbiAgICAgICAgICAgIGRpc3BsYXlOYW1lOiBkYXRhLmdldCh0aGlzLmRpc3BsYXlOYW1lRmllbGRWYWx1ZSksXG4gICAgICAgICAgICBhdHRlc3RhdGlvbjogZGF0YS5nZXQodGhpcy5hdHRlc3RhdGlvbkZpZWxkVmFsdWUpLFxuICAgICAgICAgICAgdXNlclZlcmlmaWNhdGlvbjogZGF0YS5nZXQodGhpcy51c2VyVmVyaWZpY2F0aW9uRmllbGRWYWx1ZSksXG4gICAgICAgICAgICByZXNpZGVudEtleTogZGF0YS5nZXQodGhpcy5yZXNpZGVudEtleUZpZWxkVmFsdWUpLFxuICAgICAgICAgICAgYXV0aGVudGljYXRvckF0dGFjaG1lbnQ6IGRhdGEuZ2V0KHRoaXMuYXV0aGVudGljYXRvckF0dGFjaG1lbnRGaWVsZFZhbHVlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIF9nZXRQdWJsaWNLZXlDcmVkZW50aWFsUmVxdWVzdE9wdGlvbnMoZm9ybURhdGEpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldE9wdGlvbnModGhpcy5yZXF1ZXN0T3B0aW9uc1VybFZhbHVlLCBmb3JtRGF0YSk7XG4gICAgfVxuICAgIGFzeW5jIF9nZXRQdWJsaWNLZXlDcmVkZW50aWFsQ3JlYXRpb25PcHRpb25zKGZvcm1EYXRhKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRPcHRpb25zKHRoaXMuY3JlYXRpb25PcHRpb25zVXJsVmFsdWUsIGZvcm1EYXRhKTtcbiAgICB9XG4gICAgYXN5bmMgX2dldE9wdGlvbnModXJsLCBmb3JtRGF0YSkge1xuICAgICAgICBjb25zdCBkYXRhID0gZm9ybURhdGEgfHwgdGhpcy5fZ2V0RGF0YSgpO1xuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kaXNwYXRjaEV2ZW50KCd3ZWJhdXRobjpvcHRpb25zOnJlcXVlc3QnLCB7IGRhdGEgfSk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnNSZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICAgICAgaGVhZGVyczogT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5yZXF1ZXN0SGVhZGVyc1ZhbHVlKSxcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSlcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghb3B0aW9uc1Jlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICB0aGlzLl9kaXNwYXRjaEV2ZW50KCd3ZWJhdXRobjpvcHRpb25zOmZhaWx1cmUnLCB7IGV4Y2VwdGlvbjogbnVsbCwgb3B0aW9uc1Jlc3BvbnNlIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBhd2FpdCBvcHRpb25zUmVzcG9uc2UuanNvbigpO1xuICAgICAgICB0aGlzLl9kaXNwYXRjaEV2ZW50KCd3ZWJhdXRobjpvcHRpb25zOnN1Y2Nlc3MnLCB7IGRhdGE6IG9wdGlvbnMgfSk7XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cbiAgICBhc3luYyBfZ2V0QXR0ZXN0YXRpb25SZXNwb25zZShhdXRoZW50aWNhdG9yUmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldFJlc3VsdCh0aGlzLmNyZWF0aW9uUmVzdWx0VXJsVmFsdWUsICd3ZWJhdXRobjphdHRlc3RhdGlvbjonLCBhdXRoZW50aWNhdG9yUmVzcG9uc2UpO1xuICAgIH1cbiAgICBhc3luYyBfZ2V0QXNzZXJ0aW9uUmVzcG9uc2UoYXV0aGVudGljYXRvclJlc3BvbnNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRSZXN1bHQodGhpcy5yZXF1ZXN0UmVzdWx0VXJsVmFsdWUsICd3ZWJhdXRobjphc3NlcnRpb246JywgYXV0aGVudGljYXRvclJlc3BvbnNlKTtcbiAgICB9XG4gICAgYXN5bmMgX2dldFJlc3VsdCh1cmwsIGV2ZW50UHJlZml4LCBhdXRoZW50aWNhdG9yUmVzcG9uc2UpIHtcbiAgICAgICAgY29uc3QgYXR0ZXN0YXRpb25SZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgICAgICAgaGVhZGVyczogT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5yZXF1ZXN0SGVhZGVyc1ZhbHVlKSxcbiAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYXV0aGVudGljYXRvclJlc3BvbnNlKVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKCFhdHRlc3RhdGlvblJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICB0aGlzLl9kaXNwYXRjaEV2ZW50KGV2ZW50UHJlZml4ICsgJ2ZhaWx1cmUnLCB7fSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXR0ZXN0YXRpb25SZXNwb25zZUpTT04gPSBhd2FpdCBhdHRlc3RhdGlvblJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2hFdmVudChldmVudFByZWZpeCArICdzdWNjZXNzJywgeyBkYXRhOiBhdHRlc3RhdGlvblJlc3BvbnNlSlNPTiB9KTtcbiAgICAgICAgcmV0dXJuIGF0dGVzdGF0aW9uUmVzcG9uc2VKU09OO1xuICAgIH1cbiAgICBfcHJvY2Vzc0V4dGVuc2lvbnNJbnB1dChvcHRpb25zKSB7XG4gICAgICAgIGlmICghb3B0aW9ucyB8fCAhb3B0aW9ucy5leHRlbnNpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5leHRlbnNpb25zLnByZikge1xuICAgICAgICAgICAgb3B0aW9ucy5leHRlbnNpb25zLnByZiA9IHRoaXMuX3Byb2Nlc3NQcmZJbnB1dChvcHRpb25zLmV4dGVuc2lvbnMucHJmKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG4gICAgX3Byb2Nlc3NQcmZJbnB1dChwcmYpIHtcbiAgICAgICAgaWYgKHByZi5ldmFsKSB7XG4gICAgICAgICAgICBwcmYuZXZhbCA9IHRoaXMuX2ltcG9ydFByZlZhbHVlcyhldmFsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJmLmV2YWxCeUNyZWRlbnRpYWwpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHByZi5ldmFsQnlDcmVkZW50aWFsKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBwcmYuZXZhbEJ5Q3JlZGVudGlhbFtrZXldID0gdGhpcy5faW1wb3J0UHJmVmFsdWVzKHByZi5ldmFsQnlDcmVkZW50aWFsW2tleV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByZjtcbiAgICB9XG4gICAgX2ltcG9ydFByZlZhbHVlcyh2YWx1ZXMpIHtcbiAgICAgICAgdmFsdWVzLmZpcnN0ID0gYmFzZTY0VVJMU3RyaW5nVG9CdWZmZXIodmFsdWVzLmZpcnN0KTtcbiAgICAgICAgaWYgKHZhbHVlcy5zZWNvbmQpIHtcbiAgICAgICAgICAgIHZhbHVlcy5zZWNvbmQgPSBiYXNlNjRVUkxTdHJpbmdUb0J1ZmZlcih2YWx1ZXMuc2Vjb25kKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWVzO1xuICAgIH1cbiAgICBfcHJvY2Vzc0V4dGVuc2lvbnNPdXRwdXQob3B0aW9ucykge1xuICAgICAgICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMuZXh0ZW5zaW9ucykge1xuICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZXh0ZW5zaW9ucy5wcmYpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZXh0ZW5zaW9ucy5wcmYgPSB0aGlzLl9wcm9jZXNzUHJmT3V0cHV0KG9wdGlvbnMuZXh0ZW5zaW9ucy5wcmYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgIH1cbiAgICBfcHJvY2Vzc1ByZk91dHB1dChwcmYpIHtcbiAgICAgICAgaWYgKCFwcmYucmVzdWx0KSB7XG4gICAgICAgICAgICByZXR1cm4gcHJmO1xuICAgICAgICB9XG4gICAgICAgIHByZi5yZXN1bHQgPSB0aGlzLl9leHBvcnRQcmZWYWx1ZXMocHJmLnJlc3VsdCk7XG4gICAgICAgIHJldHVybiBwcmY7XG4gICAgfVxuICAgIF9leHBvcnRQcmZWYWx1ZXModmFsdWVzKSB7XG4gICAgICAgIHZhbHVlcy5maXJzdCA9IGJ1ZmZlclRvQmFzZTY0VVJMU3RyaW5nKHZhbHVlcy5maXJzdCk7XG4gICAgICAgIGlmICh2YWx1ZXMuc2Vjb25kKSB7XG4gICAgICAgICAgICB2YWx1ZXMuc2Vjb25kID0gYnVmZmVyVG9CYXNlNjRVUkxTdHJpbmcodmFsdWVzLnNlY29uZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlcztcbiAgICB9XG59XG5kZWZhdWx0XzEudmFsdWVzID0ge1xuICAgIHJlcXVlc3RSZXN1bHRVcmw6IHsgdHlwZTogU3RyaW5nLCBkZWZhdWx0OiAnL3JlcXVlc3QnIH0sXG4gICAgcmVxdWVzdE9wdGlvbnNVcmw6IHsgdHlwZTogU3RyaW5nLCBkZWZhdWx0OiAnL3JlcXVlc3Qvb3B0aW9ucycgfSxcbiAgICByZXF1ZXN0UmVzdWx0RmllbGQ6IHsgdHlwZTogU3RyaW5nLCBkZWZhdWx0OiBudWxsIH0sXG4gICAgcmVxdWVzdFN1Y2Nlc3NSZWRpcmVjdFVyaTogU3RyaW5nLFxuICAgIGNyZWF0aW9uUmVzdWx0VXJsOiB7IHR5cGU6IFN0cmluZywgZGVmYXVsdDogJy9jcmVhdGlvbicgfSxcbiAgICBjcmVhdGlvbk9wdGlvbnNVcmw6IHsgdHlwZTogU3RyaW5nLCBkZWZhdWx0OiAnL2NyZWF0aW9uL29wdGlvbnMnIH0sXG4gICAgY3JlYXRpb25SZXN1bHRGaWVsZDogeyB0eXBlOiBTdHJpbmcsIGRlZmF1bHQ6IG51bGwgfSxcbiAgICBjcmVhdGlvblN1Y2Nlc3NSZWRpcmVjdFVyaTogU3RyaW5nLFxuICAgIHVzZXJuYW1lRmllbGQ6IHsgdHlwZTogU3RyaW5nLCBkZWZhdWx0OiAndXNlcm5hbWUnIH0sXG4gICAgZGlzcGxheU5hbWVGaWVsZDogeyB0eXBlOiBTdHJpbmcsIGRlZmF1bHQ6ICdkaXNwbGF5TmFtZScgfSxcbiAgICBhdHRlc3RhdGlvbkZpZWxkOiB7IHR5cGU6IFN0cmluZywgZGVmYXVsdDogJ2F0dGVzdGF0aW9uJyB9LFxuICAgIHVzZXJWZXJpZmljYXRpb25GaWVsZDogeyB0eXBlOiBTdHJpbmcsIGRlZmF1bHQ6ICd1c2VyVmVyaWZpY2F0aW9uJyB9LFxuICAgIHJlc2lkZW50S2V5RmllbGQ6IHsgdHlwZTogU3RyaW5nLCBkZWZhdWx0OiAncmVzaWRlbnRLZXknIH0sXG4gICAgYXV0aGVudGljYXRvckF0dGFjaG1lbnRGaWVsZDogeyB0eXBlOiBTdHJpbmcsIGRlZmF1bHQ6ICdhdXRoZW50aWNhdG9yQXR0YWNobWVudCcgfSxcbiAgICB1c2VCcm93c2VyQXV0b2ZpbGw6IHsgdHlwZTogQm9vbGVhbiwgZGVmYXVsdDogZmFsc2UgfSxcbiAgICByZXF1ZXN0SGVhZGVyczogeyB0eXBlOiBPYmplY3QsIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICAgICAgJ21vZGUnOiAnbm8tY29ycycsXG4gICAgICAgICAgICAnY3JlZGVudGlhbHMnOiAnaW5jbHVkZSdcbiAgICAgICAgfSB9LFxufTtcblxuZXhwb3J0IHsgZGVmYXVsdF8xIGFzIGRlZmF1bHQgfTtcbiIsIi8vIFRoZSBtb2R1bGUgY2FjaGVcbnZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcblxuLy8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbmZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG5cdHZhciBjYWNoZWRNb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdO1xuXHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcblx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG5cdH1cblx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcblx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG5cdFx0Ly8gbm8gbW9kdWxlLmlkIG5lZWRlZFxuXHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG5cdFx0ZXhwb3J0czoge31cblx0fTtcblxuXHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cblx0X193ZWJwYWNrX21vZHVsZXNfX1ttb2R1bGVJZF0obW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cblx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcblx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xufVxuXG4iLCIvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuX193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG5cdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuXHRcdGZ1bmN0aW9uKCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuXHRcdGZ1bmN0aW9uKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCB7IGE6IGdldHRlciB9KTtcblx0cmV0dXJuIGdldHRlcjtcbn07IiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgZGVmaW5pdGlvbikge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmosIHByb3ApIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApOyB9IiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJpbXBvcnQgeyBBcHBsaWNhdGlvbiB9IGZyb20gJ0Bob3R3aXJlZC9zdGltdWx1cyc7XG5pbXBvcnQgeyBkZWZpbml0aW9uRm9yTW9kdWxlQW5kSWRlbnRpZmllciwgaWRlbnRpZmllckZvckNvbnRleHRLZXkgfSBmcm9tICdAaG90d2lyZWQvc3RpbXVsdXMtd2VicGFjay1oZWxwZXJzJztcbmltcG9ydCAnQGhvdHdpcmVkL3R1cmJvJztcbmltcG9ydCBXZWJBdXRobiBmcm9tICdAd2ViLWF1dGgvd2ViYXV0aG4tc3RpbXVsdXMnO1xuXG5pbXBvcnQgJy4vc2NyaXB0cy9tb290YW8uanMnO1xuaW1wb3J0ICcuL3NjcmlwdHMvY29yZS5qcyc7XG5pbXBvcnQgJy4vc2NyaXB0cy9saW1pdC1oZWlnaHQuanMnO1xuXG5pbXBvcnQgJy4vc3R5bGVzL2JhY2tlbmQucGNzcyc7XG5cbi8vIFN0YXJ0IHRoZSBTdGltdWx1cyBhcHBsaWNhdGlvblxuY29uc3QgYXBwbGljYXRpb24gPSBBcHBsaWNhdGlvbi5zdGFydCgpO1xuYXBwbGljYXRpb24uZGVidWcgPSBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JztcblxuLy8gUmVnaXN0ZXIgYWxsIGNvbnRyb2xsZXJzIHdpdGggYGNvbnRhby0tYCBwcmVmaXhcbmNvbnN0IGNvbnRleHQgPSByZXF1aXJlLmNvbnRleHQoJy4vY29udHJvbGxlcnMnLCB0cnVlLCAvXFwuanMkLyk7XG5hcHBsaWNhdGlvbi5sb2FkKFxuICAgIGNvbnRleHRcbiAgICAgICAgLmtleXMoKVxuICAgICAgICAubWFwKChrZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSBpZGVudGlmaWVyRm9yQ29udGV4dEtleShrZXkpO1xuICAgICAgICAgICAgaWYgKGlkZW50aWZpZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVmaW5pdGlvbkZvck1vZHVsZUFuZElkZW50aWZpZXIoY29udGV4dChrZXkpLCBgY29udGFvLS0ke2lkZW50aWZpZXJ9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5maWx0ZXIoKHZhbHVlKSA9PiB2YWx1ZSksXG4pO1xuXG5hcHBsaWNhdGlvbi5yZWdpc3RlcignY29udGFvLS13ZWJhdXRobicsIFdlYkF1dGhuKTtcblxuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3R1cmJvOmJlZm9yZS1wcmVmZXRjaCcsIChlKSA9PiB7XG4gICAgaWYgKFxuICAgICAgICAvLyBEbyBub3QgcHJlZmV0Y2ggaWYgdGhlIHVzZXIgd2FudHMgdG8gc2F2ZSBkYXRhIG9yIGlzIG9uIGEgc2xvd1xuICAgICAgICAvLyBjb25uZWN0aW9uXG4gICAgICAgIG5hdmlnYXRvci5jb25uZWN0aW9uPy5zYXZlRGF0YSB8fFxuICAgICAgICBbJ3Nsb3ctMmcnLCAnMmcnXS5pbmNsdWRlcyhuYXZpZ2F0b3IuY29ubmVjdGlvbj8uZWZmZWN0aXZlVHlwZSkgfHxcbiAgICAgICAgLy8gRG8gbm90IHByZWZldGNoIGlmIHRoZSBVUkwgY29udGFpbnMgYSByZXF1ZXN0IHRva2VuIG9yIHRoZSBlbGVtZW50XG4gICAgICAgIC8vIGlzIHBhcnQgb2YgdGhlIFN5bWZvbnkgdG9vbGJhclxuICAgICAgICAoZS50YXJnZXQuc2VhcmNoICYmIG5ldyBVUkxTZWFyY2hQYXJhbXMoZS50YXJnZXQuc2VhcmNoKS5oYXMoJ3J0JykpIHx8XG4gICAgICAgIGUudGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnaGVhZGVyX2JhY2snKSB8fFxuICAgICAgICBlLnRhcmdldC5tYXRjaGVzKCdbb25jbGlja149XCJCYWNrZW5kLm9wZW5Nb2RhbElmcmFtZShcIl0nKSB8fFxuICAgICAgICBlLnRhcmdldC5jbG9zZXN0KCcuc2YtdG9vbGJhcicpICE9PSBudWxsXG4gICAgKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG59KTtcblxuLy8gTWFrZSB0aGUgTW9vVG9vbHMgc2NyaXB0cyByZWluaXRpYWxpemUgdGhlbXNlbHZlc1xuY29uc3QgbW9vRG9tcmVhZHkgPSAoKSA9PiB7XG4gICAgaWYgKCFkb2N1bWVudC5ib2R5Lm1vb0RvbXJlYWR5RmlyZWQpIHtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5tb29Eb21yZWFkeUZpcmVkID0gdHJ1ZTtcbiAgICAgICAgd2luZG93LmZpcmVFdmVudCgnZG9tcmVhZHknKTtcbiAgICB9XG59O1xuXG5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndHVyYm86cmVuZGVyJywgbW9vRG9tcmVhZHkpO1xuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3R1cmJvOmZyYW1lLXJlbmRlcicsIG1vb0RvbXJlYWR5KTtcblxuLy8gQWx3YXlzIGJyZWFrIG91dCBvZiBhIG1pc3NpbmcgZnJhbWUgKCM3NTAxKVxuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3R1cmJvOmZyYW1lLW1pc3NpbmcnLCAoZSkgPT4ge1xuICAgIGlmICh3aW5kb3cuY29uc29sZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oYFR1cmJvIGZyYW1lICMke2UudGFyZ2V0LmlkfSBpcyBtaXNzaW5nLmApO1xuICAgIH1cblxuICAgIC8vIERvIG5vdCBicmVhayBvdXQgb2YgZnJhbWVzIHRoYXQgbG9hZCB0aGVpciBjb250ZW50IHZpYSBzcmNcbiAgICBpZiAoZS50YXJnZXQuaGFzQXR0cmlidXRlKCdzcmMnKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGUuZGV0YWlsLnZpc2l0KGUuZGV0YWlsLnJlc3BvbnNlKTtcbn0pO1xuXG4vLyBDYWxsIHRoZSBiZWZvcmVDYWNoZSgpIGZ1bmN0aW9uIG9uIGFsbCBjb250cm9sbGVycyBpbXBsZW1lbnRpbmcgaXQuIFRoaXNcbi8vIGFsbG93cyBjb250cm9sbGVycyB0byB0ZWFyIGRvd24gdGhpbmdzIGJlZm9yZSB0aGUgcGFnZSBnZXRzIHB1dCBpbnRvIGNhY2hlLlxuLy8gTm90ZSB0aGF0IFN0aW11bHVzJyBkaXNjb25uZWN0KCkgZnVuY3Rpb24gd2lsbCBub3QgZmlyZSBhdCB0aGlzIHBvaW50IGFuZFxuLy8gdGh1cyBjYW5ub3QgYmUgdXNlZCBmb3IgdGhpcyB0YXNrLlxuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3R1cmJvOmJlZm9yZS1jYWNoZScsIChlKSA9PiB7XG4gICAgZm9yIChjb25zdCBjb250cm9sbGVyIG9mIGFwcGxpY2F0aW9uLmNvbnRyb2xsZXJzKSB7XG4gICAgICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgY29udHJvbGxlci5iZWZvcmVDYWNoZSkge1xuICAgICAgICAgICAgY29udHJvbGxlci5iZWZvcmVDYWNoZShlKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlbW92ZSB0aGUgU3ltZm9ueSB0b29sYmFyXG4gICAgZS50YXJnZXQucXVlcnlTZWxlY3RvcignLnNmLXRvb2xiYXInKT8ucmVtb3ZlKCk7XG59KTtcblxuLy8gSWYgdGhlIHByZXZpb3VzbHkgZmV0Y2hlZCByZXNvdXJjZSBnb3QgcmVkaXJlY3RlZCBhbmQgYSBmdWxsIHBhZ2UgcmVsb2FkXG4vLyBvY2N1cnMsIFR1cmJvIGN1cnJlbnRseSB1c2VzIHRoZSB3cm9uZyBVUkwgKHRoZSBvcmlnaW5hbGx5IGZldGNoZWQgb25lLCBub3Rcbi8vIHRoZSBlZmZlY3RpdmUgVVJMIGFmdGVyIHRoZSByZWRpcmVjdCkuXG4vLyBUT0RPOiBSZW1vdmUgYWdhaW4gb25jZSBob3R3aXJlZC90dXJibyMxMzkxIGlzIGZpeGVkLlxubGV0IHRhcmdldFVSTEFmdGVyUmVkaXJlY3RlZEZldGNoID0gbnVsbDtcblxuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3R1cmJvOnJlbG9hZCcsIChldmVudCkgPT4ge1xuICAgIGlmIChldmVudC5kZXRhaWwucmVhc29uICE9PSAncmVxdWVzdF9mYWlsZWQnICYmIHRhcmdldFVSTEFmdGVyUmVkaXJlY3RlZEZldGNoKSB7XG4gICAgICAgIFR1cmJvLnNlc3Npb24uYWRhcHRlci5sb2NhdGlvbiA9IG5ldyBVUkwodGFyZ2V0VVJMQWZ0ZXJSZWRpcmVjdGVkRmV0Y2gpO1xuICAgIH1cbn0pO1xuXG5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndHVyYm86YmVmb3JlLWZldGNoLXJlc3BvbnNlJywgKGV2ZW50KSA9PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBldmVudC5kZXRhaWwuZmV0Y2hSZXNwb25zZTtcbiAgICB0YXJnZXRVUkxBZnRlclJlZGlyZWN0ZWRGZXRjaCA9IHJlc3BvbnNlLnJlZGlyZWN0ZWQgPyByZXNwb25zZS5yZXNwb25zZS51cmwgOiBudWxsO1xufSk7XG4iXSwibmFtZXMiOlsiQ29udHJvbGxlciIsInZhbHVlcyIsInR5cGUiLCJTdHJpbmciLCJyZWFkT25seSIsIkJvb2xlYW4iLCJjb25uZWN0IiwiY29udGFpbmVyIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiaWQiLCJlbGVtZW50IiwiY2xhc3NOYW1lIiwicGFyZW50Tm9kZSIsImluc2VydEJlZm9yZSIsIm5leHRTaWJsaW5nIiwic3R5bGUiLCJkaXNwbGF5IiwiZWRpdG9yIiwiYWNlIiwiZWRpdCIsImdldFNlc3Npb24iLCJzZXRWYWx1ZSIsInZhbHVlIiwib24iLCJ3aW5kb3ciLCJkaXNwYXRjaEV2ZW50IiwiRXZlbnQiLCJnZXRWYWx1ZSIsImNvbW1hbmRzIiwiYmluZEtleSIsImNvbmZpZ0NhbGxiYWNrIiwic2V0TWF4TGluZXMiLCJhZGRFdmVudExpc3RlbmVyIiwiYmluZCIsImRpc2Nvbm5lY3QiLCJkZXN0cm95IiwicmVtb3ZlIiwiYmVmb3JlQ2FjaGUiLCJjb2xvckNoYW5nZSIsImV2ZW50Iiwic2V0VGhlbWUiLCJkZXRhaWwiLCJtb2RlIiwic2V0T3B0aW9uIiwiTWF0aCIsImZsb29yIiwiaW5uZXJIZWlnaHQiLCJsaW5lSGVpZ2h0IiwiZm9jdXNUcmFwIiwiVHVyYm9TdHJlYW1Db25uZWN0aW9uIiwiQmFja2VuZFNlYXJjaENvbnRyb2xsZXIiLCJ0YXJnZXRzIiwidXJsIiwibWluQ2hhcmFjdGVycyIsIk51bWJlciIsImRlYm91bmNlRGVsYXkiLCJjbGFzc2VzIiwiZGVib3VuY2VUaW1lb3V0Iiwic2VhcmNoUmVzdWx0Q29ubmVjdGlvbiIsImNyZWF0ZUZvY3VzVHJhcCIsImVzY2FwZURlYWN0aXZhdGVzIiwiYWxsb3dPdXRzaWRlQ2xpY2siLCJfc3RvcFBlbmRpbmdTZWFyY2giLCJzZWFyY2giLCJpbnB1dFRhcmdldCIsImxlbmd0aCIsIm1pbkNoYXJhY3RlcnNWYWx1ZSIsIl9zZXRTdGF0ZSIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsImRlYm91bmNlRGVsYXlWYWx1ZSIsInJlc3VsdCIsImdldCIsInVybFZhbHVlIiwia2V5d29yZHMiLCJvayIsImFjdGl2YXRlIiwiZXJyb3IiLCJvcGVuIiwiYWN0aXZlIiwiY2xvc2UiLCJQb2ludGVyRXZlbnQiLCJjb250YWlucyIsInRhcmdldCIsInJlc3VsdHNUYXJnZXQiLCJpbm5lclRleHQiLCJibHVyIiwiY2xlYXJUaW1lb3V0IiwiYWJvcnRQZW5kaW5nIiwiZGVhY3RpdmF0ZSIsInN0YXRlIiwiY2xhc3NMaXN0IiwidG9nZ2xlIiwidXBkYXRlIiwiY2hlY2tlZCIsInNvdXJjZVRhcmdldCIsImVsIiwiaW5wdXRUYXJnZXRzIiwiQ2hvaWNlc0NvbnRyb2xsZXIiLCJzZWxlY3QiLCJxdWVyeVNlbGVjdG9yIiwiY2hvaWNlcyIsIkNob2ljZXMiLCJzaG91bGRTb3J0IiwiZHVwbGljYXRlSXRlbXNBbGxvd2VkIiwiYWxsb3dIVE1MIiwicmVtb3ZlSXRlbUJ1dHRvbiIsInNlYXJjaEVuYWJsZWQiLCJvcHRpb25zIiwic2VhcmNoUmVzdWx0TGltaXQiLCJhcHBlbmRHcm91cEluU2VhcmNoIiwiY2xhc3NOYW1lcyIsImNvbnRhaW5lck91dGVyIiwiQXJyYXkiLCJmcm9tIiwiZmxpcHBlZFN0YXRlIiwiZnVzZU9wdGlvbnMiLCJpbmNsdWRlU2NvcmUiLCJ0aHJlc2hvbGQiLCJjYWxsYmFja09uSW5pdCIsImNsb3Nlc3QiLCJkYXRhc2V0IiwicGxhY2Vob2xkZXIiLCJsb2FkaW5nVGV4dCIsIkNvbnRhbyIsImxhbmciLCJsb2FkaW5nIiwibm9SZXN1bHRzVGV4dCIsIm5vUmVzdWx0cyIsIm5vQ2hvaWNlc1RleHQiLCJub09wdGlvbnMiLCJyZW1vdmVJdGVtTGFiZWxUZXh0IiwicmVtb3ZlSXRlbSIsImNvbmNhdCIsIl9yZW1vdmVDaG9pY2VzIiwiTWVzc2FnZSIsImNvbnRlbnQiLCJtZXNzYWdlIiwiZGVmYXVsdCIsIndyaXRlIiwibmF2aWdhdG9yIiwiY2xpcGJvYXJkIiwiY29uc29sZSIsIndyaXRlVGV4dCIsImNvbnRlbnRWYWx1ZSIsImluZm8iLCJtZXNzYWdlVmFsdWUiLCJDb2xvclBpY2tlciIsImhleFZhbHVlTG9hZGVkIiwidGVzdCIsInN1YnN0cmluZyIsIm9uU2F2ZSIsImNvbG9yIiwidG9IRVhBIiwidG9TdHJpbmciLCJjaGFyQXQiLCJ0b0xvd2VyQ2FzZSIsInBpY2tlciIsImhpZGUiLCJwcmVmZXJzRGFyayIsImxvY2FsU3RvcmFnZSIsImdldEl0ZW0iLCJtYXRjaE1lZGlhIiwibWF0Y2hlcyIsInNldENvbG9yU2NoZW1lIiwiZG9jdW1lbnRFbGVtZW50IiwiY29sb3JTY2hlbWUiLCJpMThuIiwiT2JqZWN0IiwibGlnaHQiLCJkYXJrIiwiaW5pdGlhbGl6ZSIsInNldExhYmVsIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImUiLCJwcmV2ZW50RGVmYXVsdCIsImlzRGFyayIsInNldEl0ZW0iLCJkaXNwYXRjaCIsImhhc0xhYmVsVGFyZ2V0IiwibGFiZWwiLCJpMThuVmFsdWUiLCJsYWJlbFRhcmdldCIsInRpdGxlIiwiVHVyYm8iLCJhZnRlckxvYWQiLCJpZGVudGlmaWVyIiwic2V0dXBDb250cm9sbGVyIiwicXVlcnlTZWxlY3RvckFsbCIsInByaW1hcnkiLCJzZWNvbmRhcnkiLCJzZXRBdHRyaWJ1dGUiLCJjb250cm9sbGVyIiwiVGhlbWUiLCJzZXR1cEN0cmxDbGljayIsIndhcm4iLCJoYW5kbGUiLCJpc1ZhbGlkIiwicHJpbWFyeUtleSIsInBsYXRmb3JtIiwic3RhcnRzV2l0aCIsInNoaWZ0S2V5IiwiaGFzUHJpbWFyeVRhcmdldCIsInByaW1hcnlUYXJnZXQiLCJocmVmIiwidmlzaXQiLCJoYXNTZWNvbmRhcnlUYXJnZXQiLCJzZWNvbmRhcnlUYXJnZXQiLCJwb2ludGVyVHlwZSIsIiR0aW1lciIsImdldEF0dHJpYnV0ZSIsInJlbW92ZUF0dHJpYnV0ZSIsInZpc2l0UHJpbWFyeSIsInZpc2l0U2Vjb25kYXJ5IiwidGFnTmFtZSIsInNob3dNb2RhbCIsImZvY3VzIiwic3VzcGVuZCIsInJlc3VtZSIsImNvbmZpZyIsIl91cGRhdGVXaXphcmQiLCJfdXBkYXRlSW5wdXRzIiwid2lkdGhUYXJnZXREaXNjb25uZWN0ZWQiLCJpbnB1dCIsIl9yZXNldElucHV0IiwiaGVpZ2h0VGFyZ2V0RGlzY29ubmVjdGVkIiwiY2FuRWRpdCIsImJ1dHRvblRhcmdldCIsImNvbmZpZ1ZhbHVlIiwiZGlzYWJsZWQiLCJpbWciLCJpbWFnZVRhcmdldHMiLCJzcmMiLCJpY29uIiwiaWNvbkRpc2FibGVkIiwic2VsZWN0VGFyZ2V0IiwiaW5kZXhPZiIsInRvSW50IiwiZGltZW5zaW9ucyIsInNlbGVjdGVkSW5kZXgiLCJ0ZXh0Iiwic3BsaXQiLCJnZXRMYXN0Iiwid2lkdGhUYXJnZXQiLCJoZWlnaHRUYXJnZXQiLCJvcGVuTW9kYWwiLCJCYWNrZW5kIiwib3Blbk1vZGFsSWZyYW1lIiwiaWRzIiwiaW5jbHVkZXMiLCJhdHRyaWJ1dGUiLCJzb3VyY2VUYXJnZXRzIiwicHVzaCIsImF0dHJpYnV0ZVZhbHVlIiwiam9pbiIsInJlbW92ZUVsZW1lbnQiLCJfZ2V0RWxlbWVudCIsInBhcmFtcyIsIl90dXJib1N0cmVhbUNvbm5lY3Rpb24iLCJfcnVubmluZ0pvYnMiLCJwZW5kaW5nSm9ic1VybCIsImRlZmF1bHRJbnRlcnZhbCIsIm1heGltdW1JbnRlcnZhbCIsImVuYWJsZWQiLCJhbGxKb2JzUHJvY2Vzc2VkTWVzc2FnZSIsIl9wb2xsSW50ZXJ2YWwiLCJkZWZhdWx0SW50ZXJ2YWxWYWx1ZSIsIl90aW1lciIsImVuYWJsZWRWYWx1ZSIsImVuYWJsZSIsIl9wb2xsIiwibGlzdFRhcmdldENvbm5lY3RlZCIsImpvYnMiLCJjb3VudFRhcmdldCIsImFsbEpvYnNQcm9jZXNzZWRNZXNzYWdlVmFsdWUiLCJtaW4iLCJtYXhpbXVtSW50ZXJ2YWxWYWx1ZSIsIl93YWl0QW5kUG9sbCIsInBlbmRpbmdKb2JzVXJsVmFsdWUiLCJzZWN0aW9uVGFyZ2V0Q29ubmVjdGVkIiwicmVidWlsZE5hdmlnYXRpb24iLCJzZWN0aW9uVGFyZ2V0RGlzY29ubmVjdGVkIiwiaGFzTmF2aWdhdGlvblRhcmdldCIsImxpbmtzIiwic2VjdGlvblRhcmdldHMiLCJhY3Rpb24iLCJzY3JvbGxJbnRvVmlldyIsImxpIiwiYXBwZW5kIiwibmF2aWdhdGlvblRhcmdldCIsInJlcGxhY2VDaGlsZHJlbiIsIm1heCIsImV4cGFuZCIsImNvbGxhcHNlIiwiZXhwYW5kQWxsIiwiZXhwYW5kQWxsVGl0bGUiLCJjb2xsYXBzZUFsbCIsImNvbGxhcHNlQWxsVGl0bGUiLCJ0b2dnbGVyTWFwIiwiV2Vha01hcCIsIm5leHRJZCIsIm9wZXJhdGlvblRhcmdldENvbm5lY3RlZCIsInVwZGF0ZU9wZXJhdGlvbiIsIm5vZGVUYXJnZXRDb25uZWN0ZWQiLCJub2RlIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsInBhZGRpbmciLCJwYXJzZUZsb2F0IiwicGFkZGluZ1RvcCIsInBhZGRpbmdCb3R0b20iLCJoZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJtYXhWYWx1ZSIsIm92ZXJmbG93IiwibWF4SGVpZ2h0IiwiYnV0dG9uIiwiZXhwYW5kVmFsdWUiLCJpbm5lckhUTUwiLCJhZGQiLCJ0b2dnbGVyIiwic2V0Iiwibm9kZVRhcmdldERpc2Nvbm5lY3RlZCIsImhhcyIsImRlbGV0ZSIsImNvbGxhcHNlVmFsdWUiLCJ0b2dnbGVBbGwiLCJpc0V4cGFuZGVkIiwiaGFzRXhwYW5kZWQiLCJhbHRLZXkiLCJub2RlVGFyZ2V0cyIsImtleXByZXNzIiwiaGFzT3BlcmF0aW9uVGFyZ2V0IiwiaGFzVG9nZ2xlcnMiLCJmaW5kIiwiZXhwYW5kZWQiLCJvcGVyYXRpb25UYXJnZXQiLCJvcGVyYXRpb25UYXJnZXRzIiwibWFwIiwiY29sbGFwc2VBbGxWYWx1ZSIsImNvbGxhcHNlQWxsVGl0bGVWYWx1ZSIsImV4cGFuZEFsbFZhbHVlIiwiZXhwYW5kQWxsVGl0bGVWYWx1ZSIsIm1lc3NhZ2VUYXJnZXRDb25uZWN0ZWQiLCJoYXNBdHRyaWJ1dGUiLCJfaGlkZSIsInJlbmRlck1lc3NhZ2UiLCJtZXNzYWdlUHJvdG90eXBlVGFyZ2V0cyIsImh0bWwiLCJnZXRIVE1MIiwicmVwbGFjZSIsImNyZWF0ZVJhbmdlIiwiY3JlYXRlQ29udGV4dHVhbEZyYWdtZW50IiwiaGlkZGVuIiwiQWNjZXNzaWJsZU1lbnUiLCJtZW51cyIsIk9wZXJhdGlvbnNNZW51Q29udHJvbGxlciIsImhhc0NvbnRyb2xsZXJUYXJnZXQiLCJoYXNNZW51VGFyZ2V0IiwiJG1lbnUiLCJEaXNjbG9zdXJlTWVudSIsIm1lbnVFbGVtZW50IiwibWVudVRhcmdldCIsIm1lbnVMaW5rU2VsZWN0b3IiLCJjb250cm9sbGVyVGFyZ2V0IiwibWVudSIsImVsZW1lbnRzIiwic3VibWVudVRvZ2dsZXMiLCJpc09wZW4iLCJzZXRQb3NpdGlvbiIsImtleSIsImVudHJpZXMiLCJmaWx0ZXIiLCJ0aXRsZVRhcmdldENvbm5lY3RlZCIsImxpbmsiLCJpc0ludGVyYWN0aXZlIiwic3RvcFByb3BhZ2F0aW9uIiwib25jZSIsIm9mZnNldCIsInN1Ym1lbnVSZWN0Iiwic3VibWVudVRhcmdldCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsInBhcmVudFJlY3QiLCJyZWN0IiwiY2xpZW50WCIsImNsaWVudFkiLCJ1bmRlZmluZWQiLCJyaWdodCIsImJvdHRvbSIsImlubmVyV2lkdGgiLCJyb3dSZWN0Iiwib3ZlcmZsb3dSaWdodCIsIndpZHRoIiwib3ZlcmZsb3dCb3R0b20iLCJ4IiwibGVmdCIsInkiLCJ0b3AiLCJIVE1MQW5jaG9yRWxlbWVudCIsIkhUTUxCdXR0b25FbGVtZW50IiwiSFRNTElucHV0RWxlbWVudCIsIm5hbWVJbnB1dFRhcmdldENvbm5lY3RlZCIsImNhbmNlbEVkaXQiLCJuYW1lSW5wdXRUYXJnZXQiLCJmb3JtVGFyZ2V0IiwicmVxdWVzdFN1Ym1pdCIsIm5hbWUiLCJidXR0b25UYXJnZXRDb25uZWN0ZWQiLCJuYW1lVmFsdWUiLCJtZW51VGFyZ2V0Q29ubmVjdGVkIiwiZG9jdW1lbnRDbGljayIsInJvd1RhcmdldENvbm5lY3RlZCIsInVwZGF0ZVNvcnRpbmciLCJyb3dUYXJnZXREaXNjb25uZWN0ZWQiLCJjb3B5Iiwicm93IiwiX2dldFJvdyIsInByZXZpb3VzIiwicHJldmlvdXNFbGVtZW50U2libGluZyIsInF1ZXVlTWljcm90YXNrIiwibmV3Um93IiwiY2xvbmVOb2RlIiwiYWZ0ZXIiLCJib2R5VGFyZ2V0IiwicHJlcGVuZCIsIl9mb2N1cyIsImNoaWxkcmVuIiwibmV4dEVsZW1lbnRTaWJsaW5nIiwiX3Jlc2V0SW5wdXRzIiwidXBkYXRlTW9kdWxlV2l6YXJkTGluayIsImltYWdlcyIsImlzQ29udGVudEVsZW1lbnQiLCJVUkwiLCJzZWFyY2hQYXJhbXMiLCJpbWFnZSIsImZvckVhY2giLCJ0ciIsImkiLCJhdXRvRm9jdXMiLCJzZXNzaW9uS2V5IiwiYmVoYXZpb3IiLCJibG9jayIsImFwcGxpY2F0aW9uIiwibG9hZEZhbGxiYWNrIiwicmVqZWN0IiwiZ2V0Q29udHJvbGxlckZvckVsZW1lbnRBbmRJZGVudGlmaWVyIiwiY29udHJvbGxlckF0dHJpYnV0ZSIsInNjaGVtYSIsImluaXRTY3JvbGxPZmZzZXQiLCJnZXRTY3JvbGxPZmZzZXQiLCJ0aGVuIiwiZGlzY2FyZCIsInN0b3JlIiwicmVzdG9yZSIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInNjcm9sbFRvIiwiYmVoYXZpb3JWYWx1ZSIsImJsb2NrVmFsdWUiLCJzY3JvbGxUb1RhcmdldENvbm5lY3RlZCIsInNjcm9sbFRvVGFyZ2V0IiwiYXV0b0ZvY3VzVGFyZ2V0Q29ubmVjdGVkIiwiYXV0b0ZvY3VzVGFyZ2V0IiwicmVhZG9ubHkiLCJvZmZzZXRXaWR0aCIsIm9mZnNldEhlaWdodCIsImF1dG9jb21wbGV0ZSIsImF1dG9Gb2N1c1RhcmdldERpc2Nvbm5lY3RlZCIsIndpZGdldEVycm9yVGFyZ2V0Q29ubmVjdGVkIiwid2lkZ2V0RXJyb3JUYXJnZXQiLCJzY3JvbGxUb3AiLCJzY3JvbGxUb1dpZGdldEVycm9yIiwiaGFzV2lkZ2V0RXJyb3JUYXJnZXQiLCJzZXNzaW9uU3RvcmFnZSIsInNlc3Npb25LZXlWYWx1ZSIsInBhcnNlSW50IiwidHJhaWwiLCJ0aXRsZVRhZyIsImZpZWxkcyIsInNvdXJjZUVsZW1lbnRzIiwiTWFwIiwic291cmNlVHlwZSIsImZpZWxkc1ZhbHVlIiwiZ2V0RWxlbWVudEJ5SWQiLCJfdXBkYXRlIiwiY2xlYXIiLCJfZ2V0VmFsdWUiLCJ0aXRsZVRhcmdldCIsInRleHRDb250ZW50IiwiX3Nob3J0ZW4iLCJfaHRtbDJzdHJpbmciLCJ0aXRsZVRhZ1ZhbHVlIiwidXJsVGFyZ2V0IiwidHJhaWxWYWx1ZSIsImlkVmFsdWUiLCJkZXNjcmlwdGlvblRhcmdldCIsInN0ciIsInN1YnN0ciIsImxhc3RJbmRleE9mIiwiRE9NUGFyc2VyIiwicGFyc2VGcm9tU3RyaW5nIiwiYm9keSIsIlNvcnRhYmxlIiwicGFyZW50TW9kZSIsInJlcXVlc3RUb2tlbiIsImRyYWdnYWJsZSIsImFuaW1hdGlvbiIsIm9uU29ydCIsIl9vblNvcnRlZCIsIml0ZW0iLCJoYXNIYW5kbGVWYWx1ZSIsImhhbmRsZVZhbHVlIiwiaGFzRHJhZ2dhYmxlVmFsdWUiLCJkcmFnZ2FibGVWYWx1ZSIsInNvcnRhYmxlIiwiaGFuZGxlcyIsImxvY2FsTmFtZSIsIm1vdmUiLCJfZ2V0SXRlbSIsImNvZGUiLCJrZXlDb2RlIiwiYmVmb3JlIiwiX3VwZGF0ZVdyYXBwZXJMZXZlbCIsImRpdnMiLCJ3cmFwTGV2ZWwiLCJfdXBkYXRlUGFyZW50U29ydGluZyIsImxvY2F0aW9uIiwicmVxdWVzdFRva2VuVmFsdWUiLCJmZXRjaCIsInJlZGlyZWN0IiwicGFyZW50TW9kZVZhbHVlIiwiSWNvbiIsIlRhYnNDb250cm9sbGVyIiwiY2xvc2VMYWJlbCIsImFjdGl2ZVRhYiIsInBhbmVsVGFyZ2V0Q29ubmVjdGVkIiwicGFuZWwiLCJpc1Jlc3RvcmUiLCJ0YWJJZCIsInJhbmRvbSIsImNvbnRhaW5lcklkIiwicGFuZWxSZWZlcmVuY2UiLCJjb250cm9sUmVmZXJlbmNlIiwic2VsZWN0QnV0dG9uIiwic2VsZWN0VGFiIiwiY2xvc2VCdXR0b24iLCJnZXRUZW1wbGF0ZSIsImNsb3NlTGFiZWxWYWx1ZSIsInBhbmVsVGFyZ2V0RGlzY29ubmVjdGVkIiwicGFyZW50RWxlbWVudCIsImhhc1BhbmVsVGFyZ2V0IiwicGFuZWxUYXJnZXQiLCJwYW5lbFRhcmdldHMiLCJpc1RhcmdldCIsInRvZ2dsZUF0dHJpYnV0ZSIsImdldEFjdGl2ZVRhYiIsImdldFRhYnMiLCJyZWR1Y2UiLCJUd2lnRWRpdG9yIiwiZWRpdG9ycyIsInR1cmJvU3RyZWFtQ29ubmVjdGlvbiIsImZvbGxvd1VybCIsImJsb2NrSW5mb1VybCIsImZvbGxvd1VybFZhbHVlIiwiYmxvY2tJbmZvVXJsVmFsdWUiLCJoYXNUaGVtZVNlbGVjdG9yVGFyZ2V0IiwidGhlbWVTZWxlY3RvclRhcmdldCIsIl9hZGRPcGVuRWRpdG9yVGFic1RvUmVxdWVzdCIsImZvcm1TdWJtaXNzaW9uIiwic3VibWl0dGVyIiwib3BlcmF0aW9uIiwiX2FkZEVkaXRvckNvbnRlbnRUb1JlcXVlc3QiLCJfZ2V0QWN0aXZlTXV0YWJsZUVkaXRvciIsImVkaXRvclRhcmdldENvbm5lY3RlZCIsImVkaXRvclRhcmdldERpc2Nvbm5lY3RlZCIsImVkaXRvckFubm90YXRpb25zVGFyZ2V0Q29ubmVjdGVkIiwic2V0QW5ub3RhdGlvbnNEYXRhIiwiSlNPTiIsInBhcnNlIiwidGFicyIsInRhYnNUYXJnZXQiLCJrZXlzIiwiZmV0Y2hSZXF1ZXN0IiwiZ2V0Q29udGVudCIsImVkaXRvckVsZW1lbnRzT25BY3RpdmVUYWIiLCJpc0VkaXRhYmxlIiwiX2Nvbm5lY3QiLCJ0aW55bWNlQ29uZmlnIiwidGlueW1jZSIsImluaXQiLCJlZGl0b3JJZCIsImxlYXZlIiwiaGFzT3duIiwicGx1Z2lucyIsImlzTm90RGlydHkiLCJkZWxlZ2F0ZSIsImNyZWF0ZUV2ZW50IiwiaW5pdEV2ZW50IiwiY29uZmlybSIsInJldHVyblZhbHVlIiwidGFibGUiLCJhZGRDb250cm9sbGVyIiwiZnMiLCJtaWdyYXRlTGVnYWN5IiwiQWpheFJlcXVlc3QiLCJ0b2dnbGVGaWVsZHNldCIsInJlYWR5U3RhdGUiLCJjb2xsYXBzZWRDbGFzcyIsInNldEFyaWFFeHBhbmRlZCIsInN0b3JlU3RhdGUiLCJmb3JtIiwiY2hlY2tWYWxpZGl0eSIsImNsaWNrIiwiaGFzSWRWYWx1ZSIsImhhc1RhYmxlVmFsdWUiLCJtZXRob2QiLCJoZWFkZXJzIiwiVVJMU2VhcmNoUGFyYW1zIiwidGFibGVWYWx1ZSIsImFyaWFFeHBhbmRlZCIsImV4cGFuZFRpdGxlIiwiY29sbGFwc2VUaXRsZSIsImN1cnJlbnRUYXJnZXQiLCJjYXRlZ29yeSIsImNvbGxhcHNlZCIsImV4cGFuZFRpdGxlVmFsdWUiLCJjb2xsYXBzZVRpdGxlVmFsdWUiLCJzZW5kUmVxdWVzdCIsIlJFUVVFU1RfVE9LRU4iLCJ0b2dnbGVBY3Rpb24iLCJsb2FkQWN0aW9uIiwicmVmZXJlcklkIiwiY2hpbGRUYXJnZXRDb25uZWN0ZWQiLCJ0b2dnbGVUb2dnbGVyIiwibGV2ZWwiLCJmb2xkZXIiLCJzaG93Q2hpbGQiLCJleHBhbmRUb2dnbGVyIiwidXBkYXRlU3RhdGUiLCJoaWRlQ2hpbGQiLCJjb2xsYXBzZVRvZ2dsZXIiLCJmZXRjaENoaWxkIiwiYWx0IiwibG9hZFRvZ2dsZXIiLCJyZWZlcmVySWRWYWx1ZSIsInJlc3BvbnNlIiwibG9hZEFjdGlvblZhbHVlIiwidHh0IiwidWwiLCJtb2RlVmFsdWUiLCJpc0ZvbGRlciIsInBhcmVudCIsIm5leHQiLCJ0eXBlT2YiLCJDdXN0b21FdmVudCIsImZpcmVFdmVudCIsImhhc0V4cGFuZGVkUm9vdCIsInVwZGF0ZUFsbFN0YXRlIiwidG9nZ2xlVGFyZ2V0cyIsImNoaWxkVGFyZ2V0cyIsInByb21pc2VzIiwiYWxsIiwidG9nZ2xlQWN0aW9uVmFsdWUiLCJyb290Q2hpbGRUYXJnZXRzIiwiVG9vbHRpcHNDb250cm9sbGVyIiwiZGVmYXVsdE9wdGlvbnNNYXAiLCJ1c2VDb250ZW50IiwiYWN0aXZlVGFyZ2V0cyIsIlNldCIsInJlbW92ZUNsaWNrVGFyZ2V0SGFuZGxlckRlbGVnYXRlcyIsInRvb2x0aXAiLCJfY3JlYXRlVGlwQ29udGFpbmVyIiwidG9vbHRpcFRhcmdldENvbm5lY3RlZCIsIl9zaG93VG9vbHRpcCIsIl9oaWRlVG9vbHRpcCIsImNsaWNrVGFyZ2V0IiwiaGFuZGxlciIsInRvb2x0aXBUYXJnZXREaXNjb25uZWN0ZWQiLCJwb3NpdGlvbiIsImFwcGVuZENoaWxkIiwidG91Y2hTdGFydCIsImRlbGF5IiwiX2dldE9wdGlvbnNGb3JFbGVtZW50IiwiSFRNTEltYWdlRWxlbWVudCIsInRpbWVyIiwid2lsbENoYW5nZSIsInJ0bCIsImRpcmVjdGlvbiIsImNsaWVudFdpZHRoIiwic2Nyb2xsWCIsInNjcm9sbFkiLCJjcml0ZXJpYSIsImRlZmF1bHRPcHRpb25zIiwibWF0Y2giLCJ0YXJnZXRTZWxlY3RvcnMiLCJtaWdyYXRlVGFyZ2V0Iiwic2VsIiwiTXV0YXRpb25PYnNlcnZlciIsIm11dGF0aW9uc0xpc3QiLCJtdXRhdGlvbiIsImFkZGVkTm9kZXMiLCJIVE1MRWxlbWVudCIsIm9ic2VydmUiLCJjaGlsZExpc3QiLCJzdWJ0cmVlIiwidW5zdXBwb3J0ZWRNZXNzYWdlIiwiYXNzZXJ0aW9uRmFpbHVyZU1lc3NhZ2UiLCJhdHRlc3RhdGlvbkZhaWx1cmVNZXNzYWdlIiwib3B0aW9uc0ZhaWx1cmVNZXNzYWdlIiwiY3NyZlVybCIsImhhbmRsZVVuc3VwcG9ydGVkIiwibWVzc2FnZVRhcmdldCIsInVuc3VwcG9ydGVkTWVzc2FnZVZhbHVlIiwiaGFuZGxlQXNzZXJ0aW9uRmFpbHVyZSIsImFzc2VydGlvbkZhaWx1cmVNZXNzYWdlVmFsdWUiLCJoYW5kbGVBdHRlc3RhdGlvbkZhaWx1cmUiLCJhdHRlc3RhdGlvbkZhaWx1cmVNZXNzYWdlVmFsdWUiLCJoYW5kbGVPcHRpb25zRmFpbHVyZSIsIm9wdGlvbnNGYWlsdXJlTWVzc2FnZVZhbHVlIiwibG9hZENzcmYiLCJjc3JmU2NyaXB0IiwiY3NyZlVybFZhbHVlIiwiYXN5bmMiLCJtYW5pZmVzdCIsImF0dHJpYnV0ZXMiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJzb3VyY2UiLCJnZXRTb3VyY2UiLCJFcnJvciIsInNvdXJjZURhcmsiLCJ0ZW1wbGF0ZSIsIl9nZXRJbWFnZSIsImRhcmtTY2hlbWUiLCJmaWxlTmFtZSIsIl9hZGRNZXNzYWdlIiwiX2Fib3J0Q29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlciIsIl9hYm9ydFNpZ25hbCIsInJlYXNvbiIsInF1ZXJ5X3BhcmFtcyIsIkFjY2VwdCIsInNpZ25hbCIsImNvbnN0cnVjdG9yIiwiYnVpbGRVUkwiLCJUdXJib1N0cmVhbVJlc3VsdCIsInJlZGlyZWN0ZWQiLCJzdGF0dXMiLCJyZW5kZXJTdHJlYW1NZXNzYWdlIiwiYWJvcnQiLCJwYWlycyIsImlzQXJyYXkiLCJ2YWx1ZTEiLCJyZXN1bHRTdGF0ZSIsImFib3J0ZWQiLCJjb250YWluZXJCYWNrdXAiLCJyZXNvdXJjZVVybCIsIm1heExpbmVzIiwid3JhcCIsInVzZVNvZnRUYWJzIiwiYXV0b1Njcm9sbEVkaXRvckludG9WaWV3IiwiZW5hYmxlTGl2ZUF1dG9jb21wbGV0aW9uIiwiZW5hYmxlS2V5Ym9hcmRBY2Nlc3NpYmlsaXR5Iiwid2hpdGVzcGFjZSIsInJlcXVpcmUiLCJkZXRlY3RJbmRlbnRhdGlvbiIsImFkZENvbW1hbmQiLCJleGVjIiwiYXJncyIsImJ1YmJsZXMiLCJyZWdpc3RlckNvZGVMZW5zUHJvdmlkZXIiLCJjb2RlTGVucyIsInByb3ZpZGVDb2RlTGVuc2VzIiwic2Vzc2lvbiIsImNhbGxiYWNrIiwiZGVzdHJveWVkIiwicGF5bG9hZCIsInJlZmVyZW5jZSIsImFuYWx5emVSZWZlcmVuY2VzIiwic3RhcnQiLCJjb2x1bW4iLCJjb21tYW5kIiwiYXJndW1lbnRzIiwiYW5hbHl6ZUJsb2NrcyIsInJlZmVyZW5jZXMiLCJnZXRMZW5ndGgiLCJ0b2tlbnMiLCJnZXRUb2tlbnMiLCJibG9ja3MiLCJkYXRhIiwiY29tcGxldGVycyIsImdldENvbXBsZXRpb25zIiwicG9zIiwicHJlZml4Iiwic2V0QW5ub3RhdGlvbnMiLCJsaW5lIiwiZ2V0UmVhZE9ubHkiLCJyZXBsYWNlV2l0aCIsInRvZ2dsZU5hdmlnYXRpb24iLCIkIiwiZ2V0UGFyZW50IiwiaGFzQ2xhc3MiLCJyZW1vdmVDbGFzcyIsIlJlcXVlc3QiLCJwb3N0IiwicmVxdWVzdF90b2tlbiIsImFkZENsYXNzIiwidG9nZ2xlU3RydWN0dXJlIiwiZ2V0U3R5bGUiLCJzZXRTdHlsZSIsImZpZWxkIiwiZXZhbFNjcmlwdHMiLCJvblJlcXVlc3QiLCJkaXNwbGF5Qm94Iiwib25TdWNjZXNzIiwiRWxlbWVudCIsImluamVjdCIsImdldE5leHQiLCJnZXRFbGVtZW50cyIsImVhY2giLCJyZWZlcmVyX2lkIiwiaGlkZUJveCIsInRvZ2dsZUZpbGVNYW5hZ2VyIiwidG9nZ2xlU3VicGFsZXR0ZSIsInVwZGF0ZVZlcnNpb25OdW1iZXIiLCJqc29uIiwiZGl2IiwiamF2YXNjcmlwdCIsIkFzc2V0Iiwib25Mb2FkIiwiQnJvd3NlciIsIlZFUlNJT05fTlVNQkVSIiwidG9nZ2xlRmllbGQiLCJyb3dJY29uIiwiaWNvbk9ubHkiLCJwdWJsaXNoZWQiLCJwYSIsImdldFByZXZpb3VzIiwiZ2V0Rmlyc3QiLCJnZXRFbGVtZW50IiwibmV3U3JjIiwic2xpY2UiLCJjaGlsZE5vZGVzIiwiY2hpbGQiLCJUZXh0Iiwibm9kZVZhbHVlIiwidHJpbSIsImNsb25lIiwidG9nZ2xlQ2hlY2tib3hHcm91cCIsImJveCIsIm92ZXJsYXkiLCJzY3JvbGwiLCJnZXRTY3JvbGwiLCJjdXJyZW50SWQiLCJwb3B1cFdpbmRvdyIsInRoZW1lUGF0aCIsInNjcmlwdF91cmwiLCJ0aGVtZSIsIm9wZW5Nb2RhbFdpbmRvdyIsIlNpbXBsZU1vZGFsIiwib25TaG93Iiwib25IaWRlIiwic2hvdyIsIm9wZW5Nb2RhbEltYWdlIiwib3B0IiwibWF4V2lkdGgiLCJnZXRTaXplIiwiTSIsIm9wZW5Nb2RhbFNlbGVjdG9yIiwiYWRkQnV0dG9uIiwiY2FuY2VsIiwiYnV0dG9ucyIsImFwcGx5IiwiZnJtIiwiZnJhbWVzIiwidmFsIiwiaW5wIiwicGlja2VyVmFsdWUiLCJzSW5kZXgiLCJhbGVydCIsImdldEVsZW1lbnRzQnlUYWdOYW1lIiwic3BsaWNlIiwib3Blbk1vZGFsQnJvd3NlciIsImZpZWxkX25hbWUiLCJ3aW4iLCJyb3V0ZXMiLCJiYWNrZW5kX3BpY2tlciIsImF1dG9TdWJtaXQiLCJub1ZhbGlkYXRlIiwidlNjcm9sbFRvIiwiYWRkRXZlbnQiLCJ0b2dnbGVDaGVja2JveGVzIiwiaXRlbXMiLCIkJCIsImNscyIsImNieCIsImNoZWNrYm94IiwidG9nZ2xlQ2hlY2tib3hFbGVtZW50cyIsIm1ha2VQYXJlbnRWaWV3U29ydGFibGUiLCJkcyIsIlNjcm9sbGVyIiwib25DaGFuZ2UiLCJsaXN0IiwiU29ydGFibGVzIiwiY29uc3RyYWluIiwib3BhY2l0eSIsIm9uU3RhcnQiLCJvbkNvbXBsZXRlIiwic3RvcCIsImdldENoaWxkcmVuIiwicGlkIiwibWFrZU11bHRpU3JjU29ydGFibGUiLCJvaWQiLCJlbHMiLCJsaXMiLCJqIiwiZGlkIiwiZGlzcG9zZSIsImVuYWJsZUZpbGVUcmVlRHJhZ0FuZERyb3AiLCJkcmFnSGFuZGxlIiwiZHJhZ0VsZW1lbnQiLCJyaWdodENsaWNrIiwiY2xvbmVCYXNlIiwiY3VycmVudEhvdmVyIiwiY3VycmVudEhvdmVyVGltZSIsImV4cGFuZExpbmsiLCJwYWdlIiwiZ2V0T2Zmc2V0UGFyZW50IiwiZ2V0UG9zaXRpb24iLCJEcmFnIiwiTW92ZSIsImRyb3BwYWJsZXMiLCJ1bkRyYWdnYWJsZVRhZ3MiLCJtb2RpZmllcnMiLCJvbkVudGVyIiwiZHJvcHBhYmxlIiwiZml4RHJvcHBhYmxlIiwiRGF0ZSIsImdldFRpbWUiLCJvbkFqYXgiLCJyZW1vdmVFdmVudCIsIm9uQ2FuY2VsIiwib25LZXl1cCIsIm9uRHJvcCIsImRlY29kZVVSSUNvbXBvbmVudCIsImVuY29kZVVSSUNvbXBvbmVudCIsIm9uTGVhdmUiLCJsaXN0V2l6YXJkIiwibWFrZVNvcnRhYmxlIiwiYWRkRXZlbnRzVG8iLCJidCIsImhhc0V2ZW50IiwiZ2V0UHJvcGVydHkiLCJ0YWJsZVdpemFyZCIsInRoZWFkIiwidGJvZHkiLCJyb3dzIiwidGV4dGFyZWEiLCJoZWFkIiwiY3VycmVudCIsIm50ciIsImluZGV4IiwiZ2V0SW5kZXgiLCJoZWFkRmlyc3QiLCJ0ZCIsImNvbHMiLCJ0YWJsZVdpemFyZFJlc2l6ZSIsImZhY3RvciIsInNpemUiLCJyb3VuZCIsImxpbWl0IiwiY2h1bmtzIiwidGFibGVXaXphcmRTZXRXaWR0aCIsImdldENvbXB1dGVkU2l6ZSIsIm9wdGlvbnNXaXphcmQiLCJrZXlWYWx1ZVdpemFyZCIsImNoZWNrYm94V2l6YXJkIiwic3BhbiIsIm5zcGFuIiwiZW5hYmxlSW1hZ2VTaXplV2lkZ2V0cyIsIndpZHRoSW5wdXQiLCJoZWlnaHRJbnB1dCIsImdldFNlbGVjdGVkIiwiZW5hYmxlVG9nZ2xlU2VsZWN0Iiwic2hpZnRUb2dnbGUiLCJ0aGlzSW5kZXgiLCJjaGVja2JveGVzIiwic3RhcnRJbmRleCIsInRvIiwiY2xpY2tFdmVudCIsImxpbWl0VG9nZ2xlciIsInNoaWZ0IiwiYm91bmRFdmVudCIsInJldHJpZXZlIiwiZWRpdFByZXZpZXdXaXphcmQiLCJpbWFnZUVsZW1lbnQiLCJpbnB1dEVsZW1lbnRzIiwiaXNEcmF3aW5nIiwicGFydEVsZW1lbnQiLCJzdGFydFBvcyIsImdldFNjYWxlIiwidXBkYXRlSW1hZ2UiLCJzY2FsZSIsImltYWdlU2l6ZSIsInNldFN0eWxlcyIsImNvbXB1dGVkVG9wIiwiY29tcHV0ZWRMZWZ0IiwidG9GbG9hdCIsInVwZGF0ZVZhbHVlcyIsInN0eWxlcyIsImdldFN0eWxlcyIsInRvRml4ZWQiLCJhYnMiLCJjYXBpdGFsaXplIiwiYWRkRXZlbnRzIiwibW91c2Vkb3duIiwidG91Y2hzdGFydCIsIm1vdXNlbW92ZSIsInRvdWNobW92ZSIsIm1vdXNldXAiLCJ0b3VjaGVuZCIsInRvdWNoY2FuY2VsIiwicmVzaXplIiwiZW5hYmxlRmlsZVRyZWVVcGxvYWQiLCJmYWxsYmFja1VybCIsImR6RWxlbWVudCIsInByZXZpZXdzQ29udGFpbmVyIiwiY2xpY2thYmxlIiwiZHoiLCJEcm9wem9uZSIsInJlbG9hZCIsImRhdGFUcmFuc2ZlciIsInR5cGVzIiwiY3Jhd2wiLCJ0aW1lb3V0IiwicHJvZ3Jlc3NCYXIiLCJwcm9ncmVzc0NvdW50IiwicmVzdWx0cyIsImRlYnVnTG9nIiwidXBkYXRlRGF0YSIsInRvdGFsIiwiZG9uZSIsInBlbmRpbmciLCJwZXJjZW50YWdlIiwiaGFzRGVidWdMb2ciLCJmaW5pc2hlZCIsInN1bW1hcnkiLCJ3YXJuaW5nIiwibG9nIiwic3Vic2NyaWJlclJlc3VsdHMiLCJzdWJzY3JpYmVyU3VtbWFyeSIsImhhc0xvZyIsIndhc1N1Y2Nlc3NmdWwiLCJleGVjUmVxdWVzdCIsIm9ubHlTdGF0dXNVcGRhdGUiLCJyZXNwb25zZVRleHQiLCJkZWNvZGUiLCJzZW5kIiwiaXNXZWJraXQiLCJjaHJvbWUiLCJzYWZhcmkiLCJ1c2VyQWdlbnQiLCJzdG9wQ2xpY2tQcm9wYWdhdGlvbiIsInNldHVwVGV4dGFyZWFSZXNpemluZyIsImllNiIsImllNyIsImllOCIsImR1bW15IiwidHdlZW4iLCJzZXR1cE1lbnVUb2dnbGUiLCJidXJnZXIiLCJ0b2dnbGVDbGFzcyIsInNldEFyaWFDb250cm9scyIsInNldHVwUHJvZmlsZVRvZ2dsZSIsInRtZW51Iiwic2V0dXBTcGxpdEJ1dHRvblRvZ2dsZSIsInRhYiIsIkZlYXR1cmVzIiwiVG91Y2giLCJoZ3QiLCJDbGFzcyIsIkV4dGVuZHMiLCJmb2xsb3dSZWRpcmVjdHMiLCJzdWNjZXNzIiwiZ2V0SGVhZGVyIiwic2VjdXJlIiwic3RyaXBTY3JpcHRzIiwic2NyaXB0IiwiZmFpbHVyZSIsIm9uRmFpbHVyZSIsInJlZmFjdG9yIiwiYXR0YWNoIiwiYm91bmQiLCJkZXRhY2giLCJjaGVjayIsImRpc3RhbmNlIiwic3FydCIsInBvdyIsIm1vdXNlIiwic25hcCIsImRyYWciLCJyZW1vdmVFdmVudHMiLCJsaXN0cyIsImRyYWdPcHRpb25zIiwibWVyZ2UiLCJ0YWciLCJhZGRJdGVtcyIsImZsYXR0ZW4iLCJyZW1vdmVJdGVtcyIsImVyYXNlIiwiZ2V0Q2xvbmUiLCJRdWV1ZSIsImF1dG9BZHZhbmNlIiwicXVldWUiLCJpc1J1bm5pbmciLCJzdG9wT25GYWlsdXJlIiwib25FeGNlcHRpb24iLCJicm93c2VyU3VwcG9ydHNXZWJBdXRobkF1dG9maWxsIiwiYnJvd3NlclN1cHBvcnRzV2ViQXV0aG4iLCJzdGFydEF1dGhlbnRpY2F0aW9uIiwic3RhcnRSZWdpc3RyYXRpb24iLCJiYXNlNjRVUkxTdHJpbmdUb0J1ZmZlciIsImJ1ZmZlclRvQmFzZTY0VVJMU3RyaW5nIiwiZGVmYXVsdF8xIiwiX2EiLCJfYiIsIl9jIiwiX2QiLCJyZXF1ZXN0UmVzdWx0VXJsIiwicmVxdWVzdFJlc3VsdFVybFZhbHVlIiwicmVxdWVzdE9wdGlvbnNVcmwiLCJyZXF1ZXN0T3B0aW9uc1VybFZhbHVlIiwicmVxdWVzdFJlc3VsdEZpZWxkIiwicmVxdWVzdFJlc3VsdEZpZWxkVmFsdWUiLCJjcmVhdGlvblJlc3VsdEZpZWxkIiwiY3JlYXRpb25SZXN1bHRGaWVsZFZhbHVlIiwicmVxdWVzdFN1Y2Nlc3NSZWRpcmVjdFVyaSIsInJlcXVlc3RTdWNjZXNzUmVkaXJlY3RVcmlWYWx1ZSIsImNyZWF0aW9uUmVzdWx0VXJsIiwiY3JlYXRpb25SZXN1bHRVcmxWYWx1ZSIsImNyZWF0aW9uT3B0aW9uc1VybCIsImNyZWF0aW9uT3B0aW9uc1VybFZhbHVlIiwiY3JlYXRpb25TdWNjZXNzUmVkaXJlY3RVcmkiLCJjcmVhdGlvblN1Y2Nlc3NSZWRpcmVjdFVyaVZhbHVlIiwiX2Rpc3BhdGNoRXZlbnQiLCJzdXBwb3J0QXV0b2ZpbGwiLCJ1c2VCcm93c2VyQXV0b2ZpbGxWYWx1ZSIsIm9wdGlvbnNSZXNwb25zZUpzb24iLCJfZ2V0UHVibGljS2V5Q3JlZGVudGlhbFJlcXVlc3RPcHRpb25zIiwiX3Byb2Nlc3NTaWduaW4iLCJzaWduaW4iLCJ1c2VCcm93c2VyQXV0b2ZpbGwiLCJfcHJvY2Vzc0V4dGVuc2lvbnNJbnB1dCIsImF1dGhlbnRpY2F0b3JSZXNwb25zZSIsIm9wdGlvbnNKU09OIiwiX3Byb2Nlc3NFeHRlbnNpb25zT3V0cHV0IiwiSFRNTEZvcm1FbGVtZW50Iiwic3RyaW5naWZ5Iiwic3VibWl0IiwiYXNzZXJ0aW9uUmVzcG9uc2UiLCJfZ2V0QXNzZXJ0aW9uUmVzcG9uc2UiLCJleGNlcHRpb24iLCJzaWdudXAiLCJfZ2V0UHVibGljS2V5Q3JlZGVudGlhbENyZWF0aW9uT3B0aW9ucyIsImF0dGVzdGF0aW9uUmVzcG9uc2VKU09OIiwiX2dldEF0dGVzdGF0aW9uUmVzcG9uc2UiLCJfZ2V0RGF0YSIsIkZvcm1EYXRhIiwicmVwb3J0VmFsaWRpdHkiLCJyZW1vdmVFbXB0eSIsIm9iaiIsInYiLCJhY2MiLCJrIiwiYXNzaWduIiwidXNlcm5hbWUiLCJ1c2VybmFtZUZpZWxkVmFsdWUiLCJkaXNwbGF5TmFtZSIsImRpc3BsYXlOYW1lRmllbGRWYWx1ZSIsImF0dGVzdGF0aW9uIiwiYXR0ZXN0YXRpb25GaWVsZFZhbHVlIiwidXNlclZlcmlmaWNhdGlvbiIsInVzZXJWZXJpZmljYXRpb25GaWVsZFZhbHVlIiwicmVzaWRlbnRLZXkiLCJyZXNpZGVudEtleUZpZWxkVmFsdWUiLCJhdXRoZW50aWNhdG9yQXR0YWNobWVudCIsImF1dGhlbnRpY2F0b3JBdHRhY2htZW50RmllbGRWYWx1ZSIsImZvcm1EYXRhIiwiX2dldE9wdGlvbnMiLCJvcHRpb25zUmVzcG9uc2UiLCJyZXF1ZXN0SGVhZGVyc1ZhbHVlIiwiX2dldFJlc3VsdCIsImV2ZW50UHJlZml4IiwiYXR0ZXN0YXRpb25SZXNwb25zZSIsImV4dGVuc2lvbnMiLCJwcmYiLCJfcHJvY2Vzc1ByZklucHV0IiwiZXZhbCIsIl9pbXBvcnRQcmZWYWx1ZXMiLCJldmFsQnlDcmVkZW50aWFsIiwiZmlyc3QiLCJzZWNvbmQiLCJfcHJvY2Vzc1ByZk91dHB1dCIsIl9leHBvcnRQcmZWYWx1ZXMiLCJ1c2VybmFtZUZpZWxkIiwiZGlzcGxheU5hbWVGaWVsZCIsImF0dGVzdGF0aW9uRmllbGQiLCJ1c2VyVmVyaWZpY2F0aW9uRmllbGQiLCJyZXNpZGVudEtleUZpZWxkIiwiYXV0aGVudGljYXRvckF0dGFjaG1lbnRGaWVsZCIsInJlcXVlc3RIZWFkZXJzIiwiQXBwbGljYXRpb24iLCJkZWZpbml0aW9uRm9yTW9kdWxlQW5kSWRlbnRpZmllciIsImlkZW50aWZpZXJGb3JDb250ZXh0S2V5IiwiV2ViQXV0aG4iLCJkZWJ1ZyIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsImNvbnRleHQiLCJsb2FkIiwicmVnaXN0ZXIiLCJjb25uZWN0aW9uIiwic2F2ZURhdGEiLCJlZmZlY3RpdmVUeXBlIiwibW9vRG9tcmVhZHkiLCJtb29Eb21yZWFkeUZpcmVkIiwiY29udHJvbGxlcnMiLCJ0YXJnZXRVUkxBZnRlclJlZGlyZWN0ZWRGZXRjaCIsImFkYXB0ZXIiLCJmZXRjaFJlc3BvbnNlIl0sInNvdXJjZVJvb3QiOiIifQ==